package gcom.arrecadacao;

import gcom.arrecadacao.FiltroConsultarDadosDiariosArrecadacao.GROUP_BY;
import gcom.arrecadacao.FiltroConsultarDadosDiariosArrecadacaoAuxiliar.GROUP_BY_AUX;
import gcom.arrecadacao.aviso.AvisoAcerto;
import gcom.arrecadacao.aviso.AvisoBancario;
import gcom.arrecadacao.aviso.AvisoDeducoes;
import gcom.arrecadacao.aviso.AvisoDeducoesPK;
import gcom.arrecadacao.aviso.bean.AcertosAvisoBancarioHelper;
import gcom.arrecadacao.aviso.bean.AvisoBancarioHelper;
import gcom.arrecadacao.aviso.bean.DeducoesHelper;
import gcom.arrecadacao.aviso.bean.PagamentosDevolucoesHelper;
import gcom.arrecadacao.aviso.bean.ValoresArrecadacaoDevolucaoAvisoBancarioHelper;
import gcom.arrecadacao.banco.Agencia;
import gcom.arrecadacao.banco.Banco;
import gcom.arrecadacao.banco.ContaBancaria;
import gcom.arrecadacao.banco.FiltroAgencia;
import gcom.arrecadacao.banco.FiltroBanco;
import gcom.arrecadacao.banco.FiltroContaBancaria;
import gcom.arrecadacao.bean.ArrecadacaoDadosDiariosValoresDiariosHelper;
import gcom.arrecadacao.bean.ArrecadadorMovimentoItemHelper;
import gcom.arrecadacao.bean.ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper;
import gcom.arrecadacao.bean.DadosConteudoCodigoBarrasHelper;
import gcom.arrecadacao.bean.DadosConteudoRegistroMovimentoArrecadadorHelper;
import gcom.arrecadacao.bean.FiltrarDadosDiariosArrecadacaoHelper;
import gcom.arrecadacao.bean.FormasArrecadacaoDadosDiariosHelper;
import gcom.arrecadacao.bean.GerarMovimentoDebitoAutomaticoBancoHelper;
import gcom.arrecadacao.bean.InformarAcertoDocumentosNaoAceitosHelper;
import gcom.arrecadacao.bean.MovimentoArrecadadoresPorNSAHelper;
import gcom.arrecadacao.bean.MovimentoArrecadadoresRelatorioHelper;
import gcom.arrecadacao.bean.PagamentoHelperCodigoBarras;
import gcom.arrecadacao.bean.PagamentoRelatorioHelper;
import gcom.arrecadacao.bean.PesquisarAnaliseArrecadacaoHelper;
import gcom.arrecadacao.bean.PesquisarAnaliseAvisosBancariosHelper;
import gcom.arrecadacao.bean.PesquisarAvisoBancarioPorContaCorrenteHelper;
import gcom.arrecadacao.bean.ProcessarPagamentoParcialContaHelper;
import gcom.arrecadacao.bean.RegistroCartaoCreditoHeaderHelper;
import gcom.arrecadacao.bean.RegistroCartaoCreditoTipo1Helper;
import gcom.arrecadacao.bean.RegistroCartaoCreditoTipo2Helper;
import gcom.arrecadacao.bean.RegistroCartaoCreditoTraillerHelper;
import gcom.arrecadacao.bean.RegistroFichaCompensacaoBuilder;
import gcom.arrecadacao.bean.RegistroFichaCompensacaoHeaderHelper;
import gcom.arrecadacao.bean.RegistroFichaCompensacaoTipo7Helper;
import gcom.arrecadacao.bean.RegistroFichaCompensacaoTrailerHelper;
import gcom.arrecadacao.bean.RegistroHelperCodigo0;
import gcom.arrecadacao.bean.RegistroHelperCodigo1;
import gcom.arrecadacao.bean.RegistroHelperCodigo3T;
import gcom.arrecadacao.bean.RegistroHelperCodigo3U;
import gcom.arrecadacao.bean.RegistroHelperCodigo5;
import gcom.arrecadacao.bean.RegistroHelperCodigo9;
import gcom.arrecadacao.bean.RegistroHelperCodigoA;
import gcom.arrecadacao.bean.RegistroHelperCodigoB;
import gcom.arrecadacao.bean.RegistroHelperCodigoBarras;
import gcom.arrecadacao.bean.RegistroHelperCodigoBarrasTipoPagamento;
import gcom.arrecadacao.bean.RegistroHelperCodigoC;
import gcom.arrecadacao.bean.RegistroHelperCodigoE;
import gcom.arrecadacao.bean.RegistroHelperCodigoF;
import gcom.arrecadacao.bean.RegistroHelperCodigoG;
import gcom.arrecadacao.bean.RegistroHelperCodigoW;
import gcom.arrecadacao.bean.RegistroHelperCodigoX;
import gcom.arrecadacao.bean.RegistroHelperCodigoZ;
import gcom.arrecadacao.bean.RegistroHelperFichaCompensacao;
import gcom.arrecadacao.bean.ResumoArrecadacaoRelatorioHelper;
import gcom.arrecadacao.big.BoletimInformacoesGerenciais;
import gcom.arrecadacao.debitoautomatico.DebitoAutomatico;
import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoMovimento;
import gcom.arrecadacao.debitoautomatico.DebitoAutomaticoRetornoCodigo;
import gcom.arrecadacao.debitoautomatico.FiltroDebitoAutomaticoRetornoCodigo;
import gcom.arrecadacao.pagamento.FiltroGuiaPagamento;
import gcom.arrecadacao.pagamento.FiltroGuiaPagamentoHistorico;
import gcom.arrecadacao.pagamento.FiltroPagamento;
import gcom.arrecadacao.pagamento.FiltroPagamentoCartaoDebito;
import gcom.arrecadacao.pagamento.FiltroPagamentoHistorico;
import gcom.arrecadacao.pagamento.GuiaPagamento;
import gcom.arrecadacao.pagamento.GuiaPagamentoCategoria;
import gcom.arrecadacao.pagamento.GuiaPagamentoCategoriaHistorico;
import gcom.arrecadacao.pagamento.GuiaPagamentoCategoriaHistoricoPK;
import gcom.arrecadacao.pagamento.GuiaPagamentoHistorico;
import gcom.arrecadacao.pagamento.Pagamento;
import gcom.arrecadacao.pagamento.PagamentoCartaoDebito;
import gcom.arrecadacao.pagamento.PagamentoHistorico;
import gcom.arrecadacao.pagamento.PagamentoSituacao;
import gcom.arrecadacao.pagamento.SequenciaCartao;
import gcom.arrecadacao.pagamento.bean.InserirPagamentoViaCanetaHelper;
import gcom.atendimentopublico.IRepositorioAtendimentoPublico;
import gcom.atendimentopublico.RepositorioAtendimentoPublicoHBM;
import gcom.atendimentopublico.ligacaoagua.LigacaoAguaSituacao;
import gcom.atendimentopublico.ligacaoesgoto.LigacaoEsgotoSituacao;
import gcom.atendimentopublico.ordemservico.OrdemServico;
import gcom.atendimentopublico.registroatendimento.FiltroRegistroAtendimento;
import gcom.atendimentopublico.registroatendimento.FiltroRegistroAtendimentoSolicitante;
import gcom.atendimentopublico.registroatendimento.RegistroAtendimento;
import gcom.atendimentopublico.registroatendimento.RegistroAtendimentoSolicitante;
import gcom.batch.ControladorBatchLocal;
import gcom.batch.ControladorBatchLocalHome;
import gcom.batch.UnidadeProcessamento;
import gcom.cadastro.ControladorCadastroLocal;
import gcom.cadastro.ControladorCadastroLocalHome;
import gcom.cadastro.EnvioEmail;
import gcom.cadastro.cliente.Cliente;
import gcom.cadastro.cliente.ClienteEndereco;
import gcom.cadastro.cliente.ClienteGuiaPagamento;
import gcom.cadastro.cliente.ClienteGuiaPagamentoHistorico;
import gcom.cadastro.cliente.ClienteImovel;
import gcom.cadastro.cliente.EsferaPoder;
import gcom.cadastro.cliente.FiltroCliente;
import gcom.cadastro.cliente.IClienteFone;
import gcom.cadastro.cliente.IRepositorioCliente;
import gcom.cadastro.cliente.RepositorioClienteHBM;
import gcom.cadastro.empresa.Empresa;
import gcom.cadastro.endereco.Cep;
import gcom.cadastro.endereco.ControladorEnderecoLocal;
import gcom.cadastro.endereco.ControladorEnderecoLocalHome;
import gcom.cadastro.endereco.EnderecoReferencia;
import gcom.cadastro.endereco.LogradouroBairro;
import gcom.cadastro.endereco.LogradouroCep;
import gcom.cadastro.funcionario.Funcionario;
import gcom.cadastro.imovel.Categoria;
import gcom.cadastro.imovel.ControladorImovelLocal;
import gcom.cadastro.imovel.ControladorImovelLocalHome;
import gcom.cadastro.imovel.EntidadeBeneficente;
import gcom.cadastro.imovel.FiltroCategoria;
import gcom.cadastro.imovel.FiltroEntidadeBeneficente;
import gcom.cadastro.imovel.FiltroImovel;
import gcom.cadastro.imovel.FiltroImovelDoacao;
import gcom.cadastro.imovel.FiltroImovelPerfil;
import gcom.cadastro.imovel.IRepositorioImovel;
import gcom.cadastro.imovel.Imovel;
import gcom.cadastro.imovel.ImovelDoacao;
import gcom.cadastro.imovel.ImovelPerfil;
import gcom.cadastro.imovel.RepositorioImovelHBM;
import gcom.cadastro.localidade.ControladorLocalidadeLocal;
import gcom.cadastro.localidade.ControladorLocalidadeLocalHome;
import gcom.cadastro.localidade.FiltroGerenciaRegional;
import gcom.cadastro.localidade.FiltroLocalidade;
import gcom.cadastro.localidade.FiltroUnidadeNegocio;
import gcom.cadastro.localidade.GerenciaRegional;
import gcom.cadastro.localidade.IRepositorioLocalidade;
import gcom.cadastro.localidade.Localidade;
import gcom.cadastro.localidade.Quadra;
import gcom.cadastro.localidade.RepositorioLocalidadeHBM;
import gcom.cadastro.localidade.SetorComercial;
import gcom.cadastro.localidade.UnidadeNegocio;
import gcom.cadastro.sistemaparametro.SistemaParametro;
import gcom.cobranca.CobrancaDebitoSituacao;
import gcom.cobranca.CobrancaDocumento;
import gcom.cobranca.CobrancaDocumentoItem;
import gcom.cobranca.ControladorCobrancaLocal;
import gcom.cobranca.ControladorCobrancaLocalHome;
import gcom.cobranca.DocumentoTipo;
import gcom.cobranca.FiltroCobrancaDocumento;
import gcom.cobranca.FiltroCobrancaDocumentoItem;
import gcom.cobranca.FiltroDocumentoTipo;
import gcom.cobranca.IRepositorioCobranca;
import gcom.cobranca.RepositorioCobrancaHBM;
import gcom.cobranca.bean.ContaValoresHelper;
import gcom.cobranca.bean.DebitoACobrarValoresHelper;
import gcom.cobranca.bean.GuiaPagamentoValoresHelper;
import gcom.cobranca.bean.ObterDebitoImovelOuClienteHelper;
import gcom.cobranca.contratoparcelamento.ControladorContratoParcelamentoLocal;
import gcom.cobranca.contratoparcelamento.ControladorContratoParcelamentoLocalHome;
import gcom.cobranca.contratoparcelamento.InformarPagamentoContratoParcelamentoHelper;
import gcom.cobranca.parcelamento.FiltroParcelamentoPagamentoCartaoCredito;
import gcom.cobranca.parcelamento.ParcelamentoPagamentoCartaoCredito;
import gcom.cobranca.parcelamento.ParcelamentoPerfil;
import gcom.fachada.Fachada;
import gcom.faturamento.ControladorFaturamentoLocal;
import gcom.faturamento.ControladorFaturamentoLocalHome;
import gcom.faturamento.FaturamentoGrupo;
import gcom.faturamento.GuiaPagamentoGeral;
import gcom.faturamento.IRepositorioFaturamento;
import gcom.faturamento.ImpostoTipo;
import gcom.faturamento.RepositorioFaturamentoHBM;
import gcom.faturamento.bean.CalcularValoresAguaEsgotoHelper;
import gcom.faturamento.conta.Conta;
import gcom.faturamento.conta.ContaGeral;
import gcom.faturamento.conta.ContaHistorico;
import gcom.faturamento.conta.Fatura;
import gcom.faturamento.conta.FiltroConta;
import gcom.faturamento.conta.FiltroContaHistorico;
import gcom.faturamento.conta.IConta;
import gcom.faturamento.credito.CreditoARealizar;
import gcom.faturamento.credito.CreditoARealizarGeral;
import gcom.faturamento.credito.CreditoOrigem;
import gcom.faturamento.credito.CreditoRealizado;
import gcom.faturamento.credito.CreditoTipo;
import gcom.faturamento.credito.FiltroCreditoARealizar;
import gcom.faturamento.credito.FiltroCreditoTipo;
import gcom.faturamento.debito.DebitoACobrar;
import gcom.faturamento.debito.DebitoACobrarGeral;
import gcom.faturamento.debito.DebitoACobrarHistorico;
import gcom.faturamento.debito.DebitoCreditoSituacao;
import gcom.faturamento.debito.DebitoTipo;
import gcom.faturamento.debito.FiltroDebitoACobrar;
import gcom.faturamento.debito.FiltroDebitoACobrarHistorico;
import gcom.faturamento.debito.FiltroDebitoTipo;
import gcom.financeiro.FinanciamentoTipo;
import gcom.financeiro.lancamento.LancamentoItem;
import gcom.financeiro.lancamento.LancamentoItemContabil;
import gcom.financeiro.lancamento.LancamentoTipo;
import gcom.gerencial.cadastro.IRepositorioGerencialCadastro;
import gcom.gerencial.cadastro.RepositorioGerencialCadastroHBM;
import gcom.interceptor.RegistradorOperacao;
import gcom.micromedicao.ArquivoTextoRoteiroEmpresa;
import gcom.micromedicao.ControladorMicromedicaoLocal;
import gcom.micromedicao.ControladorMicromedicaoLocalHome;
import gcom.micromedicao.IRepositorioMicromedicao;
import gcom.micromedicao.Leiturista;
import gcom.micromedicao.RepositorioMicromedicaoHBM;
import gcom.micromedicao.Rota;
import gcom.micromedicao.ServicoTipoCelular;
import gcom.micromedicao.SituacaoTransmissaoLeitura;
import gcom.micromedicao.bean.ConsultarArquivoTextoRoteiroEmpresaHelper;
import gcom.micromedicao.hidrometro.Hidrometro;
import gcom.relatorio.RelatorioAcompanhamentoMovimentoArrecadadores;
import gcom.relatorio.arrecadacao.AcertosRelatorioHelper;
import gcom.relatorio.arrecadacao.AvisoBancarioRelatorioHelper;
import gcom.relatorio.arrecadacao.DeducoesRelatorioHelper;
import gcom.relatorio.arrecadacao.GuiaDevolucaoRelatorioHelper;
import gcom.relatorio.arrecadacao.RelatorioAnaliseArrecadacaoBean;
import gcom.relatorio.arrecadacao.RelatorioAnaliseAvisosBancariosBean;
import gcom.relatorio.arrecadacao.RelatorioAnalisePagamentoCartaoDebitoBean;
import gcom.relatorio.arrecadacao.RelatorioAvisoBancarioPorContaCorrenteBean;
import gcom.relatorio.arrecadacao.RelatorioComparativoFatArrecExpurgoBean;
import gcom.relatorio.arrecadacao.RelatorioDocumentoNaoAceitosBean;
import gcom.relatorio.arrecadacao.RelatorioMovimentoArrecadador;
import gcom.relatorio.arrecadacao.RelatorioMovimentoDebitoAutomaticoBanco;
import gcom.relatorio.arrecadacao.RelatorioPagamentoEntidadesBeneficentesAnaliticoBean;
import gcom.relatorio.arrecadacao.RelatorioPagamentoEntidadesBeneficentesSinteticoBean;
import gcom.relatorio.arrecadacao.RelatorioTranferenciaPagamentoBean;
import gcom.relatorio.arrecadacao.dto.ResumoCreditosAvisosBancariosDTO;
import gcom.relatorio.arrecadacao.pagamento.GuiaPagamentoRelatorioHelper;
import gcom.relatorio.big.RelatorioBIGHelper;
import gcom.seguranca.ControladorPermissaoEspecialLocal;
import gcom.seguranca.ControladorPermissaoEspecialLocalHome;
import gcom.seguranca.acesso.Abrangencia;
import gcom.seguranca.acesso.ControladorAcessoLocal;
import gcom.seguranca.acesso.ControladorAcessoLocalHome;
import gcom.seguranca.acesso.Operacao;
import gcom.seguranca.acesso.OperacaoEfetuada;
import gcom.seguranca.acesso.usuario.Usuario;
import gcom.seguranca.acesso.usuario.UsuarioAcao;
import gcom.seguranca.acesso.usuario.UsuarioAcaoUsuarioHelper;
import gcom.seguranca.transacao.ControladorTransacaoLocal;
import gcom.seguranca.transacao.ControladorTransacaoLocalHome;
import gcom.spcserasa.ControladorSpcSerasaLocal;
import gcom.spcserasa.ControladorSpcSerasaLocalHome;
import gcom.spcserasa.IRepositorioSpcSerasa;
import gcom.spcserasa.RepositorioSpcSerasaHBM;
import gcom.tarefa.TarefaRelatorio;
import gcom.util.ConstantesAplicacao;
import gcom.util.ConstantesJNDI;
import gcom.util.ConstantesSistema;
import gcom.util.ControladorException;
import gcom.util.ControladorUtilLocal;
import gcom.util.ControladorUtilLocalHome;
import gcom.util.ErroRepositorioException;
import gcom.util.IRepositorioUtil;
import gcom.util.IoUtil;
import gcom.util.ParametroNaoInformadoException;
import gcom.util.RepositorioUtilHBM;
import gcom.util.ServiceLocator;
import gcom.util.ServiceLocatorException;
import gcom.util.SistemaException;
import gcom.util.Util;
import gcom.util.ZipUtil;
import gcom.util.email.ErroEmailException;
import gcom.util.email.ServicosEmail;
import gcom.util.filtro.Intervalo;
import gcom.util.filtro.ParametroNulo;
import gcom.util.filtro.ParametroSimples;
import gcom.util.filtro.ParametroSimplesColecao;
import gcom.util.filtro.ParametroSimplesColecaoDiferenteDe;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.zip.ZipOutputStream;

import javax.ejb.CreateException;
import javax.ejb.EJBException;
import javax.ejb.SessionBean;
import javax.ejb.SessionContext;
import javax.mail.SendFailedException;

import org.apache.log4j.Logger;


/**
 * Controlador Arrecadacao PADRÃO
 * 
 * @author Raphael Rossiter
 * @date 30/04/2007
 */
public class ControladorArrecadacao implements SessionBean {

	private static final long serialVersionUID = 1L;

	protected IRepositorioCliente repositorioCliente = null;

	protected IRepositorioImovel repositorioImovel = null;

	protected IRepositorioLocalidade repositorioLocalidade = null;

	protected IRepositorioFaturamento repositorioFaturamento = null;

	protected IRepositorioUtil repositorioUtil = null;

	protected IRepositorioArrecadacao repositorioArrecadacao = null;

	protected IRepositorioCobranca repositorioCobranca = null;

	protected IRepositorioSpcSerasa repositorioSpcSerasa = null;
	
	private IRepositorioMicromedicao repositorioMicromedicao = null;
	
	private IRepositorioGerencialCadastro repositorioGerencialCadastro = null;
	
	private IRepositorioAtendimentoPublico repositorioAtendimentoPublico = null;
	
	SessionContext sessionContext;
	
	private SistemaParametro sistemaParametro = null;
	
	private static Logger logger = Logger.getLogger(ControladorArrecadacao.class);


	/**
	 * < <Descrição do método>>
	 * 
	 * @exception CreateException
	 *                Descrição da exceção
	 */
	public void ejbCreate() throws CreateException {

		repositorioCliente = RepositorioClienteHBM.getInstancia();
		repositorioLocalidade = RepositorioLocalidadeHBM.getInstancia();
		repositorioImovel = RepositorioImovelHBM.getInstancia();
		repositorioUtil = RepositorioUtilHBM.getInstancia();
		repositorioFaturamento = RepositorioFaturamentoHBM.getInstancia();
		repositorioArrecadacao = RepositorioArrecadacaoHBM.getInstancia();
		repositorioCobranca = RepositorioCobrancaHBM.getInstancia();
		repositorioSpcSerasa = RepositorioSpcSerasaHBM.getInstancia();
		repositorioMicromedicao = RepositorioMicromedicaoHBM.getInstancia();
		repositorioGerencialCadastro = RepositorioGerencialCadastroHBM.getInstancia();
		repositorioAtendimentoPublico = RepositorioAtendimentoPublicoHBM.getInstancia();
	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbRemove() {
	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbActivate() {
	}

	/**
	 * < <Descrição do método>>
	 */
	public void ejbPassivate() {
	}

	/**
	 * Seta o valor de sessionContext
	 * 
	 * @param sessionContext
	 *            O novo valor de sessionContext
	 */
	public void setSessionContext(SessionContext sessionContext) {
		this.sessionContext = sessionContext;
	}

	/**
	 * Retorna o valor de controladorAcesso
	 * 
	 * @return O valor de controladorAcesso
	 */
	protected ControladorAcessoLocal getControladorAcesso() {
		ControladorAcessoLocalHome localHome = null;
		ControladorAcessoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorAcessoLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_ACESSO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}
	
	/**
	 * Retorna o valor de controladorAcesso
	 * 
	 * @return O valor de controladorAcesso
	 */
	protected ControladorSpcSerasaLocal getControladorSpcSerasa() {
		ControladorSpcSerasaLocalHome localHome = null;
		ControladorSpcSerasaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorSpcSerasaLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_SPC_SERASA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna o controladorCadastro
	 * 
	 * @author Thiago Tenório
	 * @date 18/08/2006
	 * 
	 */
	protected ControladorCadastroLocal getControladorCadastro() {
		ControladorCadastroLocalHome localHome = null;
		ControladorCadastroLocal local = null;

		ServiceLocator locator = null;
		try {
			locator = ServiceLocator.getInstancia();
			localHome = (ControladorCadastroLocalHome) locator
					.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_CADASTRO_SEJB);

			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}
	
	/**
	 * Retorna o valor de controladorMicromedicao
	 * 
	 * @return O valor de controladorMicromedicao
	 */
	private ControladorMicromedicaoLocal getControladorMicromedicao() {
		ControladorMicromedicaoLocalHome localHome = null;
		ControladorMicromedicaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorMicromedicaoLocalHome) locator
					.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_MICROMEDICAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * Retorna a interface remota de ControladorParametro
	 * 
	 * @return A interface remota do controlador de parâmetro
	 */
	protected ControladorLocalidadeLocal getControladorLocalidade() {
		ControladorLocalidadeLocalHome localHome = null;
		ControladorLocalidadeLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorLocalidadeLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_LOCALIDADE_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * Author: Sávio Luiz Data: 04/01/2006
	 * 
	 * Retorna o valor do Controlador de Cobranca
	 * 
	 * @return O valor de controladorCobrancaLocal
	 */
	protected ControladorCobrancaLocal getControladorCobranca() {

		ControladorCobrancaLocalHome localHome = null;
		ControladorCobrancaLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorCobrancaLocalHome) locator
					.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_COBRANCA_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}

	}

	/**
	 * Author: Vivianne Sousa Data: 1804/03/2006
	 * 
	 * Retorna o valor do Controlador Util
	 * 
	 * @return O valor de controladorUtil
	 */
	protected ControladorUtilLocal getControladorUtil() {

		ControladorUtilLocalHome localHome = null;
		ControladorUtilLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorUtilLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_UTIL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}

	}

	/**
	 * 
	 * Cria uma instância do controlador de imóvel
	 * 
	 * @author Pedro Alexandre
	 * @date 19/04/2006
	 * 
	 * @return
	 */
	protected ControladorImovelLocal getControladorImovel() {

		ControladorImovelLocalHome localHome = null;
		ControladorImovelLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorImovelLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_IMOVEL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}

	}

	/**
	 * Retorna o valor de controladorLocalidade
	 * 
	 * @return O valor de controladorLocalidade
	 */
	protected ControladorFaturamentoLocal getControladorFaturamento() {
		ControladorFaturamentoLocalHome localHome = null;
		ControladorFaturamentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorFaturamentoLocalHome) locator
					.getLocalHomePorEmpresa(ConstantesJNDI.CONTROLADOR_FATURAMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}


	/**
	 * Retorna o valor de controladorEndereco
	 * 
	 * @return O valor de controladorEndereco
	 */
	protected ControladorEnderecoLocal getControladorEndereco() {

		ControladorEnderecoLocalHome localHome = null;
		ControladorEnderecoLocal local = null;

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorEnderecoLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_ENDERECO_SEJB);

			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * 
	 * Cria uma instância do controlador de imóvel
	 * 
	 * @author Vivianne Sousa
	 * @date 01/08/2007
	 * 
	 * @return
	 */
	protected ControladorPermissaoEspecialLocal getControladorPermissaoEspecial() {
		ControladorPermissaoEspecialLocalHome localHome = null;
		ControladorPermissaoEspecialLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorPermissaoEspecialLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_PERMISSAO_ESPECIAL_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * 
	 * Cria uma instância do controlador de contrato parcelamento
	 * 
	 * @author Mariana Victor
	 * @date 04/08/2011
	 * 
	 * @return
	 */
	protected ControladorContratoParcelamentoLocal getControladorContratoParcelamento() {
		ControladorContratoParcelamentoLocalHome localHome = null;
		ControladorContratoParcelamentoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorContratoParcelamentoLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_CONTRATO_PARCELAMENTO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas à
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0020] - Processar Pagamento de Contrato Parcelamento
	 * 
	 * DOCUMENTO COBRANÇA TIPO 08 - EXTRATO CONTRATO PARCELAMENTO
	 * 
	 * @author Mariana Victor
	 * @date 04/08/2011
	 */
	@SuppressWarnings("rawtypes")
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasContratoParcelamento(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao, Usuario usuarioLogado) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();
		Collection colecaoDevolucoes = new ArrayList();

		// 1.2.	Código do cliente 
		// [FS0007] ? Validar código do cliente
		boolean idClienteInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		Integer idClienteNaBase = null;

		if (idClienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		} else {
			// 1.4.	Caso o código do cliente esteja válido, verifica o cliente 
			Integer idCliente = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idClienteNaBase = repositorioCliente
						.verificarExistenciaCliente(new Integer(idCliente));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteNaBase == null) {
				// caso o cliente não exista atribuir o valor
				//   "CÓDIGO DO CLIENTE NÃO CADASTRADO" ao campo Descrição da Ocorrência do Movimento
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		// 1.3.	Tipo do documento 
		// [FS0006] ? Validar tipo do documento
		boolean tipoDocumentoInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4());

		if (tipoDocumentoInvalido) {
			descricaoOcorrencia = "TIPO DO DOCUMENTO NÃO NUMÉRICO";
		}

		if (descricaoOcorrencia.equals("OK")) {
			// 1.5.	Caso contrário, verifica o documento de cobrança 

			// inicializa a coleção de cobranca documento item
			Object[] dadosItem = null;

			Integer idPrestacao = Integer
					.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento3());

			try {

				dadosItem = repositorioCobranca
						.obterDadosDocumentoCobrancaItemContratoParcelamento(idPrestacao);
				
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			// caso exista documento de cobrança
			// verifica se a coleção é diferente de nula
			if (dadosItem != null) {

				BigDecimal valorItemCobrado = null;
				Integer numeroPrestacao = null;
				Integer idContrato = null;
				
				if(dadosItem[0] != null) {
					valorItemCobrado = (BigDecimal) dadosItem[0];
				}
				
				if(dadosItem[1] != null) {
					numeroPrestacao = (Integer) dadosItem[1];
				}
				
				if(dadosItem[2] != null) {
					idContrato = (Integer) dadosItem[2];
				}
				
				InformarPagamentoContratoParcelamentoHelper helper = new InformarPagamentoContratoParcelamentoHelper();
				
				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(idFormaArrecadacao);
				
				helper.setIdRegistro(idContrato.toString());
				helper.setNumeroParcela(numeroPrestacao.toString());
				helper.setIdCliente(idClienteNaBase.toString());
				helper.setValorParcelado(Util.formatarMoedaReal(valorItemCobrado));
				helper.setDataPagamento(Util.formatarData(dataPagamento));
				helper.setArrecadacaoForma(arrecadacaoForma);
				
				// 1.1.1.	Caso contrário:
				//   O sistema armazena o pagamento, para cada o item cobrado
				Object[] dadosPagamento = this.getControladorContratoParcelamento()
					.efetuarPagamentoParcelaContratoParcelamentoPorCliente(
							helper, usuarioLogado);
				
				colecaoPagamentos = (Collection) dadosPagamento[1];
				
			} else {
				// 1.5.1. Caso o documento de cobrança não exista, atribuir o valor 
				//    "DOCUMENTO DE COBRANÇA INEXISTENTE" ao campo Descrição da Ocorrência do Movimento 
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				// e atribuir o valor 2 (NÃO) ao Indicador de Aceitação do Registro do Movimento
				indicadorAceitacaoRegistro = "2";
			}

		} else {
			// atribui o valor 2(NÃO) ao indicador aceitacao
			// registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		pagamentoHelperCodigoBarras.setColecaoDevolucao(colecaoDevolucoes);
		
		
		return pagamentoHelperCodigoBarras;
	}

    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores 
     * Autor: Sávio Luiz , Vivianne Sousa, Raphael Rossiter
     * Data: 30/01/2006 , 23/11/2007, 09/01/2007
     */

    @SuppressWarnings("rawtypes")
	public Collection registrarMovimentoArrecadadores(
            StringBuilder stringBuilderTxt, Short codigoArrecadador,
            String nomeArrecadador, String idTipoMovimento,
            int quantidadeRegistros, Usuario usuario, Integer idArrecadador,
            ArrecadadorContrato arrecadadorContrato)
            throws ControladorException {

        Collection<ArrecadadorMovimento> arrecadadoresMovimento = new ArrayList<ArrecadadorMovimento>();

        boolean sucesso = true;
        EnvioEmail envioEmailError = null;
        
        int aux = 1;
        
        try {

            envioEmailError = getControladorCadastro().pesquisarEnvioEmail(
                    EnvioEmail.REGISTRAR_MOVIMENTO_ARRECADADORES_COM_ERRO);

            // tamanho de cada linha da string builder
            int tamanhoLinha = 0;
            // inicio da linha da string builder
            Integer inicioLinha = 0;

            ArrecadadorMovimento arrecadadorMovimento = null;

            // inicializa um RegistroHelperCodigoA
            RegistroHelperCodigoA registroHelperCodigoA = null;
            
            // cria uma coleção com as linhas do txt
            Collection linhas = new ArrayList();
            // Coleção dos registros C para serem mandados para o acrrecadador
            Collection colecaoCodigoRegistrosC = new ArrayList();
            // cria uma coleção de avisos bancarios
            Collection<AvisoBancario> avisosBancarios = new ArrayList<AvisoBancario>();
            // cria uma coleção de pagamentos
            Collection pagamentos = new ArrayList();
            // cria uma coleção de pagamentos
            Collection devolucoes = new ArrayList();
            // cria uma coleção para os pagamentos parciais de conta
            Collection pagamentosParciais = new ArrayList();

            // recupera o numeroSequencialArquivoEnvioDebitoAutomatico da tabela ArrecadadorContrato
            // para ser inserido no arquivo de envio caso exista a coleção de registros C
            Integer numeroSequencialArquivoEnvioDebitoAutomatico = null;
            // caso seja código de barras
            Integer numeroSequecialArquivoRetornoCodigoBarras = null;
            // caso seja debito automático
            Integer numeroSequencialArquivoRetornoDebitoAutomatico = null;

            int countRegistros = 0;

            // verifica se existe o registro Z no arquivo
            boolean verificaRegistroZ = false;

            // recupera o arrecadadorContrato para atualizar o numero sequencial do arquivo
            boolean flagRetornoCodigoBarras = false;
            boolean flagRetornoDebitoAutomatico = false;
            boolean flagEnvioDebitoAutomatico = false;
            boolean flagRetornoFichaCompensacao = false;

            // cria um boolean que verifica se é a primeira linha
            boolean primeiraLinha = true;
            
            if (idTipoMovimento != null && (idTipoMovimento.equals("DEBITO AUTOMATICO") || idTipoMovimento.equals("CODIGO DE BARRAS"))) {
            //[SB0001]-Validar Arquivo de Movimento de Arrecadador 
                tamanhoLinha = 150;
                
                for (int i = 1; i <= quantidadeRegistros; i++) {
                    countRegistros = countRegistros + 1;
                    
                    String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);
                    
                    //incrementa a primeira linha.O +1 é para tirar o
    
                    // System.getProperty("line.separator")
                    inicioLinha = inicioLinha + tamanhoLinha + 1;
    
                    // cria uma variavel da descrição da ocorrencia do
                    // movimento com o valor setado para OK
                    String descricaoOcorrenciaMovimento = "OK";
                    // cria uma variavel do indicador de aceitação do
                    // registro do movimento
                    int indicadorAceitacaoRegistroMovimento = 1;
    
                    // recupera o codigo do registro
                    String codigoRegistro = linha.substring(0, 1);
    
                    short numeroSequencialAvisoBancario = 0;
    
                    
                    // verifica se é a primeira linha
                    if (primeiraLinha) {
                        /**
                         * [SF0001] - Validar Arquivo de Movimento de Arrecadador
                         * Autor: Sávio Luiz Data: 31/01/2006
                         */
                    	
                    	/*
                    	 * Colocado por Raphael Rossiter em 10/11/2008 Analista: Eduardo Borges
                    	 * [SB0001] - Validar Arquivo de Movimento de Arrecadador
                    	 */
                    	arrecadadorContrato = this.obterArrecadadorContrato(arrecadadorContrato.getId());
                    	

                        if (arrecadadorContrato != null && !arrecadadorContrato.equals("")) {
                        	// recupera o numeroSequecialArquivoRetornoCodigoBarras
                            numeroSequecialArquivoRetornoCodigoBarras = arrecadadorContrato
                            .getNumeroSequecialArquivoRetornoCodigoBarras();

                            // recupera o numeroSequencialArquivoRetornoDebitoAutomatico
                            numeroSequencialArquivoRetornoDebitoAutomatico = arrecadadorContrato
                            .getNumeroSequencialArquivoRetornoDebitoAutomatico();

                            // recupera o numeroSequencialArquivoEnvioDebitoAutomatico
                            numeroSequencialArquivoEnvioDebitoAutomatico = arrecadadorContrato
                            .getNumeroSequencialArquivoEnvioDebitoAutomatico();
                        }
                        
                        //[SF0001] - Validar Arquivo de Movimento de Arrecadador
                    	registroHelperCodigoA = this.validarArquivoMovimentoArrecadador(codigoRegistro, linha, codigoArrecadador,
                        nomeArrecadador, idTipoMovimento, arrecadadorContrato, numeroSequecialArquivoRetornoCodigoBarras, 
                        numeroSequencialArquivoRetornoDebitoAutomatico, numeroSequencialArquivoEnvioDebitoAutomatico, idArrecadador);
                    	
                    	//Verifica o Tipo de Pagamento
                        if (registroHelperCodigoA.getTipoMovimento().equals(ConstantesSistema.DEBITO_AUTOMATICO)) {
                            numeroSequencialArquivoRetornoDebitoAutomatico += 1;
                            flagRetornoDebitoAutomatico = true;
                        } 
                        else {
                            numeroSequecialArquivoRetornoCodigoBarras += 1;
                            flagRetornoCodigoBarras = true;
                        }
                    	
                    	if (registroHelperCodigoA.getCodigoBanco() != null
                                && registroHelperCodigoA.getDataGeracaoArquivo() != null) {
    
                            Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA
                                            .getDataGeracaoArquivo());
    
                            Short valorMaximoNumeroSequencia = null;
                            try {
                                valorMaximoNumeroSequencia = repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(
                                                dataGeracao, registroHelperCodigoA.getCodigoBanco());
                            } catch (ErroRepositorioException e) {
                                throw new ControladorException("erro.sistema");
                            }
    
                            if (valorMaximoNumeroSequencia != null) {
                                numeroSequencialAvisoBancario = (short) (valorMaximoNumeroSequencia.shortValue() + 1);
                            }
                        } else {
                            numeroSequencialAvisoBancario = 0;
                        }
    
                        // depois de ler a primeira linha atribui ela para falso
                        primeiraLinha = false;
    
                    } else {
    
                        // verifica se o código do registro é "A", caso seja então
                        // não existe o codigo do registro "Z" e encerra o caso de uso
                        if (codigoRegistro.toUpperCase().equals("A")) {
                            throw new ControladorException("atencao.arquivo.movimento.nao.codigo.z");
                        }
                        if (registroHelperCodigoA.getTipoMovimento() != null
                                && !registroHelperCodigoA.getTipoMovimento().equals("")) {
                            // caso o tipo de medição seja igual a DEBITO AUTOMATICO
                            if (registroHelperCodigoA.getTipoMovimento().equals("DEBITO AUTOMATICO")) {
    
                                // caso exista no arquivo codigo do registro igual de "G"
                                if (codigoRegistro.toUpperCase().equals("G")) {
                                    throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
                                }
    
                            } else {
                                // caso exista no arquivo codigo do registro diferente de "A" , "G" , "Z"
                                if (!codigoRegistro.toUpperCase().equals("A") 
                                        && !codigoRegistro.toUpperCase().equals("G")
                                        && !codigoRegistro.toUpperCase().equals("Z")) {
                                    throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
                                }
                            }
                        } else {
                            // caso exista no arquivo codigo do registro diferente de "A" , "G" , "Z"
                            if (!codigoRegistro.toUpperCase().equals("A")
                                    && !codigoRegistro.toUpperCase().equals("G")
                                    && !codigoRegistro.toUpperCase().equals("Z")) {
                                throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
                            }
    
                        }
    
                        // verifica se o código do registro é diferente de "Z", caso seja então adiciona
                        // a linha na coleção de linhas para depois serem processadas
                        if (!codigoRegistro.toUpperCase().equals("Z")) {
    
                            linhas.add(linha);
                        } else {
                            // se entrou no else então é porque tem registro Z então seta o boolean para true
                            verificaRegistroZ = true;
    
                            // caso código do registro seja "Z" então processa a coleção
                            // de linhas e inseri o movimento de arrecadadores
                            RegistroHelperCodigoZ registroHelperCodigoZ = (RegistroHelperCodigoZ) distribuirdadosRegistroMovimentoArrecadador(
                                    linha, null);
                            // caso a quantidade de registros for diferente da
                            // quantidade de registros do txt então ecerra o caso de uso
                            if (Integer.parseInt(registroHelperCodigoZ.
                                    getTotalRegistrosArquivo().trim()) != countRegistros) {
                                throw new ControladorException("atencao.total.registros.invalido");
                            }
                            
                            // [SF0002] - Inserir o movimento do arrecadador 
                            // Autor: Sávio Luiz 
                            // Data: 31/01/2006
                            arrecadadorMovimento = inserirMovimentoArrecadador(
                                    registroHelperCodigoA, registroHelperCodigoZ,idTipoMovimento);
                            arrecadadoresMovimento.add(arrecadadorMovimento);
    
                            Date dataGeracao = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA
                                            .getDataGeracaoArquivo());
    
                            // cria uma iterator para pegar linha a linha da coleção de linhas
                            Iterator linhaIterator = linhas.iterator();
                            aux = 1;
                            while (linhaIterator.hasNext()) {

                                aux++;
                                // cria uma variavel da descrição da ocorrencia do
                                // movimento com o valor setado para OK
                                descricaoOcorrenciaMovimento = "OK";
                                // cria uma variavel do indicador de aceitação do registro do movimento
                                indicadorAceitacaoRegistroMovimento = 1;
    
                                // cria uma variavel para validar data
                                boolean dataInvalida = false;
    
                                boolean valorDebitoInvalido = false;
    
                                Date dataDebito = null;
    
                                // recupera a linha da coelção
                                String linhaRegistro = (String) linhaIterator.next();
    
                                final char b = 'B';
                                final char f = 'F';
                                final char g = 'G';
                                final char x = 'X';
                                
                                // recupera o código do registro de cada linha
                                char codigoRegistroChar = linhaRegistro.substring(0, 1).toUpperCase().charAt(0);
                                switch (codigoRegistroChar) {
    
                                case b:
                                    
                                	/**
                                     * [SF0003] - Processar Registro Código B 
                                     * Autor: Sávio Luiz 
                                     * Data: 31/01/2006
                                     */
                                	
                                	//[SF0003] - Processar Registro Código B
                                	RegistroHelperCodigoC registroHelperCodigoC = this.processarRegistroCodigoTipoB(registroHelperCodigoA,
                                	linhaRegistro, arrecadadorMovimento);
                                    
                                	if (registroHelperCodigoC != null){
                                		colecaoCodigoRegistrosC.add(registroHelperCodigoC);
                                	}
                                	
                                	break;
    
                                case f:
                                	/**
                                     * [SF0004] - Processar Registro Código F 
                                     * Autor: Sávio Luiz 
                                     * Data: 31/01/2006
                                     */
                                    RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) distribuirdadosRegistroMovimentoArrecadador(
                                            linhaRegistro, null);
                                    
                                    Integer anoMesArrecadacao = Integer.parseInt(registroHelperCodigoF.getDataDebito().substring(0,6));
    
                                    boolean dataExcludentes = false;
    
                                    // valida a data
                                    dataInvalida = Util.validarAnoMesDiaSemBarra(registroHelperCodigoF.getDataDebito());
                                    if (dataInvalida) {
                                        dataExcludentes = true;
                                        descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO INVÁLIDA";
                                    }
                                    // caso a data seja inválida não verifica se é maior que a data atual
                                    if (!dataExcludentes) {
                                        // verifica se a data de bedito/pagamento é superior a atual
                                        dataDebito = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoF
                                                        .getDataDebito());
                                        //[FS0008]Validar data de débito/pagamento
                                        
                                        
                                        if (dataDebito.after(new Date())
                                        		&& (registroHelperCodigoF.getCodigoRetorno().equals("00") 
                                        		|| registroHelperCodigoF.getCodigoRetorno().equals("31"))) {
                                            descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO POSTERIOR A DATA CORRENTE";
                                        }
                                    }
                                    
                                    // VALIDANDO O ANO E MÊS DE REFERÊNCIA DA CONTA
                                    boolean anoMesReferencia = false;
                                    
                                    if (!registroHelperCodigoF.getAnoMesReferenciaConta().equals("")){
                                    	
                                    	anoMesReferencia = Util
                                        .validarAnoMesSemBarra(registroHelperCodigoF.getAnoMesReferenciaConta());
                                    }
                                    
                                    if (anoMesReferencia) {
                                        descricaoOcorrenciaMovimento = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
                                    }
                                    
                                    // valida o valor de debito recebido
                                    valorDebitoInvalido = Util
                                            .validarValorNaoNumerico(registroHelperCodigoF.getValorDebito());
                                    if (valorDebitoInvalido) {
                                        descricaoOcorrenciaMovimento = "VALOR DEBITADO/RECEBIDO NÃO NUMÉRICO";
                                    }
                                    
                                    // verifica se existe a matricula do imóvel na base
                                    Integer idImovelNaBase = null;
                                    
                                    boolean codigoDebitoAutomaticoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoF.getIdClienteEmpresa());
                                    
                                    if(codigoDebitoAutomaticoInvalido){
                                    	descricaoOcorrenciaMovimento = "CÓDIGO PARA DÉBITO AUTOMÁTICO INVÁLIDO";
                                    }
                                    
                                    Integer codigoDebitoAutomatico = new Integer(registroHelperCodigoF.getIdClienteEmpresa());
                                    
                                    FiltroImovel filtroImovel = new FiltroImovel();
                             		
                             		filtroImovel.adicionarParametro(
                             				new ParametroSimples(FiltroImovel.CODIGO_DEBITO_AUTOMATICO,codigoDebitoAutomatico));
                             		
                             		Collection colecaoImoveis = 
                             			this.getControladorUtil()
                             				.pesquisar(filtroImovel, Imovel.class.getName());
                             		
                             		if(colecaoImoveis!=null && !colecaoImoveis.isEmpty()){
                             			Imovel imovel = (Imovel) colecaoImoveis.iterator().next();                           
                                 		idImovelNaBase = imovel.getId();
                             		}else{
                             			
                             			FiltroImovel filtroImovelAntigo = new FiltroImovel();
                                  		
                             			filtroImovelAntigo.adicionarParametro(
                                  				new ParametroSimples(FiltroImovel.ID,codigoDebitoAutomatico));
                                  		
                                  		Collection colecaoImoveisAntigo = 
                                  			this.getControladorUtil()
                                  				.pesquisar(filtroImovelAntigo, Imovel.class.getName());
                             			
                                  		if(colecaoImoveisAntigo!=null && !colecaoImoveisAntigo.isEmpty()){
                                  			Imovel imovel = (Imovel) colecaoImoveisAntigo.iterator().next();                           
                                     		idImovelNaBase = imovel.getId();
                                  		
                                  		}else{
                             			
                                  			descricaoOcorrenciaMovimento = "DÉBITO AUTOMÁTICO NÃO CADASTRADO";
                             			
                                  		}
                             		}                                                        		                                
    
                                    // caso a descricao de movimento seja igual a OK
                                    if (descricaoOcorrenciaMovimento.equals("OK")) {
    
                                        // verifica a conta
                                        DebitoAutomaticoMovimento debitoAutomaticoMovimento = null;
    
                                        Integer idConta = null;
                                        
                                        if (idImovelNaBase != null) {
                                            
                                        	try {
                                        		Imovel imovel = new Imovel();
                                                imovel.setId(idImovelNaBase);
                                                
                                                // OBTENDO A CONTA ATRAVÉS DO ANO E MES DE REFERÊNCIA E A IDENTIFICAÇÃO DO IMÓVEL
                                                if (!registroHelperCodigoF.getAnoMesReferenciaConta().equals("")){
                                                	
                                                	idConta = repositorioFaturamento.pesquisarExistenciaContaComSituacaoAtual(
                                                     imovel,new Integer(registroHelperCodigoF.getAnoMesReferenciaConta()));
                                                }
                                                
                                                //OBTENDO A CONTA ATRAVÉS DA IDENTIFICAÇÃO QUE ESTA VINDO NO ARQUIVO
                                                else if (! registroHelperCodigoF.getReservadoFuturo().equals("")){
                                                	
                                                	Long identificacao = Long.valueOf(registroHelperCodigoF.getReservadoFuturo());
                                                	Conta contaPorIdentificacao = this.pesquisarExistenciaContaPorNumeroFatura(identificacao.toString());
                                                	
                                                	if (contaPorIdentificacao != null){
                                                		
                                                		idConta = contaPorIdentificacao.getId();
                                                    	registroHelperCodigoF.setAnoMesReferenciaConta(
                                                    	String.valueOf(contaPorIdentificacao.getReferencia()));
                                                	}
                                                	
                                                }
                                                
                                                if (idConta != null) {
                                                    
                                                	debitoAutomaticoMovimento = repositorioFaturamento
                                                    .obterDebitoAutomaticoMovimento(idImovelNaBase,
                                                    new Integer(registroHelperCodigoF.getAnoMesReferenciaConta()));
                                                	
                                                } 
                                                else {
                                                    descricaoOcorrenciaMovimento = "CONTA INEXISTENTE";
                                                }
                                                
                                            } catch (ErroRepositorioException e) {
                                                throw new ControladorException("erro.sistema", e);
                                            }
                                        }
    
                                        // se debitoAutomaticaMovimento for nula seta o valor para o
                                        // campo descrição movimento caso contrario atualiza o
                                        // debitoAutomaticaMovimento
                                        if (debitoAutomaticoMovimento != null) {
    
                                            DebitoAutomaticoRetornoCodigo debitoAutomaticoRetornoCodigo = new DebitoAutomaticoRetornoCodigo();
                                            debitoAutomaticoRetornoCodigo.setId(new Integer(registroHelperCodigoF.getCodigoRetorno()));
                                            debitoAutomaticoMovimento.setDebitoAutomaticoRetornoCodigo(debitoAutomaticoRetornoCodigo);
                                            debitoAutomaticoMovimento.setRetornoBanco(new Date());
                                            debitoAutomaticoMovimento.setNumeroSequenciaArquivoRecebido(new Integer(
                                                            registroHelperCodigoA.getNumeroSequencialArquivo()));
                                            debitoAutomaticoMovimento.setUltimaAlteracao(new Date());
                                            try {
                                                repositorioUtil.atualizar(debitoAutomaticoMovimento);
                                            } catch (ErroRepositorioException e) {
                                                throw new ControladorException("erro.sistema", e);
                                            }
                                            
                                            if (idImovelNaBase != null) {
                                            	if (registroHelperCodigoF.getCodigoRetorno().equals("30")) {
                                            		this.getControladorCobranca().removerDebitoAutomatico(idImovelNaBase.toString(), 
                                            				registroHelperCodigoA.getCodigoBanco(), registroHelperCodigoF.getAgenciaDebito(),
                                            				registroHelperCodigoF.getIdClienteBanco(), new Date());
                                            	}
                                            }
                                        }
    
                                        
                                        if (!registroHelperCodigoF.getAnoMesReferenciaConta().equals("")){
                                        	/**
                                        	 *
                                        	 * As contas em débito automático que retornavam com o código 31
                                        	 * não tinham o seu pagamento efetuado
                                        	 * 
                                        	 * @author Wellington Rocha
                                        	 * @date 25/01/2012*/
                                        	Integer codigoDeRetorno = new Integer (registroHelperCodigoF.getCodigoRetorno());
                                            if (codigoDeRetorno.equals(DebitoAutomaticoRetornoCodigo.DEBITADO) ||
                                            		codigoDeRetorno.equals(DebitoAutomaticoRetornoCodigo.DEBITO_EFETUADO_DATA_DIFERENTE_DA_DATA_INFORMADA)) {
        
                                                // inseri o item movimento arrecadador
                                                Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadador(
                                                    linhaRegistro,arrecadadorMovimento.getId(),descricaoOcorrenciaMovimento,
                                                    indicadorAceitacaoRegistroMovimento, idImovelNaBase);
        
                                                // inicializa o id da localidade
                                                Integer idLocalidade = null;
        
                                                /*
                                                 * Alterado por Raphael Rossiter em 09/01/2008 - Analistas: Eduardo e Aryed
                                                 * OBJ: Gerar os pagamentos associados com a localidade da conta e NÃO com
                                                 * a localidade do imóvel.
                                                 */
                                                if (idConta != null) {
                                                	
                                                	try {
                                                        idLocalidade = repositorioLocalidade
                                                        .pesquisarIdLocalidadePorConta(idConta);
        
                                                    } catch (ErroRepositorioException e) {
                                                        throw new ControladorException("erro.sistema", e);
                                                    }
                                                }
                                                else{
                                                	
                                                	try {
                                                        idLocalidade = repositorioLocalidade
                                                        .pesquisarIdLocalidade(idImovelNaBase);
        
                                                    } catch (ErroRepositorioException e) {
                                                        throw new ControladorException("erro.sistema", e);
                                                    }
                                                }
                                                
                                                // cria o objeto pagamento para setar os dados
                                                Pagamento pagamento = new Pagamento();
                                                pagamento.setAnoMesReferenciaPagamento(Integer
                                                        .parseInt(registroHelperCodigoF.getAnoMesReferenciaConta()));
                                                Integer anoMesDebito = Util.recuperaAnoMesDaData(dataDebito);
                                                // caso o ano mes da data de dedito seja maior que o ano mes de
                                                // arrecadação da tabela sistema parametro então
                                                // seta o ano mes da data de debito
                                                if (anoMesDebito > getSistemaParametro().getAnoMesArrecadacao()) {
                                                    pagamento.setAnoMesReferenciaArrecadacao(anoMesDebito);
                                                } else {
                                                    // caso contrario seta o o ano mes
                                                    // arrecadação da tabela sistema parametro
                                                    pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
                                                                    .getAnoMesArrecadacao());
                                                }
                                                // formata o valor debitado
                                                BigDecimal valorDebitado = Util.
                                                formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoF
                                                                .getValorDebito());
                                                pagamento.setValorPagamento(valorDebitado);
                                                pagamento.setDataPagamento(dataDebito);
                                                pagamento.setPagamentoSituacaoAtual(null);
                                                pagamento.setPagamentoSituacaoAnterior(null);
                                                pagamento.setDebitoTipo(null);
                                                // verifica se o id da conta é diferente de nulo
                                                if (idConta != null) {
                                                    ContaGeral conta = new ContaGeral();
                                                    conta.setId(idConta);
                                                    pagamento.setContaGeral(conta);
                                                } else {
                                                    pagamento.setContaGeral(null);
                                                }
                                                pagamento.setGuiaPagamento(null);
        
                                                // verifica se o id da Localidade é diferente de nulo
                                                if (idLocalidade != null) {
                                                    Localidade localidade = new Localidade();
                                                    localidade.setId(idLocalidade);
                                                    pagamento.setLocalidade(localidade);
                                                } else {
                                                    pagamento.setLocalidade(null);
                                                }
                                                DocumentoTipo documentoTipo = new DocumentoTipo();
                                                documentoTipo.setId(DocumentoTipo.CONTA);
                                                pagamento.setDocumentoTipo(documentoTipo);
        
                                                // seta o id do aviso bancario
        
                                                // seta o imovel
                                                if (idImovelNaBase != null) {
                                                    Imovel imovel = new Imovel();
                                                    imovel.setId(idImovelNaBase);
                                                    pagamento.setImovel(imovel);
                                                } else {
                                                    pagamento.setImovel(null);
                                                }
        
                                                ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
                                                arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItem);
        
                                                pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
        
                                                ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
                                                arrecadacaoForma.setId(ArrecadacaoForma.DEBITO_AUTOMATICO);
                                                pagamento.setArrecadacaoForma(arrecadacaoForma);
                                                pagamento.setCliente(null);
                                                pagamento.setUltimaAlteracao(new Date());
        
                                    			/*
                                    			 * Alteracao referente ao relatorio de Float - Francisco 04/11/08
                                    			 */
                                    			pagamento.setFatura(null);
                                    			pagamento.setCobrancaDocumento(null);
                                    			
                                    			DocumentoTipo documentoTipoAgregador = new DocumentoTipo();
                                    			documentoTipoAgregador.setId(DocumentoTipo.CONTA);
                                    			pagamento.setDocumentoTipoAgregador(documentoTipoAgregador);
                                    			
                                    			pagamento.setDataProcessamento(new Date());
                                    			
                                                Integer codigoBanco = new Integer(registroHelperCodigoA.getCodigoBanco());
        
                                                // pesquisa a quantidade de dias de float
                                                Short numeroDiasFloat = null;
                                                Integer idFormaArrecadacao = ArrecadacaoForma.DEBITO_AUTOMATICO;
                                                try {
                                                    numeroDiasFloat = repositorioArrecadacao
                                                            .pesquisarNumeroDiasFloat(codigoBanco,idFormaArrecadacao);
                                                } catch (ErroRepositorioException e) {
                                                    throw new ControladorException("erro.sistema", e);
                                                }
        
                                                Date dataPrevistaCredito = null;
                                                if (numeroDiasFloat != null) {
        
                                                    dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(
                                                                    dataDebito, numeroDiasFloat);
                                                } else {
                                                    dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(dataDebito, 0);
                                                }
        
                                                // 2.5.3.Parte que determina os valores calculado 
                                                // e informado do pagamento e da devolução
                                                BigDecimal valorCalcPagamento = valorDebitado;
                                                BigDecimal valorCalcDevolucao = new BigDecimal("0.00");
                                                BigDecimal valorInfPagamento = valorDebitado;
                                                BigDecimal valorInfDevolucao = new BigDecimal("0.00");
        
                                                // pesquisa o aviso bancario passando o
                                                // código do banco a data de geração
                                                // do arquivo e a data prevista calculada
                                                AvisoBancario avisoBancario = null;
                                                try {
                                                    avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(
                                                                    codigoBanco,dataGeracao,dataPrevistaCredito,arrecadadorMovimento.getId(),
                                                                    idFormaArrecadacao);
        
                                                } catch (ErroRepositorioException e) {
                                                    throw new ControladorException("erro.sistema", e);
                                                }
        
                                                // verifica seo aviso bancario é diferente de nulo
    											// Alterado por Sávio Luiz
    											// Data:04/01/2007
                                                if (avisoBancario != null) {
                                                    // avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
                                                    // avisoBancario.adicionarUsuario(usuario, usuarioAcao);
        
                                                    if (avisoBancario.getValorArrecadacaoCalculado() != null
                                                            && !avisoBancario.getValorArrecadacaoCalculado().equals("")) {
                                                        BigDecimal novoValorArrecadacaoCalculado = avisoBancario
                                                                .getValorArrecadacaoCalculado().add(valorCalcPagamento);
                                                        avisoBancario
                                                                .setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
                                                    } else {
                                                        avisoBancario.setValorArrecadacaoCalculado(valorCalcPagamento);
                                                    }
        
                                                    if (avisoBancario.getValorDevolucaoCalculado() != null
                                                            && !avisoBancario.getValorDevolucaoCalculado().equals("")) {
                                                        BigDecimal novoValorDevolucaoCalculado = avisoBancario
                                                                .getValorDevolucaoCalculado().add(valorCalcDevolucao);
                                                        avisoBancario.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
                                                    } else {
                                                        avisoBancario.setValorDevolucaoCalculado(valorCalcDevolucao);
                                                    }
        
                                                    if (avisoBancario.getValorArrecadacaoInformado() != null
                                                            && !avisoBancario.getValorArrecadacaoInformado().equals("")) {
                                                        BigDecimal novoValorArrecadacaoInformado = avisoBancario
                                                                .getValorArrecadacaoInformado().add(valorInfPagamento);
                                                        avisoBancario
                                                                .setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
                                                    } else {
                                                        avisoBancario.setValorArrecadacaoInformado(valorInfPagamento);
                                                    }
                                                    
                                                    if (avisoBancario.getValorRealizado() != null
                                                            && !avisoBancario.getValorRealizado().equals("")) {
                                                        BigDecimal novoValorArrecadacaoInformado = avisoBancario
                                                                .getValorRealizado().add(valorInfPagamento);
                                                        avisoBancario.setValorRealizado(novoValorArrecadacaoInformado);
                                                    } else {
                                                        avisoBancario.setValorRealizado(valorInfPagamento);
                                                    }
        
                                                    if (avisoBancario.getValorDevolucaoInformado() != null
                                                            && !avisoBancario.getValorDevolucaoInformado().equals("")) {
                                                        BigDecimal novoValorDevolucaoInformado = avisoBancario
                                                                .getValorDevolucaoInformado().add(valorInfDevolucao);
                                                        avisoBancario.setValorDevolucaoInformado(novoValorDevolucaoInformado);
                                                    } else {
                                                        avisoBancario.setValorDevolucaoInformado(valorInfDevolucao);
                                                    }
        
                                                    avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
                                                    avisoBancario.setUltimaAlteracao(new Date());
                                                    // atualiza o aviso bancário
                                                    try {
                                                        repositorioUtil.atualizar(avisoBancario);
                                                    } catch (ErroRepositorioException e) {
                                                        throw new ControladorException("erro.sistema", e);
                                                    }
        
                                                    pagamento.setAvisoBancario(avisoBancario);
        
                                                } else {
                                                    // seta o aviso bancario para null
                                                    pagamento.setAvisoBancario(null);
                                                    // seta o valor da data prevista para quando for inserir o
                                                    // pagamento saber de que aviso bancário o pagamento está relacionádo.
                                                    pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);
        
                                                    Iterator avisosBancarioIterator = avisosBancarios.iterator();
                                                    // cria um boolean para saber se existe algum aviso bancario da
                                                    // coleção com a mesma data prevista da data
                                                    // prevista calculada anteriormente
                                                    boolean achou = false;
                                                    while (avisosBancarioIterator.hasNext()) {
                                                        AvisoBancario avisoBancarioDaColecao = (AvisoBancario) avisosBancarioIterator
                                                                .next();
                                                        boolean comparaDataIguais = Util
                                                        .datasIguais(
                                                                avisoBancarioDaColecao
                                                                        .getDataPrevista(),
                                                                dataPrevistaCredito);
                                                		                                          
    		                                            boolean formasArrecadacaoIguais = avisoBancarioDaColecao
    		                                            	.getArrecadacaoForma().getId().intValue() ==
    		                                            		idFormaArrecadacao.intValue();
    		                                            
    		                                            boolean anoMesReferenciaArrecadacaoIguais = avisoBancarioDaColecao.getAnoMesReferenciaArrecadacao() == anoMesArrecadacao;
    	                                            
    		                                            if (comparaDataIguais && formasArrecadacaoIguais && anoMesReferenciaArrecadacaoIguais) {
        
                                                            if (avisoBancarioDaColecao.getValorArrecadacaoCalculado() != null
                                                                    && !avisoBancarioDaColecao.getValorArrecadacaoCalculado().equals("")) {
                                                                BigDecimal novoValorArrecadacaoCalculado = 
                                                                    avisoBancarioDaColecao.getValorArrecadacaoCalculado()
                                                                        .add(valorCalcPagamento);
                                                                avisoBancarioDaColecao.setValorArrecadacaoCalculado(
                                                                        novoValorArrecadacaoCalculado);
                                                            } else {
                                                                avisoBancarioDaColecao.setValorArrecadacaoCalculado(valorCalcPagamento);
                                                            }
                                                            
                                                            if (avisoBancarioDaColecao.getValorDevolucaoCalculado() != null
                                                                    && !avisoBancarioDaColecao.getValorDevolucaoCalculado().equals("")) {
                                                                BigDecimal novoValorDevolucaoCalculado = avisoBancarioDaColecao
                                                                        .getValorDevolucaoCalculado().add(valorCalcDevolucao);
                                                                avisoBancarioDaColecao.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
                                                            } else {
                                                                avisoBancarioDaColecao.setValorDevolucaoCalculado(valorCalcDevolucao);
                                                            }
        
                                                            if (avisoBancarioDaColecao
                                                                    .getValorArrecadacaoInformado() != null
                                                                    && !avisoBancarioDaColecao
                                                                            .getValorArrecadacaoInformado()
                                                                            .equals("")) {
                                                                BigDecimal novoValorArrecadacaoInformado = avisoBancarioDaColecao
                                                                        .getValorArrecadacaoInformado()
                                                                        .add(
                                                                                valorInfPagamento);
                                                                avisoBancarioDaColecao
                                                                        .setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
                                                            } else {
                                                                avisoBancarioDaColecao
                                                                        .setValorArrecadacaoInformado(valorInfPagamento);
                                                            }
        
                                                            if (avisoBancarioDaColecao
                                                                    .getValorRealizado() != null
                                                                    && !avisoBancarioDaColecao
                                                                            .getValorRealizado()
                                                                            .equals("")) {
                                                                BigDecimal novoValorArrecadacaoInformado = avisoBancarioDaColecao
                                                                        .getValorRealizado()
                                                                        .add(
                                                                                valorInfPagamento);
                                                                avisoBancarioDaColecao
                                                                        .setValorRealizado(novoValorArrecadacaoInformado);
                                                            } else {
                                                                avisoBancarioDaColecao
                                                                        .setValorRealizado(valorInfPagamento);
                                                            }
        
                                                            if (avisoBancarioDaColecao
                                                                    .getValorDevolucaoInformado() != null
                                                                    && !avisoBancarioDaColecao
                                                                            .getValorDevolucaoInformado()
                                                                            .equals("")) {
                                                                BigDecimal novoValorDevolucaoInformado = avisoBancarioDaColecao
                                                                        .getValorDevolucaoInformado()
                                                                        .add(
                                                                                valorInfDevolucao);
                                                                avisoBancarioDaColecao
                                                                        .setValorDevolucaoInformado(novoValorDevolucaoInformado);
                                                            } else {
                                                                avisoBancarioDaColecao
                                                                        .setValorDevolucaoInformado(valorInfDevolucao);
                                                            }
                                                            
                                                            avisoBancario = avisoBancarioDaColecao;
                                                            
                                                            achou = true;
                                                            break;
                                                        }
                                                    }
                                                    if (!achou) {
        
                                                        // chama o método para cria
                                                        // o objeto
                                                        // do aviso bancário
                                                        avisoBancario = gerarOcorrenciaAvisoBancario(
                                                                arrecadadorMovimento
                                                                        .getId(),
                                                                registroHelperCodigoA,
                                                                dataPrevistaCredito,
                                                                registroHelperCodigoZ
                                                                        .getValorTotalRegistrosArquivo(),
                                                                registroHelperCodigoA
                                                                        .getCodigoBanco(),
                                                                valorCalcPagamento,
                                                                valorInfPagamento,
                                                                valorCalcDevolucao,
                                                                valorInfDevolucao,
                                                                numeroSequencialAvisoBancario,
                                                                idFormaArrecadacao,
                                                               	indicadorAceitacaoRegistroMovimento,
                                                               	arrecadadorContrato.getCodigoConvenio(), anoMesArrecadacao);
        
                                                        numeroSequencialAvisoBancario += 1;
        
                                                        avisoBancario
                                                                .setValorRealizado(valorInfPagamento);
        
                                                        // adiciona o aviso bancário
                                                        // na
                                                        // coleção de avisos
                                                        // bancários
                                                        avisosBancarios
                                                                .add(avisoBancario);
                                                    }
                                                }
        
                                                // adiciona o pagamento na coleção
                                                // de
                                                // pagamentos
                                                pagamentos.add(pagamento);
                                                
                                                pagamento.setAvisoBancario(avisoBancario);
        
                                            } 
                                            else {
        
                                            	/*
                                            	 * Seta o indicador de aceitação do registro
                                            	 * do movimento para 2(NÃO).
                                            	 */
                                                indicadorAceitacaoRegistroMovimento = 2;
        
                                                // Atualiza o aviso bancário
                                                try {
                                                    descricaoOcorrenciaMovimento = repositorioArrecadacao
                                                    .pesquisarDescricaoDebitoAutomatico(new Integer(
                                                    registroHelperCodigoF.getCodigoRetorno()));
                                                    
                                                } 
                                                catch (ErroRepositorioException e) {
                                                	throw new ControladorException("erro.sistema", e);
                                                }
        
                                                // inseri o item movimento arrecadador
                                                inserirItemMovimentoArrecadador(linhaRegistro,
                                                arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
                                                indicadorAceitacaoRegistroMovimento, null);
                                            }
                                        }
                                        else{
                                        	
                                        	/*
                                        	 * Seta o indicador de aceitação do registro
                                        	 * do movimento para 2(NÃO).
                                        	 */
                                        	indicadorAceitacaoRegistroMovimento = 2;
        
                                            // Inseri o item movimento arrecadador
                                            this.inserirItemMovimentoArrecadador(linhaRegistro,
                                            arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
                                            indicadorAceitacaoRegistroMovimento, null);
                                        }
                                    } 
                                    else {
                                        
                                    	/*
                                    	 * Seta o indicador de aceitação do registro
                                    	 * do movimento para 2(NÃO).
                                    	 */
                                    	indicadorAceitacaoRegistroMovimento = 2;
    
                                        // Inseri o item movimento arrecadador
                                        this.inserirItemMovimentoArrecadador(linhaRegistro,
                                        arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento,
                                        indicadorAceitacaoRegistroMovimento, null);
                                    }
                                    
                                    break;
    
                                case g:
                                    /**
                                     * [SF0005] - Processar Registro Código G Autor:
                                     * Sávio Luiz Data: 31/01/2006
                                     */
    
                                	if (aux % 500 == 0){                                		
                                		System.out.println("MovArrec.TipoG.leituraArquivo=" + aux);	
                                	}
                                	
                                    RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) distribuirdadosRegistroMovimentoArrecadador(
                                            linhaRegistro, null);
                                    Integer anoMesReferenciaArrecadacao =  Integer.parseInt(registroHelperCodigoG.getDataPagamento().substring(0, 6));
    
                                    dataExcludentes = false;
    
                                    // valida a data
                                    dataInvalida = Util
                                            .validarAnoMesDiaSemBarra(registroHelperCodigoG
                                                    .getDataPagamento());
                                    if (dataInvalida) {
                                        dataExcludentes = true;
                                        descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO INVÁLIDA";
                                    }
                                    // caso a data seja inválida não verifica se
                                    // é maior
                                    // que a data
                                    // atual
                                    if (!dataExcludentes) {
                                        // verifica se a data de
                                        // bedito/pagamento é
                                        // superior
                                        // a atual
                                        dataDebito = Util
                                                .converteStringInvertidaSemBarraParaDate(registroHelperCodigoG
                                                        .getDataPagamento());
                                        if (dataDebito.after(new Date())) {
                                            descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO POSTERIOR A DATA CORRENTE";
                                        }
                                    }
                                    // validar data de credito
                                    if(!registroHelperCodigoG
                                            .getDataPrevistaCredito().equals("")){
                                    	
                                    	dataInvalida = Util
                                            .validarAnoMesDiaSemBarra(registroHelperCodigoG
                                                    .getDataPrevistaCredito());
                                    	
                                    	if (dataInvalida) {
                                    	
                                    		descricaoOcorrenciaMovimento = "DATA DE CRÉDITO INVÁLIDA";
                                        
                                    	}
                                    }
    
                                    // valida o valor recebido
                                    valorDebitoInvalido = Util
                                            .validarValorNaoNumerico(registroHelperCodigoG
                                                    .getValorRecebido());
                                    if (valorDebitoInvalido) {
                                        descricaoOcorrenciaMovimento = "VALOR DEBITADO/RECEBIDO NÃO NUMÉRICO";
                                    }
    
                                    // caso a descricao de movimento seja igual
                                    // a OK
                                    if (descricaoOcorrenciaMovimento.equals("OK")) {
    
                                        String codigoBarras = registroHelperCodigoG
                                                .getCodigoBarras();
    
                                        Integer idFormaArrecadacao = null;
    
                                        try {
                                        	idFormaArrecadacao = repositorioArrecadacao
                                                    .pesquisarIdArrecadacaoForma(registroHelperCodigoG
                                                            .getCodigoFormaArrecadacao());
                                        } catch (ErroRepositorioException e) {
                                            throw new ControladorException(
                                                    "erro.sistema", e);
                                        }
    
                                        if (idFormaArrecadacao == null) {
                                        	idFormaArrecadacao = ArrecadacaoForma.GUICHE_CAIXA;
                                        }
    
                                        // chama o caso de uso [UC0259] -
                                        // Processar
                                        // Pagamento com Código de Barras
                                        PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = processarPagamentosCodigoBarras(
                                                codigoBarras, dataDebito,
                                                idFormaArrecadacao, getSistemaParametro(), usuario);
    
                                        // seta a descricao da occerencia do
                                        // caso de uso
                                        // [UC0259] - Processar Pagamento com
                                        // Código de
                                        // Barras
                                        descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras
                                                .getDescricaoOcorrencia();
    
                                        // seta o indicador daaceitação do caso
                                        // de uso
                                        // [UC0259] - Processar Pagamento com
                                        // Código de
                                        // Barras
                                        indicadorAceitacaoRegistroMovimento = Integer
                                        .parseInt(pagamentoHelperCodigoBarras
                                                .getIndicadorAceitacaoRegistro());
                                        
                                        // caso o indicador de aceitação for
                                        // igual a
                                        // 1(SIM)
                                        Short numeroDiasFloat = null;
                                        Integer codigoBanco = new Integer(
                                                registroHelperCodigoA
                                                        .getCodigoBanco());
                                        
                                        Date dataPrevistaCredito = null;
                                        
                                        // verifica se a data prevista é
                                        // zero, se
                                        // for calcula a data prevista
                                        if (registroHelperCodigoG
                                                .getDataPrevistaCredito().equals("")) {
    
                                            try {
                                                numeroDiasFloat = repositorioArrecadacao
                                                        .pesquisarNumeroDiasFloat(
                                                                codigoBanco,
                                                                idFormaArrecadacao);
                                                
                                                dataPrevistaCredito = Util
                                                .adicionarNumeroDiasDeUmaData(
                                                        dataDebito, numeroDiasFloat);
                                                
                                                
                                            } catch (ErroRepositorioException e) {
                                                throw new ControladorException(
                                                        "erro.sistema", e);
                                            }
                                            	
                                        } else {
                                        	dataPrevistaCredito = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoG
                                                    .getDataPrevistaCredito());
                                        }
    
                                        // verifica se a data de
                                        // dedito/pagamento é superior
                                        // a atual
                                        
    
                                        // pesquisa o aviso bancario
                                        // passando o
                                        // código do banco a data de geração
                                        // do
                                        // arquivo
                                        // e a data prevista calculada
                                        AvisoBancario avisoBancario = null;
                                        try {
                                            avisoBancario = repositorioArrecadacao
                                                    .pesquisarAvisoBancario(
                                                            codigoBanco,
                                                            dataGeracao,
                                                            dataPrevistaCredito,arrecadadorMovimento.getId(),
                                                            idFormaArrecadacao);
                                        } catch (ErroRepositorioException e) {
                                            throw new ControladorException(
                                                    "erro.sistema", e);
                                        }
                                        // recupera o valor debitado
                                        // formatado
                                        // como
                                        // bigDecimal
                                        BigDecimal valorDebito = Util
                                                .formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG
                                                        .getRegistroHelperCodigoBarras()
                                                        .getValorPagamento());
    
                                        // 3.4.4.Parte que determina os
                                        // valores
                                        // calculado e informado do
                                        // pagamento e da
                                        // devolução
                                        BigDecimal valorCalcPagamento = new BigDecimal(
                                                "0.00");
                                        BigDecimal valorCalcDevolucao = new BigDecimal(
                                                "0.00");
                                        BigDecimal valorInfPagamento = valorDebito;
                                        BigDecimal valorInfDevolucao = new BigDecimal(
                                                "0.00");
                                        
                                        if (indicadorAceitacaoRegistroMovimento == 1) {
    
                                            Integer idImovelPagamento = null;
                                            if (pagamentoHelperCodigoBarras
                                                    .getColecaoPagamentos() != null
                                                    && !pagamentoHelperCodigoBarras
                                                            .getColecaoPagamentos()
                                                            .isEmpty()) {
                                                Pagamento pagamento = (Pagamento) Util
                                                        .retonarObjetoDeColecao(pagamentoHelperCodigoBarras
                                                                .getColecaoPagamentos());
                                                if (pagamento.getImovel() != null) {
                                                	
                                                	
                                                    idImovelPagamento = pagamento
                                                            .getImovel().getId();
                                                }
                                            }
    
                                            // inseri o item movimento
                                            // arrecadador
                                            Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadador(
                                                    linhaRegistro,
                                                    arrecadadorMovimento.getId(),
                                                    descricaoOcorrenciaMovimento,
                                                    indicadorAceitacaoRegistroMovimento,
                                                    idImovelPagamento);
                                            ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
                                            arrecadadorMovimentoItem
                                                    .setId(idArrecadadorMovimentoItem);
    
                                            /*
                                             * Verifica seo aviso bancario é diferente de nulo
                                             */
                                            if (avisoBancario != null) {
    
                                                /*
                                                 * PAGAMENTO
                                                 * 
                                                 * Recupera a coleção de pagamentos do caso de uso
                                                 * [UC0259] - Processar Pagamento com Código de Barras
                                                 * para setar o aviso bancário no objeto pagamento
                                                 */
                                            	Collection pagamentosCodigoBarras = pagamentoHelperCodigoBarras
                                                .getColecaoPagamentos();
                                                
                                                
                                                Iterator pagamentosCodigoBarraIterator = pagamentosCodigoBarras
                                                .iterator();
    
                                                while (pagamentosCodigoBarraIterator.hasNext()) {
                                                    
                                                	Pagamento pagamento = (Pagamento) 
                                                	pagamentosCodigoBarraIterator.next();
    
                                                    // Adiciona o valor do pagamento
                                                    valorCalcPagamento = valorCalcPagamento.add(pagamento
                                                    .getValorPagamento());
    
                                                    pagamento.setAvisoBancario(avisoBancario);
    
                                                    pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
    
                                                    // PAGAMENTOS QUE SERÃO INSERIDOS
                                                    pagamentos.add(pagamento);
    
                                                }
    
                                                
                                                /*
                                                 * DEVOLUÇÃO
                                                 * 
                                                 * Alterado por Raphael Rossiter em 31/10/2007
                                                 * Analista: Aryed Lins
                                                 * 
                                                 * Recupera uma coleção de devoluções do caso de uso
                                                 * [UC0259] - Processar Pagamento com Código de Barras
                                                 */
                                                Collection<Devolucao> colecaoDevolucaoCodigoBarras = 
                                                pagamentoHelperCodigoBarras.getColecaoDevolucao();
    
                                                if (colecaoDevolucaoCodigoBarras != null && 
                                                	!colecaoDevolucaoCodigoBarras.isEmpty()) {
    
                                                    for (Devolucao devolucao : colecaoDevolucaoCodigoBarras) {
    
                                                        // Adiciona o valor da devolução
                                                        valorCalcDevolucao = valorCalcDevolucao
                                                        .add(devolucao.getValorDevolucao());
    
                                                        devolucao.setAvisoBancario(avisoBancario);
    
                                                        devolucao.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
    
                                                        // DEVOLUÇÕES QUE SERÃO INSERIDAS
                                                        devolucoes.add(devolucao);
                                                    }
                                                }
                                            } 
                                            else {
                                                
                                            	/*
                                                 * PAGAMENTO
                                                 * 
                                                 * Recupera a coleção de pagamentos do caso de uso
                                                 * [UC0259] - Processar Pagamento com Código de Barras
                                                 * para setar o aviso bancário no objeto pagamento
                                                 */
                                                Collection pagamentosCodigoBarras = pagamentoHelperCodigoBarras
                                                .getColecaoPagamentos();
                                                
                                                Iterator pagamentosCodigoBarraIterator = pagamentosCodigoBarras
                                                .iterator();
    
                                                while (pagamentosCodigoBarraIterator.hasNext()) {
                                                    
                                                	Pagamento pagamento = (Pagamento) 
                                                	pagamentosCodigoBarraIterator.next();
    
                                                	 // Adiciona o valor do pagamento
                                                    valorCalcPagamento = valorCalcPagamento
                                                    .add(pagamento.getValorPagamento());
                                                    
                                                	// Seta o aviso bancario para NULL
                                                    pagamento.setAvisoBancario(null);
                                                    
                                                    pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

                                                    /*
                                                     * Seta o valor da data prevista para quando for inserir o
                                                     * pagamento saber de que aviso bancário o pagamento está
                                                     * relacionado.
                                                     */
                                                    pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);
    
                                                    //PAGAMENTOS QUE SERÃO INSERIDOS
                                                    pagamentos.add(pagamento);
    
                                                }
    
                                                
                                                /*
                                                 * DEVOLUÇÃO
                                                 * 
                                                 * Alterado por Raphael Rossiter em 31/10/2007
                                                 * Analista: Aryed Lins
                                                 * 
                                                 * Recupera uma coleção de devoluções do caso de uso
                                                 * [UC0259] - Processar Pagamento com Código de Barras
                                                 */
                                                Collection<Devolucao> colecaoDevolucaoCodigoBarras = 
                                                pagamentoHelperCodigoBarras.getColecaoDevolucao();
    
                                                if (colecaoDevolucaoCodigoBarras != null && 
                                                	!colecaoDevolucaoCodigoBarras.isEmpty()) {
    
                                                    for (Devolucao devolucao : colecaoDevolucaoCodigoBarras) {
    
                                                        // Adiciona o valor da devolução
                                                        valorCalcDevolucao = valorCalcDevolucao
                                                        .add(devolucao.getValorDevolucao());
    
                                                        devolucao.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
                                                        
                                                        /*
                                                         * Seta o valor da data prevista para quando for inserir o
                                                         * pagamento saber de que aviso bancário o pagamento está
                                                         * relacionado.
                                                         */
                                                        devolucao.setDataPrevistaCreditoHelper(dataPrevistaCredito);
    
                                                        //DEVOLUÇÕES QUE SERÃO INSERIDAS
                                                        devolucoes.add(devolucao);
                                                    }
                                                }
                                            }
                                            
                                            /*
                                             * PAGAMENTO PARCIAL
                                             * 
                                             * Alterado por Raphael Rossiter em 13/10/2009
                                             * Analista: Rosana Carvalho
                                             * 
                                             * Recupera uma coleção de pagamentos parciais do caso de uso
                                             * [UC0259] - Processar Pagamento com Código de Barras
                                             */
                                            Collection<ProcessarPagamentoParcialContaHelper> 
                                            colecaoPagamentosParciaisCodigoBarras = pagamentoHelperCodigoBarras
                                            .getColecaoProcessarPagamentoParcialContaHelper();

                                            if (colecaoPagamentosParciaisCodigoBarras != null && 
                                            	!colecaoPagamentosParciaisCodigoBarras.isEmpty()) {

                                                //PAGAMENTOS PARCIAIS QUE SERÃO INSERIDOS
                                            	pagamentosParciais.addAll(colecaoPagamentosParciaisCodigoBarras);
                                            }
    
                                        } else {
                                            // inseri o item movimento
                                            // arrecadador
                                            Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadador(
                                                    linhaRegistro,
                                                    arrecadadorMovimento.getId(),
                                                    descricaoOcorrenciaMovimento,
                                                    indicadorAceitacaoRegistroMovimento,
                                                    null);

                                            ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
                                            arrecadadorMovimentoItem
                                                    .setId(idArrecadadorMovimentoItem);
                                            
                                            // 3.5.	Caso contrário, ou seja, o Indicador de Aceitação do Registro do Movimento corresponda a 2 (NÃO):
                                            // 3.5.1. E caso exista cliente fictício para documento não identificado (CLIE_IDDOCNAOIDENTIFICADO da tabela SISTEMA_PARAMETRO com valor diferente de nulo).
                                            if (getSistemaParametro().getClienteFicticioParaAssociarOsPagamentosNaoIdentificados() != null
                                            		&& getSistemaParametro().getClienteFicticioParaAssociarOsPagamentosNaoIdentificados().getId() != null) {
                                        	  
	                                        	  // 3.5.1.1. O sistema cria um pagamento para esse cliente [SB0019 ? Inserir pagamento para cliente fictício].
	                                        	  Pagamento pagamentoCliente = this.inserirPagamentosClienteFicticio(
	                                          			registroHelperCodigoG.getValorRecebido(), 
	                                          			registroHelperCodigoG.getDataPagamento(),
	                                          			idFormaArrecadacao, dataPrevistaCredito);
	                                        	  
	                                        	  // 3.5.1.2. Adiciona o pagamento à coleção de pagamentos deste caso de uso;
	                                        	  Collection colecaoPagamentos = new ArrayList();
	                                        	  colecaoPagamentos.add(pagamentoCliente);
	                                        	  pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
	                                        	  
	                                        	  // 3.5.1.3. Determina os valores calculados e informados do pagamento e da devolução:

	                                            /*
	                                             * 3.5.2. Caso já exista o aviso bancário o sistema atualiza o valor da arrecadação e da devolução do aviso bancário 
	                                             */
	                                            if (avisoBancario != null) {
	    
	                                                /*
	                                                 * PAGAMENTO
	                                                 */
	                                            	Collection pagamentosCodigoBarras = pagamentoHelperCodigoBarras
	                                                .getColecaoPagamentos();
	                                                
	                                                
	                                                Iterator pagamentosCodigoBarraIterator = pagamentosCodigoBarras
	                                                .iterator();
	    
	                                                while (pagamentosCodigoBarraIterator.hasNext()) {
	                                                    
	                                                	Pagamento pagamento = (Pagamento) 
	                                                	pagamentosCodigoBarraIterator.next();
	    
	                                                    // Adiciona o valor do pagamento
	                                                    valorCalcPagamento = valorCalcPagamento.add(pagamento
	                                                    .getValorPagamento());
	    
	                                                    pagamento.setAvisoBancario(avisoBancario);
	    
	                                                    pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
	    
	                                                    // PAGAMENTOS QUE SERÃO INSERIDOS
	                                                    pagamentos.add(pagamento);
	    
	                                                }
	    
	                                                /*
	                                                 * DEVOLUÇÃO
	                                                 */
	                                                Collection<Devolucao> colecaoDevolucaoCodigoBarras = 
	                                                pagamentoHelperCodigoBarras.getColecaoDevolucao();
	    
	                                                if (colecaoDevolucaoCodigoBarras != null && 
	                                                	!colecaoDevolucaoCodigoBarras.isEmpty()) {
	    
	                                                    for (Devolucao devolucao : colecaoDevolucaoCodigoBarras) {
	    
	                                                        // Adiciona o valor da devolução
	                                                        valorCalcDevolucao = valorCalcDevolucao
	                                                        .add(devolucao.getValorDevolucao());
	    
	                                                        devolucao.setAvisoBancario(avisoBancario);
	    
	                                                        devolucao.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
	    
	                                                        // DEVOLUÇÕES QUE SERÃO INSERIDAS
	                                                        devolucoes.add(devolucao);
	                                                    }
	                                                }
	                                                
	                                            } else {
	                                                // 3.5.3. Caso contrário, o sistema gera uma nova ocorrência na coleção de avisos bancários 
	                                            	/*
	                                                 * PAGAMENTO
	                                                 */
	                                                Collection pagamentosCodigoBarras = pagamentoHelperCodigoBarras
	                                                .getColecaoPagamentos();
	                                                
	                                                Iterator pagamentosCodigoBarraIterator = pagamentosCodigoBarras
	                                                .iterator();
	    
	                                                while (pagamentosCodigoBarraIterator.hasNext()) {
	                                                    
	                                                	Pagamento pagamento = (Pagamento) 
	                                                	pagamentosCodigoBarraIterator.next();
	    
	                                                	 // Adiciona o valor do pagamento
	                                                    valorCalcPagamento = valorCalcPagamento
	                                                    .add(pagamento.getValorPagamento());
	                                                    
	                                                	// Seta o aviso bancario para NULL
	                                                    pagamento.setAvisoBancario(null);
	                                                    
	                                                    pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
	
	                                                    pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);
	    
	                                                    //PAGAMENTOS QUE SERÃO INSERIDOS
	                                                    pagamentos.add(pagamento);
	    
	                                                }
	    
	                                                
	                                                /*
	                                                 * DEVOLUÇÃO
	                                                 */
	                                                Collection<Devolucao> colecaoDevolucaoCodigoBarras = 
	                                                pagamentoHelperCodigoBarras.getColecaoDevolucao();
	    
	                                                if (colecaoDevolucaoCodigoBarras != null && 
	                                                	!colecaoDevolucaoCodigoBarras.isEmpty()) {
	    
	                                                    for (Devolucao devolucao : colecaoDevolucaoCodigoBarras) {
	    
	                                                        // Adiciona o valor da devolução
	                                                        valorCalcDevolucao = valorCalcDevolucao
	                                                        .add(devolucao.getValorDevolucao());
	    
	                                                        devolucao.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
	                                                        
	                                                        devolucao.setDataPrevistaCreditoHelper(dataPrevistaCredito);
	    
	                                                        //DEVOLUÇÕES QUE SERÃO INSERIDAS
	                                                        devolucoes.add(devolucao);
	                                                    }
	                                                }  
                                                }
                                            }
                                          
                                        }
    
                                        if (avisoBancario != null) {
    
                                            if (avisoBancario
                                                    .getValorArrecadacaoCalculado() != null
                                                    && !avisoBancario
                                                            .getValorArrecadacaoCalculado()
                                                            .equals("")) {
                                                BigDecimal novoValorArrecadacaoCalculado = avisoBancario
                                                        .getValorArrecadacaoCalculado()
                                                        .add(valorCalcPagamento);
                                                avisoBancario
                                                        .setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
                                            } else {
                                                avisoBancario
                                                        .setValorArrecadacaoCalculado(valorCalcPagamento);
                                            }
    
                                            if (avisoBancario
                                                    .getValorDevolucaoCalculado() != null
                                                    && !avisoBancario
                                                            .getValorDevolucaoCalculado()
                                                            .equals("")) {
                                                BigDecimal novoValorDevolucaoCalculado = avisoBancario
                                                        .getValorDevolucaoCalculado()
                                                        .add(valorCalcDevolucao);
                                                avisoBancario
                                                        .setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
                                            } else {
                                                avisoBancario
                                                        .setValorDevolucaoCalculado(valorCalcDevolucao);
                                            }
    
                                            if (avisoBancario
                                                    .getValorArrecadacaoInformado() != null
                                                    && !avisoBancario
                                                            .getValorArrecadacaoInformado()
                                                            .equals("")) {
                                                BigDecimal novoValorArrecadacaoInformado = avisoBancario
                                                        .getValorArrecadacaoInformado()
                                                        .add(valorInfPagamento);
                                                avisoBancario
                                                        .setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
                                                avisoBancario
                                                        .setValorRealizado(novoValorArrecadacaoInformado);
                                            } else {
                                                avisoBancario
                                                        .setValorArrecadacaoInformado(valorInfPagamento);
                                                avisoBancario
                                                        .setValorRealizado(valorInfPagamento);
                                            }
    
                                            // se for atualiza o valor da
                                            // arrecadação no aviso bancario
    
                                            avisoBancario
                                                    .setArrecadadorMovimento(arrecadadorMovimento);
                                            avisoBancario
                                                    .setUltimaAlteracao(new Date());
                                            // atualiza o aviso bancário
                                            try {
                                                repositorioUtil
                                                        .atualizar(avisoBancario);
                                            } catch (ErroRepositorioException e) {
                                                throw new ControladorException(
                                                        "erro.sistema", e);
                                            }
                                        } else {
                                            Iterator avisosBancarioIterator = avisosBancarios
                                                    .iterator();
                                            // cria um boolean para saber se
                                            // existe
                                            // algum aviso bancario da
                                            // coleção
                                            // com a mesma data prevista da
                                            // data
                                            // prevista calculada
                                            // anteriormente
                                            boolean achou = false;
											while (avisosBancarioIterator.hasNext()) {
												AvisoBancario avisoBancarioDaColecao = (AvisoBancario) avisosBancarioIterator.next();
												boolean comparaDataIguais = Util.datasIguais(avisoBancarioDaColecao.getDataPrevista(), dataPrevistaCredito);

												boolean formasArrecadacaoIguais = avisoBancarioDaColecao.getArrecadacaoForma().getId().intValue() == idFormaArrecadacao
														.intValue();
												
												boolean anoMesReferenciaArrecadacaoIguais = avisoBancarioDaColecao.getAnoMesReferenciaArrecadacao() == anoMesReferenciaArrecadacao;

												if (comparaDataIguais && formasArrecadacaoIguais && anoMesReferenciaArrecadacaoIguais) {

													if (avisoBancarioDaColecao.getValorArrecadacaoCalculado() != null
															&& !avisoBancarioDaColecao.getValorArrecadacaoCalculado().equals("")) {
														BigDecimal novoValorArrecadacaoCalculado = avisoBancarioDaColecao.getValorArrecadacaoCalculado().add(
																valorCalcPagamento);
														avisoBancarioDaColecao.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
													} else {
														avisoBancarioDaColecao.setValorArrecadacaoCalculado(valorCalcPagamento);
													}

													if (avisoBancarioDaColecao.getValorDevolucaoCalculado() != null
															&& !avisoBancarioDaColecao.getValorDevolucaoCalculado().equals("")) {
														BigDecimal novoValorDevolucaoCalculado = avisoBancarioDaColecao.getValorDevolucaoCalculado().add(
																valorCalcDevolucao);
														avisoBancarioDaColecao.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
													} else {
														avisoBancarioDaColecao.setValorDevolucaoCalculado(valorCalcDevolucao);
													}

													if (avisoBancarioDaColecao.getValorArrecadacaoInformado() != null
															&& !avisoBancarioDaColecao.getValorArrecadacaoInformado().equals("")) {
														BigDecimal novoValorArrecadacaoInformado = avisoBancarioDaColecao.getValorArrecadacaoInformado().add(
																valorInfPagamento);
														avisoBancarioDaColecao.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
														avisoBancarioDaColecao.setValorRealizado(novoValorArrecadacaoInformado);
													} else {
														avisoBancarioDaColecao.setValorArrecadacaoInformado(valorInfPagamento);
														avisoBancarioDaColecao.setValorRealizado(valorInfPagamento);
													}

													avisoBancario = avisoBancarioDaColecao;
													achou = true;
													break;
												}
											}
                                            if (!achou) {
                                            	
                                            							
                                            /**
                                             * @date 24/10/2013
                                             * @author Adriana Muniz e Wellington Rocha
                                             * Correção da passagem de paramêtros
                                             * */	
    
                                                // chama o método para cria
                                                // o
                                                // objeto
                                                // do aviso bancário
                                                avisoBancario = gerarOcorrenciaAvisoBancario(
                                                        arrecadadorMovimento
                                                                .getId(),
                                                        registroHelperCodigoA,
                                                        dataPrevistaCredito,
                                                        registroHelperCodigoZ
                                                                .getValorTotalRegistrosArquivo(),
                                                        registroHelperCodigoA
                                                                .getCodigoBanco(),
                                                        valorInfPagamento,
                                                        valorCalcPagamento,
                                                        valorCalcDevolucao,
                                                        valorInfDevolucao,
                                                        numeroSequencialAvisoBancario,
                                                        idFormaArrecadacao,
                                                        indicadorAceitacaoRegistroMovimento,
                                                        arrecadadorContrato.getCodigoConvenio(),
                                                        anoMesReferenciaArrecadacao);
                                                numeroSequencialAvisoBancario += 1;
    
                                                // adiciona o aviso bancário
                                                // na
                                                // coleção de avisos
                                                // bancários
                                                avisosBancarios.add(avisoBancario);
                                            }
                                        }
                                        
                                     } else {
                                        // seta o indicador de aceitação do
                                        // registro
                                        // do movimento para 2(NÃO)
                                        indicadorAceitacaoRegistroMovimento = 2;
    
                                        // inseri o item movimento arrecadador
                                        inserirItemMovimentoArrecadador(
                                                linhaRegistro,
                                                arrecadadorMovimento.getId(),
                                                descricaoOcorrenciaMovimento,
                                                indicadorAceitacaoRegistroMovimento,
                                                null);
                                    }
                                    break;
    
                                case x:
                                    /**
                                     * [SF0007] - Processar Registro Código X Autor:
                                     * Sávio Luiz Data: 21/02/2006
                                     */
    
                                    RegistroHelperCodigoX registroHelperCodigoX = (RegistroHelperCodigoX) distribuirdadosRegistroMovimentoArrecadador(
                                            linhaRegistro, null);
    
                                    Agencia agencia = null;
    
                                    try {
                                        agencia = repositorioArrecadacao
                                                .pesquisarAgencia(
                                                        registroHelperCodigoX
                                                                .getCodigoAgencia(),
                                                        new Integer(
                                                                registroHelperCodigoA
                                                                        .getCodigoBanco()));
                                    } catch (NumberFormatException e) {
                                        agencia = null;
                                    }
                                    // caso exista agencia então atualiza a agencia
                                    if (agencia != null && !agencia.equals("")) {
                                        // nome da agencia
                                        agencia
                                                .setNomeAgencia(registroHelperCodigoX
                                                        .getNomeAgencia());
                                        // id do cep
                                        Cep cep = null;
                                        try {
                                            cep = getControladorEndereco()
                                                    .pesquisarCep(
                                                            new Integer(
                                                                    registroHelperCodigoX
                                                                            .getCodigoCep()
                                                                            + registroHelperCodigoX
                                                                                    .getSufixoCep()));
                                        } catch (NumberFormatException e) {
                                            cep = null;
                                        }
    
                                        if (cep != null && !cep.equals("")) {
                                            agencia.setCep(cep);
                                        }
    
                                        // numero do imovel
                                        agencia
                                                .setNumeroImovel(registroHelperCodigoX
                                                        .getNumero());
    
                                        // numero do imovel
                                        agencia.setUltimaAlteracao(new Date());
                                        // atualiza a agencia na base
                                        getControladorUtil().atualizar(agencia);
    
                                    } else {
                                        // caso não exista agencia então cria uma
                                        // agencia com os dados do arquivo
                                        agencia = new Agencia();
                                        agencia
                                                .setCodigoAgencia(registroHelperCodigoX
                                                        .getCodigoAgencia());
                                        Banco banco = new Banco();
                                        banco
                                                .setId(Util
                                                        .converterStringParaInteger(registroHelperCodigoA
                                                                .getCodigoBanco()));
                                        agencia.setBanco(banco);
    
                                        // nome da agencia
                                        agencia
                                                .setNomeAgencia(registroHelperCodigoX
                                                        .getNomeAgencia());
                                        agencia.setNumeroTelefone("0");
    
                                        // numero do imovel
                                        agencia
                                                .setNumeroImovel(registroHelperCodigoX
                                                        .getNumero());
    
                                        // id do cep
                                        Cep cep = null;
                                        try {
                                            cep = getControladorEndereco()
                                                    .pesquisarCep(
                                                            new Integer(
                                                                    registroHelperCodigoX
                                                                            .getCodigoCep()
                                                                            + registroHelperCodigoX
                                                                                    .getSufixoCep()));
                                        } catch (NumberFormatException e) {
                                            cep = null;
                                        }
    
                                        if (cep != null && !cep.equals("")) {
                                            agencia.setCep(cep);
                                        }
    
                                        EnderecoReferencia endenrecoReferencia = new EnderecoReferencia();
                                        endenrecoReferencia
                                                .setId(EnderecoReferencia.NUMERO);
                                        agencia
                                                .setEnderecoReferencia(endenrecoReferencia);
                                        agencia.setUltimaAlteracao(new Date());
    
                                        // inseri a agencia na base
                                        getControladorUtil().inserir(agencia);
                                    }
    
                                    // inseri o item movimento arrecadador
                                    inserirItemMovimentoArrecadador(linhaRegistro,
                                            arrecadadorMovimento.getId(),
                                            descricaoOcorrenciaMovimento,
                                            indicadorAceitacaoRegistroMovimento,
                                            null);
    
                                    break;
                                // caso não tenha sido nenhuma das opções
                                // anteriores
                                default:
                                    descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO NÃO IDENTIFICADO";
    
                                    // o indicador de aceitação é setado para
                                    // 2(NÃO)
                                    indicadorAceitacaoRegistroMovimento = 2;
    
                                    // inseri o item movimento arrecadador
                                    inserirItemMovimentoArrecadador(linhaRegistro,
                                            arrecadadorMovimento.getId(),
                                            descricaoOcorrenciaMovimento,
                                            indicadorAceitacaoRegistroMovimento,
                                            null);
    
                                }
                            }
    
                            // verifica se a coleção de registros C é diferente de
                            // nulo,null
                            if (colecaoCodigoRegistrosC != null
                                    && !colecaoCodigoRegistrosC.isEmpty()) {
                                // cria um arquivo para mandar para o banco com os
                                // registros do tipo c
                                gerarArquivoRegistrosTipoC(
                                        registroHelperCodigoA,
                                        registroHelperCodigoZ,
                                        colecaoCodigoRegistrosC,
                                        numeroSequencialArquivoEnvioDebitoAutomatico,
                                        descricaoOcorrenciaMovimento,
                                        indicadorAceitacaoRegistroMovimento,
                                        idTipoMovimento);
    
                            }
    
                            // verifica se a coleção de avisos bancario é diferente
                            // de
                            // nulo
                            if (avisosBancarios != null
                                    && !avisosBancarios.isEmpty()) {
                                Iterator avisosBancarioIterator = avisosBancarios
                                        .iterator();
                                while (avisosBancarioIterator.hasNext()) {
                                    AvisoBancario avisoBancario = (AvisoBancario) avisosBancarioIterator
                                            .next();
                                    // avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
                                    // avisoBancario
                                    // .adicionarUsuario(usuario, usuarioAcao);
                                    //
                                    // inseri o aviso bancário na base e recupera o
                                    // id
                                    Integer idAvisoBancario = (Integer)getControladorUtil()
                                            .inserir(avisoBancario);
    
                                    avisoBancario.setId(idAvisoBancario);
    
                                }
                            }
    
                            // PREPARANDO A INSERÇÃO DOS PAGAMENTOS
                            if (pagamentos != null && !pagamentos.isEmpty()) {
    
                                Collection colecaoPagamentos = new ArrayList();
    
                                Iterator pagamentoIterator = pagamentos.iterator();
                                
                                while (pagamentoIterator.hasNext()) {
                                    
                                	Pagamento pagamento = (Pagamento) pagamentoIterator.next();
                                    
                                    /*
                                     * Verifica se existe o aviso bancário no pagamento,
                                     * se não existe então seta o aviso bancário no pagamento
                                     */
                                	if (pagamento.getAvisoBancario() == null) {
                                        
                                		Iterator avisosBancarioIterator = avisosBancarios.iterator();
                                        
                                		while (avisosBancarioIterator.hasNext()) {
                                            
                                			AvisoBancario avisoBancario = (AvisoBancario) 
                                			avisosBancarioIterator.next();
                                            
                                			/*
                                			 * Caso a data prevista seja a mesma estão seta o aviso
                                			 * bancário no pagamento.
                                			 */
                                			boolean comparaDataIguais = Util.datasIguais(
                                            avisoBancario.getDataPrevista(),
                                            pagamento.getDataPrevistaCreditoHelper());
                                    		                                    
		                                    boolean formasArrecadacaoIguais = 
		                                    avisoBancario.getArrecadacaoForma().getId().intValue() ==
		                                    pagamento.getArrecadacaoForma().getId().intValue();
		                                    
		                                    if (comparaDataIguais && formasArrecadacaoIguais) {

                                                pagamento.setAvisoBancario(avisoBancario);
                                                break;
                                            }
                                        }
                                    }
                                	
                                	//PAGAMENTOS QUE SERÃO INSERIDOS
                                    colecaoPagamentos.add(pagamento);
                                }
    
                                System.out.println(" >> MovArrec.Inserindo pagamentos [" 
                                + nomeArrecadador + ", " + idTipoMovimento + "] = " + colecaoPagamentos.size());
                                
                                
                                //INSERINDO OS PAGAMENTOS
                                getControladorBatch().inserirColecaoObjetoParaBatchTransacao(
                                colecaoPagamentos);
                                
                                
                                System.out.println(" >> MovArrec.Pagamentos inseridos [" 
                                + nomeArrecadador + ", " + idTipoMovimento + "] = " + colecaoPagamentos.size());
                                
                                
                                /*
                                 * Alterado por Francisco - 28/05/2008 / Analista: Ana Breda
                                 * 
                                 * Para cada pagamento, atualizar os itens de documento de cobranca correspondente
                                 * Para uso do Resumo de Ações de cobranca
                                 */
                                int contador = 1;
                                int total = colecaoPagamentos.size();
                                Iterator iter = colecaoPagamentos.iterator();
                                
                                while (iter.hasNext()) {
                                	
                                	if (contador++ % 500 == 0){
                                		
                                		System.out.println(" >> MovArrec.Atualizando itens de cobranca[" 
                                		+ contador++ + "/" + total +"]");
                                		
                                	}
                                	
                                	Pagamento pagamento = (Pagamento) iter.next();
									
									getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
									CobrancaDebitoSituacao.PAGO);		
									
									//CRC2725 - alterado por Vivianne Sousa - 11/09/2009 analista:Fátima
									//Atualizar os itens de negativação
									//[SB0017] - Verificar correspondência do pagamento com item de cobrança ou de negativação
									getControladorSpcSerasa().atualizarNegativadorMovimentoRegItemAPartirPagamento(pagamento);
									

								}
                                
                                System.out.println(" >> MovArrec.Finalizou atualização dos itens");
                            }
    
                            
                            // PREPARANDO A INSERÇÃO DAS DEVOLUÇÕES
                            if (devolucoes != null && !devolucoes.isEmpty()) {
    
                                /*
                                 * Colocado por Raphael Rossiter em 29/10/2007
                                 * Analista: Aryed Lins 
                                 * 
                                 * OBJ: Este caso de uso ficará
                                 * responsável pela inserção das guias de devolução
                                 */
                                Integer idGuiaDevolucao = null;
                                Collection colecaoDevolucao = new ArrayList();
    
                                Iterator devolucaoIterator = devolucoes.iterator();
                                
                                while (devolucaoIterator.hasNext()) {
                                    
                                	Devolucao devolucao = (Devolucao) devolucaoIterator.next();
                                    
                                	/*
                                	 * Verifica se existe o aviso bancário no pagamento,
                                	 * se não existe então seta o aviso bancario no pagamento
                                	 */
                                	if (devolucao.getAvisoBancario() == null) {
                                        
                                		Iterator avisosBancarioIterator = avisosBancarios.iterator();
                                        
                                		while (avisosBancarioIterator.hasNext()) {
                                            
                                			AvisoBancario avisoBancario = (AvisoBancario) 
                                			avisosBancarioIterator.next();
                                            
                                			/*
                                			 * Caso a data prevista seja a mesma estão seta o aviso
                                			 * bancário no pagamento
                                			 */
                                			boolean comparaDataIguais = Util.datasIguais(
                                            devolucao.getDataPrevistaCreditoHelper(),
                                            avisoBancario.getDataPrevista());
                                            
                                			if (comparaDataIguais) {
                                                
                                				devolucao.setAvisoBancario(avisoBancario);
                                                
                                				break;
                                            }
                                        }
                                    }
                                	
                                    /*
                                     * Colocado por Sávio Luiz em 14/11/2007
                                     * Analista: Aryed Lins 
                                     * 
                                     * OBJ: Este caso de uso ficará responsável pela inserção das 
                                     * guias de devolução
                                     */
                                    if (devolucao.getGuiaDevolucao() != null) {
                                        
                                    	//GERANDO A GUIA DE DEVOLUÇÃO
                                    	idGuiaDevolucao = (Integer) getControladorUtil()
                                        .inserir(devolucao.getGuiaDevolucao());
                                        
                                    	devolucao.getGuiaDevolucao().setId(idGuiaDevolucao);
                                    }
    
                                    colecaoDevolucao.add(devolucao);
                                }
    
                                //INSERINDO AS DEVOLUÇÕES
                                getControladorBatch().inserirColecaoObjetoParaBatchTransacao(
                                colecaoDevolucao);
    
                            }
                            
                            // PREPARANDO A RETIFICAÇÃO DAS CONTAS PARA DAR BAIXA NOS PAGAMENTOS PARCIAIS
                            if (pagamentosParciais != null && !pagamentosParciais.isEmpty()) {
                            	
                            	try {
                            		
                            		Iterator pagamentosParciaisIterator = pagamentosParciais.iterator();
                                    
                                    while (pagamentosParciaisIterator.hasNext()) {
                                        
                                    	ProcessarPagamentoParcialContaHelper helper = 
                                    	(ProcessarPagamentoParcialContaHelper) pagamentosParciaisIterator.next();
                                        
                                    	System.out.println(" >> MovArrec.Retificando Contas[ ID Conta = " 
                                    	+ helper.getConta().getId().toString() + " ]");
                                    	
                                    	Integer consumoAgua = 0;
                                		if (helper.getConta().getConsumoAgua() != null){
                                			consumoAgua = helper.getConta().getConsumoAgua();
                                		}
                                		
                                		Integer volumeEsgoto = 0;
                                		if (helper.getConta().getConsumoEsgoto() != null){
                                			volumeEsgoto = helper.getConta().getConsumoEsgoto();
                                		}
                                    	
                                    	//[UC0150] - Retificar Conta
                						this.getControladorFaturamento().retificarConta(
                						new Integer(helper.getConta().getReferencia()), helper.getConta(), 
                						helper.getConta().getImovel(), helper.getColecaoDebitoCobrado(), 
                						helper.getColecaoCreditoRealizado(), helper.getConta().getLigacaoAguaSituacao(),
                						helper.getConta().getLigacaoEsgotoSituacao(), 
                						helper.getColecaoCategoriaOUSubcategoria(), 
                						consumoAgua.toString(), volumeEsgoto.toString(), 
                						helper.getConta().getPercentualEsgoto().toString(),
                						helper.getConta().getDataVencimentoConta(), 
                						helper.getValoresConta(), helper.getContaMotivoRetificacao(), null, 
                						Usuario.USUARIO_BATCH, 
                						helper.getConta().getConsumoTarifa().getId().toString(), false,
                						null,null,false, null,null,null,null,null);

                                    }
                                    
                                    System.out.println(" >> MovArrec.Finalizou Retificação das Contas");
                                    
                            	} catch (Exception ex) {
                    				sessionContext.setRollbackOnly();
                    				ex.printStackTrace();
                    				new ControladorException("erro.sistema", ex);
                    			}
                            	
                            }
    
                            // o sistema atualiza o numero sequencial do
                            // arquivo(NSA)
                            // verifica o tipo de pagamento
                            if (registroHelperCodigoA.getTipoMovimento().equals(
                                    ConstantesSistema.DEBITO_AUTOMATICO)) {
                                arrecadadorContrato
                                        .setNumeroSequencialArquivoRetornoDebitoAutomatico(numeroSequencialArquivoRetornoDebitoAutomatico);
    
                            } else {
                                arrecadadorContrato
                                        .setNumeroSequecialArquivoRetornoCodigoBarras(numeroSequecialArquivoRetornoCodigoBarras);
    
                            }
    
                            // caso a coleção de registros c não está vazia então
                            // adiciona mais 1 para numero do
                            // sequencial do arquivo de envio.
                            if (colecaoCodigoRegistrosC != null
                                    && !colecaoCodigoRegistrosC.isEmpty()) {
                                numeroSequencialArquivoEnvioDebitoAutomatico += 1;
                                flagEnvioDebitoAutomatico = true;
                                arrecadadorContrato
                                        .setNumeroSequencialArquivoEnvioDebitoAutomatico(numeroSequencialArquivoEnvioDebitoAutomatico);
                            }
    
                            // atualiza arrecadação contrato na base
                            try {
                                repositorioArrecadacao
                                        .atualizarDadosArrecadadorContrato(
                                                arrecadadorContrato,
                                                flagEnvioDebitoAutomatico,
                                                flagRetornoCodigoBarras,
                                                flagRetornoDebitoAutomatico,
                                                flagRetornoFichaCompensacao);
                            } catch (ErroRepositorioException e) {
                                throw new ControladorException("erro.sistema", e);
                            }
    
                            // -- PARTE QUE LIMPA OS CAMPOS PARA LER UM NOVO ARQUIVO(CASO EXISTA)--
                            linhas = new ArrayList();
                            registroHelperCodigoA = null;
                            colecaoCodigoRegistrosC = new ArrayList();
                            primeiraLinha = true;
                            avisosBancarios = new ArrayList();
                            pagamentos = new ArrayList();
                            //comentador por: Anderson Italo
                            //data:15/03/2010
                            //motivo: Não faz sentido limpar o arrecadadorContrato pois
                            //apenas deve existir um, devido ao usuário ter informado o código do
                            //convênio na tela.
                            //arrecadadorContrato = null;
                            flagEnvioDebitoAutomatico = false;
                            flagRetornoCodigoBarras = false;
                            flagRetornoDebitoAutomatico = false;
                            countRegistros = 0;
                            devolucoes = new ArrayList();
                        }
    
                    }
                }
                // caso não exista o registro Z.
                if (!verificaRegistroZ) {
                    throw new ControladorException(
                            "atencao.arquivo.movimento.nao.codigo.z");
                }
                
            }else{
                tamanhoLinha = 400;

                flagRetornoFichaCompensacao = true;
                
                boolean verificaRegistro9 = false;
                
                //Integer numeroSequecialArquivoRetornoFichaComp = null;
                
                RegistroFichaCompensacaoHeaderHelper registroHeader = null;
                RegistroFichaCompensacaoTipo7Helper registroTipo7 = null;
                RegistroFichaCompensacaoTrailerHelper registroTrailer = null;
                
                
                
                BigDecimal somatorioValorRecebido = BigDecimal.ZERO;
                
                for (int i = 1; i <= quantidadeRegistros; i++) {
                    countRegistros = countRegistros + 1;
    
                    String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);
                    
                    inicioLinha = inicioLinha + tamanhoLinha + 1;
    
                    String descricaoOcorrenciaMovimento = "OK";
                    int indicadorAceitacaoRegistroMovimento = 1;
    
                    String codigoRegistro = linha.substring(0, 1);
    
                    short numeroSequencialAvisoBancario = 0;
                    
                    if (primeiraLinha) {
                    	arrecadadorContrato = this.obterArrecadadorContrato(arrecadadorContrato.getId());

                    	registroHeader = RegistroFichaCompensacaoBuilder.getHeader(linha, arrecadadorContrato);

                    	if (registroHeader.getIdCodigoBanco() != null
                                && registroHeader.getDataGravacao() != null) {
    
                            Date dataGeracao = Util.converteStringSemBarraParaDateAnoSimples(registroHeader.getDataGravacao());
    
                            Short valorMaximoNumeroSequencia = null;
                            try {
                                valorMaximoNumeroSequencia = repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(
                                                dataGeracao, registroHeader.getIdCodigoBanco());
                            } catch (ErroRepositorioException e) {
                                throw new ControladorException("erro.sistema");
                            }
    
                            if (valorMaximoNumeroSequencia != null) {
                                numeroSequencialAvisoBancario = (short) (valorMaximoNumeroSequencia.shortValue() + 1);
                            }
                        } else {
                            numeroSequencialAvisoBancario = 0;
                        }
                        
                        primeiraLinha = false;

                    } else {
                    	
                        if (!codigoRegistro.equals("0") && !codigoRegistro.equals("2")
                            && !codigoRegistro.equals("3") && !codigoRegistro.equals("5")
                            && !codigoRegistro.equals("7") && !codigoRegistro.equals("9")) {
                            throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
                        }
                        
                        if (!codigoRegistro.equals("9")){
                              linhas.add(linha);
                        } else {
                            verificaRegistro9 = true;
                            
                            registroTrailer = RegistroFichaCompensacaoBuilder.getTrailer(linha);

                            if (registroTrailer.getTotalLinhas() != countRegistros) {
                                throw new ControladorException("atencao.total.registros.invalido");
                            }
                            
                            arrecadadorMovimento = inserirMovimentoArrecadadorFichaCompensacaoNovo(registroHeader, registroTrailer);
                            
                            arrecadadoresMovimento.add(arrecadadorMovimento);

                            Iterator linhaIterator = linhas.iterator();
                            aux = 1;

                            while (linhaIterator.hasNext()) {

                            	aux++;
                            	descricaoOcorrenciaMovimento = "OK";
                            	indicadorAceitacaoRegistroMovimento = 1;

                            	boolean dataValida = false;
                            	//boolean valorDebitoInvalido = false;
                            	//Date dataDebito = null;

                            	String linhaRegistro = (String) linhaIterator.next();

                            	Integer codigoRegistroInteger = new Integer (linhaRegistro.substring(0,1));

                            	switch (codigoRegistroInteger) {

                            	case 7:
                            		registroTipo7 = RegistroFichaCompensacaoBuilder.getTipo7(linhaRegistro);
                            		
                            		dataValida = Util.validarDiaMesAnoSemBarraAnoSimples(registroTipo7.getDataLiquidacao());
                            		if (!dataValida) {
                            			descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO INVÁLIDA";
                            		} else {
                            			if (registroTipo7.getDataLiquidacaoFormatado().after(new Date())) {
                            				descricaoOcorrenciaMovimento = "DATA DE DÉBITO/PAGAMENTO POSTERIOR A DATA CORRENTE";
                            			}
                            		}

                            		if (Util.validarValorNaoNumerico(registroTipo7.getValorRecebido())) {
                            			descricaoOcorrenciaMovimento = "VALOR DEBITADO/RECEBIDO NÃO NUMÉRICO";
                            		}

                            		somatorioValorRecebido = somatorioValorRecebido.add(registroTipo7.getValorRecebidoFormatado());
                            		
                            		Date dataLiquidacao = Util.converteStringSemBarraParaDateAnoSimples(registroTipo7.getDataLiquidacao());
                                    Integer anoMesReferenciaArrecadacao = Integer.parseInt(new SimpleDateFormat("yyyyMM").format(dataLiquidacao));

                            		if (descricaoOcorrenciaMovimento.equals("OK")) {


                            			PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = processarPagamentosFichaCompensacaoNovo(
                            					registroTipo7, ArrecadacaoForma.FICHA_COMPENSACAO, usuario);

                            			descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras.getDescricaoOcorrencia();

                            			indicadorAceitacaoRegistroMovimento = Integer.parseInt(pagamentoHelperCodigoBarras.getIndicadorAceitacaoRegistro());

                            			Date dataPrevistaCredito = Util.adicionarNumeroDiasDeUmaData(registroTipo7.getDataLiquidacaoFormatado(), 2);

                            			AvisoBancario avisoBancario = null;

                            			try {
                            				avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(
                            						Integer.valueOf(registroHeader.getIdCodigoBanco()), registroHeader.getDataGravacaoFormatado(), 
                            						dataPrevistaCredito,arrecadadorMovimento.getId(),
                            						ArrecadacaoForma.FICHA_COMPENSACAO);
                            			} catch (ErroRepositorioException e) {
                            				throw new ControladorException("erro.sistema", e);
                            			}


                            			BigDecimal valorCalcPagamento = new BigDecimal("0.00");
                            			BigDecimal valorCalcDevolucao = new BigDecimal("0.00");
                            			BigDecimal valorInfPagamento = registroTipo7.getValorRecebidoFormatado();
                            			BigDecimal valorInfDevolucao = new BigDecimal("0.00");

                            			if (indicadorAceitacaoRegistroMovimento == 1) {

                            				Integer idImovelPagamento = null;
                            				if (pagamentoHelperCodigoBarras.getColecaoPagamentos() != null
                            						&& !pagamentoHelperCodigoBarras.getColecaoPagamentos().isEmpty()) {

                            					Pagamento pagamento = (Pagamento) Util
                            							.retonarObjetoDeColecao(pagamentoHelperCodigoBarras.getColecaoPagamentos());

                            					if (pagamento.getImovel() != null) {
                            						idImovelPagamento = pagamento.getImovel().getId();
                            					}
                            				}

                            				Integer idArrecadadorMovimentoItem = inserirItemMovimentoArrecadadorFichaCompensacaoNovo(
                            						linhaRegistro, arrecadadorMovimento.getId(), descricaoOcorrenciaMovimento, 
                            						indicadorAceitacaoRegistroMovimento,idImovelPagamento);

                            				ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
                            				arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItem);

                            				if (avisoBancario != null && avisoBancario.getValorArrecadacaoCalculado().compareTo(BigDecimal.ZERO) == 0) {

                            					Collection pagamentosFichaCompensacao = pagamentoHelperCodigoBarras.getColecaoPagamentos();
                            					Iterator pagamentosFichaCompensacaoIterator = pagamentosFichaCompensacao.iterator();

                            					while (pagamentosFichaCompensacaoIterator.hasNext()) {
                            						Pagamento pagamento = (Pagamento) pagamentosFichaCompensacaoIterator.next();

                            						valorCalcPagamento = valorCalcPagamento.add(pagamento.getValorPagamento());

                            						pagamento.setAvisoBancario(avisoBancario);
                            						pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

                            						pagamentos.add(pagamento);

                            					}

                            				} else {
                            					Collection pagamentosFichaCompensacao = pagamentoHelperCodigoBarras.getColecaoPagamentos();
                            					Iterator pagamentosFichaCompensacaoIterator = pagamentosFichaCompensacao.iterator();

                            					while (pagamentosFichaCompensacaoIterator.hasNext()) {
                            						Pagamento pagamento = (Pagamento) pagamentosFichaCompensacaoIterator.next();

                            						pagamento.setAvisoBancario(null);
                            						pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);
                            						pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);

                            						valorCalcPagamento = valorCalcPagamento.add(pagamento.getValorPagamento());

                            						pagamentos.add(pagamento);

                            					}
                            				}

                            			}

                            			if (avisoBancario != null) {

                            				if (avisoBancario.getValorArrecadacaoCalculado() != null
                            						&& !avisoBancario.getValorArrecadacaoCalculado().equals("")) {
                            					BigDecimal novoValorArrecadacaoCalculado = avisoBancario
                            							.getValorArrecadacaoCalculado().add(valorCalcPagamento);
                            					avisoBancario.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
                            				} else {
                            					avisoBancario.setValorArrecadacaoCalculado(valorCalcPagamento);
                            				}

                            				if (avisoBancario.getValorDevolucaoCalculado() != null
                            						&& !avisoBancario.getValorDevolucaoCalculado().equals("")) {
                            					BigDecimal novoValorDevolucaoCalculado = avisoBancario
                            							.getValorDevolucaoCalculado().add(valorCalcDevolucao);
                            					avisoBancario.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
                            				} else {
                            					avisoBancario.setValorDevolucaoCalculado(valorCalcDevolucao);
                            				}

                            				if (avisoBancario.getValorArrecadacaoInformado() != null
                            						&& !avisoBancario.getValorArrecadacaoInformado().equals("")) {
                            					BigDecimal novoValorArrecadacaoInformado = avisoBancario
                            							.getValorArrecadacaoInformado().add(valorInfPagamento);
                            					avisoBancario.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
                            					avisoBancario.setValorRealizado(novoValorArrecadacaoInformado);
                            				} else {
                            					avisoBancario.setValorArrecadacaoInformado(valorInfPagamento);
                            					avisoBancario.setValorRealizado(valorInfPagamento);
                            				}

                            				avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
                            				avisoBancario.setUltimaAlteracao(new Date());

                            				try {
                            					repositorioUtil.atualizar(avisoBancario);
                            				} catch (ErroRepositorioException e) {
                            					throw new ControladorException("erro.sistema", e);
                            				}
                            			} else {
                            				Iterator<AvisoBancario> avisosBancarioIterator = avisosBancarios.iterator();

                            				boolean achou = false;
                            				while (avisosBancarioIterator.hasNext()) {
                            					AvisoBancario avisoBancarioDaColecao = avisosBancarioIterator.next();
                            					boolean comparaDataIguais = Util.datasIguais(avisoBancarioDaColecao.getDataPrevista(), dataPrevistaCredito);
                            					boolean comparaAnoMeReferenciaIguais = avisoBancarioDaColecao.getAnoMesReferenciaArrecadacao() == anoMesReferenciaArrecadacao;
                            					if (comparaDataIguais && comparaAnoMeReferenciaIguais) {

                            						if (avisoBancarioDaColecao.getValorArrecadacaoCalculado() != null
                            								&& !avisoBancarioDaColecao.getValorArrecadacaoCalculado().equals("")) {
                            							BigDecimal novoValorArrecadacaoCalculado = avisoBancarioDaColecao
                            									.getValorArrecadacaoCalculado().add(valorCalcPagamento);
                            							avisoBancarioDaColecao.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
                            						} else {
                            							avisoBancarioDaColecao.setValorArrecadacaoCalculado(valorCalcPagamento);
                            						}

                            						if (avisoBancarioDaColecao.getValorDevolucaoCalculado() != null
                            								&& !avisoBancarioDaColecao.getValorDevolucaoCalculado().equals("")) {
                            							BigDecimal novoValorDevolucaoCalculado = avisoBancarioDaColecao
                            									.getValorDevolucaoCalculado().add(valorCalcDevolucao);
                            							avisoBancarioDaColecao.setValorDevolucaoCalculado(novoValorDevolucaoCalculado);
                            						} else {
                            							avisoBancarioDaColecao.setValorDevolucaoCalculado(valorCalcDevolucao);
                            						}

                            						if (avisoBancarioDaColecao.getValorArrecadacaoInformado() != null
                            								&& !avisoBancarioDaColecao.getValorArrecadacaoInformado().equals("")) {
                            							BigDecimal novoValorArrecadacaoInformado = avisoBancarioDaColecao
                            									.getValorArrecadacaoInformado().add(valorInfPagamento);
                            							avisoBancarioDaColecao.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
                            							avisoBancarioDaColecao.setValorRealizado(novoValorArrecadacaoInformado);
                            						} else {
                            							avisoBancarioDaColecao.setValorArrecadacaoInformado(valorInfPagamento);
                            							avisoBancarioDaColecao.setValorRealizado(valorInfPagamento);
                            						}

                            						achou = true;
                            						break;
                            					}
                            				}
                            				if (!achou) {

                            					avisoBancario = gerarOcorrenciaFichaAvisoBancarioNovo(
                            							arrecadadorMovimento.getId(), registroHeader,
                            							dataPrevistaCredito, anoMesReferenciaArrecadacao,
                            							valorInfPagamento, valorCalcPagamento, valorCalcDevolucao,      
                            							valorInfDevolucao, numeroSequencialAvisoBancario);

                            					numeroSequencialAvisoBancario += 1;

                            					avisosBancarios.add(avisoBancario);
                            				}
                            			}
                            		}

                            		break;


                            		// caso não tenha sido nenhuma das opções
                            		// anteriores
                            	default:
                            		descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO NÃO IDENTIFICADO";

                            		// o indicador de aceitação é setado para 2(NÃO)
                            		indicadorAceitacaoRegistroMovimento = 2;

                            		// inseri o item movimento arrecadador
                            		inserirItemMovimentoArrecadador(linhaRegistro,
                            				arrecadadorMovimento.getId(),
                            				descricaoOcorrenciaMovimento,
                            				indicadorAceitacaoRegistroMovimento,
                            				null);

                            	}
                            }
                            
                            // atualiza valor total movimento do ARRECADADOR_MOVIMENTO
                            atualizarValorMovimentoArrecadadorMovimento(
                                    arrecadadorMovimento.getId(), somatorioValorRecebido);
                            
                            
                            //verifica se a coleção de avisos bancario é diferente de nulo
                            if (avisosBancarios != null && !avisosBancarios.isEmpty()) {
                                Iterator avisosBancarioIterator = avisosBancarios.iterator();
                                while (avisosBancarioIterator.hasNext()) {
                                    AvisoBancario avisoBancario = (AvisoBancario) avisosBancarioIterator.next();
                                    
                                    // insere o aviso bancário na base e recupera o id
                                    Integer idAvisoBancario = (Integer) getControladorUtil().inserir(avisoBancario);
    
                                    avisoBancario.setId(idAvisoBancario);
    
                                }
                            }
    
                            // verifica se a coleção de pagamentos está diferente de nulo
    
                            if (pagamentos != null && !pagamentos.isEmpty()) {
    
                                Collection colecaoPagamentos = new ArrayList();
    
                                Iterator pagamentoIterator = pagamentos.iterator();
                                while (pagamentoIterator.hasNext()) {
                                    Pagamento pagamento = (Pagamento) pagamentoIterator.next();
                                    // verifica se existe o aviso bancario no pagamento,
                                    // se não existe então seta o aviso bancario no pagamento
                                    if (pagamento.getAvisoBancario() == null
                                            || pagamento.getAvisoBancario().equals("")) {
                                        
                                        Iterator avisosBancarioIterator = avisosBancarios.iterator();
                                        while (avisosBancarioIterator.hasNext()) {
                                            AvisoBancario avisoBancario = (AvisoBancario) avisosBancarioIterator.next();
                                            
                                            // caso a data prevista seja a mesma 
                                            // estão seta o aviso bancário no pagamento
                                            boolean comparaDataIguais = Util.datasIguais(pagamento
                                                    .getDataPrevistaCreditoHelper(), avisoBancario.getDataPrevista());
                                            if (comparaDataIguais) {
                                                pagamento.setAvisoBancario(avisoBancario);
                                                break;
                                            }
                                        }
                                    }
                                    colecaoPagamentos.add(pagamento);
    
                                }
    
                                System.out.println(" >> MovArrec.Inserindo pagamentos [" 
                                	+ nomeArrecadador + ", " + idTipoMovimento + "] = " + colecaoPagamentos.size());
                                getControladorBatch().inserirColecaoObjetoParaBatchTransacao(colecaoPagamentos);
                                
                                System.out.println(" >> MovArrec.Pagamentos inseridos [" 
                                    	+ nomeArrecadador + ", " + idTipoMovimento + "] = " + colecaoPagamentos.size());
                                	        
                                // Alterado por Francisco - 14/10/2008 / Analista: Ana Breda
                                // Para cada pagamento, atualizar os itens de documento de cobranca correspondente
                                // Para uso do Resumo de Ações de cobranca
                                int contador = 1;
                                int total = colecaoPagamentos.size();
                                Iterator iter = colecaoPagamentos.iterator();
                                while (iter.hasNext()) {
                                	if (contador++ % 500 == 0){
                                		System.out.println(" >> MovArrec.Atualizando itens de cobranca[" + contador++ + "/" + total +"]");
                                	}
                                    Pagamento pagamento = (Pagamento) iter.next();
                                    getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
                                          CobrancaDebitoSituacao.PAGO);   
                                    
//                                  //CRC3233 - alterado por Vivianne Sousa - 01/12/2009 analista:Fátima
									//[SB0017] - Verificar correspondência do pagamento com item de cobrança ou de negativação
									getControladorSpcSerasa().atualizarNegativadorMovimentoRegItemAPartirPagamento(pagamento);
                                    
                                }

                                System.out.println(" >> MovArrec.Finalizou atualização dos itens");                                
    
                            }
                            
                            arrecadadorContrato.setNumeroSequencialArquivoRetornoFichaCompensacao(Integer.valueOf(registroHeader.getSequencialRetorno()));
    
                            // atualiza arrecadação contrato na base
                            try {
                                repositorioArrecadacao.atualizarDadosArrecadadorContrato(
                                        arrecadadorContrato, flagEnvioDebitoAutomatico,flagRetornoCodigoBarras,flagRetornoDebitoAutomatico,flagRetornoFichaCompensacao);
                            } catch (ErroRepositorioException e) {
                                throw new ControladorException("erro.sistema", e);
                            }
                            
                        }    
                    }
                }
                
                //caso não exista o registro 9.
                if (!verificaRegistro9) {
                    throw new ControladorException(
                            "atencao.arquivo.movimento.nao.codigo.z");
                }
                
            }
            

        } catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(e.getMessage());
		} catch (Exception e) {            
            System.out.println( "Deu erro na linha: " + aux );
            e.printStackTrace();

            String mensagem = e.getMessage();
            if (mensagem != null) {
                String[] inicioMensagem = mensagem.split("\\.");
                if (inicioMensagem != null && 
                	(!inicioMensagem[0].equals("erro") && !inicioMensagem[0].equals("atencao"))) {
                    
                	mensagem = "erro.sistema";
                }
            } else {
                mensagem = "erro.sistema";
            }

            String emailRemetente = envioEmailError.getEmailRemetente();
            String tituloMensagem = envioEmailError.getTituloMensagem() + " "
            	+ stringBuilderTxt.substring(73, 79).trim();
            String emailReceptor = envioEmailError.getEmailReceptor();

            try {
                
            	ServicosEmail.enviarMensagem(emailRemetente, 
                	emailReceptor,
                    tituloMensagem, 
                    ConstantesAplicacao.get(mensagem));
                
            } catch (ErroEmailException e1) {

            }
            
            
            e.printStackTrace();
            if(!(e instanceof SendFailedException)) {
            	sessionContext.setRollbackOnly();
                sucesso = false;
			}
            

        }

        if (sucesso) {

            EnvioEmail envioEmail = getControladorCadastro()
                    .pesquisarEnvioEmail(
                            EnvioEmail.REGISTRAR_MOVIMENTO_ARRECADADORES_PDF);
            
            // Parte que gera o relatório e envia por email
            // cria uma instância da classe do relatório
            RelatorioMovimentoArrecadador relatorioMovimentoArrecadador = 
            	new RelatorioMovimentoArrecadador(usuario);
            
            Collection arrecadadores = new ArrayList();

            //Metodo que pesquisar os Movimentos Arrecadadores Atualizados, para exibir os valores atuais no relatorio.
            if ( arrecadadoresMovimento != null ) {
	            Iterator iteratorArrecadadoresMovimento = arrecadadoresMovimento.iterator();
	            
	            while ( iteratorArrecadadoresMovimento.hasNext() ) {
	            	
	            	ArrecadadorMovimento arrecadadorMovimento = (ArrecadadorMovimento) iteratorArrecadadoresMovimento.next();
	            
	            	FiltroArrecadadorMovimento filtroArrecadadorMovimento = new FiltroArrecadadorMovimento();
	                filtroArrecadadorMovimento.adicionarParametro( new ParametroSimples( FiltroArrecadadorMovimento.ID , arrecadadorMovimento.getId()));
	                
	                ArrecadadorMovimento arrecadador = new ArrecadadorMovimento();
					try {
						
						Collection colecaoArrecadador =  repositorioUtil.pesquisar( 
									filtroArrecadadorMovimento , ArrecadadorMovimento.class.getName() );
						
						arrecadador = ( ArrecadadorMovimento ) Util.retonarObjetoDeColecao(colecaoArrecadador);
						arrecadadores.add( arrecadador );
						
					} catch (ErroRepositorioException e) {
						
						e.printStackTrace();
					}
	            	
	            
	            
	            }
            }
            
            
            
            
            relatorioMovimentoArrecadador.addParametro("arrecadadoresMovimentos", arrecadadores);
            relatorioMovimentoArrecadador.addParametro("tipoFormatoRelatorio",TarefaRelatorio.TIPO_PDF);
            
            byte[] relatorioGerado = (byte[]) relatorioMovimentoArrecadador.executar();

            String emailRemetente = envioEmail.getEmailRemetente();

            String tituloMensagem = envioEmail.getTituloMensagem() + " "
            	+ stringBuilderTxt.substring(73, 79).trim();

            String corpoMensagem = envioEmail.getCorpoMensagem();
            String emailReceptor = envioEmail.getEmailReceptor();

            String mensagemErro = "Ocorreu um problema no processamento de: " + nomeArrecadador;
            
            ZipOutputStream zos = null;
            FileOutputStream out = null;
            try {
            	
            	String nomeZip = "registrar_movimento_arrecadador_banco_"+nomeArrecadador+ "-"+idTipoMovimento;
            	nomeZip = nomeZip.replace("/","");
            	nomeZip = nomeZip.replace(" ","_");
            	
            	File leitura = new File(nomeZip +".PDF");
                File compactado = new File(nomeZip + ".zip"); // nomeZip
				zos = new ZipOutputStream(new FileOutputStream(compactado));
                
				out = new FileOutputStream(leitura.getAbsolutePath());
                out.write(relatorioGerado);
                out.flush();
                
                ZipUtil.adicionarArquivo(zos, leitura);
				
               /* ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
               		emailRemetente, 
	                tituloMensagem, 
	                corpoMensagem, 
	                leitura);*/
                
                leitura.delete();

            } catch (IOException e) {
            	
            	try {
					
            		ServicosEmail.enviarMensagem(emailRemetente,
						emailReceptor, 
						tituloMensagem, 
						mensagemErro);
					
				} catch (ErroEmailException e1) {
					e1.printStackTrace();
				}
				
//            	sessionContext.setRollbackOnly();
                throw new ControladorException("erro.sistema", e);
                
            } catch (Exception e) {
            	
            	try {
					
            		ServicosEmail.enviarMensagem(emailRemetente,
				        emailReceptor, 
				        tituloMensagem, 
				        mensagemErro);
					
				} catch (ErroEmailException e1) {
					e1.printStackTrace();
				}
            	
//				sessionContext.setRollbackOnly();
                throw new ControladorException("erro.sistema", e);
            } finally {
            	IoUtil.fecharStream(out);
            	IoUtil.fecharStream(zos);
            }
            
        }
        // não tem mais retorno
        return null;

    }

	private SistemaParametro getSistemaParametro() throws ControladorException {
		try {
			sistemaParametro = repositorioUtil.pesquisarParametrosDoSistema();
		} catch (ErroRepositorioException e) {
		    throw new ControladorException("erro.sistema", e);
		}
		return sistemaParametro;
	}
    
    
    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores
     * Obtem o ArrecadorContrato para atualizar com NSA atualizado
     *
     * @author Raphael Rossiter, Anderson Italo
     * @date 11/11/2008, 15/03/2009
     *
     * @param idArrecadadorContrato
     * @return ArrecadadorContrato
     * @throws ControladorException
     */
    public ArrecadadorContrato obterArrecadadorContrato(Integer idArrecadadorContrato) throws ControladorException{
    	
    	ArrecadadorContrato arrecadadorContrato = null;
    	
    	try {
    		arrecadadorContrato = repositorioArrecadacao.pesquisarNumeroSequecialArrecadadorContrato(idArrecadadorContrato);
        } catch (ErroRepositorioException e) {
        	throw new ControladorException("erro.sistema");
        }
        
        return arrecadadorContrato;
    }
    
    
    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores
     *
     * @author Raphael Rossiter
     * @date 11/11/2008
     *
     * @param idClienteEmpresa
     * @return Integer
     * @throws ControladorException
     */
    public Integer recuperarMatriculaImovel(String idClienteEmpresa) throws ControladorException{
    	
    	Integer matriculaImovelInteger = null;
    	String matriculaImovel = null;
    	
    	if (idClienteEmpresa != null) {
			
    		int max = 10;
    		
    		if (idClienteEmpresa.length() < 10){
    			max = idClienteEmpresa.length();
    		}
    		
    		matriculaImovel = idClienteEmpresa.substring(0, max);
			
			try {
				
				matriculaImovelInteger = new Integer(matriculaImovel);
				
			} catch (Exception e) {
				matriculaImovelInteger = 0;
			}
		}
        
        return matriculaImovelInteger;
    }
    
    
    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores
     *
     * [SF0003] - Processar Registro Código B
     *
     * @author Raphael Rossiter
     * @date 11/11/2008
     *
     * @param registroHelperCodigoA
     * @param linhaRegistro
     * @param arrecadadorMovimento
     * @return RegistroHelperCodigoC
     * @throws ControladorException
     */
    @SuppressWarnings("rawtypes")
	public RegistroHelperCodigoC processarRegistroCodigoTipoB(RegistroHelperCodigoA registroHelperCodigoA, String linhaRegistro,
    		ArrecadadorMovimento arrecadadorMovimento) throws ControladorException{
    	
    	/**
         * [SF0003] - Processar Registro Código B 
         * Autor: Sávio Luiz, Raphael Rossiter 
         * Data: 31/01/2006, 11/11/2008
         */
    	RegistroHelperCodigoC registroHelperCodigoC = null;
    	
    	//cria uma variavel da descrição da ocorrencia do
        // movimento com o valor setado para OK
        String descricaoOcorrenciaMovimento = "OK";
        
        // cria uma variavel do indicador de aceitação do registro do movimento
        int indicadorAceitacaoRegistroMovimento = 1;

        boolean dataInvalida = false;
        boolean codigoDebitoAutomaticoInvalido = false;
        
        Integer matriculaImovel = null;
        Integer codigoDebitoAutomatico = null;
    	
        RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) 
        distribuirdadosRegistroMovimentoArrecadador(linhaRegistro, null);

        // verifica se o código de movimento é diferente de null
        if (!registroHelperCodigoB.getCodigoMovimento().equals(RegistroHelperCodigoB.EXCLUSAO_DEBITO_AUTOMATICO) && 
        	!registroHelperCodigoB.getCodigoMovimento().equals(RegistroHelperCodigoB.INCLUSAO_DEBITO_AUTOMATICO)) {
            
        	descricaoOcorrenciaMovimento = "CÓDIGO DE MOVIMENTO INVÁLIDO";

        }
        
        // valida a data
        dataInvalida = Util.validarAnoMesDiaSemBarra(registroHelperCodigoB
                        .getDataOpcaoExclusao());
        if (dataInvalida) {
            descricaoOcorrenciaMovimento = "DATA DE OPÇÃO/EXCLUSÃO INVÁLIDA";
        }
        
        // Valida código para debito automático
        codigoDebitoAutomaticoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoB.getIdClienteEmpresa());
        
        if(codigoDebitoAutomaticoInvalido){
        	descricaoOcorrenciaMovimento = "CÓDIGO PARA DÉBITO AUTOMÁTICO INVÁLIDO";
        }
        
        // caso a descricao de movimento seja igual a OK
        if (descricaoOcorrenciaMovimento.equals("OK")){
            
        	
        	//Código do banco
            String codigoBanco = registroHelperCodigoA.getCodigoBanco();
            
            /*
             * Alterado por Sávio Luiz Data: 24/04/09
             * Caso o banco que veio no arquivo seja diferente do idArrecador da tabela arrecadador_contrato, passar
             *  como código do banco o id do arrecadador.
             */ 
            String idArrecadadorBanco = registroHelperCodigoA.getIdArrecadadorBanco();
            if(idArrecadadorBanco != null && !idArrecadadorBanco.equals(codigoBanco)){
            	codigoBanco = idArrecadadorBanco;
            }
            
            // Código da agencia
            String codigoAgencia = registroHelperCodigoB.getAgenciaDebito();
            
            // identificação do cliente no banco
            String identificacaoCliente = registroHelperCodigoB.getIdClienteBanco();

            Date dataExcluso = Util.converteStringInvertidaSemBarraParaDate(
            registroHelperCodigoB.getDataOpcaoExclusao());
        	
            // Comentado Para inclusão da nova forma de obter a matricula do
        	// imovel atravez do coigo do debito automatico.
          	//
        	// Author:Hugo Amorim Data:22/03/2010 
        	//
        	// matricula do imóvel com os 8 primeiros
            // digitos da identificação do cliente na empresa
            //matriculaImovel = this.recuperarMatriculaImovel(registroHelperCodigoB.getIdClienteEmpresa());
            
        	/*
        	 * Alterado por Raphael Rossiter em 04/08/2010
        	 * OBJ: Não aceitar os movimentos que venham com a MATRÍCULA DO IMÓVEL no local do CÓDIGO DE DÉBITO AUTOMATICO para os 
        	 * casos de inclusão de débito automatico, 
        	 */
            codigoDebitoAutomatico = this.recuperarMatriculaImovel(registroHelperCodigoB.getIdClienteEmpresa());
        	
        	FiltroImovel filtroImovel = new FiltroImovel();
     		
     		filtroImovel.adicionarParametro(new ParametroSimples(FiltroImovel.CODIGO_DEBITO_AUTOMATICO, codigoDebitoAutomatico));
     		
     		Collection colecaoImoveis = this.getControladorUtil().pesquisar(filtroImovel, Imovel.class.getName());
     		
     		
            if (registroHelperCodigoB.getCodigoMovimento().equals(RegistroHelperCodigoB.EXCLUSAO_DEBITO_AUTOMATICO)) { 
                
            	if(colecaoImoveis !=null && !colecaoImoveis.isEmpty()){
    	     		
            		Imovel imovel = (Imovel) colecaoImoveis.iterator().next();
    	     		matriculaImovel = imovel.getId();
         		}
         		else{
         			matriculaImovel = codigoDebitoAutomatico;
         		}
         		
                descricaoOcorrenciaMovimento = this.getControladorCobranca().removerDebitoAutomatico(matriculaImovel.toString(),
                		codigoBanco, codigoAgencia, identificacaoCliente, dataExcluso);
            } 
            else if (registroHelperCodigoB.getCodigoMovimento().equals(RegistroHelperCodigoB.INCLUSAO_DEBITO_AUTOMATICO)) {
                
            	if (colecaoImoveis != null && !colecaoImoveis.isEmpty()){
         			
         			Imovel imovel = (Imovel) colecaoImoveis.iterator().next();
    	     		matriculaImovel = imovel.getId();
    	     		
    	     		//Processar inclusão
                    descricaoOcorrenciaMovimento = this.getControladorCobranca()
                    .inserirDebitoAutomatico(matriculaImovel.toString(), codigoBanco, codigoAgencia, identificacaoCliente, dataExcluso);
         		}
         		else{
         			
         			descricaoOcorrenciaMovimento = "CÓDIGO PARA DÉBITO AUTOMÁTICO INVÁLIDO";
         		}
            }
     		
            // caso a descricao de movimento não seja igual a OK
            if (!descricaoOcorrenciaMovimento.equals("OK")) {
                // seta o indicador de aceitação do registro do movimento para 2(NÃO)
                indicadorAceitacaoRegistroMovimento = 2;

                // adiciona a linha do registro na colecao codigoRegistrosC quando o método
                // distribuirdadosRegistroMovimentoArrecadador é chamado passando
                // a descricaoOcorrenciaMovimento então é retornado um registro do tipo C
                registroHelperCodigoC = (RegistroHelperCodigoC) 
                    distribuirdadosRegistroMovimentoArrecadador(linhaRegistro, descricaoOcorrenciaMovimento);

            }

        } 
        else {
            // seta o indicador de aceitação do registro
            // do movimento para 2(NÃO)
            indicadorAceitacaoRegistroMovimento = 2;

            // adiciona a linha do registro na colecao codigoRegistrosC quando o método
            // distribuirdadosRegistroMovimentoArrecadador é chamado passando
            // a descricaoOcorrenciaMovimento então é retornado um registro do tipo C
            registroHelperCodigoC = (RegistroHelperCodigoC) distribuirdadosRegistroMovimentoArrecadador(
                    linhaRegistro, descricaoOcorrenciaMovimento);
        }
        
        // inseri o item movimento arrecadador
        inserirItemMovimentoArrecadador(linhaRegistro, arrecadadorMovimento.getId(),
        descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, null);
        
        return registroHelperCodigoC;
    }
    
    
    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores
     *
     * [SF0001] - Validar Arquivo de Movimento de Arrecadador
     *
     * @author Raphael Rossiter
     * @date 10/11/2008
     *
     * @param codigoRegistro
     * @param linha
     * @param codigoArrecadador
     * @param nomeArrecadador
     * @param idTipoMovimento
     * @param arrecadadorContrato
     * @param numeroSequecialArquivoRetornoCodigoBarras
     * @param numeroSequencialArquivoRetornoDebitoAutomatico
     * @param numeroSequencialArquivoEnvioDebitoAutomatico
     * @return RegistroHelperCodigoA
     * @throws ControladorException
     */
    public RegistroHelperCodigoA validarArquivoMovimentoArrecadador(
			String codigoRegistro, String linha, Short codigoArrecadador,
			String nomeArrecadador, String idTipoMovimento,
			ArrecadadorContrato arrecadadorContrato,
			Integer numeroSequecialArquivoRetornoCodigoBarras,
			Integer numeroSequencialArquivoRetornoDebitoAutomatico,
			Integer numeroSequencialArquivoEnvioDebitoAutomatico,
			Integer idArrecadador) throws ControladorException {

		/**
		 * [SF0001] - Validar Arquivo de Movimento de Arrecadador Autor: Sávio
		 * Luiz Data: 31/01/2006
		 */
		RegistroHelperCodigoA registroHelperCodigoA = null;

		SistemaParametro sistemaParametro = this.getControladorUtil()
				.pesquisarParametrosDoSistema();

		// verifica se o código do registro é diferente de "A", caso
		// seja encerra o caso de uso
		if (!codigoRegistro.toUpperCase().equals("A")) {
			throw new ControladorException(
					"atencao.arquivo.movimento.sem.header");
		}
		registroHelperCodigoA = (RegistroHelperCodigoA) distribuirdadosRegistroMovimentoArrecadador(
				linha, null);
		// verifica se o código da remessa é diferente de 2 caso
		// seja encerra o caso de uso
		if (!registroHelperCodigoA.getCodigoRemessa().equals("2")) {
			throw new ControladorException("atencao.codigo.remessa.invalido");
		}
		// verifica se o código do banco é diferente do codigo do
		// arrecadador caso seja encerra o caso de uso
		Short codigoBancoTxt = new Short(registroHelperCodigoA.getCodigoBanco()
				.trim());

		if (!codigoBancoTxt.equals(codigoArrecadador)) {
			throw new ControladorException("atencao.movimento.nao.arrecadador",
					null, "" + codigoArrecadador, nomeArrecadador);
		}
		// verifica se o layout é diferente do layout da tabela
		// sistemaParematros
		Short versaoLayoutTxt = new Short(registroHelperCodigoA
				.getVersaoLayout().trim());
		if (versaoLayoutTxt > getSistemaParametro().getNumeroLayoutFebraban()) {
			throw new ControladorException("atencao.versao.arquivo.incalida");
		}

		// verifica se o tipo de movimento do txt é diferente nulo
		if (registroHelperCodigoA.getTipoMovimento() != null
				&& !registroHelperCodigoA.getTipoMovimento().equals("")) {

			// verifica se o tipo de movimento selecionado é
			// diferente do tipo de movimento do txt
			if (!idTipoMovimento.equals("CODIGO DE BARRAS")) {
				if (!registroHelperCodigoA.getTipoMovimento().trim().equals(
						idTipoMovimento)) {
					throw new ControladorException(
							"atencao.tipo.movimento.nao.selecionado");
				}
			} else {
				if (registroHelperCodigoA.getTipoMovimento().equals(
						"DEBITO AUTOMATICO")) {
					throw new ControladorException(
							"atencao.tipo.movimento.nao.selecionado");
				}
			}

		} else {
			// nesse caso só pode ser CODIGO BARRAS então faz a
			// verificacao se o tipo selecionado é diferente de DEBITO
			// AUTOMATICO
			if (idTipoMovimento.equals("DEBITO AUTOMATICO")) {
				throw new ControladorException(
						"atencao.tipo.movimento.nao.selecionado");
			}
		}

		// verifica o numero sequencial do txt se está de acordo com o da base
		// verifica se o arrecadadorContrato é diferente de nulo , para
		// não ficar fazendo essa pesquisa varias vezes
		//if (arrecadadorContrato == null) {

		//	arrecadadorContrato = this
		//			.obterArrecadadorContrato(idArrecadador/* codigoArrecadador */);

		//	if (arrecadadorContrato != null && !arrecadadorContrato.equals("")) {
				// recupera o numeroSequecialArquivoRetornoCodigoBarras
		//		numeroSequecialArquivoRetornoCodigoBarras = arrecadadorContrato
		//				.getNumeroSequecialArquivoRetornoCodigoBarras();

				

				// recupera o numeroSequencialArquivoRetornoDebitoAutomatico
		//		numeroSequencialArquivoRetornoDebitoAutomatico = arrecadadorContrato
		//				.getNumeroSequencialArquivoRetornoDebitoAutomatico();
				

				// recupera o numeroSequencialArquivoEnvioDebitoAutomatico
		//		numeroSequencialArquivoEnvioDebitoAutomatico = arrecadadorContrato
		//				.getNumeroSequencialArquivoEnvioDebitoAutomatico();

		//	}
		//} else {
			numeroSequecialArquivoRetornoCodigoBarras = arrecadadorContrato
					.getNumeroSequecialArquivoRetornoCodigoBarras();

			

			// recupera o numeroSequencialArquivoRetornoDebitoAutomatico
			numeroSequencialArquivoRetornoDebitoAutomatico = arrecadadorContrato
					.getNumeroSequencialArquivoRetornoDebitoAutomatico();
			

			// recupera o numeroSequencialArquivoEnvioDebitoAutomatico
			numeroSequencialArquivoEnvioDebitoAutomatico = arrecadadorContrato
					.getNumeroSequencialArquivoEnvioDebitoAutomatico();
		//}
		// verifica o tipo de pagamento
		if (registroHelperCodigoA.getTipoMovimento().equals(
				ConstantesSistema.DEBITO_AUTOMATICO)) {
			
			if (numeroSequencialArquivoRetornoDebitoAutomatico == null) {
				throw new ControladorException(
						"atencao.arquivo.movimento.fora.sequencia");
			}
			
			numeroSequencialArquivoRetornoDebitoAutomatico += 1;
			
			if (!new Integer(registroHelperCodigoA.getNumeroSequencialArquivo())
					.equals(numeroSequencialArquivoRetornoDebitoAutomatico)) {
				throw new ControladorException(
						"atencao.arquivo.movimento.fora.sequencia");
			}

		} else {
			if (numeroSequecialArquivoRetornoCodigoBarras == null) {
				throw new ControladorException(
						"atencao.arquivo.movimento.fora.sequencia");
			}
			
			numeroSequecialArquivoRetornoCodigoBarras += 1;
			if (!new Integer(registroHelperCodigoA.getNumeroSequencialArquivo())
					.equals(numeroSequecialArquivoRetornoCodigoBarras)) {
				throw new ControladorException(
						"atencao.arquivo.movimento.fora.sequencia");
			}

		}
		// Recupera o id do arrecadador para ser usado no caso do tipo de registro "B"
		registroHelperCodigoA.setIdArrecadadorBanco(Util.adicionarZerosEsquedaNumeroTruncando(3,""+idArrecadador));

		return registroHelperCodigoA;
	}
    
    /**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * 
	 * [SF0011] - Validar Arquivo de Movimento de Arrecadador da Ficha de
	 * Compensação
	 * 
	 * @author Raphael Rossiter
	 * @date 10/11/2008
	 * 
	 * @param codigoRegistro
	 * @param linha
	 * @param codigoArrecadador
	 * @param nomeArrecadador
	 * @param idTipoMovimento
	 * @param arrecadadorContrato
	 * @param numeroSequecialArquivoRetornoFichaComp
	 * @return RegistroHelperCodigo0
	 * @throws ControladorException
	 */
    public RegistroHelperCodigo0 validarArquivoMovimentoArrecadadorFichaCompensacao(String codigoRegistro, String linha, 
    		Short codigoArrecadador, String nomeArrecadador, String idTipoMovimento, ArrecadadorContrato arrecadadorContrato,
    		Integer numeroSequecialArquivoRetornoFichaComp,Integer idArrecadador) throws ControladorException {
    	
    	/**
         * [SF0011] - Validar Arquivo de Movimento de Arrecadador da Ficha de Compensação
         * Autor: Vivianne Sousa
         * Data: 26/11/2007
         */
    	RegistroHelperCodigo0 registroHelperCodigo0 = null;

        //1. verifica se o código do registro é diferente de "0", 
        // caso seja encerra o caso de uso
        if (!codigoRegistro.toUpperCase().equals("0")) {
            throw new ControladorException("atencao.arquivo.movimento.sem.header");
        }
		registroHelperCodigo0 = (RegistroHelperCodigo0) 
		    distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(linha, null);
        //2. verifica se o código da remessa é diferente de 2,
        // caso seja encerra o caso de uso
        if (!registroHelperCodigo0.getCodigoRemessaRetorno().equals("2")) {
            throw new ControladorException("atencao.codigo.remessa.invalido");
        }
        //3. verifica se o código do banco é diferente do codigo do
        // arrecadador caso seja encerra o caso de uso
        Short codigoBancoTxt = new Short(registroHelperCodigo0.getCodigoBancoCompensacao().trim());

        if (!codigoBancoTxt.equals(codigoArrecadador)) {
            throw new ControladorException("atencao.movimento.nao.arrecadador", null, ""
                            + codigoArrecadador, nomeArrecadador);
        }
        //4. verifica se o lote de serviço é diferente de 0000 caso
        // seja encerra o caso de uso
        if (!registroHelperCodigo0.getLoteServico().equals("0000")) {
            throw new ControladorException("atencao.lote.nao.corresponde.header");
        }
        
        //5. verifica o numero sequencial do txt se está de acordo com o da base
        // verifica se o arrecadadorContrato é diferente de nulo , para
        // não ficar fazendo essa pesquisa varias vezes
        //if (arrecadadorContrato == null) {
        	
    	arrecadadorContrato = this.obterArrecadadorContrato(arrecadadorContrato.getId());

        //if (arrecadadorContrato != null && !arrecadadorContrato.equals("")) {
        // recupera o numeroSequecialArquivoRetornoFichaComp
        numeroSequecialArquivoRetornoFichaComp = arrecadadorContrato
                .getNumeroSequencialArquivoRetornoFichaCompensacao();

        //}
       //}
        
        numeroSequecialArquivoRetornoFichaComp = arrecadadorContrato.getNumeroSequencialArquivoRetornoFichaCompensacao();
        numeroSequecialArquivoRetornoFichaComp += 1;
        if (!new Integer(registroHelperCodigo0.getNumeroSequencialArquivo())
                .equals(numeroSequecialArquivoRetornoFichaComp)) {
            throw new ControladorException("atencao.arquivo.movimento.fora.sequencia");
        }

        
        return registroHelperCodigo0;
    }
    
    
	/**
	 * [UC0262] - Distribuir dados do Registro de Movimento do Arrecadador
	 * Autor: Sávio Luiz Data: 30/01/2006
	 * 
	 * Caso a descrição de Ocorrencia venha nula então recupera o código
	 * registro da linha senão então seta o valor de código registro para 'C'
	 */

	public Object A(String linha, String descricaoOcorrencia, String a)
			throws ControladorException {
		Object registroHelperCodigo = null;

		// inicializa a variavel como 0
		char codigoRegistro = '0';
		// se a descrição da ocorrencia for diferente de null
		// então é para setar o objeto registroHelperCodigoC
		if (descricaoOcorrencia != null) {
			codigoRegistro = 'C';
		} else {
			codigoRegistro = linha.substring(0, 1).toUpperCase().charAt(0);
		}

		switch (codigoRegistro) {

		case 'A':
			RegistroHelperCodigoA registroHelperCodigoA = new RegistroHelperCodigoA();
			// recupera o codigo do registro
			registroHelperCodigoA.setCodigoRegistro("" + codigoRegistro);
			// recupera o codigo da remessa
			registroHelperCodigoA
					.setCodigoRemessa(linha.substring(1, 2).trim());
			// recupera o código do convênio
			registroHelperCodigoA.setCodigoConvenio(linha.substring(2, 22)
					.trim());
			// recupera o nome da empresa
			registroHelperCodigoA
					.setNomeEmpresa(linha.substring(22, 42).trim());
			// recupera o codigo do banco
			registroHelperCodigoA
					.setCodigoBanco(linha.substring(42, 45).trim());
			// recupera o nome do banco
			registroHelperCodigoA.setNomeBanco(linha.substring(45, 65).trim());
			// recupera a data de geração do arquivo
			registroHelperCodigoA.setDataGeracaoArquivo(linha.substring(65, 73)
					.trim());
			// recupera o numero sequencial do arquivo(NSA)
			registroHelperCodigoA.setNumeroSequencialArquivo(linha.substring(
					73, 79).trim());
			// recupera a versão do layout
			registroHelperCodigoA.setVersaoLayout(linha.substring(79, 81)
					.trim());
			// recupera o tipo de movimento
			registroHelperCodigoA.setTipoMovimento(linha.substring(81, 98)
					.trim());
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoA.setReservadoFuturo(linha.substring(98,
						149).trim());
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoA.setReservadoFuturo(linha.substring(98,
						150).trim());
			}

			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoA;
			break;

		case 'B':
			RegistroHelperCodigoB registroHelperCodigoB = new RegistroHelperCodigoB();
			// recupera o codigo do registro
			registroHelperCodigoB.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoB.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoB.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoB.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a data de Opção/Exclusão
			registroHelperCodigoB.setDataOpcaoExclusao(linha.substring(44, 52)
					.trim());
			// recupera o reservado para o futuro
			registroHelperCodigoB.setReservadoFuturo(linha.substring(52, 149)
					.trim());
			// recupera a codigo movimento
			if (!linha.substring(149, 150).trim().equals("*")) {
				registroHelperCodigoB.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoB;
			break;

		case 'C':
			RegistroHelperCodigoC registroHelperCodigoC = new RegistroHelperCodigoC();
			// recupera o codigo do registro
			registroHelperCodigoC.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoC.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoC.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoC.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a descrição da ocorrencia do movimento
			registroHelperCodigoC
					.setDescricaoOcorrenciaMovimento(descricaoOcorrencia);
			// recupera os brancos
			registroHelperCodigoC.setBrancos(linha.substring(84, 124).trim());
			// recupera o reservado para o futuro
			registroHelperCodigoC.setReservadoFuturo(linha.substring(124, 149)
					.trim());
			if (!linha.substring(149, 150).trim().equals("*")) {
				// recupera a codigo movimento
				registroHelperCodigoC.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoC;
			break;

		case 'E':
			RegistroHelperCodigoE registroHelperCodigoE = new RegistroHelperCodigoE();
			// recupera o codigo do registro
			registroHelperCodigoE.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoE.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoE.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoE.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a data do debito
			registroHelperCodigoE.setDataDebito(linha.substring(44, 52).trim());
			// recupera o valor debitado
			registroHelperCodigoE
					.setValorDebito(linha.substring(52, 67).trim());
			// recupera o codigo da moeda
			registroHelperCodigoE
					.setCodigoMoeda(linha.substring(67, 69).trim());
			// recupera o código de movimento
			registroHelperCodigoE.setAnoMesReferenciaConta(linha.substring(69,
					75).trim());
			// recupera o digito verificado no modulo dez(10) do ano e mes
			// da
			// contadebitada
			registroHelperCodigoE.setDigitoVerificadoAnoMesConta(linha
					.substring(75, 76).trim());
			// grupo de faturamento
			registroHelperCodigoE.setGruposFaturamento(linha.substring(76, 129)
					.trim());
			// recupera o reservado para o futuro
			registroHelperCodigoE.setReservadoFuturo(linha.substring(129, 149)
					.trim());
			if (!linha.substring(149, 150).trim().equals("*")) {
				// recupera o codigo do movimento enviado no registro de
				// código
				// E
				registroHelperCodigoE.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoE;
			break;

		case 'F':
			RegistroHelperCodigoF registroHelperCodigoF = new RegistroHelperCodigoF();
			// recupera o codigo do registro
			registroHelperCodigoF.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoF.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoF.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoF.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a data do debito
			registroHelperCodigoF.setDataDebito(linha.substring(44, 52).trim());
			// recupera o valor debitado
			registroHelperCodigoF
					.setValorDebito(linha.substring(52, 67).trim());
			// recupera o codigo do retorno
			registroHelperCodigoF.setCodigoRetorno(linha.substring(67, 69)
					.trim());
			// recupera o ano mes de referencia da conta
			registroHelperCodigoF.setAnoMesReferenciaConta(linha.substring(69,
					75).trim());
			// recupera o digito verificado no modulo dez(10) do ano e mes
			// da
			// contadebitada
			registroHelperCodigoF.setDigitoVerificadoAnoMesConta(linha
					.substring(75, 76).trim());
			// grupo de faturamento
			registroHelperCodigoF.setGruposFaturamento(linha.substring(76, 129)
					.trim());
			// recupera o reservado para o futuro
			registroHelperCodigoF.setReservadoFuturo(linha.substring(129, 149)
					.trim());
			if (!linha.substring(149, 150).trim().equals("*")) {
				// recupera o codigo do movimento enviado no registro de
				// código
				// F
				registroHelperCodigoF.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoF;
			break;

		case 'G':
			RegistroHelperCodigoG registroHelperCodigoG = new RegistroHelperCodigoG();
			// recupera o codigo do registro
			registroHelperCodigoG.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação da agencia /conta/digito creditada
			registroHelperCodigoG.setIdAgenciaContaDigito(linha
					.substring(1, 21).trim());
			// recupera a data de pagamento(AAAAMMDD)
			registroHelperCodigoG.setDataPagamento(linha.substring(21, 29)
					.trim());
			// recupera a data prevista para o credito(AAAAMMDD)
			registroHelperCodigoG.setDataPrevistaCredito(linha
					.substring(29, 37).trim());
			// recupera O CÓDIGO DE BARRAS
			String codigoBarras = linha.substring(37, 81).trim();
			RegistroHelperCodigoBarras registroHelperCodigoBarras = distribuirDadosCodigoBarras(codigoBarras);
			// seta também o código de barra como string
			registroHelperCodigoG.setCodigoBarras(codigoBarras);
			registroHelperCodigoG
					.setRegistroHelperCodigoBarras(registroHelperCodigoBarras);
			// recupera o valor recebido
			registroHelperCodigoG.setValorRecebido(linha.substring(81, 93)
					.trim());
			// recupera o valor da tarifa
			registroHelperCodigoG.setValorTarifa(linha.substring(93, 100)
					.trim());
			// recupera o numero sequencial do registro(NRS)
			registroHelperCodigoG.setNumeroSeqRegistro(linha
					.substring(100, 108).trim());
			// recupera o codigo da agencia arrecadadora
			registroHelperCodigoG.setCodigoAgenciaArrecadadora(linha.substring(
					108, 116).trim());
			// recupera a foma de arrecadação/captura
			registroHelperCodigoG.setFormaArrecadacao(linha.substring(116, 117)
					.trim());
			// recupera o numero de autenticação caixa ou código de
			// transação
			registroHelperCodigoG.setNumeroAutenticacao(linha.substring(117,
					140).trim());
			// recupera a forma de pagamento
			registroHelperCodigoG.setFormaPagamento(linha.substring(140, 141)
					.trim());
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoG.setReservadoFuturo(linha.substring(141,
						149).trim());
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoG.setReservadoFuturo(linha.substring(141,
						150).trim());
			}

			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoG;
			break;

		case 'X':
			RegistroHelperCodigoX registroHelperCodigoX = new RegistroHelperCodigoX();
			// recupera o codigo do registro
			registroHelperCodigoX.setCodigoRegistro("" + codigoRegistro);
			// recupera o código agencia
			registroHelperCodigoX.setCodigoAgencia(linha.substring(1, 5));
			// recupera o nome da agencia
			registroHelperCodigoX.setNomeAgencia(linha.substring(5, 35));
			// recupera o nome do logradouro
			registroHelperCodigoX.setNomelogradouro(linha.substring(35, 65));
			// recupera o numero
			registroHelperCodigoX.setNumero(linha.substring(65, 70));
			// recupera o código do cep
			registroHelperCodigoX.setCodigoCep(linha.substring(70, 75));
			// recupera o sufixo do cep
			registroHelperCodigoX.setSufixoCep(linha.substring(75, 78));
			// recupera o nome da cidade
			registroHelperCodigoX.setNomeCidade(linha.substring(78, 98));
			// recupera a sigla da unidade federação
			registroHelperCodigoX.setSiglaUnidadeFederacao(linha.substring(98,
					100));
			// recupera a situação da agencia
			registroHelperCodigoX.setCodigoAgencia(linha.substring(100, 101));
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoX.setReservadoFuturo(linha.substring(101,
						149));
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoX.setReservadoFuturo(linha.substring(101,
						150));
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoX;
			break;

		case 'Z':
			RegistroHelperCodigoZ registroHelperCodigoZ = new RegistroHelperCodigoZ();
			// recupera o codigo do registro
			registroHelperCodigoZ.setCodigoRegistro("" + codigoRegistro);
			// recupera o total de registros do arquivo
			registroHelperCodigoZ.setTotalRegistrosArquivo(linha
					.substring(1, 7));
			// recupera o valor total recebido dos registrosdo arquivo
			registroHelperCodigoZ.setValorTotalRegistrosArquivo(linha
					.substring(7, 24));
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoZ.setReservadoFuturo(linha.substring(24,
						149));
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoZ.setReservadoFuturo(linha.substring(24,
						150));
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoZ;
			break;

		}
		return registroHelperCodigo;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0009] - Inserir o
	 * item de movimento do arrecadador Autor: Sávio Luiz Data: 30/01/2006
	 */
	public Integer inserirItemMovimentoArrecadador(String linhaRegistro,
			Integer idMovimento, String descricaoOcorrencia,
			int indicadorAceitacaoRegistro, Integer idImovelPagamento)
			throws ControladorException {

		Integer idArrecadadorMovimentoItem = null;

		// recupera o código do registro de cada linha
		String codigoRegistro = linhaRegistro.substring(0, 1);

		// recupera o id do registro da tabela REGSITRO_CÓDIGO passando o código
		// do registro
		Integer idRegistroCodigo = null;
		try {
			idRegistroCodigo = repositorioArrecadacao
					.pesquisarIdRegistroCodigo(codigoRegistro);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		// seta os campos para a inserção em arrecadador movimento item
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

		RegistroCodigo registroCodigo = new RegistroCodigo();
		registroCodigo.setId(idRegistroCodigo);
		String completaLinhaRegistro = null;
		if (linhaRegistro != null && linhaRegistro.trim().length() == 150) {
			completaLinhaRegistro = linhaRegistro;
		} else {
			completaLinhaRegistro = Util.completaString(linhaRegistro, 149);
			completaLinhaRegistro = completaLinhaRegistro.concat("*");
		}

		arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);
		arrecadadorMovimentoItem.setConteudoRegistro(completaLinhaRegistro);
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);
		arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);
		arrecadadorMovimentoItem.setIndicadorAceitacao(new Short(""
				+ indicadorAceitacaoRegistro));
		arrecadadorMovimentoItem.setUltimaAlteracao(new Date());
		if (idImovelPagamento != null) {
			Imovel imovel = new Imovel();
			imovel.setId(idImovelPagamento);
			arrecadadorMovimentoItem.setImovel(imovel);
		}

		try {
			idArrecadadorMovimentoItem = (Integer) repositorioUtil
					.inserir(arrecadadorMovimentoItem);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		return idArrecadadorMovimentoItem;

	}


	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * CONTA
	 * 
	 * @autor: Raphael Rossiter, Raphael Rossiter 
	 * @data: 02/05/2007, 09/01/2008
	 */
	@SuppressWarnings("rawtypes")
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasConta(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamnetos = new ArrayList();

		boolean idLocalidadeInvalida = false;
		boolean matriculaImovelInvalida = false;

		int anoMes = 0;
		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		boolean anoMesReferencia = false;

		idLocalidadeInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}

		matriculaImovelInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if (matriculaImovelInvalida) {
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		} else {

			/*
			 * Verifica se existe a matricula do imóvel na base
			 */
			matriculaImovel = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			idImovelNaBase = null;

			try {
				idImovelNaBase = repositorioImovel
						.recuperarMatriculaImovel(matriculaImovel);
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			/*
			 * Se o id do imovel pesquisado na base for diferente de nulo
			 */
			if (idImovelNaBase == null) {
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		
		anoMesReferencia = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4());

		if (!anoMesReferencia) {

			// valida o namo mes de referencia da conta
			anoMes = Util.formatarMesAnoParaAnoMes(Integer
					.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento4()));

			anoMesReferencia = Util.validarAnoMesSemBarra("" + anoMes);

			if (anoMesReferencia) {
				descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
			}

		} else {
			descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
		}

		if (descricaoOcorrencia.equals("OK")) {

			Integer idLocalidade = null;

			Integer idConta = null;

			// Valida o amo mes de referencia da conta
			int anoMesReferenciaInt = Util.formatarMesAnoParaAnoMes(Integer
					.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento4()));

			Imovel imovel = new Imovel();
			imovel.setId(idImovelNaBase);

			try {
				idConta = repositorioFaturamento
						.pesquisarExistenciaContaComSituacaoAtual(imovel,
								anoMesReferenciaInt);

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}
			
			/*
             * Alterado por Raphael Rossiter em 09/01/2008 - Analistas: Eduardo e Aryed
             * OBJ: Gerar os pagamentos associados com a localidade da conta e NÃO com
             * a localidade do imóvel.
             */
			if (idConta == null || idConta.equals("")) {
				descricaoOcorrencia = "CONTA INEXISTENTE";
			
				try {
                    idLocalidade = repositorioLocalidade
                    .pesquisarIdLocalidade(idImovelNaBase);

                } catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
			}
			else {
				
				try {
                    idLocalidade = repositorioLocalidade
                    .pesquisarIdLocalidadePorConta(idConta);

                } catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
			}

			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(anoMes);

			/*
			 * Caso o ano mes da data de dedito seja maior que o ano mes de
			 * arrecadação da tabela sistema parametro então seta o ano mes da
			 * data de debito
			 */
			if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {

				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

			} else {

				/*
				 * caso contrario seta o o ano mes arrecadação da tabela sistema
				 * parametro
				 */
				pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
						.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			pagamento.setDebitoTipo(null);

			// Verifica se o id da conta é diferente de nulo
			if (idConta != null) {

				ContaGeral conta = new ContaGeral();
				conta.setId(idConta);
				pagamento.setContaGeral(conta);

			} else {

				pagamento.setContaGeral(null);
			}
			pagamento.setGuiaPagamento(null);

			// verifica se o id da conta é diferente de nulo
			if (idLocalidade != null) {

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);
			} else {

				pagamento.setLocalidade(null);
			}

			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.CONTA);
			documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_CONTA);
			pagamento.setDocumentoTipo(documentoTipo);
			pagamento.setAvisoBancario(null);

			if (idImovelNaBase != null) {
				pagamento.setImovel(imovel);
			} else {
				pagamento.setImovel(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaArrecadacao);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setCliente(null);
			pagamento.setUltimaAlteracao(new Date());
			
			/*
			 * Alteracao referente ao relatorio de Float - Francisco : 14/07/08
			 */
			pagamento.setFatura(null);
			pagamento.setCobrancaDocumento(null);
			
			DocumentoTipo documentoAgregador = new DocumentoTipo();
			documentoAgregador.setId(DocumentoTipo.CONTA);
			pagamento.setDocumentoTipoAgregador(documentoAgregador);
			
			pagamento.setDataProcessamento(new Date());

			colecaoPagamnetos.add(pagamento);

		} else {
			// atribui o valor 2(NÃO) ao indicador aceitacao
			// registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamnetos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras
				.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * GUIA DE PAGAMENTO
	 * 
	 * @autor: Raphael Rossiter 
	 * @data: 02/05/2007
	 */
	@SuppressWarnings("rawtypes")
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasGuiaPagamento(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();
		Collection colecaoPagamentoParcial = new ArrayList();

		boolean idLocalidadeInvalida = false;
		boolean matriculaImovelInvalida = false;

		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		idLocalidadeInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}

		matriculaImovelInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if (matriculaImovelInvalida) {
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		} else {

			// Verifica se existe a matricula do imóvel na base
			matriculaImovel = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idImovelNaBase = repositorioImovel
						.recuperarMatriculaImovel(new Integer(matriculaImovel));
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if (idImovelNaBase == null) {
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		// Valida o namo mes de referencia da conta
		boolean codigoTipoDebito = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4());

		if (codigoTipoDebito) {
			descricaoOcorrencia = "TIPO DO DÉBITO NÃO NUMÉRICO";
		} else {

			Integer idDebitoTipoNaBase = getControladorFaturamento()
					.verificarExistenciaDebitoTipo(
							Util
									.converterStringParaInteger(registroHelperCodigoBarras
											.getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento4()));

			if (idDebitoTipoNaBase == null) {
				descricaoOcorrencia = "TIPO DO DÉBITO INEXISTENTE";
			}
		}

		if (descricaoOcorrencia.equals("OK")) {

			Integer idLocalidade = null;

			Integer idGuiaPagamento = null;

			Integer idDebitoTipo = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento4());

			Imovel imovel = new Imovel();
			imovel.setId(idImovelNaBase);

			try {
				
				/*
	             * Alterado por Ana Maria em 11/08/2008 - Analistas: Denys e Aryed
	             * Colocar o valor do pagamento na pesquisa de guia. Caso retorne mais
	             * de uma guia de pagamento, selecionar a que tiver o menor vencimento.
	             */
				
				idGuiaPagamento = repositorioArrecadacao
						.pesquisarExistenciaGuiaPagamento(imovel, idDebitoTipo, valorPagamento);

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if (idGuiaPagamento == null) {
				descricaoOcorrencia = "GUIA PAGAMENTO INEXISTENTE";
			}

			/**
			 * Alterado por Arthur Carvalho em 29/12/2009 - Analista Rafael Pinto
			 * Gera Guia de Pagamento. Caso a Guia de Pagamento seja NUlA e o Debito tipo = DOACAO.
			 */
			if ( idGuiaPagamento == null ) {
				
				FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro( 
					new ParametroSimples( FiltroDebitoTipo.ID, idDebitoTipo) );

				Collection colecaoDebitoTipo = 
					getControladorUtil().pesquisar(filtroDebitoTipo, 
						DebitoTipo.class.getName());
				
				if ( colecaoDebitoTipo != null && !colecaoDebitoTipo.equals("")) {
					
					DebitoTipo debitoTipo = 
						(DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitoTipo);
					
					if (debitoTipo.getCodigoConstante() != null && DebitoTipo.DOACAO == debitoTipo.getCodigoConstante().intValue() ) {
						
						//Gera Guia de Pagamento
						idGuiaPagamento = this.inserirGuiaPagamentoReferenteDebitoTipoDoacao(
								idImovelNaBase, 
								debitoTipo, 
								dataPagamento, 
								valorPagamento);
						
					}
				}
			}
			
			
			/*
             * Alterado por Raphael Rossiter em 11/01/2008 - Analistas: Eduardo e Aryed
             * OBJ: Gerar os pagamentos associados com a localidade da guia de pagamento e NÃO com
             * a localidade do imóvel.
             */
            if (idGuiaPagamento != null) {
            	
            	try {
                    idLocalidade = repositorioLocalidade
                    .pesquisarIdLocalidadePorGuiaPagamento(idGuiaPagamento);

                } catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
       
            }
            else{
            	
            	try {
                    idLocalidade = repositorioLocalidade
                    .pesquisarIdLocalidade(idImovelNaBase);

                } catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
            }
            

			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(null);

			/*
			 * Caso o ano mes da data de dedito seja maior que o ano mes de
			 * arrecadação da tabela sistema parametro então seta o ano mes da
			 * data de debito
			 */
			if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {

				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

			} else {

				/*
				 * caso contrario seta o o ano mes arrecadação da tabela sistema
				 * parametro
				 */
				pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
						.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			DebitoTipo debitoTipo = new DebitoTipo();
			debitoTipo.setId(idDebitoTipo);
			pagamento.setDebitoTipo(debitoTipo);

			pagamento.setContaGeral(null);

			// Verifica se o id da conta é diferente de nulo
			if (idGuiaPagamento != null) {

				GuiaPagamento guiaPagamento = new GuiaPagamento();
				guiaPagamento.setId(idGuiaPagamento);
				pagamento.setGuiaPagamento(guiaPagamento);

			} else {
				pagamento.setGuiaPagamento(null);
			}

			// verifica se o id da conta é diferente de nulo
			if (idLocalidade != null) {

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);

			} else {
				pagamento.setLocalidade(null);
			}

			DocumentoTipo documentoTipo = new DocumentoTipo();
			/**
			 * Alterado por Arthur Carvalho
			 * Data: 31/05/2010
			 */
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
			documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
			pagamento.setDocumentoTipo(documentoTipo);

			pagamento.setAvisoBancario(null);

			if (idImovelNaBase != null) {
				pagamento.setImovel(imovel);
			} else {
				pagamento.setImovel(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaArrecadacao);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setCliente(null);
			pagamento.setUltimaAlteracao(new Date());

			pagamento.setFatura(null);
			pagamento.setCobrancaDocumento(null);
			
			/*
			 * Alteracao referente ao Relatorio do Float - Francisco: 14/07/08
			 */
			DocumentoTipo documentoAgregador = new DocumentoTipo();
			documentoAgregador.setId(DocumentoTipo.GUIA_PAGAMENTO);
			pagamento.setDocumentoTipoAgregador(documentoAgregador);
			
			pagamento.setDataProcessamento(new Date());
			
			colecaoPagamentos.add(pagamento);
			
			/*
			 * Caso o pagamento tenha sido incluído para uma guia existente e que tenha uma conta 
			 * associada (CNTA_ID da tabela GUIA_PAGAMENTO_ITEM com valor diferente de nulo)
			 */
			if (idGuiaPagamento != null){
				
				Conta contaPagamentoParcial = null;
				
				try {
					
					contaPagamentoParcial = repositorioArrecadacao
                    .pesquisarContaParaPagamentoParcial(idGuiaPagamento);

                } catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
                
                if (contaPagamentoParcial != null){
                	
                	//[SB0016] - Processar Pagamento Parcial de Conta
                	ProcessarPagamentoParcialContaHelper helper = 
                	this.processarPagamentoParcialConta(contaPagamentoParcial, valorPagamento);
                	
                	colecaoPagamentoParcial.add(helper);
                }
			}

		} else {

			// Atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		pagamentoHelperCodigoBarras.setColecaoProcessarPagamentoParcialContaHelper(colecaoPagamentoParcial);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * GUIA DE PAGAMENTO CLIENTE(Tipo 6)
	 * 
	 * Autor: Ana Maria Data: 06/08/2007
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasGuiaPagamentoCliente(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamnetos = new ArrayList();

		boolean idLocalidadeInvalida = false;
		boolean idClienteInvalido = false;

		Integer idClienteNaBase = null;

		idLocalidadeInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}

		idClienteInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		Integer idCliente = null;
		if (idClienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		} else {
			// verifica se existe o id do cliente na
			// base
			idCliente = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idClienteNaBase = repositorioCliente
						.verificarExistenciaCliente(new Integer(idCliente));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteNaBase == null) {
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		// Valida o namo mes de referencia da conta
		boolean codigoTipoDebito = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4());

		if (codigoTipoDebito) {
			descricaoOcorrencia = "TIPO DO DÉBITO NÃO NUMÉRICO";
		} else {

			Integer idDebitoTipoNaBase = getControladorFaturamento()
					.verificarExistenciaDebitoTipo(
							Util
									.converterStringParaInteger(registroHelperCodigoBarras
											.getRegistroHelperCodigoBarrasTipoPagamento()
											.getIdPagamento4()));

			if (idDebitoTipoNaBase == null) {
				descricaoOcorrencia = "TIPO DO DÉBITO INEXISTENTE";
			}
		}

		if (descricaoOcorrencia.equals("OK")) {

			Integer idLocalidade = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento1());

			Integer idGuiaPagamento = null;

			Integer idDebitoTipo = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento4());

			try {
				idGuiaPagamento = repositorioArrecadacao
						.pesquisarExistenciaGuiaPagamentoCliente(idCliente,
								idDebitoTipo);

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if (idGuiaPagamento == null || idGuiaPagamento.equals("")) {
				descricaoOcorrencia = "GUIA PAGAMENTO INEXISTENTE";
			}

			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(null);

			/*
			 * Caso o ano mes da data de dedito seja maior que o ano mes de
			 * arrecadação da tabela sistema parametro então seta o ano mes da
			 * data de debito
			 */
			if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {

				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

			} else {

				/*
				 * caso contrario seta o o ano mes arrecadação da tabela sistema
				 * parametro
				 */
				pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
						.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			DebitoTipo debitoTipo = new DebitoTipo();
			debitoTipo.setId(idDebitoTipo);
			pagamento.setDebitoTipo(debitoTipo);

			pagamento.setContaGeral(null);

			// Verifica se o id da conta é diferente de nulo
			if (idGuiaPagamento != null) {

				GuiaPagamento guiaPagamento = new GuiaPagamento();
				guiaPagamento.setId(idGuiaPagamento);
				pagamento.setGuiaPagamento(guiaPagamento);

			} else {
				pagamento.setGuiaPagamento(null);
			}

			// verifica se o id da conta é diferente de nulo
			if (idLocalidade != null) {

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);

			} else {
				pagamento.setLocalidade(null);
			}

			DocumentoTipo documentoTipo = new DocumentoTipo();
		
			// Alterado por Rômulo Aurélio Data: 15/07/2010, Analista Rosana/Aryed
			// quando o tipo de debito for Entrada de Guia é pra inserir 
			// o tipo de documento como guia de Parcelamento
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);				
		
			documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
			pagamento.setDocumentoTipo(documentoTipo);

			pagamento.setAvisoBancario(null);

			if (idCliente != null) {
				Cliente cliente = new Cliente();
				cliente.setId(idCliente);
				pagamento.setCliente(cliente);
			} else {
				pagamento.setCliente(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaArrecadacao);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setImovel(null);
			pagamento.setUltimaAlteracao(new Date());

			pagamento.setFatura(null);
			pagamento.setCobrancaDocumento(null);
			
			DocumentoTipo documentoAgregador = new DocumentoTipo();
			documentoAgregador.setId(DocumentoTipo.GUIA_PAGAMENTO);
			pagamento.setDocumentoTipoAgregador(documentoAgregador);	
			
			pagamento.setDataProcessamento(new Date());
			
			colecaoPagamnetos.add(pagamento);

		} else {

			// Atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamnetos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras
				.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * DOCUMENTO COBRANÇA TIPO 05
	 * 
	 * Autor: Raphael Rossiter Data: 02/05/2007
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasDocumentoCobrancaTipo5(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao, Usuario usuarioLogado) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		Collection colecaoDevolucoes = new ArrayList();
		
		Collection colecaoDebitosACobrarJurosParcelamento = new ArrayList();

		boolean idLocalidadeInvalida = false;
		boolean matriculaImovelInvalida = false;

		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		// Valida o id da localidade
		idLocalidadeInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}
		// valida a matricula do imóvel
		matriculaImovelInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());
		if (matriculaImovelInvalida) {
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		} else {
			// verifica se existe a matricula do imóvel na
			// base
			matriculaImovel = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());
			idImovelNaBase = null;
			try {
				idImovelNaBase = repositorioImovel
						.recuperarMatriculaImovel(new Integer(matriculaImovel));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idImovelNaBase == null) {
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		// valida o namo mes de referencia da conta
		boolean tipoDocumentoInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4());

		if (tipoDocumentoInvalido) {
			descricaoOcorrencia = "TIPO DO DOCUMENTO NÃO NUMÉRICO";
		}
		if (descricaoOcorrencia.equals("OK")) {
			// inicializa o id da localidade
			Integer idLocalidade = null;

			// inicializa a coleção de cobranca documento item
			Collection cobrancaDocumentoItens = null;
			// inicializa a coleção de cobranca documento item
			Object[] parmsDocumentoCobranca = null;

			int numeroSequencialDocumento = Integer
					.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento3());

			try {

				cobrancaDocumentoItens = repositorioCobranca
						.pesquisarCobrancaDocumentoItem(idImovelNaBase,
								numeroSequencialDocumento);
				parmsDocumentoCobranca = repositorioCobranca
						.pesquisarParmsCobrancaDocumento(idImovelNaBase,
								numeroSequencialDocumento);
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			// caso exista documento de cobrança
			if (parmsDocumentoCobranca != null) {
				Integer idCobrancaDocumento = null;
				BigDecimal valorAcrescimo = new BigDecimal("0.00");
				BigDecimal valorDesconto = new BigDecimal("0.00");
				Date dataEmissao = null;
				BigDecimal valorTaxa = new BigDecimal("0.00");
				Integer idDocumentoTipo = null;
				if (parmsDocumentoCobranca[0] != null) {
					valorAcrescimo = ((BigDecimal) parmsDocumentoCobranca[0]);
				}
				if (parmsDocumentoCobranca[1] != null) {
					valorDesconto = ((BigDecimal) parmsDocumentoCobranca[1]);
				}
				if (parmsDocumentoCobranca[2] != null) {
					dataEmissao = ((Date) parmsDocumentoCobranca[2]);
				}
				if (parmsDocumentoCobranca[3] != null) {
					idCobrancaDocumento = ((Integer) parmsDocumentoCobranca[3]);
				}
				if (parmsDocumentoCobranca[4] != null) {
					valorTaxa = ((BigDecimal) parmsDocumentoCobranca[4]);
				}
				
				/*
                 * Alterado por Raphael Rossiter em 10/01/2008 - Analistas: Eduardo e Aryed
                 * OBJ: Gerar os pagamentos associados com a localidade do document de cobrança e NÃO com
                 * a localidade do imóvel.
                 */
				if (parmsDocumentoCobranca[5] != null) {

					idLocalidade = ((Integer) parmsDocumentoCobranca[5]);
				}
				else{
					
					try {
                        idLocalidade = repositorioLocalidade
                        .pesquisarIdLocalidade(idImovelNaBase);

                    } catch (ErroRepositorioException e) {
                        throw new ControladorException("erro.sistema", e);
                    }
                    
				}
				if (parmsDocumentoCobranca[6] != null) {
					idDocumentoTipo = ((Integer) parmsDocumentoCobranca[6]);
				}
				
				// caso o valor de acrescimo for maior que zero
				if (valorAcrescimo.compareTo(new BigDecimal("0.00")) == 1) {
					// [SB0008 - Alterar vencimento dos itens do
					// documento de cobrança]

					alterarVencimentoItensDocumentoCobranca(
							idCobrancaDocumento, dataEmissao);

				}
				// caso o valor de acrescimos seja maior que o valor
				// de
				// descontos
				if (valorAcrescimo.compareTo(valorDesconto) == 1) {
					valorAcrescimo = valorAcrescimo.subtract(valorDesconto);
					valorDesconto = new BigDecimal("0.00");
				} else {
					valorDesconto = valorDesconto.subtract(valorAcrescimo);
					valorAcrescimo = new BigDecimal("0.00");
				}

				// caso o valor de acrescimo for maior que zero
				if (valorAcrescimo.compareTo(new BigDecimal("0.00")) == 1) {
					// [SB0005 - Processar Recebimento de Acrescimos
					// por
					// Impontualidade]

					Pagamento pagamento = processarRecebimentoAcrescimosImpontualidade(
							idCobrancaDocumento, dataPagamento, valorAcrescimo,
							idImovelNaBase, idLocalidade, getSistemaParametro(),
							idFormaArrecadacao, idDocumentoTipo);

					colecaoPagamentos.add(pagamento);

				}

				// caso o valor de desconto for maior que zero
				if (valorDesconto.compareTo(new BigDecimal("0.00")) == 1) {
					// [SB0006 - Processar Desconto concedido no
					// documento de cobrança]
					Devolucao devolucao = processarDescontoConcedidoDocumentoCobranca(
							idCobrancaDocumento, dataPagamento, valorDesconto,
							idImovelNaBase, idLocalidade, getSistemaParametro(),
							idFormaArrecadacao, idDocumentoTipo);

					colecaoDevolucoes.add(devolucao);

				}

				// caso o valor da taxa referente ao documento de cobrança for
				// maior que zero
				if (valorTaxa.compareTo(new BigDecimal("0.00")) == 1) {
					// [SB0006 - Processar Desconto concedido no
					// documento de cobrança]
					Pagamento pagamento = processarTaxaDocumentoCobranca(
							idCobrancaDocumento, dataPagamento, valorTaxa,
							idImovelNaBase, idLocalidade, getSistemaParametro(),
							idFormaArrecadacao, idDocumentoTipo);

					colecaoPagamentos.add(pagamento);

				}

				// verifica se a coleção é diferente de nula
				if (cobrancaDocumentoItens != null && !cobrancaDocumentoItens.isEmpty()) {
					
					Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens.iterator();

					while (cobrancaDocumentoItensIterator.hasNext()) {

						Object[] arrayCobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator.next();
						
						CobrancaDocumentoItem cobrancaDocumentoItem = new CobrancaDocumentoItem();
						
						//VALOR DO ITEM COBRADO
						cobrancaDocumentoItem.setValorItemCobrado((BigDecimal) arrayCobrancaDocumentoItem[3]);
						
						//NUMERO DE PARCELAS ANTECIPADAS
						cobrancaDocumentoItem.setNumeroParcelasAntecipadas((Integer) arrayCobrancaDocumentoItem[18]);
						
						/*
						 * Colocado por Raphael Rossiter em 31/10/2007 OBJ:
						 * Apenas gerar os pagamentos referentes aos itens que
						 * NAO tenham CreditoARealizar
						 */
						if (arrayCobrancaDocumentoItem[13] == null) {
							
							ContaGeral contaGeral = null;
							Conta conta = null;
							
							//CONTA
							if (arrayCobrancaDocumentoItem[0] != null) {
								
								conta = new Conta();
								conta.setId((Integer) arrayCobrancaDocumentoItem[0]);
								
								//REFERENCIA DA CONTA
								if (arrayCobrancaDocumentoItem[4] != null) {
									conta.setReferencia((Integer) arrayCobrancaDocumentoItem[4]);
								}
								else{
									conta.setReferencia(0);
								}
								
								contaGeral = new ContaGeral();
								contaGeral.setConta(conta);
								contaGeral.setId(conta.getId());
								
								cobrancaDocumentoItem.setContaGeral(contaGeral);
							} 
							
							//CONTA HISTORICO
							else if (arrayCobrancaDocumentoItem[10] != null){
								
								conta = new Conta();
								conta.setId((Integer) arrayCobrancaDocumentoItem[10]);
								
								//REFERENCIA DA CONTA
								if (arrayCobrancaDocumentoItem[5] != null) {
									conta.setReferencia((Integer) arrayCobrancaDocumentoItem[5]);
								}
								else{
									conta.setReferencia(0);
								}
								
								contaGeral = new ContaGeral();
								contaGeral.setConta(conta);
								contaGeral.setId(conta.getId());
								
								cobrancaDocumentoItem.setContaGeral(contaGeral);
							}
							
							
							GuiaPagamentoGeral guiaPagamentoGeral = null;
							GuiaPagamento guiaPagamento = null;
							
							//GUIA DE PAGAMENTO
							if (arrayCobrancaDocumentoItem[1] != null) {
								
								guiaPagamentoGeral = new GuiaPagamentoGeral();
								guiaPagamento = new GuiaPagamento();
								
								guiaPagamento.setId((Integer) arrayCobrancaDocumentoItem[1]);
								guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
								guiaPagamentoGeral.setId(guiaPagamento.getId());
								
								cobrancaDocumentoItem.setGuiaPagamentoGeral(guiaPagamentoGeral);
							}
							
							//GUIA DE PAGAMENTO HISTORICO
							else if (arrayCobrancaDocumentoItem[11] != null){
								
								guiaPagamentoGeral = new GuiaPagamentoGeral();
								guiaPagamento = new GuiaPagamento();
								
								guiaPagamento.setId((Integer) arrayCobrancaDocumentoItem[11]);
								guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
								guiaPagamentoGeral.setId(guiaPagamento.getId());
								
								cobrancaDocumentoItem.setGuiaPagamentoGeral(guiaPagamentoGeral);
							}
							
							
							DebitoACobrarGeral debitoACobrarGeral = null;
							DebitoACobrar debitoACobrar = null;
							
							//DEBITO A COBRAR
							if (arrayCobrancaDocumentoItem[2] != null) {
								
								debitoACobrarGeral = new DebitoACobrarGeral();
								debitoACobrar = new DebitoACobrar();
								
								debitoACobrar.setId((Integer) arrayCobrancaDocumentoItem[2]);
								debitoACobrar.setNumeroPrestacaoDebito((Short) arrayCobrancaDocumentoItem[16]);
								debitoACobrar.setNumeroPrestacaoCobradas((Short) arrayCobrancaDocumentoItem[17]);
								
								debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
								debitoACobrarGeral.setId(debitoACobrar.getId());
								
								cobrancaDocumentoItem.setDebitoACobrarGeral(debitoACobrarGeral);
								
								// [SB0012]- Verifica Pagamento de Débito a Cobrar de Parcelamento
								this.verificaPagamentoDebitoACobrarParcelamento(cobrancaDocumentoItem.getDebitoACobrarGeral()
								.getDebitoACobrar().getId(), cobrancaDocumentoItem.getNumeroParcelasAntecipadas());
							}
							
							//DEBITO A COBRAR HISTORICO
							else if (arrayCobrancaDocumentoItem[12] != null){
								
								debitoACobrarGeral = new DebitoACobrarGeral();
								debitoACobrar = new DebitoACobrar();
								
								debitoACobrar.setId((Integer) arrayCobrancaDocumentoItem[12]);
								
								debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
								debitoACobrarGeral.setId(debitoACobrar.getId());
								
								cobrancaDocumentoItem.setDebitoACobrarGeral(debitoACobrarGeral);
							}
							
							//CRÉDITO A REALIZAR (UTILIZADO PARA PAGAMENTO ANTECIPADO)
							
							//IDENTIFICANDO O TIPO DE DEBITO QUE SERA ASSOCIADO AO PAGAMENTO
							Integer idDebitoTipo = null;
							
							if (cobrancaDocumentoItem.getContaGeral() == null) {
								
								//CASO SEJA PARA GUIA DE PAGAMENTO
								if (cobrancaDocumentoItem.getGuiaPagamentoGeral() != null) {
									
									//GUIA DE PAGAMENTO
									if (arrayCobrancaDocumentoItem[6] != null) {
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[6];
									} 
									//GUIA DE PAGAMENTO HISTORICO
									else if (arrayCobrancaDocumentoItem[7] != null){
										 idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[7];
									}
								}
								
								//CASO SEJA PARA DEBITO A COBRAR
								if (cobrancaDocumentoItem.getDebitoACobrarGeral() != null) {
									
									//DEBITO A COBRAR
									if (arrayCobrancaDocumentoItem[8] != null) {
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[8];

									} 
									//DEBITO A COBRAR HISTORICO
									else if (arrayCobrancaDocumentoItem[9] != null) {
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[9];
									}
								}
							}
							
							//[SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas
							DebitoACobrar debitoACobrarAntecipacao = null;
							if (cobrancaDocumentoItem.getNumeroParcelasAntecipadas() != null){
								
								debitoACobrarAntecipacao = (DebitoACobrar) 
								this.gerarDebitoCreditoParcelasAntecipadas(idImovelNaBase, cobrancaDocumentoItem, usuarioLogado);
								
								/*
								* Caso o débito a cobrar com parcelas antecipadas tenha juros de parcelamento (FNTP_ID = Juros de Parcelamento da
								* tabela DEBITO_A_COBRAR com PARC_ID = PARC_ID do débito com parcelas antecipadas). O sistema deverá
								* atualizar a quantidade de parcela bônus do débito a cobrar de juros (DBAC_NNPARCELABONUS =
								* DBAC_NNPARCELABONUS + quantidade de parcelas antecipadas e DBAC_TMULTIMAALTERACAO = Data e Hora Correntes)
								*/
								DebitoACobrar debitoACobrarJurosParcelamento = this.pesquisarDebitoACobrarJurosParcelamento(
								debitoACobrarAntecipacao.getParcelamento().getId());

								if (debitoACobrarJurosParcelamento != null){

									if (!colecaoDebitosACobrarJurosParcelamento.contains(debitoACobrarJurosParcelamento)){

										Short numeroParcelaBonus = debitoACobrarAntecipacao.getNumeroPrestacaoDebito();

										if (debitoACobrarJurosParcelamento.getNumeroParcelaBonus() != null){

											numeroParcelaBonus = Short.valueOf(String.valueOf(debitoACobrarJurosParcelamento.getNumeroParcelaBonus()
													.shortValue() + debitoACobrarAntecipacao.getNumeroPrestacaoDebito()));
										}

										debitoACobrarJurosParcelamento.setNumeroParcelaBonus(numeroParcelaBonus);
										colecaoDebitosACobrarJurosParcelamento.add(debitoACobrarJurosParcelamento);
									}
								}
							}
							
							
							//GERANDO O PAGAMENTO
							Pagamento pagamento = new Pagamento();
							
							//REFERENCIA DO PAGAMENTO
							if (cobrancaDocumentoItem.getContaGeral() != null &&
								cobrancaDocumentoItem.getContaGeral().getConta().getReferencia() != 0) {
								
								pagamento.setAnoMesReferenciaPagamento(cobrancaDocumentoItem.getContaGeral().getConta().getReferencia());
							} 
							else {
								pagamento.setAnoMesReferenciaPagamento(null);
							}

							/*
							 * Caso o ano mes da data de debito seja maior que o ano mes de arrecadação da
							 * tabela sistema parametro então seta o ano mes da data de debito
							 */
							if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
								
								pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
							} 
							//Caso contrario seta o o ano mes arrecadação da tabela sistema parametro
							else {
								
								pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
							}
							
							//VALOR DO PAGAMENTO
							pagamento.setValorPagamento(cobrancaDocumentoItem.getValorItemCobrado());
							
							//DATA DO PAGAMENTO
							pagamento.setDataPagamento(dataPagamento);
							
							//SITUAÇÃO ATUAL
							pagamento.setPagamentoSituacaoAtual(null);
							
							//SITUAÇÃO ANTERIOR
							pagamento.setPagamentoSituacaoAnterior(null);
							
							if (idDebitoTipo != null) {
								DebitoTipo debitoTipo = new DebitoTipo();
								debitoTipo.setId(idDebitoTipo);
								pagamento.setDebitoTipo(debitoTipo);
							} else {
								pagamento.setDebitoTipo(null);
							}

							//VERIFICA SE O PAGAMENTO SERÁ RELACIONADO COM UMA CONTA
							if (cobrancaDocumentoItem.getContaGeral() != null) {
									
								/*
								 * Colocado por Raphael Rossiter em 26/11/2008 - CRC264
								 * OBJ: Inserir o pagamento com a localidade da própria conta e não
								 * com a localidade do documento de cobrança
								 */
								Integer idLocalidadeConta = null;
								
								try {
									idLocalidadeConta = repositorioLocalidade
									.pesquisarIdLocalidadePorConta(cobrancaDocumentoItem.getContaGeral().getConta().getId());

					            } catch (ErroRepositorioException e) {
					            	throw new ControladorException("erro.sistema", e);
					            }
					            
					            if (idLocalidadeConta != null){
					            	pagamento.setContaGeral(cobrancaDocumentoItem.getContaGeral());
					            }
					            else{
					            	try {
										idLocalidadeConta = repositorioLocalidade
										.pesquisarIdLocalidadePorContaHistorico(cobrancaDocumentoItem.getContaGeral().getConta().getId());

						            } catch (ErroRepositorioException e) {
						            	throw new ControladorException("erro.sistema", e);
						            }
					            }
					            
					            idLocalidade = idLocalidadeConta;
								 
								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.CONTA);
								pagamento.setDocumentoTipo(documentoTipo);
							} 
							else {
								
								pagamento.setContaGeral(null);
							}
							
							//VERIFICA SE O PAGAMENTO SERÁ RELACIONADO COM UMA GUIA DE PAGAMENTO
							if (cobrancaDocumentoItem.getGuiaPagamentoGeral() != null) {
								
								
									
								/*
								 * Colocado por Raphael Rossiter em 26/11/2008 - CRC264
								 * OBJ: Inserir o pagamento com a localidade da própria guia e não
								 * com a localidade do documento de cobrança
								 */
								Integer idLocalidadeGuiaPagamento = null;
								
								try {
									idLocalidadeGuiaPagamento = repositorioLocalidade
									.pesquisarIdLocalidadePorGuiaPagamento(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento().getId());

					            } catch (ErroRepositorioException e) {
					            	throw new ControladorException("erro.sistema", e);
					            }
					            
					            if (idLocalidadeGuiaPagamento != null){
					            	pagamento.setGuiaPagamento(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento());
					            }
					            else{
					            	try {
					            		idLocalidadeGuiaPagamento = repositorioLocalidade
										.pesquisarIdLocalidadePorGuiaPagamentoHistorico(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento().getId());

						            } catch (ErroRepositorioException e) {
						            	throw new ControladorException("erro.sistema", e);
						            }
					            }
					            
					            idLocalidade = idLocalidadeGuiaPagamento;
								
								DocumentoTipo documentoTipo = new DocumentoTipo();
								
								/*
								 * verificar se o tipo de debito eh 'entrada de parcelamento', e preencher o documentotipo
								 * com o 'entrada de parcelamento'
								 */
								
								// Alterado por Rômulo Aurélio, Analista Rosana/Aryed
								// quando o tipo de debito for Entrada de Guia é pra inserir 
								// o tipo de documento como guia de Parcelamento
								documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);	
								
								
								documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
								pagamento.setDocumentoTipo(documentoTipo);

							} 
							else {
								
								pagamento.setGuiaPagamento(null);
							}

							//VERIFICA SE O PAGAMENTO SERÁ RELACIONADO COM UM DEBITO A COBRAR
							if (cobrancaDocumentoItem.getDebitoACobrarGeral() != null) {
								
								try {
										
									if (debitoACobrarAntecipacao != null){
										
										debitoACobrarGeral.setDebitoACobrar(debitoACobrarAntecipacao);
										debitoACobrarGeral.setId(debitoACobrarAntecipacao.getId());
										
										pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
										
										/*
										 * Colocado por Raphael Rossiter em 26/11/2008 - CRC264
										 * OBJ: Inserir o pagamento com a localidade do próprio debito a cobrar e não
										 * com a localidade do documento de cobrança
										 */
										idLocalidade = repositorioLocalidade
							            .pesquisarIdLocalidadePorDebitoACobrar(debitoACobrarGeral.getDebitoACobrar().getId());
									}
									else if (cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getNumeroPrestacaoCobradas() !=
										cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getNumeroPrestacaoDebito()) {
											
										/*
										 * Colocado por Raphael Rossiter em 26/11/2008 - CRC264
										 * OBJ: Inserir o pagamento com a localidade do próprio debito a cobrar e não
										 * com a localidade do documento de cobrança
										 */
										Integer idLocalidadeDebitoACobrar = null;
										
										try {
											idLocalidadeDebitoACobrar = repositorioLocalidade
								            .pesquisarIdLocalidadePorDebitoACobrar(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getId());

							            } catch (ErroRepositorioException e) {
							            	throw new ControladorException("erro.sistema", e);
							            }
							            
							            if (idLocalidadeDebitoACobrar != null){
							            	pagamento.setDebitoACobrarGeral(cobrancaDocumentoItem.getDebitoACobrarGeral());
							            }
							            else{
							            	try {
							            		idLocalidadeDebitoACobrar = repositorioLocalidade
												.pesquisarIdLocalidadePorDebitoACobrarHistorico(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getId());

								            } catch (ErroRepositorioException e) {
								            	throw new ControladorException("erro.sistema", e);
								            }
							            }
							            
							            idLocalidade = idLocalidadeDebitoACobrar;
									}
										
								} catch (ErroRepositorioException e) {
									throw new ControladorException("erro.sistema", e);
								}

								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
								pagamento.setDocumentoTipo(documentoTipo);

							} 
							else {
								
								pagamento.setDebitoACobrarGeral(null);
							}

							//LOCALIDADE
							if (idLocalidade != null) {
								Localidade localidade = new Localidade();
								localidade.setId(idLocalidade);
								pagamento.setLocalidade(localidade);
							} else {
								pagamento.setLocalidade(null);

							}

							//AVISO BANCARIO
							pagamento.setAvisoBancario(null);

							//IMOVEL
							if (idImovelNaBase != null) {
								Imovel imovel = new Imovel();
								imovel.setId(idImovelNaBase);
								pagamento.setImovel(imovel);
							} else {
								pagamento.setImovel(null);
							}

							pagamento.setArrecadadorMovimentoItem(null);

							ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
							arrecadacaoForma.setId(idFormaArrecadacao);
							pagamento.setArrecadacaoForma(arrecadacaoForma);
							pagamento.setCliente(null);
							pagamento.setUltimaAlteracao(new Date());
							
							pagamento.setFatura(null);
							
							CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
							cobrancaDocumento.setId(idCobrancaDocumento);
							pagamento.setCobrancaDocumento(cobrancaDocumento);							
							
							// documento tipo do documento de cobranca
							if(idDocumentoTipo != null){
								DocumentoTipo documentoAgregador = new DocumentoTipo();
								documentoAgregador.setId(idDocumentoTipo);
								pagamento.setDocumentoTipoAgregador(documentoAgregador);
							}
							
							pagamento.setDataProcessamento(new Date());
							
							if (pagamento.getDocumentoTipo() != null) {
								colecaoPagamentos.add(pagamento);
							}
						} 
						else {

							CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
							creditoARealizarGeral.setId((Integer) arrayCobrancaDocumentoItem[13]);
							
							cobrancaDocumentoItem.setCreditoARealizarGeral(creditoARealizarGeral);
							
							//[SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas
							CreditoARealizar creditoARealizarAntecipacao = null;
							if (cobrancaDocumentoItem.getNumeroParcelasAntecipadas() != null){
								
								creditoARealizarAntecipacao = (CreditoARealizar) this.gerarDebitoCreditoParcelasAntecipadas(idImovelNaBase, 
								cobrancaDocumentoItem, usuarioLogado);
								
								creditoARealizarGeral.setId(creditoARealizarAntecipacao.getId());
								creditoARealizarGeral.setCreditoARealizar(creditoARealizarAntecipacao);
							}
							
							// Para os itens que tenham CreditoARealizar gerar
							// suas respectivas devoluções

							Devolucao devolucao = new Devolucao();

							// DataDevolucao = DataPagamento
							devolucao.setDataDevolucao(dataPagamento);

							/*
							 * AnoMesReferenciaDevolucao Caso o anoMes da data
							 * de devolução seja MAIOR que a
							 * PARM_AMREFERENCIAARRECADACAO da tabela
							 * SISTEMA_PARAMETROS atribuir o anoMes da data da
							 * devolução, caso contrário atribuir o
							 * PARM_AMREFERENCIAARRECADACAO.
							 */
							Integer anoMesDataDevolucao = Util.getAnoMesComoInteger(devolucao.getDataDevolucao());

							if (anoMesDataDevolucao > getSistemaParametro().getAnoMesArrecadacao()) {
								
								devolucao.setAnoMesReferenciaArrecadacao(anoMesDataDevolucao);
							} 
							else {
								
								devolucao.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
							}

							// ValorDevolucao = ValorItemCobrado
							devolucao.setValorDevolucao(cobrancaDocumentoItem.getValorItemCobrado());

							// Localidade = Localidade da tabela
							// COBRANCA_DOCUMENTO
							if (arrayCobrancaDocumentoItem[14] != null) {
								Localidade localidade = new Localidade();
								localidade
										.setId((Integer) arrayCobrancaDocumentoItem[14]);
								devolucao.setLocalidade(localidade);
							}

							// Imovel = Imovel da tabela COBRANCA_DOCUMENTO
							if (arrayCobrancaDocumentoItem[15] != null) {
								Imovel imovel = new Imovel();
								imovel
										.setId((Integer) arrayCobrancaDocumentoItem[15]);
								devolucao.setImovel(imovel);
							}

							// DebitoTipo = DebitoTipo com o valor
							// correspondente a outros
							DebitoTipo debitoTipo = new DebitoTipo();
							debitoTipo.setId(DebitoTipo.OUTROS);
							devolucao.setDebitoTipo(debitoTipo);

							// CreditoARealizarGeral = CreditoARealizarGeral da
							// tabela COBRANCA_DOCUMENTO_ITEM
							devolucao.setCreditoARealizarGeral(creditoARealizarGeral);

							// Ultima Alteração
							devolucao.setUltimaAlteracao(new Date());

							CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
							cobrancaDocumento.setId(idCobrancaDocumento);
							devolucao.setCobrancaDocumento(cobrancaDocumento);							
							
							// documento tipo do documento de cobranca
							if(idDocumentoTipo != null){
								DocumentoTipo documentoAgregador = new DocumentoTipo();
								documentoAgregador.setId(idDocumentoTipo);
								devolucao.setDocumentoTipoAgregador(documentoAgregador);
							}
							
							// ADICIONANDO A DEVOLUCAO GERADA NA COLECAO DE
							// RETORNO
							colecaoDevolucoes.add(devolucao);
						}
					}
					
					/*
					 * Caso o débito a cobrar com parcelas antecipadas tenha juros de parcelamento (FNTP_ID = Juros de Parcelamento da 
					 * tabela DEBITO_A_COBRAR com PARC_ID = PARC_ID do débito com parcelas antecipadas). O sistema deverá 
					 * atualizar a quantidade de parcela bônus do débito a cobrar de juros (DBAC_NNPARCELABONUS = 
					 * DBAC_NNPARCELABONUS + quantidade de parcelas antecipadas e DBAC_TMULTIMAALTERACAO = Data e Hora Correntes)
					 */
					if (colecaoDebitosACobrarJurosParcelamento != null &&
						!colecaoDebitosACobrarJurosParcelamento.isEmpty()){
						
						Iterator itDebitosACobrarJurosParcelamento = colecaoDebitosACobrarJurosParcelamento.iterator();
						
						while(itDebitosACobrarJurosParcelamento.hasNext()){
							
							this.atualizarNumeroParcelasBonus((DebitoACobrar) itDebitosACobrarJurosParcelamento.next());
						}
					}
				}

			} else {
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		} else {
			// atribui o valor 2(NÃO) ao indicador aceitacao
			// registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setColecaoDevolucao(colecaoDevolucoes);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras
				.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;

	}
	
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasDocumentoCobrancaTipo5Novo(
			RegistroHelperCodigoBarras registroHelperCodigoBarras, RegistroFichaCompensacaoTipo7Helper registroTipo7, Integer idFormaArrecadacao, 
			Usuario usuarioLogado) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();

		Collection colecaoDevolucoes = new ArrayList();
		
		Collection colecaoDebitosACobrarJurosParcelamento = new ArrayList();

		boolean idLocalidadeInvalida = false;
		boolean matriculaImovelInvalida = false;

		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;

		idLocalidadeInvalida = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento1());
		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}

		matriculaImovelInvalida = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
		if (matriculaImovelInvalida) {
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		
		} else {
			matriculaImovel = new Integer(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
			idImovelNaBase = null;
			try {
				idImovelNaBase = repositorioImovel.recuperarMatriculaImovel(new Integer(matriculaImovel));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idImovelNaBase == null) {
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}

		// valida o namo mes de referencia da conta
		boolean tipoDocumentoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4());

		if (tipoDocumentoInvalido) {
			descricaoOcorrencia = "TIPO DO DOCUMENTO NÃO NUMÉRICO";
		}
		if (descricaoOcorrencia.equals("OK")) {
			Integer idLocalidade = null;

			Collection cobrancaDocumentoItens = null;

			Object[] parmsDocumentoCobranca = null;

			int numeroSequencialDocumento = Integer.parseInt(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

			try {

				cobrancaDocumentoItens = repositorioCobranca.pesquisarCobrancaDocumentoItem(idImovelNaBase, numeroSequencialDocumento);
				parmsDocumentoCobranca = repositorioCobranca.pesquisarParmsCobrancaDocumento(idImovelNaBase, numeroSequencialDocumento);
				
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (parmsDocumentoCobranca != null) {
				Integer idCobrancaDocumento = null;
				BigDecimal valorAcrescimo = new BigDecimal("0.00");
				BigDecimal valorDesconto = new BigDecimal("0.00");
				Date dataEmissao = null;
				BigDecimal valorTaxa = new BigDecimal("0.00");
				Integer idDocumentoTipo = null;
				
				if (parmsDocumentoCobranca[0] != null) {
					valorAcrescimo = ((BigDecimal) parmsDocumentoCobranca[0]);
				}
				if (parmsDocumentoCobranca[1] != null) {
					valorDesconto = ((BigDecimal) parmsDocumentoCobranca[1]);
				}
				if (parmsDocumentoCobranca[2] != null) {
					dataEmissao = ((Date) parmsDocumentoCobranca[2]);
				}
				if (parmsDocumentoCobranca[3] != null) {
					idCobrancaDocumento = ((Integer) parmsDocumentoCobranca[3]);
				}
				if (parmsDocumentoCobranca[4] != null) {
					valorTaxa = ((BigDecimal) parmsDocumentoCobranca[4]);
				}
				if (parmsDocumentoCobranca[5] != null) {
					idLocalidade = ((Integer) parmsDocumentoCobranca[5]);
				}
				else{
					try {
                        idLocalidade = repositorioLocalidade.pesquisarIdLocalidade(idImovelNaBase);
                    } catch (ErroRepositorioException e) {
                        throw new ControladorException("erro.sistema", e);
                    }
				}
				if (parmsDocumentoCobranca[6] != null) {
					idDocumentoTipo = ((Integer) parmsDocumentoCobranca[6]);
				}
				if (valorAcrescimo.compareTo(new BigDecimal("0.00")) == 1) {
					alterarVencimentoItensDocumentoCobranca(idCobrancaDocumento, dataEmissao);
					Pagamento pagamento = processarRecebimentoAcrescimosImpontualidade(
							idCobrancaDocumento, registroTipo7.getDataLiquidacaoFormatado(), valorAcrescimo,
							idImovelNaBase, idLocalidade, getSistemaParametro(),
							idFormaArrecadacao, idDocumentoTipo);
					
					colecaoPagamentos.add(pagamento);
				}
				if (valorAcrescimo.compareTo(valorDesconto) == 1) {
					valorAcrescimo = valorAcrescimo.subtract(valorDesconto);
					valorDesconto = new BigDecimal("0.00");
				} else {
					valorDesconto = valorDesconto.subtract(valorAcrescimo);
					valorAcrescimo = new BigDecimal("0.00");
				}

				if (valorDesconto.compareTo(new BigDecimal("0.00")) == 1) {
					Devolucao devolucao = processarDescontoConcedidoDocumentoCobranca(
							idCobrancaDocumento, registroTipo7.getDataLiquidacaoFormatado(), valorDesconto,
							idImovelNaBase, idLocalidade, getSistemaParametro(),
							idFormaArrecadacao, idDocumentoTipo);

					colecaoDevolucoes.add(devolucao);
				}

				if (valorTaxa.compareTo(new BigDecimal("0.00")) == 1) {
					Pagamento pagamento = processarTaxaDocumentoCobranca(
							idCobrancaDocumento, registroTipo7.getDataLiquidacaoFormatado(), valorTaxa,
							idImovelNaBase, idLocalidade, getSistemaParametro(),
							idFormaArrecadacao, idDocumentoTipo);

					colecaoPagamentos.add(pagamento);
				}

				if (cobrancaDocumentoItens != null && !cobrancaDocumentoItens.isEmpty()) {
					
					Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens.iterator();

					while (cobrancaDocumentoItensIterator.hasNext()) {

						Object[] arrayCobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator.next();
						
						CobrancaDocumentoItem cobrancaDocumentoItem = new CobrancaDocumentoItem();
						cobrancaDocumentoItem.setValorItemCobrado((BigDecimal) arrayCobrancaDocumentoItem[3]);
						cobrancaDocumentoItem.setNumeroParcelasAntecipadas((Integer) arrayCobrancaDocumentoItem[18]);
						
						if (arrayCobrancaDocumentoItem[13] == null) {
							
							Conta conta = null;
							if (arrayCobrancaDocumentoItem[0] != null) {
								conta = preencheConta((Integer) arrayCobrancaDocumentoItem[0], (Integer) arrayCobrancaDocumentoItem[4], 
																															cobrancaDocumentoItem);
							} else if (arrayCobrancaDocumentoItem[10] != null){
								conta = preencheConta((Integer) arrayCobrancaDocumentoItem[10], (Integer) arrayCobrancaDocumentoItem[5], 
																															cobrancaDocumentoItem);
							}
							
							GuiaPagamento guiaPagamento = null;
							if (arrayCobrancaDocumentoItem[1] != null) {
								guiaPagamento = preencheGuiaPagamento((Integer) arrayCobrancaDocumentoItem[1], cobrancaDocumentoItem);
							} else if (arrayCobrancaDocumentoItem[11] != null){
								guiaPagamento = preencheGuiaPagamento((Integer) arrayCobrancaDocumentoItem[11], cobrancaDocumentoItem);
							}
							
							DebitoACobrarGeral debitoACobrarGeral = null;
							if (arrayCobrancaDocumentoItem[2] != null) {
								debitoACobrarGeral = preencheDebitoACobrar((Integer) arrayCobrancaDocumentoItem[2], cobrancaDocumentoItem);
								debitoACobrarGeral.getDebitoACobrar().setNumeroPrestacaoDebito((Short) arrayCobrancaDocumentoItem[16]);
								debitoACobrarGeral.getDebitoACobrar().setNumeroPrestacaoCobradas((Short) arrayCobrancaDocumentoItem[17]);
								
								this.verificaPagamentoDebitoACobrarParcelamento(cobrancaDocumentoItem.getDebitoACobrarGeral()
								.getDebitoACobrar().getId(), cobrancaDocumentoItem.getNumeroParcelasAntecipadas());
								
							}else if (arrayCobrancaDocumentoItem[12] != null){
								debitoACobrarGeral = preencheDebitoACobrar((Integer) arrayCobrancaDocumentoItem[12], cobrancaDocumentoItem);
							}
							
							Integer idDebitoTipo = null;
							if (cobrancaDocumentoItem.getContaGeral() == null) {
								if (cobrancaDocumentoItem.getGuiaPagamentoGeral() != null) {
									if (arrayCobrancaDocumentoItem[6] != null) {
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[6];
									} 
									else if (arrayCobrancaDocumentoItem[7] != null){
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[7];
									}
								}
								
								if (cobrancaDocumentoItem.getDebitoACobrarGeral() != null) {
									if (arrayCobrancaDocumentoItem[8] != null) {
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[8];
									} 
									else if (arrayCobrancaDocumentoItem[9] != null) {
										idDebitoTipo = (Integer) arrayCobrancaDocumentoItem[9];
									}
								}
							}
							
							DebitoACobrar debitoACobrarAntecipacao = null;
							if (cobrancaDocumentoItem.getNumeroParcelasAntecipadas() != null){
								
								debitoACobrarAntecipacao = (DebitoACobrar) this.gerarDebitoCreditoParcelasAntecipadas(idImovelNaBase, 
																												cobrancaDocumentoItem, usuarioLogado);
								
								DebitoACobrar debitoACobrarJurosParcelamento = this.pesquisarDebitoACobrarJurosParcelamento(
																								debitoACobrarAntecipacao.getParcelamento().getId());

								if (debitoACobrarJurosParcelamento != null){

									if (!colecaoDebitosACobrarJurosParcelamento.contains(debitoACobrarJurosParcelamento)){

										Short numeroParcelaBonus = debitoACobrarAntecipacao.getNumeroPrestacaoDebito();

										if (debitoACobrarJurosParcelamento.getNumeroParcelaBonus() != null){

											numeroParcelaBonus = Short.valueOf(String.valueOf(debitoACobrarJurosParcelamento.getNumeroParcelaBonus()
													.shortValue() + debitoACobrarAntecipacao.getNumeroPrestacaoDebito()));
										}

										debitoACobrarJurosParcelamento.setNumeroParcelaBonus(numeroParcelaBonus);
										colecaoDebitosACobrarJurosParcelamento.add(debitoACobrarJurosParcelamento);
									}
								}
							}
							
							Pagamento pagamento = new Pagamento();

							if (cobrancaDocumentoItem.getContaGeral() != null && cobrancaDocumentoItem.getContaGeral().getConta().getReferencia() != 0) {
								pagamento.setAnoMesReferenciaPagamento(cobrancaDocumentoItem.getContaGeral().getConta().getReferencia());
							} else {
								pagamento.setAnoMesReferenciaPagamento(null);
							}

							int anoMesPagamento = Util.formataAnoMes(registroTipo7.getDataLiquidacaoFormatado()); 
							
							if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
								pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
							} else {
								pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
							}
							
							pagamento.setValorPagamento(cobrancaDocumentoItem.getValorItemCobrado());
							pagamento.setDataPagamento(registroTipo7.getDataLiquidacaoFormatado());
							pagamento.setPagamentoSituacaoAtual(null);
							pagamento.setPagamentoSituacaoAnterior(null);
							
							if (idDebitoTipo != null) {
								DebitoTipo debitoTipo = new DebitoTipo();
								debitoTipo.setId(idDebitoTipo);
								pagamento.setDebitoTipo(debitoTipo);
							} else {
								pagamento.setDebitoTipo(null);
							}

							if (cobrancaDocumentoItem.getContaGeral() != null) {
									
								Integer idLocalidadeConta = null;
								
								try {
									idLocalidadeConta = repositorioLocalidade
									.pesquisarIdLocalidadePorConta(cobrancaDocumentoItem.getContaGeral().getConta().getId());

					            } catch (ErroRepositorioException e) {
					            	throw new ControladorException("erro.sistema", e);
					            }
					            
					            if (idLocalidadeConta != null){
					            	pagamento.setContaGeral(cobrancaDocumentoItem.getContaGeral());
					            } else {
					            	try {
										idLocalidadeConta = repositorioLocalidade
										.pesquisarIdLocalidadePorContaHistorico(cobrancaDocumentoItem.getContaGeral().getConta().getId());

						            } catch (ErroRepositorioException e) {
						            	throw new ControladorException("erro.sistema", e);
						            }
					            }
					            
					            idLocalidade = idLocalidadeConta;
								 
								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.CONTA);
								pagamento.setDocumentoTipo(documentoTipo);
							} else {
								pagamento.setContaGeral(null);
							}
							
							if (cobrancaDocumentoItem.getGuiaPagamentoGeral() != null) {
								
								Integer idLocalidadeGuiaPagamento = null;
								
								try {
									idLocalidadeGuiaPagamento = repositorioLocalidade
									.pesquisarIdLocalidadePorGuiaPagamento(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento().getId());

					            } catch (ErroRepositorioException e) {
					            	throw new ControladorException("erro.sistema", e);
					            }
					            
					            if (idLocalidadeGuiaPagamento != null){
					            	pagamento.setGuiaPagamento(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento());
					            }
					            else{
					            	try {
					            		idLocalidadeGuiaPagamento = repositorioLocalidade
										.pesquisarIdLocalidadePorGuiaPagamentoHistorico(cobrancaDocumentoItem.getGuiaPagamentoGeral().getGuiaPagamento().getId());

						            } catch (ErroRepositorioException e) {
						            	throw new ControladorException("erro.sistema", e);
						            }
					            }
					            
					            idLocalidade = idLocalidadeGuiaPagamento;
								
								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);	
								documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);

								pagamento.setDocumentoTipo(documentoTipo);
								
							} else {
								
								pagamento.setGuiaPagamento(null);
							}

							if (cobrancaDocumentoItem.getDebitoACobrarGeral() != null) {
								
								try {
									if (debitoACobrarAntecipacao != null){
										
										debitoACobrarGeral.setDebitoACobrar(debitoACobrarAntecipacao);
										debitoACobrarGeral.setId(debitoACobrarAntecipacao.getId());
										
										pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
										
										idLocalidade = repositorioLocalidade
							            .pesquisarIdLocalidadePorDebitoACobrar(debitoACobrarGeral.getDebitoACobrar().getId());
									}
									else if (cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getNumeroPrestacaoCobradas() !=
										cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getNumeroPrestacaoDebito()) {
											
										Integer idLocalidadeDebitoACobrar = null;
										
										try {
											idLocalidadeDebitoACobrar = repositorioLocalidade
								            .pesquisarIdLocalidadePorDebitoACobrar(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getId());

							            } catch (ErroRepositorioException e) {
							            	throw new ControladorException("erro.sistema", e);
							            }
							            
							            if (idLocalidadeDebitoACobrar != null){
							            	pagamento.setDebitoACobrarGeral(cobrancaDocumentoItem.getDebitoACobrarGeral());
							            } else {
							            	try {
							            		idLocalidadeDebitoACobrar = repositorioLocalidade
												.pesquisarIdLocalidadePorDebitoACobrarHistorico(cobrancaDocumentoItem.getDebitoACobrarGeral().getDebitoACobrar().getId());

								            } catch (ErroRepositorioException e) {
								            	throw new ControladorException("erro.sistema", e);
								            }
							            }
							            
							            idLocalidade = idLocalidadeDebitoACobrar;
									}
										
								} catch (ErroRepositorioException e) {
									throw new ControladorException("erro.sistema", e);
								}

								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
								pagamento.setDocumentoTipo(documentoTipo);

							} 
							else {
								pagamento.setDebitoACobrarGeral(null);
							}

							if (idLocalidade != null) {
								Localidade localidade = new Localidade();
								localidade.setId(idLocalidade);
								pagamento.setLocalidade(localidade);
							} else {
								pagamento.setLocalidade(null);

							}

							pagamento.setAvisoBancario(null);

							if (idImovelNaBase != null) {
								Imovel imovel = new Imovel();
								imovel.setId(idImovelNaBase);
								pagamento.setImovel(imovel);
							} else {
								pagamento.setImovel(null);
							}

							pagamento.setArrecadadorMovimentoItem(null);

							ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
							arrecadacaoForma.setId(idFormaArrecadacao);
							pagamento.setArrecadacaoForma(arrecadacaoForma);
							pagamento.setCliente(null);
							pagamento.setUltimaAlteracao(new Date());
							
							pagamento.setFatura(null);
							
							CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
							cobrancaDocumento.setId(idCobrancaDocumento);
							pagamento.setCobrancaDocumento(cobrancaDocumento);							
							
							if(idDocumentoTipo != null){
								DocumentoTipo documentoAgregador = new DocumentoTipo();
								documentoAgregador.setId(idDocumentoTipo);
								pagamento.setDocumentoTipoAgregador(documentoAgregador);
							}
							
							pagamento.setDataProcessamento(new Date());
							
							if (pagamento.getDocumentoTipo() != null) {
								colecaoPagamentos.add(pagamento);
							}
						} else {

							CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
							creditoARealizarGeral.setId((Integer) arrayCobrancaDocumentoItem[13]);
							
							cobrancaDocumentoItem.setCreditoARealizarGeral(creditoARealizarGeral);
							
							CreditoARealizar creditoARealizarAntecipacao = null;
							if (cobrancaDocumentoItem.getNumeroParcelasAntecipadas() != null){
								
								creditoARealizarAntecipacao = (CreditoARealizar) this.gerarDebitoCreditoParcelasAntecipadas(idImovelNaBase, 
								cobrancaDocumentoItem, usuarioLogado);
								
								creditoARealizarGeral.setId(creditoARealizarAntecipacao.getId());
								creditoARealizarGeral.setCreditoARealizar(creditoARealizarAntecipacao);
							}
							
							Devolucao devolucao = new Devolucao();

							devolucao.setDataDevolucao(registroTipo7.getDataLiquidacaoFormatado());

							Integer anoMesDataDevolucao = Util.getAnoMesComoInteger(devolucao.getDataDevolucao());
							if (anoMesDataDevolucao > getSistemaParametro().getAnoMesArrecadacao()) {
								devolucao.setAnoMesReferenciaArrecadacao(anoMesDataDevolucao);
							} else {
								devolucao.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
							}

							devolucao.setValorDevolucao(cobrancaDocumentoItem.getValorItemCobrado());

							if (arrayCobrancaDocumentoItem[14] != null) {
								Localidade localidade = new Localidade();
								localidade.setId((Integer) arrayCobrancaDocumentoItem[14]);
								devolucao.setLocalidade(localidade);
							}

							if (arrayCobrancaDocumentoItem[15] != null) {
								Imovel imovel = new Imovel();
								imovel.setId((Integer) arrayCobrancaDocumentoItem[15]);
								devolucao.setImovel(imovel);
							}

							DebitoTipo debitoTipo = new DebitoTipo();
							debitoTipo.setId(DebitoTipo.OUTROS);

							devolucao.setDebitoTipo(debitoTipo);
							devolucao.setCreditoARealizarGeral(creditoARealizarGeral);
							devolucao.setUltimaAlteracao(new Date());

							CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
							cobrancaDocumento.setId(idCobrancaDocumento);

							devolucao.setCobrancaDocumento(cobrancaDocumento);							
							
							if(idDocumentoTipo != null){
								DocumentoTipo documentoAgregador = new DocumentoTipo();
								documentoAgregador.setId(idDocumentoTipo);

								devolucao.setDocumentoTipoAgregador(documentoAgregador);
							}
							
							colecaoDevolucoes.add(devolucao);
						}
					}
					
					if (colecaoDebitosACobrarJurosParcelamento != null && !colecaoDebitosACobrarJurosParcelamento.isEmpty()){
						
						Iterator itDebitosACobrarJurosParcelamento = colecaoDebitosACobrarJurosParcelamento.iterator();
						
						while(itDebitosACobrarJurosParcelamento.hasNext()){
							this.atualizarNumeroParcelasBonus((DebitoACobrar) itDebitosACobrarJurosParcelamento.next());
						}
					}
				}

			} else {
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		} else {
			indicadorAceitacaoRegistro = "2";
		}

		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setColecaoDevolucao(colecaoDevolucoes);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}
	
	private DebitoACobrarGeral preencheDebitoACobrar(Integer idDebitoACobrar, CobrancaDocumentoItem cobrancaDocumentoItem) {
		DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
		DebitoACobrar debitoACobrar = new DebitoACobrar();
		
		debitoACobrar.setId(idDebitoACobrar);
		
		debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
		debitoACobrarGeral.setId(debitoACobrar.getId());
		
		cobrancaDocumentoItem.setDebitoACobrarGeral(debitoACobrarGeral);
		
		return debitoACobrarGeral;
	}
	
	private GuiaPagamento preencheGuiaPagamento(Integer idGuiaPagamento, CobrancaDocumentoItem cobrancaDocumentoItem) {
		GuiaPagamentoGeral guiaPagamentoGeral = new GuiaPagamentoGeral();
		GuiaPagamento guiaPagamento = new GuiaPagamento();
		
		guiaPagamento.setId(idGuiaPagamento);
		guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
		guiaPagamentoGeral.setId(guiaPagamento.getId());
		
		cobrancaDocumentoItem.setGuiaPagamentoGeral(guiaPagamentoGeral);
		
		return guiaPagamento;
	}
	
	private Conta preencheConta(Integer idConta, Integer referencia, CobrancaDocumentoItem cobrancaDocumentoItem) {
		Conta conta = new Conta();
		conta.setId(idConta);
		
		if (referencia != null) {
			conta.setReferencia((Integer) referencia);
		}
		else{
			conta.setReferencia(0);
		}
		
		ContaGeral contaGeral = new ContaGeral();
		contaGeral.setConta(conta);
		contaGeral.setId(conta.getId());
		
		cobrancaDocumentoItem.setContaGeral(contaGeral);
		
		return conta;
	}

	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * CLIENTE RESPONSÁVEL
	 * 
	 * Autor: Raphael Rossiter Data: 02/05/2007
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasClienteResponsavel(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamnetos = new ArrayList();

		int anoMes = 0;

		boolean anoMesReferencia = false;

		// valida a matricula do imóvel
		boolean idClienteInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());
		Integer idClienteNaBase = null;

		if (idClienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		} else {
			// verifica se existe o id do cliente na
			// base
			Integer idCliente = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idClienteNaBase = repositorioCliente
						.verificarExistenciaCliente(new Integer(idCliente));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteNaBase == null) {
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		// valida o namo mes de referencia da conta
		anoMes = Util.formatarMesAnoParaAnoMes(Integer
				.parseInt(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4()));
		anoMesReferencia = Util.validarAnoMesSemBarra("" + anoMes);
		if (anoMesReferencia) {
			descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDA";
		}
		if (descricaoOcorrencia.equals("OK")) {

			// inicializa a coleção de fatura item
			Collection faturaItens = null;

			Integer numeroSequencial = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento6());
			try {
				faturaItens = repositorioFaturamento.pesquisarFaturaItem(
						idClienteNaBase, anoMes, numeroSequencial,
						valorPagamento);
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			// verifica se a coleção é diferente de nula
			if (faturaItens != null && !faturaItens.isEmpty()) {
				Iterator faturaItensIterator = faturaItens.iterator();
				while (faturaItensIterator.hasNext()) {
					Object[] faturaItem = (Object[]) faturaItensIterator.next();
					// inicializa as variaveis que veio da pesquisa
					Integer idContaPesquisa = null;
					Integer idImovelPesquisa = null;
					Integer idLocalidadePesquisa = null;
					BigDecimal valorConta = null;
					Integer idFatura = null;
					// verifica o valor da conta
					if (faturaItem[0] != null) {
						valorConta = (BigDecimal) faturaItem[0];
					}
					// verifica o id da conta
					if (faturaItem[1] != null) {
						idContaPesquisa = (Integer) faturaItem[1];
					}
					// verifica o id da localidade
					if (faturaItem[2] != null) {
						idLocalidadePesquisa = (Integer) faturaItem[2];
					}
					// verifica o id do imovel
					if (faturaItem[3] != null) {
						idImovelPesquisa = (Integer) faturaItem[3];
					}
					// verifica o id da localidade de Conta
					// Histórico
					if (faturaItem[4] != null) {
						idLocalidadePesquisa = (Integer) faturaItem[4];
					}
					
					
					// verifica o id do imovel de Conta Histórico
					if (faturaItem[5] != null) {
						idImovelPesquisa = (Integer) faturaItem[5];
					}
					// verifica o id da fatura
					if (faturaItem[6] != null) {
						idFatura = (Integer) faturaItem[6];
					}

					// cria o objeto pagamento para setar os
					// dados
					Pagamento pagamento = new Pagamento();
					pagamento.setAnoMesReferenciaPagamento(anoMes);
					// caso o ano mes da data de dedito seja
					// maior que o ano mes de arrecadação da
					// tabela sistema parametro então seta o ano
					// mes da data de debito
					if (anoMesPagamento > getSistemaParametro()
							.getAnoMesArrecadacao()) {
						pagamento
								.setAnoMesReferenciaArrecadacao(anoMesPagamento);
					} else {
						// caso contrario seta o o ano mes
						// arrecadação da tabela sistema
						// parametro
						pagamento
								.setAnoMesReferenciaArrecadacao(getSistemaParametro()
										.getAnoMesArrecadacao());
					}
					pagamento.setValorPagamento(valorConta);
					pagamento.setDataPagamento(dataPagamento);
					pagamento.setPagamentoSituacaoAtual(null);
					pagamento.setPagamentoSituacaoAnterior(null);
					pagamento.setDebitoTipo(null);
					// verifica se o id da conta é diferente de
					// nulo
					if (idContaPesquisa != null) {
						ContaGeral conta = new ContaGeral();
						conta.setId(idContaPesquisa);
						pagamento.setContaGeral(conta);
					} else {
						pagamento.setContaGeral(null);
					}
					pagamento.setGuiaPagamento(null);

					pagamento.setDebitoACobrarGeral(null);

					// verifica se o id da conta é diferente de
					// nulo
					if (idLocalidadePesquisa != null) {
						Localidade localidade = new Localidade();
						localidade.setId(idLocalidadePesquisa);
						pagamento.setLocalidade(localidade);
					} else {
						pagamento.setLocalidade(null);
					}
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);
					documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);
					pagamento.setDocumentoTipo(documentoTipo);

					// seta o id do aviso bancario
					pagamento.setAvisoBancario(null);

					// seta o imovel
					if (idImovelPesquisa != null) {
						Imovel imovel = new Imovel();
						imovel.setId(idImovelPesquisa);
						pagamento.setImovel(imovel);
					} else {
						pagamento.setImovel(null);
					}

					pagamento.setArrecadadorMovimentoItem(null);

					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(idFormaArrecadacao);
					pagamento.setArrecadacaoForma(arrecadacaoForma);
					pagamento.setCliente(null);
					pagamento.setUltimaAlteracao(new Date());

					Fatura fatura = new Fatura();
					fatura.setId(idFatura);
					pagamento.setFatura(fatura);
					
					pagamento.setCobrancaDocumento(null);
					
					DocumentoTipo documentoAgregador = new DocumentoTipo();
					documentoAgregador.setId(DocumentoTipo.FATURA_CLIENTE);
					pagamento.setDocumentoTipoAgregador(documentoAgregador);
					
					pagamento.setDataProcessamento(new Date());
					
					colecaoPagamnetos.add(pagamento);
				}
			}
		} else {
			// atribui o valor 2(NÃO) ao indicador aceitacao
			// registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamnetos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras
				.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}

	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasDocumentoCobrancaTipo8Novo(
			RegistroHelperCodigoBarras registroHelperCodigoBarras, RegistroFichaCompensacaoTipo7Helper registroTipo7, Integer idFormaArrecadacao) 
																														throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();
		Collection colecaoDevolucoes = new ArrayList();

		boolean idClienteInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
		Integer idClienteNaBase = null;

		if (idClienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		} else {
			Integer idCliente = new Integer(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());

			try {
				idClienteNaBase = repositorioCliente.verificarExistenciaCliente(new Integer(idCliente));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteNaBase == null) {
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		boolean tipoDocumentoInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4());

		if (tipoDocumentoInvalido) {
			descricaoOcorrencia = "TIPO DO DOCUMENTO NÃO NUMÉRICO";
		}

		if (descricaoOcorrencia.equals("OK")) {
			Collection cobrancaDocumentoItens = null;

			int numeroSequencialDocumento = Integer.parseInt(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3());

			try {

				cobrancaDocumentoItens = repositorioCobranca.pesquisarCobrancaDocumentoItemCliente(idClienteNaBase, numeroSequencialDocumento);
				
				FiltroCobrancaDocumento filtro = new FiltroCobrancaDocumento();
				filtro.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.ID, numeroSequencialDocumento));
				CobrancaDocumento cobrancaDocumento = (CobrancaDocumento)getControladorUtil().pesquisar(filtro, CobrancaDocumento.class.getName()).iterator().next();
				
				if(cobrancaDocumento != null && cobrancaDocumento.getValorAcrescimos() != null 
						&& cobrancaDocumento.getValorAcrescimos().compareTo(new BigDecimal("0.00")) != 0) {
					
					colecaoPagamentos.addAll(
							processarRecebimentoAcrescimosImpontualidadePorCliente(
								numeroSequencialDocumento, registroTipo7.getDataLiquidacaoFormatado(), cobrancaDocumento.getValorAcrescimos(),
								idClienteNaBase, null, getSistemaParametro(),
								idFormaArrecadacao, cobrancaDocumento.getDocumentoTipo().getId()));
				}
				
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (cobrancaDocumentoItens != null && !cobrancaDocumentoItens.isEmpty()) {
				Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens.iterator();
				
				while (cobrancaDocumentoItensIterator.hasNext()) {
					Object[] cobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator.next();

					Integer idContaPesquisa = null;
					Integer idContaGeralPesquisa = null;
					Integer idGuiaPagamento = null;
					Integer idDebitoACobrar = null;
					Integer idCreditoARealizarGeralPesquisa = null;
					BigDecimal valorItemCobrado = null;
					int contaReferencia = 0;
					Integer idDebitoTipo = null;
					Integer idGuiaPagamentoGeralPesquisa = null;
					Integer idDebitoACobrarGeralPesquisa = null;
					Integer idCobrancaDocumento = null;
					Integer idDocumentoTipo = null;
					Short numeroPrestacaoCobradas = null;
					Short numeroPrestacaoDebito = null;
					
					if (cobrancaDocumentoItem[0] != null) {
						idContaPesquisa = (Integer) cobrancaDocumentoItem[0];
						idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[0];

						if (cobrancaDocumentoItem[4] != null) {
							contaReferencia = (Integer) cobrancaDocumentoItem[4];
						}
					} else {
						if (cobrancaDocumentoItem[10] != null) {
							idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[10];
						}

						if (cobrancaDocumentoItem[5] != null) {
							contaReferencia = (Integer) cobrancaDocumentoItem[5];
						}
					}

					if (cobrancaDocumentoItem[1] != null) {
						idGuiaPagamento = (Integer) cobrancaDocumentoItem[1];
						idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[1];
					} else {
						if (cobrancaDocumentoItem[11] != null) {
							idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[11];
						}
					}

					if (cobrancaDocumentoItem[2] != null) {
						idDebitoACobrar = (Integer) cobrancaDocumentoItem[2];
						idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[2];
						numeroPrestacaoDebito = (Short) cobrancaDocumentoItem[27];
						numeroPrestacaoCobradas = (Short) cobrancaDocumentoItem[28];

						verificaPagamentoDebitoACobrarParcelamento(idDebitoACobrar, null);
					} else {
						if (cobrancaDocumentoItem[12] != null) {
							idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[12];
						}
					}
					
					if (cobrancaDocumentoItem[29] != null) {
						idCreditoARealizarGeralPesquisa = (Integer)cobrancaDocumentoItem[29];
					}
					
					if (cobrancaDocumentoItem[3] != null) {
						valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[3];
					}

					if (cobrancaDocumentoItem[25] != null){
						idCobrancaDocumento = (Integer) cobrancaDocumentoItem[25]; 
					}
					if (cobrancaDocumentoItem[26] != null){
						idDocumentoTipo = (Integer) cobrancaDocumentoItem[26]; 
					}
					
					if(idCreditoARealizarGeralPesquisa == null){
						
						if (idContaGeralPesquisa == null) {
							if (idGuiaPagamentoGeralPesquisa != null) {
								if (cobrancaDocumentoItem[6] != null) {
									idDebitoTipo = (Integer) cobrancaDocumentoItem[6];
								} else {
									if (cobrancaDocumentoItem[7] != null) {
										idDebitoTipo = (Integer) cobrancaDocumentoItem[7];
									}
								}
							}
							if (idDebitoACobrarGeralPesquisa != null) {
								if (cobrancaDocumentoItem[8] != null) {
									idDebitoTipo = (Integer) cobrancaDocumentoItem[8];
	
								} else {
									if (cobrancaDocumentoItem[9] != null) {
										idDebitoTipo = (Integer) cobrancaDocumentoItem[9];
									}
								}
							}
						}
	
						Pagamento pagamento = new Pagamento();

						if (contaReferencia != 0) {
							pagamento.setAnoMesReferenciaPagamento(contaReferencia);
						} else {
							pagamento.setAnoMesReferenciaPagamento(null);
						}
	
						int anoMesPagamento = Util.formataAnoMes(registroTipo7.getDataLiquidacaoFormatado());
						if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
							pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
						} else {
							pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
						}
						
						pagamento.setValorPagamento(valorItemCobrado);
						pagamento.setDataPagamento(registroTipo7.getDataLiquidacaoFormatado());
						pagamento.setPagamentoSituacaoAtual(null);
						pagamento.setPagamentoSituacaoAnterior(null);

						if (idDebitoTipo != null) {
							DebitoTipo debitoTipo = new DebitoTipo();
							debitoTipo.setId(idDebitoTipo);
							pagamento.setDebitoTipo(debitoTipo);
						} else {
							pagamento.setDebitoTipo(null);
						}
	
						if (idContaGeralPesquisa != null) {
							if (idContaPesquisa != null) {
								ContaGeral conta = new ContaGeral();
								conta.setId(idContaPesquisa);
								pagamento.setContaGeral(conta);
							} else {
								pagamento.setContaGeral(null);
							}
	
							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.CONTA);
							pagamento.setDocumentoTipo(documentoTipo);
						} else {
							pagamento.setContaGeral(null);
						}
						
						if (idGuiaPagamentoGeralPesquisa != null) {
							if (idGuiaPagamento != null) {
								GuiaPagamento guiaPagamento = new GuiaPagamento();
								guiaPagamento.setId(idGuiaPagamento);
								pagamento.setGuiaPagamento(guiaPagamento);
	
							} else {
								pagamento.setGuiaPagamento(null);
							}
							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
							pagamento.setDocumentoTipo(documentoTipo);
	
						} else {
							pagamento.setGuiaPagamento(null);
						}
	
						if (idDebitoACobrarGeralPesquisa != null) {
							if (idDebitoACobrar != null) {
	
								if (numeroPrestacaoCobradas.intValue() != numeroPrestacaoDebito.intValue()) {
									DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
									debitoACobrarGeral.setId(idDebitoACobrar);
	
									pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
								}
								try {
									repositorioFaturamento.atualizarSituacaoAtualDebitoACobrar(idDebitoACobrar);
									
								} catch (ErroRepositorioException e) {
									throw new ControladorException("erro.sistema",
											e);
								}
							} else {
								pagamento.setDebitoACobrarGeral(null);
							}

							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
							documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
							pagamento.setDocumentoTipo(documentoTipo);
	
						} else {
							pagamento.setGuiaPagamento(null);
						}
	
						pagamento.setAvisoBancario(null);

						Imovel imovel = new Imovel();
						Localidade localidade = new Localidade();
						
						if (idContaGeralPesquisa != null) {
							if (cobrancaDocumentoItem[16] != null){
								imovel.setId((Integer) cobrancaDocumentoItem[13]);
								localidade.setId((Integer) cobrancaDocumentoItem[16]);
							} else {
								imovel.setId((Integer) cobrancaDocumentoItem[19]);
								localidade.setId((Integer) cobrancaDocumentoItem[20]);
							}
							
							pagamento.setImovel(imovel);
							pagamento.setLocalidade(localidade);
							
						} else if (idGuiaPagamentoGeralPesquisa != null) {
							
							if (cobrancaDocumentoItem[17] != null){
								imovel.setId((Integer) cobrancaDocumentoItem[14]);
								localidade.setId((Integer) cobrancaDocumentoItem[17]);
							} else {
								imovel.setId((Integer) cobrancaDocumentoItem[21]);
								localidade.setId((Integer) cobrancaDocumentoItem[22]);
							}
							
							pagamento.setImovel(imovel);
							pagamento.setLocalidade(localidade);
							
						} 
						
						else if (idDebitoACobrarGeralPesquisa != null) {
							
							if (cobrancaDocumentoItem[18] != null){
								imovel.setId((Integer) cobrancaDocumentoItem[15]);
								localidade.setId((Integer) cobrancaDocumentoItem[18]);
							} else {
								imovel.setId((Integer) cobrancaDocumentoItem[23]);
								localidade.setId((Integer) cobrancaDocumentoItem[24]);
							}
							
							pagamento.setImovel(imovel);
							pagamento.setLocalidade(localidade);
						}
						
						pagamento.setArrecadadorMovimentoItem(null);
	
						ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
						arrecadacaoForma.setId(idFormaArrecadacao);
						pagamento.setArrecadacaoForma(arrecadacaoForma);
						pagamento.setCliente(null);
						pagamento.setUltimaAlteracao(new Date());
						
						pagamento.setFatura(null);
						
						CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
						cobrancaDocumento.setId(idCobrancaDocumento);
						pagamento.setCobrancaDocumento(cobrancaDocumento);							
						
						if(idDocumentoTipo != null){
							DocumentoTipo documentoAgregador = new DocumentoTipo();
							documentoAgregador.setId(idDocumentoTipo);
							pagamento.setDocumentoTipoAgregador(documentoAgregador);
						}
						
						pagamento.setDataProcessamento(new Date());
						
						colecaoPagamentos.add(pagamento);
					
					}else{
						
						Devolucao devolucao = new Devolucao();
						devolucao.setDataDevolucao(registroTipo7.getDataLiquidacaoFormatado());

						Integer anoMesDataDevolucao = Util.getAnoMesComoInteger(devolucao.getDataDevolucao());

						if (anoMesDataDevolucao > getSistemaParametro().getAnoMesArrecadacao()) {
							devolucao.setAnoMesReferenciaArrecadacao(anoMesDataDevolucao);
						} else {
							devolucao.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
						}

						devolucao.setValorDevolucao(valorItemCobrado);

						if (cobrancaDocumentoItem[30] != null) {
							Localidade localidade = new Localidade();
							localidade.setId((Integer) cobrancaDocumentoItem[30]);
							devolucao.setLocalidade(localidade);
						}

						if (cobrancaDocumentoItem[31] != null) {
							Imovel imovel = new Imovel();
							imovel.setId((Integer) cobrancaDocumentoItem[31]);
							devolucao.setImovel(imovel);
						}

						DebitoTipo debitoTipo = new DebitoTipo();
						debitoTipo.setId(DebitoTipo.OUTROS);
						devolucao.setDebitoTipo(debitoTipo);

						CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
						creditoARealizarGeral.setId((Integer) cobrancaDocumentoItem[29]);
						devolucao.setCreditoARealizarGeral(creditoARealizarGeral);

						devolucao.setUltimaAlteracao(new Date());

						CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
						cobrancaDocumento.setId(idCobrancaDocumento);
						devolucao.setCobrancaDocumento(cobrancaDocumento);							
						
						if(idDocumentoTipo != null){
							DocumentoTipo documentoAgregador = new DocumentoTipo();
							documentoAgregador.setId(idDocumentoTipo);
							devolucao.setDocumentoTipoAgregador(documentoAgregador);
						}
						
						colecaoDevolucoes.add(devolucao);
					}
				}
			} else {
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		} else {
			indicadorAceitacaoRegistro = "2";
		}

		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		pagamentoHelperCodigoBarras.setColecaoDevolucao(colecaoDevolucoes);
		
		return pagamentoHelperCodigoBarras;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * DOCUMENTO COBRANÇA TIPO 08
	 * 
	 * Autor: Raphael Rossiter Data: 02/05/2007
	 */
	@SuppressWarnings({ "unchecked", "rawtypes" })
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasDocumentoCobrancaTipo8(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();
		Collection colecaoDevolucoes = new ArrayList();

		// valida o cliente
		boolean idClienteInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		Integer idClienteNaBase = null;

		if (idClienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		} else {
			// verifica se existe o id do cliente na
			// base
			Integer idCliente = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idClienteNaBase = repositorioCliente
						.verificarExistenciaCliente(new Integer(idCliente));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteNaBase == null) {
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		// valida o namo mes de referencia da conta
		boolean tipoDocumentoInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4());

		if (tipoDocumentoInvalido) {
			descricaoOcorrencia = "TIPO DO DOCUMENTO NÃO NUMÉRICO";
		}

		if (descricaoOcorrencia.equals("OK")) {

			// inicializa a coleção de cobranca documento item
			Collection cobrancaDocumentoItens = null;
			// inicializa a coleção de cobranca documento item
			// Object[] parmsDocumentoCobranca = null;

			int numeroSequencialDocumento = Integer
					.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento3());

			try {

				cobrancaDocumentoItens = repositorioCobranca
						.pesquisarCobrancaDocumentoItemCliente(idClienteNaBase,
								numeroSequencialDocumento);
				
				//pesquisar o doc de cobrança
				FiltroCobrancaDocumento filtro = new FiltroCobrancaDocumento();
				filtro.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumento.ID, numeroSequencialDocumento));
				
				Collection<CobrancaDocumento> listaDocumentosCobranca = getControladorUtil().pesquisar(filtro, CobrancaDocumento.class.getName());
		        
		        CobrancaDocumento cobrancaDocumento = null; 
		        
		        if (!listaDocumentosCobranca.isEmpty()) {
		          cobrancaDocumento = listaDocumentosCobranca.iterator().next();
		        }
				if(cobrancaDocumento != null && cobrancaDocumento.getValorAcrescimos() != null 
						&& cobrancaDocumento.getValorAcrescimos().compareTo(new BigDecimal("0.00")) != 0) {
					colecaoPagamentos.addAll(processarRecebimentoAcrescimosImpontualidadePorCliente(
							numeroSequencialDocumento, dataPagamento, cobrancaDocumento.getValorAcrescimos(),
							idClienteNaBase, null, getSistemaParametro(),
							idFormaArrecadacao, cobrancaDocumento.getDocumentoTipo().getId()));
				}
				
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			// caso exista documento de cobrança
			// verifica se a coleção é diferente de nula
			if (cobrancaDocumentoItens != null
					&& !cobrancaDocumentoItens.isEmpty()) {
				Iterator cobrancaDocumentoItensIterator = cobrancaDocumentoItens
						.iterator();
				while (cobrancaDocumentoItensIterator.hasNext()) {
					Object[] cobrancaDocumentoItem = (Object[]) cobrancaDocumentoItensIterator
							.next();
					// inicializa as variaveis que veio da
					// pesquisa
					Integer idContaPesquisa = null;
					Integer idContaGeralPesquisa = null;
					Integer idGuiaPagamento = null;
					Integer idDebitoACobrar = null;
					Integer idCreditoARealizarGeralPesquisa = null;
					BigDecimal valorItemCobrado = null;
					int contaReferencia = 0;
					Integer idDebitoTipo = null;
					Integer idGuiaPagamentoGeralPesquisa = null;
					Integer idDebitoACobrarGeralPesquisa = null;
					Integer idCobrancaDocumento = null;
					Integer idDocumentoTipo = null;
					Short numeroPrestacaoCobradas = null;
					Short numeroPrestacaoDebito = null;
					
					// verifica o id da conta
					if (cobrancaDocumentoItem[0] != null) {
						idContaPesquisa = (Integer) cobrancaDocumentoItem[0];
						idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[0];
						// referencia conta
						if (cobrancaDocumentoItem[4] != null) {
							contaReferencia = (Integer) cobrancaDocumentoItem[4];
						}
					} else {
						// caso não exista na conta então pesquisa
						// na conta histórico
						if (cobrancaDocumentoItem[10] != null) {
							idContaGeralPesquisa = (Integer) cobrancaDocumentoItem[10];
						}

						// referencia conta histórico
						if (cobrancaDocumentoItem[5] != null) {
							contaReferencia = (Integer) cobrancaDocumentoItem[5];
						}
					}

					// verifica o id da guia pagamento
					if (cobrancaDocumentoItem[1] != null) {
						idGuiaPagamento = (Integer) cobrancaDocumentoItem[1];
						idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[1];
					} else {
						// caso não exista no guia pagamento então
						// pesquisa no guia pagamento histórico
						if (cobrancaDocumentoItem[11] != null) {
							idGuiaPagamentoGeralPesquisa = (Integer) cobrancaDocumentoItem[11];
						}
					}
					// verifica o id do debito a cobrar
					if (cobrancaDocumentoItem[2] != null) {
						idDebitoACobrar = (Integer) cobrancaDocumentoItem[2];
						idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[2];
						numeroPrestacaoDebito = (Short) cobrancaDocumentoItem[27];
						numeroPrestacaoCobradas = (Short) cobrancaDocumentoItem[28];

						// [SB0012]- Verifica Pagamento de Débito a Cobrar de
						// Parcelamento
						verificaPagamentoDebitoACobrarParcelamento(idDebitoACobrar, null);

					} else {
						// caso não exista no debito a cobrar então
						// pesquisa no guia pagamento histórico
						if (cobrancaDocumentoItem[12] != null) {
							idDebitoACobrarGeralPesquisa = (Integer) cobrancaDocumentoItem[12];
						}
					}
					
					//adicionado por Vivianne Sousa - CRC1357 - 27/02/2009
					//verifica o id do credito a realizar
					if (cobrancaDocumentoItem[29] != null) {
						idCreditoARealizarGeralPesquisa = (Integer)cobrancaDocumentoItem[29];
					}
					
					
					// verifica o valor do item cobrado da
					// cobranca
					// documento item
					if (cobrancaDocumentoItem[3] != null) {
						valorItemCobrado = (BigDecimal) cobrancaDocumentoItem[3];
					}

					
					/*
					 * Adicao dos campos 'id do Documento de cobranca' e 'id do tipo de documento' usados no
					 * relatório do Float
					 * Francisco 18/07/08
					 */
					if (cobrancaDocumentoItem[25] != null){
						idCobrancaDocumento = (Integer) cobrancaDocumentoItem[25]; 
					}
					if (cobrancaDocumentoItem[26] != null){
						idDocumentoTipo = (Integer) cobrancaDocumentoItem[26]; 
					}
					
					// adicionado por Vivianne Sousa - CRC1357 - 27/02/2009
					//para itens de documento de cobrança com id  do credito a realizar == null
					if(idCreditoARealizarGeralPesquisa == null){
						
						// se o id da conta for igual a null
						if (idContaGeralPesquisa == null) {
							// caso exista guia de pagamento
							if (idGuiaPagamentoGeralPesquisa != null) {
								// verifica o id do debito tipo se é da
								// guia
								if (cobrancaDocumentoItem[6] != null) {
									idDebitoTipo = (Integer) cobrancaDocumentoItem[6];
								} else {
									// caso não exista no guia pagamento
									// então
									// pesquisa no guia pagamento
									// histórico
									if (cobrancaDocumentoItem[7] != null) {
										idDebitoTipo = (Integer) cobrancaDocumentoItem[7];
									}
								}
							}
							// caso exista debito a cobrar
							if (idDebitoACobrarGeralPesquisa != null) {
								// verifica o id do debito tipo no
								// debito a cobrar
								if (cobrancaDocumentoItem[8] != null) {
									idDebitoTipo = (Integer) cobrancaDocumentoItem[8];
	
								} else {
									// caso não exista no debito a
									// cobrar
									// então
									// pesquisa no debito a cobrar
									// histórico
									if (cobrancaDocumentoItem[9] != null) {
										idDebitoTipo = (Integer) cobrancaDocumentoItem[9];
									}
								}
							}
						}
	
						// cria o objeto pagamento para setar os
						// dados
						Pagamento pagamento = new Pagamento();
						if (contaReferencia != 0) {
							pagamento.setAnoMesReferenciaPagamento(contaReferencia);
						} else {
							pagamento.setAnoMesReferenciaPagamento(null);
						}
	
						// caso o ano mes da data de dedito seja
						// maior que o ano mes de arrecadação da
						// tabela sistema parametro então seta o ano
						// mes da data de debito
						if (anoMesPagamento > getSistemaParametro()
								.getAnoMesArrecadacao()) {
							pagamento
									.setAnoMesReferenciaArrecadacao(anoMesPagamento);
						} else {
							// caso contrario seta o o ano mes
							// arrecadação da tabela sistema
							// parametro
							pagamento
									.setAnoMesReferenciaArrecadacao(getSistemaParametro()
											.getAnoMesArrecadacao());
						}
						pagamento.setValorPagamento(valorItemCobrado);
						pagamento.setDataPagamento(dataPagamento);
						pagamento.setPagamentoSituacaoAtual(null);
						pagamento.setPagamentoSituacaoAnterior(null);
						if (idDebitoTipo != null) {
							DebitoTipo debitoTipo = new DebitoTipo();
							debitoTipo.setId(idDebitoTipo);
							pagamento.setDebitoTipo(debitoTipo);
						} else {
							pagamento.setDebitoTipo(null);
						}
	
						// verifica se o id da conta é diferente de
						// nulo
						if (idContaGeralPesquisa != null) {
							if (idContaPesquisa != null) {
								ContaGeral conta = new ContaGeral();
								conta.setId(idContaPesquisa);
								pagamento.setContaGeral(conta);
							} else {
								pagamento.setContaGeral(null);
							}
	
							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.CONTA);
							pagamento.setDocumentoTipo(documentoTipo);
						} else {
							pagamento.setContaGeral(null);
						}
						// verifica se o id da guia de pagamento é
						// diferente de nulo
						if (idGuiaPagamentoGeralPesquisa != null) {
							if (idGuiaPagamento != null) {
								GuiaPagamento guiaPagamento = new GuiaPagamento();
								guiaPagamento.setId(idGuiaPagamento);
								pagamento.setGuiaPagamento(guiaPagamento);
	
							} else {
								pagamento.setGuiaPagamento(null);
							}
							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
							pagamento.setDocumentoTipo(documentoTipo);
	
						} else {
							pagamento.setGuiaPagamento(null);
						}
	
						// verifica se o id do debito a cobrar é
						// diferente de nulo
						if (idDebitoACobrarGeralPesquisa != null) {
							if (idDebitoACobrar != null) {
	
								if (numeroPrestacaoCobradas.intValue() != numeroPrestacaoDebito.intValue()) {
									DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
									debitoACobrarGeral.setId(idDebitoACobrar);
	
									pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
								}
								try {
									// atualiza a situação atual para
									// cancelada
									repositorioFaturamento
											.atualizarSituacaoAtualDebitoACobrar(idDebitoACobrar);
								} catch (ErroRepositorioException e) {
									throw new ControladorException("erro.sistema",
											e);
								}
	
							} else {
								pagamento.setDebitoACobrarGeral(null);
							}
							DocumentoTipo documentoTipo = new DocumentoTipo();
							documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
							documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
							pagamento.setDocumentoTipo(documentoTipo);
	
						} else {
							pagamento.setGuiaPagamento(null);
						}
	
						// seta o id do aviso bancario
						pagamento.setAvisoBancario(null);
	
						
						// SETANDO A LOCALIDADE E O IMÓVEL DO PAGAMENTO 
						Imovel imovel = new Imovel();
						Localidade localidade = new Localidade();
						
						//CONTA
						if (idContaGeralPesquisa != null) {
							
							if (cobrancaDocumentoItem[16] != null){
								
								//Imovel na tabela CONTA
								imovel.setId((Integer) cobrancaDocumentoItem[13]);
								
								//Localidade na tabela CONTA
								localidade.setId((Integer) cobrancaDocumentoItem[16]);
							}
							else{
								
								//Imovel na tabela CONTA_HISTORICO
								imovel.setId((Integer) cobrancaDocumentoItem[19]);
								
								//Localidade na tabela CONTA_HISTORICO
								localidade.setId((Integer) cobrancaDocumentoItem[20]);
							}
							
							pagamento.setImovel(imovel);
							pagamento.setLocalidade(localidade);
							
						} 
						
						//GUIA_PAGAMENTO
						else if (idGuiaPagamentoGeralPesquisa != null) {
							
							if (cobrancaDocumentoItem[17] != null){
								
								//Imovel na tabela GUIA_PAGAMENTO
								imovel.setId((Integer) cobrancaDocumentoItem[14]);
								
								//Localidade na tabela GUIA_PAGAMENTO
								localidade.setId((Integer) cobrancaDocumentoItem[17]);
							}
							else{
								
								//Imovel na tabela GUIA_PAGAMENTO_HISTORICO
								imovel.setId((Integer) cobrancaDocumentoItem[21]);
								
								//Localidade na tabela GUIA_PAGAMENTO_HISTORICO
								localidade.setId((Integer) cobrancaDocumentoItem[22]);
							}
							
							pagamento.setImovel(imovel);
							pagamento.setLocalidade(localidade);
							
						} 
						
						//DEBITO_A_COBRAR
						else if (idDebitoACobrarGeralPesquisa != null) {
							
							if (cobrancaDocumentoItem[18] != null){
								
								//Imovel na tabela DEBITO_A_COBRAR
								imovel.setId((Integer) cobrancaDocumentoItem[15]);
								
								//Localidade na tabela DEBITO_A_COBRAR
								localidade.setId((Integer) cobrancaDocumentoItem[18]);
							}
							else{
								
								//Imovel na tabela DEBITO_A_COBRAR_HISTORICO
								imovel.setId((Integer) cobrancaDocumentoItem[23]);
								
								//Localidade na tabela DEBITO_A_COBRAR_HISTORICO
								localidade.setId((Integer) cobrancaDocumentoItem[24]);
							}
							
							pagamento.setImovel(imovel);
							pagamento.setLocalidade(localidade);
						}
						
	
						/*
						 * if (idImovelNaBase != null) { Imovel imovel = new
						 * Imovel(); imovel.setId(idImovelNaBase);
						 * pagamento.setImovel(imovel); } else {
						 * pagamento.setImovel(null); }
						 */
	
						// ArrecadadorMovimentoItem
						// arrecadadorMovimentoItem
						// = new ArrecadadorMovimentoItem();
						pagamento.setArrecadadorMovimentoItem(null);
	
						ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
						arrecadacaoForma.setId(idFormaArrecadacao);
						pagamento.setArrecadacaoForma(arrecadacaoForma);
						pagamento.setCliente(null);
						pagamento.setUltimaAlteracao(new Date());
						
						pagamento.setFatura(null);
						
						CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
						cobrancaDocumento.setId(idCobrancaDocumento);
						pagamento.setCobrancaDocumento(cobrancaDocumento);							
						
						// documento tipo do documento de cobranca
						if(idDocumentoTipo != null){
							DocumentoTipo documentoAgregador = new DocumentoTipo();
							documentoAgregador.setId(idDocumentoTipo);
							pagamento.setDocumentoTipoAgregador(documentoAgregador);
						}
						
						pagamento.setDataProcessamento(new Date());
						
						colecaoPagamentos.add(pagamento);
					
					
					}else{
						
						// Para os itens que tenham CreditoARealizar gerar
						// suas respectivas devoluções

						Devolucao devolucao = new Devolucao();

						// DataDevolucao = DataPagamento
						devolucao.setDataDevolucao(dataPagamento);

						/*
						 * AnoMesReferenciaDevolucao Caso o anoMes da data
						 * de devolução seja MAIOR que a
						 * PARM_AMREFERENCIAARRECADACAO da tabela
						 * SISTEMA_PARAMETROS atribuir o anoMes da data da
						 * devolução, caso contrário atribuir o
						 * PARM_AMREFERENCIAARRECADACAO.
						 */
						Integer anoMesDataDevolucao = Util.getAnoMesComoInteger(devolucao.getDataDevolucao());

						if (anoMesDataDevolucao > getSistemaParametro().getAnoMesArrecadacao()) {
							devolucao.setAnoMesReferenciaArrecadacao(anoMesDataDevolucao);
						} else {
							devolucao.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
						}

						// ValorDevolucao = ValorItemCobrado
						devolucao.setValorDevolucao(valorItemCobrado);

						// Localidade = Localidade da tabela COBRANCA_DOCUMENTO
						if (cobrancaDocumentoItem[30] != null) {
							Localidade localidade = new Localidade();
							localidade.setId((Integer) cobrancaDocumentoItem[30]);
							devolucao.setLocalidade(localidade);
						}

						// Imovel = Imovel da tabela COBRANCA_DOCUMENTO
						if (cobrancaDocumentoItem[31] != null) {
							Imovel imovel = new Imovel();
							imovel.setId((Integer) cobrancaDocumentoItem[31]);
							devolucao.setImovel(imovel);
						}

						// DebitoTipo = DebitoTipo com o valor
						// correspondente a outros
						DebitoTipo debitoTipo = new DebitoTipo();
						debitoTipo.setId(DebitoTipo.OUTROS);
						devolucao.setDebitoTipo(debitoTipo);

						// CreditoARealizarGeral = CreditoARealizarGeral da
						// tabela COBRANCA_DOCUMENTO_ITEM
						CreditoARealizarGeral creditoARealizarGeral = new CreditoARealizarGeral();
						creditoARealizarGeral.setId((Integer) cobrancaDocumentoItem[29]);
						devolucao.setCreditoARealizarGeral(creditoARealizarGeral);

						// Ultima Alteração
						devolucao.setUltimaAlteracao(new Date());

						CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
						cobrancaDocumento.setId(idCobrancaDocumento);
						devolucao.setCobrancaDocumento(cobrancaDocumento);							
						
						// documento tipo do documento de cobranca
						if(idDocumentoTipo != null){
							DocumentoTipo documentoAgregador = new DocumentoTipo();
							documentoAgregador.setId(idDocumentoTipo);
							devolucao.setDocumentoTipoAgregador(documentoAgregador);
						}
						
						// ADICIONANDO A DEVOLUCAO GERADA NA COLECAO DE RETORNO
						colecaoDevolucoes.add(devolucao);
						
						
					}

				}
				
			} else {
				descricaoOcorrencia = "DOCUMENTO DE COBRANÇA INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}

		} else {
			// atribui o valor 2(NÃO) ao indicador aceitacao
			// registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		pagamentoHelperCodigoBarras.setColecaoDevolucao(colecaoDevolucoes);
		
		
		return pagamentoHelperCodigoBarras;
	}

	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * @author Sávio Luiz, Raphael Rossiter
	 * @date 01/02/2006, 26/05/2008
	 *
	 * @param codigoBarras
	 * @param dataPagamento
	 * @param idFormaPagamento
	 * @param sistemaParametro
	 * @return PagamentoHelperCodigoBarras
	 * @throws ControladorException
	 */
	public PagamentoHelperCodigoBarras processarPagamentosCodigoBarras(
			String codigoBarras, Date dataPagamento, Integer idFormaArrecadacao,
			SistemaParametro sistemaParametro, Usuario usuarioLogado) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";
		
		Collection colecaoPagamentos = new ArrayList();

		/*
		 * Recupera o objeto registroHelperCodigoBarras passando a string do
		 * código de barras.
		 */
		RegistroHelperCodigoBarras registroHelperCodigoBarras = distribuirDadosCodigoBarras(codigoBarras);
		
		BigDecimal valorPagamento = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
		registroHelperCodigoBarras.getValorPagamento());

		// Recupera o ano e o mes da data de pagamento
		Integer anoMesPagamento = Util.recuperaAnoMesDaData(dataPagamento);

		Short identificadorEmpresaCodigoBarras = new Short(
		registroHelperCodigoBarras.getIdEmpresa());

		/*
		 * Caso o identificador da empresa no txt não seja igual ao código da
		 * empresa no sistemas parametro.
		 */
		if (!identificadorEmpresaCodigoBarras.equals(getSistemaParametro()
				.getCodigoEmpresaFebraban())) {

			// Atribui o valor 2(NÃO) ao indicador aceitação registro
			indicadorAceitacaoRegistro = "2";

			descricaoOcorrencia = "CÓDIGO DE BARRAS NÃO PERTENCE A "
			+ getSistemaParametro().getNomeEmpresa();

			// Seta os parametros que serão retornados
			pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
			pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
			pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		} 
		else {

			//Processar Pagamentos com Código de Barras
			pagamentoHelperCodigoBarras = this.processarPagamentosCodigoBarrasPorTipoPagamento(registroHelperCodigoBarras, 
			dataPagamento, anoMesPagamento, valorPagamento, idFormaArrecadacao, getSistemaParametro(), usuarioLogado);
		}

		return pagamentoHelperCodigoBarras;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 26/05/2008
	 *
	 * @param registroHelperCodigoBarras
	 * @param dataPagamento
	 * @param anoMesPagamento
	 * @param valorPagamento
	 * @param idFormaPagamento
	 * @param sistemaParametro
	 * @return PagamentoHelperCodigoBarras
	 * @throws ControladorException
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasPorTipoPagamento(
			RegistroHelperCodigoBarras registroHelperCodigoBarras, Date dataPagamento, Integer anoMesPagamento,
			BigDecimal valorPagamento, Integer idFormaArrecadacao, SistemaParametro sistemaParametro, Usuario usuarioLogado) 
			throws ControladorException {
		
		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
		
		String tipoPagamento = registroHelperCodigoBarras.getTipoPagamento();
	
		if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_COM_IDENTIFICACAO_MATRICULA.toString())){
			
			pagamentoHelperCodigoBarras = this
			.processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoMatricula(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao);

			//===============================================================================================================================
		}
			
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA.toString())){
			
			pagamentoHelperCodigoBarras = this
				.processarPagamentosCodigoBarrasConta(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao);

			//===============================================================================================================================
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO.toString())){
			
			pagamentoHelperCodigoBarras = this
				.processarPagamentosCodigoBarrasGuiaPagamento(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao);

			//===============================================================================================================================
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA.toString())){

			pagamentoHelperCodigoBarras = this
				.processarPagamentosCodigoBarrasDocumentoCobrancaTipo5(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao, usuarioLogado);
			

			//===============================================================================================================================
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_CLIENTE.toString())){
			
			pagamentoHelperCodigoBarras = this
				.processarPagamentosCodigoBarrasGuiaPagamentoCliente(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao);
			
	
			//===============================================================================================================================
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL.toString())){
			
			pagamentoHelperCodigoBarras = this
				.processarPagamentosCodigoBarrasClienteResponsavel(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao);
			
			//===============================================================================================================================
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_NOVO.toString())){
			
			if(registroHelperCodigoBarras.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento4().compareTo(
								DocumentoTipo.EXTRATO_CONTRATO_PARCELAMENTO.toString()) == 0) {
				pagamentoHelperCodigoBarras = this
					.processarPagamentosCodigoBarrasContratoParcelamento(
						registroHelperCodigoBarras, getSistemaParametro(),
						dataPagamento, anoMesPagamento, valorPagamento,
						idFormaArrecadacao, usuarioLogado);
			} else {
				pagamentoHelperCodigoBarras = this
					.processarPagamentosCodigoBarrasDocumentoCobrancaTipo8(
						registroHelperCodigoBarras, getSistemaParametro(),
						dataPagamento, anoMesPagamento, valorPagamento,
						idFormaArrecadacao);
			}
			//===============================================================================================================================			
		}
		
		else if(tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_COM_IDENTIFICACAO_CLIENTE.toString())){
			
			pagamentoHelperCodigoBarras = this
				.processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoCliente(
					registroHelperCodigoBarras, getSistemaParametro(),
					dataPagamento, anoMesPagamento, valorPagamento,
					idFormaArrecadacao);
			
			//===============================================================================================================================			
		}else{
			
			// atribui o valor 2(NÃO) ao indicador aceitacao registro
			Collection colecaoPagamentos = new ArrayList();
			pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
			
			pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
			pagamentoHelperCodigoBarras.setDescricaoOcorrencia("CÓDIGO DE BARRAS COM TIPO DE PAGAMENTO INVÁLIDO");
			pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro("2");
			
			//===============================================================================================================================
		}

		return pagamentoHelperCodigoBarras;
	}

	/**
	 * [UC0259] - Processar Pagamneto com Código de Barras
	 * 
	 * Autor: Rafael Pinto
	 * 
	 * Data: 19/04/2007
	 */
	protected Pagamento processarPagamentosCodigoBarrasTipoFatura(
			Object[] faturaItem, int anoMes, Integer anoMesPagamento,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer idFormaPagamento) throws ControladorException {

		// inicializa as variaveis que veio da pesquisa
		Integer idContaPesquisa = null;
		Integer idImovelPesquisa = null;
		Integer idLocalidadePesquisa = null;
		BigDecimal valorConta = null;
		Integer idFatura = null;
		// verifica o valor da conta
		if (faturaItem[0] != null) {
			valorConta = (BigDecimal) faturaItem[0];
		}
		// verifica o id da conta
		if (faturaItem[1] != null) {
			idContaPesquisa = (Integer) faturaItem[1];
		}
		// verifica o id da localidade
		if (faturaItem[2] != null) {
			idLocalidadePesquisa = (Integer) faturaItem[2];
		}
		// verifica o id do imovel
		if (faturaItem[3] != null) {
			idImovelPesquisa = (Integer) faturaItem[3];
		}
		// verifica o id do imovel
		if (faturaItem[3] != null) {
			idImovelPesquisa = (Integer) faturaItem[3];
		}
		// verifica o id da localidade de Conta
		// Histórico
		if (faturaItem[4] != null) {
			idLocalidadePesquisa = (Integer) faturaItem[4];
		}
		// verifica o id do imovel de Conta Histórico
		if (faturaItem[5] != null) {
			idImovelPesquisa = (Integer) faturaItem[5];
		}
		if (faturaItem[6] != null){
			idFatura = (Integer) faturaItem[6];
		}

		// cria o objeto pagamento para setar os
		// dados
		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(anoMes);
		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		} else {
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
					.getAnoMesArrecadacao());
		}
		pagamento.setValorPagamento(valorConta);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		pagamento.setDebitoTipo(null);
		// verifica se o id da conta é diferente de
		// nulo
		if (idContaPesquisa != null) {
			ContaGeral conta = new ContaGeral();
			conta.setId(idContaPesquisa);
			pagamento.setContaGeral(conta);
		} else {
			pagamento.setContaGeral(null);
		}
		pagamento.setGuiaPagamento(null);

		pagamento.setDebitoACobrarGeral(null);

		// verifica se o id da conta é diferente de
		// nulo
		if (idLocalidadePesquisa != null) {
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidadePesquisa);
			pagamento.setLocalidade(localidade);
		} else {
			pagamento.setLocalidade(null);
		}
		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.CONTA);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if (idImovelPesquisa != null) {
			Imovel imovel = new Imovel();
			imovel.setId(idImovelPesquisa);
			pagamento.setImovel(imovel);
		} else {
			pagamento.setImovel(null);
		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaPagamento);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		Fatura fatura = new Fatura();
		fatura.setId(idFatura);
		pagamento.setFatura(fatura);
		
		pagamento.setCobrancaDocumento(null);

		DocumentoTipo documentoTipoAgregador = new DocumentoTipo();
		documentoTipoAgregador.setId(DocumentoTipo.FATURA_CLIENTE);
		pagamento.setDocumentoTipoAgregador(documentoTipo);		
		
		pagamento.setDataProcessamento(new Date());

		return pagamento;
	}

	

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0005] - Processar
	 * Recebimento de Acréscimos por Inpontualidade Autor: Sávio Luiz
	 * Data:15/02/2006
	 */

	public Pagamento processarRecebimentoAcrescimosImpontualidade(
			Integer idCobrancaDocumento, Date dataPagamento,
			BigDecimal valorDebito, Integer idImovel, Integer idLocalidade,
			SistemaParametro sistemaParametro, Integer idFormaArrecadacao,
			Integer idDocumentoTipo)
			throws ControladorException {

		GuiaPagamento guiaPagamento = new GuiaPagamento();
		guiaPagamento.setValorDebito(valorDebito);
		Imovel imovel = null;
		if (idImovel != null) {
			imovel = new Imovel();
			imovel.setId(idImovel);
		}
		guiaPagamento.setImovel(imovel);
		guiaPagamento.setDataVencimento(dataPagamento);

		Integer idGuiaPagamento = getControladorFaturamento()
				.inserirGuiaPagamentoCodigoBarras(guiaPagamento,
						DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE);
		guiaPagamento.setId(idGuiaPagamento);

		// cria o objeto pagamento para setar os
		// dados
		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(null);

		Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		} else {
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
					.getAnoMesArrecadacao());
		}

		pagamento.setValorPagamento(valorDebito);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		DebitoTipo debitoTipo = new DebitoTipo();
		debitoTipo.setId(DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE);
		pagamento.setDebitoTipo(debitoTipo);
		pagamento.setContaGeral(null);

		pagamento.setGuiaPagamento(guiaPagamento);

		pagamento.setDebitoACobrarGeral(null);

		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if (imovel != null && !imovel.equals("")) {
			pagamento.setImovel(imovel);
			if (idLocalidade != null) {
				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);
			} else {
				pagamento.setLocalidade(null);
			}
		} else {
			pagamento.setImovel(null);

		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaArrecadacao);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		pagamento.setFatura(null);
		
		CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
		cobrancaDocumento.setId(idCobrancaDocumento);
		pagamento.setCobrancaDocumento(cobrancaDocumento);
		
		DocumentoTipo documentoAgregador = new DocumentoTipo();
		documentoAgregador.setId(idDocumentoTipo);
		pagamento.setDocumentoTipoAgregador(documentoAgregador);
		
		pagamento.setDataProcessamento(new Date());
		
		return pagamento;

	}
	
	/**
	 * [UC0259] - Processar Pagamento com código de Barras Por Cliente
	 * [SB0005] - Processar Recebimento de Acréscimos por Inpontualidade 
	 * Autor: Adriana Muniz e Wellington Rocha
	 * Data:23/10/2013
	 */

	public Collection<Pagamento> processarRecebimentoAcrescimosImpontualidadePorCliente(
			Integer idCobrancaDocumento, Date dataPagamento,
			BigDecimal valorDebito, Integer idCliente, Integer idLocalidade,
			SistemaParametro sistemaParametro, Integer idFormaArrecadacao,
			Integer idDocumentoTipo)
			throws ControladorException {
		
		Collection<Pagamento> pagamentos = new ArrayList<Pagamento>();
		
		Map<Integer,BigDecimal> mapLocalidadeValor = new HashMap<Integer,BigDecimal>();
		
		FiltroCobrancaDocumentoItem filtro = new FiltroCobrancaDocumentoItem();
		filtro.adicionarParametro(new ParametroSimples(FiltroCobrancaDocumentoItem.COBRANCA_DOCUMENTO_ID, idCobrancaDocumento));
		filtro.adicionarCaminhoParaCarregamentoEntidade("contaGeral");
		Collection<CobrancaDocumentoItem> itens = getControladorUtil().pesquisar(filtro, CobrancaDocumentoItem.class.getName());

		for(CobrancaDocumentoItem item : itens) {
			if(item.getContaGeral() != null && item.getValorAcrescimos().compareTo(new BigDecimal("0.00")) != 0) {
				if(item.getContaGeral().getIndicadorHistorico() == ConstantesSistema.SIM) {
					FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
					filtroContaHistorico.adicionarParametro(new ParametroSimples(FiltroContaHistorico.ID, item.getContaGeral().getId()));
					filtroContaHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
					idLocalidade = ((ContaHistorico)getControladorUtil().pesquisar(filtroContaHistorico, ContaHistorico.class.getName()).iterator().next()).getLocalidade().getId();
				} else {
					FiltroConta filtroConta = new FiltroConta();
					filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.ID, item.getContaGeral().getId()));
					filtroConta.adicionarCaminhoParaCarregamentoEntidade("localidade");
					idLocalidade = ((Conta)getControladorUtil().pesquisar(filtroConta, Conta.class.getName()).iterator().next()).getLocalidade().getId();
				}

				if(mapLocalidadeValor.containsKey(idLocalidade)){
					BigDecimal valorAcrescimo = mapLocalidadeValor.get(idLocalidade);
					valorAcrescimo = valorAcrescimo.add(item.getValorAcrescimos());

					mapLocalidadeValor.put(idLocalidade, valorAcrescimo);
				}else {
					mapLocalidadeValor.put(idLocalidade, item.getValorAcrescimos());
				}

			}
		}
		
		Cliente cliente = null;
		if (idCliente != null) {
			cliente = new Cliente();
			cliente.setId(idCliente);
		}
		
		Set<Integer> chaves = mapLocalidadeValor.keySet();
		for(Integer chave: chaves) {
			GuiaPagamento guiaPagamento = new GuiaPagamento();
			guiaPagamento.setValorDebito(mapLocalidadeValor.get(chave));

			guiaPagamento.setCliente(cliente);
			guiaPagamento.setDataVencimento(dataPagamento);
			
			Integer idGuiaPagamento = getControladorFaturamento().inserirGuiaPagamentoCodigoBarrasPorCliente(guiaPagamento,
					DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE, idLocalidade);
			guiaPagamento.setId(idGuiaPagamento);

			Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

			// cria o objeto pagamento para setar os
			// dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(anoMesPagamento);

			// caso o ano mes da data de dedito seja
			// maior que o ano mes de arrecadação da
			// tabela sistema parametro então seta o ano
			// mes da data de debito
			if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
			} else {
				// caso contrario seta o o ano mes
				// arrecadação da tabela sistema
				// parametro
				pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
						.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorDebito);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			DebitoTipo debitoTipo = new DebitoTipo();
			debitoTipo.setId(DebitoTipo.ACRESCIMOS_POR_IMPONTUALIDADE);
			pagamento.setDebitoTipo(debitoTipo);
			pagamento.setContaGeral(null);

			pagamento.setGuiaPagamento(guiaPagamento);

			pagamento.setDebitoACobrarGeral(null);

			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
			pagamento.setDocumentoTipo(documentoTipo);

			// seta o id do aviso bancario
			pagamento.setAvisoBancario(null);

			pagamento.setLocalidade(new Localidade(chave));
			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaArrecadacao);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setCliente(null);
			pagamento.setUltimaAlteracao(new Date());

			pagamento.setFatura(null);

			CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
			cobrancaDocumento.setId(idCobrancaDocumento);
			pagamento.setCobrancaDocumento(cobrancaDocumento);

			DocumentoTipo documentoAgregador = new DocumentoTipo();
			documentoAgregador.setId(idDocumentoTipo);
			pagamento.setDocumentoTipoAgregador(documentoAgregador);

			pagamento.setDataProcessamento(new Date());

			pagamentos.add(pagamento);
		}
		return pagamentos;

	}

	protected int obterMesAnoReferencia(int anoMes) {
		int retorno = 0;
		int calculo = 0;

		final int CONSTANTE_REFERENCIA = 457;
		final int CONSTANTE_ANO_MES = 200001;

		calculo = anoMes - CONSTANTE_REFERENCIA;

		Date data = Util.adcionarOuSubtrairMesesAData(null, calculo,
				CONSTANTE_ANO_MES);

		Integer resultadoAnoMes = Util.recuperaAnoMesDaData(data);

		retorno = resultadoAnoMes.intValue();

		return retorno;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0006] - Processar
	 * Desconto Concedido no Documento de Cobrança Autor: Sávio Luiz
	 * Data:15/02/2006
	 */

	public Devolucao processarDescontoConcedidoDocumentoCobranca(
			Integer idCobrancaDocumento, Date dataPagamento,
			BigDecimal valorDebito, Integer idImovel, Integer idLocalidade,
			SistemaParametro sistemaParametro, Integer idFormaArrecadacao, Integer idDocumentoTipo)
			throws ControladorException {

		GuiaDevolucao guiaDevolucao = new GuiaDevolucao();
		if (idLocalidade != null) {
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			guiaDevolucao.setLocalidade(localidade);
		} else {
			guiaDevolucao.setLocalidade(null);
		}
		Imovel imovel = null;
		if (idImovel != null) {
			imovel = new Imovel();
			imovel.setId(idImovel);
		}
		guiaDevolucao.setImovel(imovel);
		guiaDevolucao.setCliente(null);
		guiaDevolucao.setAnoMesReferenciaContabil(getSistemaParametro()
				.getAnoMesArrecadacao());
		guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
		guiaDevolucao.setDataEmissao(new Date());
		guiaDevolucao.setDataValidade(new Date());
		guiaDevolucao.setValorDevolucao(valorDebito);
		guiaDevolucao.setRegistroAtendimento(null);
		guiaDevolucao.setOrdemServico(null);
		Integer idLancamentoItemContabil = null;
		try {

			idLancamentoItemContabil = repositorioArrecadacao
					.pesquisarIdLancamentoItemContabil(CreditoTipo.DESCONTOS_CONCEDIDOS);

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		if (idLancamentoItemContabil != null
				&& !idLancamentoItemContabil.equals("")) {
			LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
			lancamentoItemContabil.setId(idLancamentoItemContabil);
			guiaDevolucao.setLancamentoItemContabil(lancamentoItemContabil);
		}
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
		guiaDevolucao.setDebitoCreditoSituacaoAnterior(null);

		CreditoTipo creditoTipo = new CreditoTipo();
		creditoTipo.setId(CreditoTipo.DESCONTOS_CONCEDIDOS);
		guiaDevolucao.setCreditoTipo(creditoTipo);

		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);
		guiaDevolucao.setDocumentoTipo(documentoTipo);
		guiaDevolucao.setConta(null);
		guiaDevolucao.setGuiaPagamento(null);
		guiaDevolucao.setDebitoACobrarGeral(null);
		DebitoTipo debitoTipo = new DebitoTipo();
		debitoTipo.setId(DebitoTipo.OUTROS);
		guiaDevolucao.setDebitoTipo(debitoTipo);

		guiaDevolucao.setUltimaAlteracao(new Date());


		// cria o objeto pagamento para setar os
		// dados
		Devolucao devolucao = new Devolucao();
		devolucao.setAnoMesReferenciaDevolucao(null);

		Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
			devolucao.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		} else {
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			devolucao.setAnoMesReferenciaArrecadacao(getSistemaParametro()
					.getAnoMesArrecadacao());
		}

		devolucao.setValorDevolucao(valorDebito);
		devolucao.setDataDevolucao(dataPagamento);
		devolucao.setDevolucaoSituacaoAtual(null);
		devolucao.setDevolucaoSituacaoAnterior(null);
		// seta o id do aviso bancario
		devolucao.setAvisoBancario(null);
		devolucao.setDebitoTipo(null);

		devolucao.setGuiaDevolucao(guiaDevolucao);

		if (idLocalidade != null) {
			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			devolucao.setLocalidade(localidade);
		} else {
			devolucao.setLocalidade(null);
		}

		if (idImovel != null) {
			imovel = new Imovel();
			imovel.setId(idImovel);
			devolucao.setImovel(imovel);
		} else {
			devolucao.setImovel(null);
		}
		devolucao.setCliente(null);

		devolucao.setDebitoTipo(debitoTipo);

		devolucao.setUltimaAlteracao(new Date());

		devolucao.setCreditoARealizarGeral(null);
		
		CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
		cobrancaDocumento.setId(idCobrancaDocumento);
		devolucao.setCobrancaDocumento(cobrancaDocumento);
		
		DocumentoTipo documentoAgregador = new DocumentoTipo();
		documentoAgregador.setId(idDocumentoTipo);
		devolucao.setDocumentoTipoAgregador(documentoAgregador);
		
		return devolucao;

	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0007] - Processar
	 * Taxa do Documento de Cobrança Autor: Sávio Luiz Data:15/02/2006
	 */

	public Pagamento processarTaxaDocumentoCobranca(
			Integer idCobrancaDocumento, Date dataPagamento,
			BigDecimal valorTaxa, Integer idImovel, Integer idLocalidade,
			SistemaParametro sistemaParametro, Integer idFormaArrecadacao, Integer idDocumentoTipo)
			throws ControladorException {

		GuiaPagamento guiaPagamento = new GuiaPagamento();
		guiaPagamento.setValorDebito(valorTaxa);
		Imovel imovel = null;
		if (idImovel != null) {
			imovel = new Imovel();
			imovel.setId(idImovel);
		}
		guiaPagamento.setImovel(imovel);
		guiaPagamento.setDataVencimento(dataPagamento);

		Integer idGuiaPagamento = getControladorFaturamento()
				.inserirGuiaPagamentoCodigoBarras(guiaPagamento,
						DebitoTipo.TAXA_COBRANCA);
		guiaPagamento.setId(idGuiaPagamento);

		// cria o objeto pagamento para setar os
		// dados
		Pagamento pagamento = new Pagamento();
		pagamento.setAnoMesReferenciaPagamento(null);

		Integer anoMesPagamento = Util.formataAnoMes(dataPagamento);

		// caso o ano mes da data de dedito seja
		// maior que o ano mes de arrecadação da
		// tabela sistema parametro então seta o ano
		// mes da data de debito
		if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
			pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
		} else {
			// caso contrario seta o o ano mes
			// arrecadação da tabela sistema
			// parametro
			pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
					.getAnoMesArrecadacao());
		}

		pagamento.setValorPagamento(valorTaxa);
		pagamento.setDataPagamento(dataPagamento);
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		DebitoTipo debitoTipo = new DebitoTipo();
		debitoTipo.setId(DebitoTipo.TAXA_COBRANCA);
		pagamento.setDebitoTipo(debitoTipo);
		pagamento.setContaGeral(null);

		pagamento.setGuiaPagamento(guiaPagamento);

		pagamento.setDebitoACobrarGeral(null);

		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
		pagamento.setDocumentoTipo(documentoTipo);

		// seta o id do aviso bancario
		pagamento.setAvisoBancario(null);

		// seta o imovel
		if (imovel != null && !imovel.equals("")) {
			pagamento.setImovel(imovel);
			if (idLocalidade != null) {
				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);
			} else {
				pagamento.setLocalidade(null);
			}
		} else {
			pagamento.setImovel(null);

		}

		pagamento.setArrecadadorMovimentoItem(null);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaArrecadacao);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		pagamento.setCliente(null);
		pagamento.setUltimaAlteracao(new Date());

		pagamento.setFatura(null);
		
		CobrancaDocumento cobrancaDocumento = new CobrancaDocumento();
		cobrancaDocumento.setId(idCobrancaDocumento);
		pagamento.setCobrancaDocumento(cobrancaDocumento);
		
		DocumentoTipo documentoAgregador = new DocumentoTipo();
		documentoAgregador.setId(idDocumentoTipo);
		pagamento.setDocumentoTipoAgregador(documentoAgregador);
		
		pagamento.setDataProcessamento(new Date());
		
		return pagamento;

	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras [SB0008] - Alterar
	 * Vencimento dos Itens do documento de cobrança Autor: Sávio Luiz
	 * Data:15/02/2006
	 */

	public void alterarVencimentoItensDocumentoCobranca(
			Integer idCobrancaDocumento, Date dataEmissao)
			throws ControladorException {
		Collection colecaoContas = null;
		Collection colecaoGuiasPagamentos = null;
		try {
			colecaoContas = repositorioCobranca
					.pesquisarCobrancaDocumentoItemComConta(idCobrancaDocumento);

			// 1.1
			// [UC151] - Alterar Vencimento de Conta
			getControladorFaturamento().alterarVencimentoConta(colecaoContas,
					null, dataEmissao, null);

			// 1.2 - alterar a data de vencimento das guias de pagamento
			colecaoGuiasPagamentos = repositorioCobranca
					.pesquisarCobrancaDocumentoItemComGuiaPagamento(idCobrancaDocumento);

			if (colecaoGuiasPagamentos != null
					&& !colecaoGuiasPagamentos.isEmpty()) {
				repositorioCobranca.atualizarGuiaPagamento(
						colecaoGuiasPagamentos, dataEmissao);
			}

		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}


	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Rafael Corrêa
	 * @date 12/05/2008
	 *
	 * @param codigoBarras
	 * @return RegistroHelperCodigoBarras
	 */
	public RegistroHelperCodigoBarras distribuirDadosCodigoBarrasGeral(
			String codigoBarras) {
		// instancia o objeto de código de barras
		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();
		// seta as subStrings nos respectivos campos do objeto
		// registroHelperCodigoBarras
		registroHelperCodigoBarras.setIdProduto(codigoBarras.substring(0, 1)
				.trim());
		registroHelperCodigoBarras.setIdSegmento(codigoBarras.substring(1, 2)
				.trim());
		registroHelperCodigoBarras.setIdValorReal(codigoBarras.substring(2, 3)
				.trim());
		registroHelperCodigoBarras.setDigitoVerificadorGeral(codigoBarras
				.substring(3, 4).trim());
		
		if (codigoBarras.length() > 44){
			
			//VALOR EFETIVAMENTE ARRECADADO PELO BANCO
			registroHelperCodigoBarras.setValorPagamento(codigoBarras.substring(44, 56).trim());
		}
		else{
			
			//VALOR DO CÓDIGO DE BARRAS
			registroHelperCodigoBarras.setValorPagamento(codigoBarras.substring(4, 15).trim());
		}
		
		
		registroHelperCodigoBarras.setIdEmpresa(codigoBarras.substring(15, 19)
				.trim());
		
		return registroHelperCodigoBarras;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras 
	 *
	 * @author Sávio Luiz, Rafael Corrêa
	 * @date 15/02/2006, 12/05/2008
	 *
	 * @param codigoBarras
	 * @return RegistroHelperCodigoBarras
	 */
	public RegistroHelperCodigoBarras distribuirDadosCodigoBarras(
			String codigoBarras) throws ControladorException {
		
		// instancia o objeto de código de barras, setando os valores que são iguais para todas as empresas
		RegistroHelperCodigoBarras registroHelperCodigoBarras = distribuirDadosCodigoBarrasGeral(codigoBarras);
		
		registroHelperCodigoBarras.setTipoPagamento(codigoBarras.substring(43,
				44).trim());

		// recupera o id pagamento da string
		String idPagamento = codigoBarras.substring(19, 43);
		
		// recupera o tipo pagamento e passa para int
		/*int tipoPagamento = Integer.parseInt(registroHelperCodigoBarras
		.getTipoPagamento().trim());*/
		
		// chama o método distribuirDadosCodigoBarrasPorTipoPagamento para
		// distribuir os dados de acordo com o tipo de pagamento
		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = distribuirDadosCodigoBarrasPorTipoPagamento(
		idPagamento, registroHelperCodigoBarras.getTipoPagamento().trim(), registroHelperCodigoBarras.getIdEmpresa());

		registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);

		return registroHelperCodigoBarras;
	}
	

	/**
	 * retorna o objeto distribuido de acordo comj o tipo de pagamento [UC0264] -
	 * Distribuir Dados do Código de Barras [SF0001] - Distribuir Pagamento de
	 * Conta [SF0002] - Distribuir Pagamento de Guia de Pagamento [SF0003] -
	 * Distribuir Pagamento de Documento de Cobramça [SF0004] - Distribuir
	 * Pagamento de Fatura do Cliente Responsável Autor: Sávio Luiz Data:
	 * 15/02/2006
	 */

	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento(
			String idPagamento, String tipoPagamento, String idEmpresa) throws ControladorException {

		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
		
		/*
		int tipoPagamentoParaComparacao = Integer.parseInt(tipoPagamento.trim());

		switch (tipoPagamentoParaComparacao) {
		//GUIA DE PAGAMENTO COM IDENTIFICACAO
		case 1:

			registroHelperCodigoBarrasTipoPagamento = 
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_COM_IDENTIFICACAO(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;
		//CONTA	
		case 3:

			registroHelperCodigoBarrasTipoPagamento = 
			this.distribuirDadosCodigoBarrasPorTipoPagamento_CONTA(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;

		//GUIA PAGAMENTO - IMOVEL
		case 4:
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_IMOVEL(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;
			
		//DOCUMENTO COBRANCA - EXTRATO DE DEBITO
		case 5:
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_EXTRATO_DEBITO(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;
			
		//GUIA PAGAMENTO - CLIENTE
		case 6:
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_CLIENTE(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;
			
		//FATURA CLIENTE RESPONSÁVEL
		case 7:
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_FATURA_CLIENTE_RESPONSAVEL(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;

		//DOCUMENTO COBRANCA NOVO
		case 8:
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_DOCUMENTO_COBRANCA(registroHelperCodigoBarrasTipoPagamento, idPagamento);
			
			break;
		
		//GUIA DE PAGAMENTO COM IDENTIFICACAO
		case 9:

			registroHelperCodigoBarrasTipoPagamento = 
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_COM_IDENTIFICACAO(registroHelperCodigoBarrasTipoPagamento, idPagamento);
				
			break;
		}
		*/
		
		if(tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_COM_IDENTIFICACAO_MATRICULA.toString()))
			
			registroHelperCodigoBarrasTipoPagamento = 
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_COM_IDENTIFICACAO(registroHelperCodigoBarrasTipoPagamento, idPagamento);	
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA.toString())){
			
			registroHelperCodigoBarrasTipoPagamento = 
			this.distribuirDadosCodigoBarrasPorTipoPagamento_CONTA(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO.toString())){
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_IMOVEL(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA.toString())){
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_EXTRATO_DEBITO(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_CLIENTE.toString())){
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_CLIENTE(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL.toString())){
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_FATURA_CLIENTE_RESPONSAVEL(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		else if (tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA_NOVO.toString())){
			
			registroHelperCodigoBarrasTipoPagamento =
			this.distribuirDadosCodigoBarrasPorTipoPagamento_DOCUMENTO_COBRANCA(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		else if(tipoPagamento.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_COM_IDENTIFICACAO_CLIENTE.toString())){
			
			registroHelperCodigoBarrasTipoPagamento = 
			this.distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_COM_IDENTIFICACAO(registroHelperCodigoBarrasTipoPagamento, idPagamento);
		}
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 06/11/2008
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_CONTA(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		//seta o código da localidade
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3).trim());
		
		/*
		 * Identifica se a matrícula ou o id do cliente foram formatados com 8 ou 9 dígitos
		 * 0 = 8 dígitos
		 * 1 = 9 dígitos
		 */
		String indicadorTamanhoIdentificacao = idPagamento.substring(13, 14).trim();
		
		if (indicadorTamanhoIdentificacao.equals(ConstantesSistema.OITO_DIGITOS)){
			
			//seta a matrícula do imóvel
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11).trim());
			
			// não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 14).trim());
		}
		else{
			
			//seta a matrícula do imóvel
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 12).trim());
			
			// não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(12, 14).trim());
		}
		
		//seta o mês e ano de referência(MMAAAA)
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(14, 20).trim());
		
		// seta o digito verificador da conta no módulo 10
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(20, 21).trim());
		
		// não está sendo utilizado
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento6(idPagamento.substring(21, 24).trim());
		
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 06/11/2008
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_IMOVEL(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		//seta o código da localidade
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3).trim());
		
		/*
		 * Identifica se a matrícula ou o id do cliente foram formatados com 8 ou 9 dígitos
		 * 0 = 8 dígitos
		 * 1 = 9 dígitos
		 */
		String indicadorTamanhoIdentificacao = idPagamento.substring(13, 14).trim();
		
		if (indicadorTamanhoIdentificacao.equals(ConstantesSistema.OITO_DIGITOS)){
			
			//seta a matrícula do imóvel
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11).trim());
			
			// não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 14).trim());
		}
		else{
			
			//seta a matrícula do imóvel
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 12).trim());
			
			// não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(12, 14).trim());
		}
		
		// seta o código do tipo do debito
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(14, 17).trim());
		
		// seta o ano da emissão da guia de pagamento(AAAA)
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(17, 21).trim());
		
		// não está sendo utilizado
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento6(idPagamento.substring(21, 24).trim());
		
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 06/11/2008
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_EXTRATO_DEBITO(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		//seta o código da localidade
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3).trim());
		
		/*
		 * Identifica se a matrícula ou o id do cliente foram formatados com 8 ou 9 dígitos
		 * 0 = 8 dígitos
		 * 1 = 9 dígitos
		 */
		String indicadorTamanhoIdentificacao = idPagamento.substring(23, 24).trim();
		
		if (indicadorTamanhoIdentificacao.equals(ConstantesSistema.OITO_DIGITOS)){
			
			//seta a matrícula do imóvel
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11).trim());
			
			// seta o sequencial do documento de cobrança
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 20).trim());
			
			// seta o código do tipo de documento
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(20, 22).trim());
			
			// não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(22, 24).trim());
		}
		else{
			
			//seta a matrícula do imóvel
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 12).trim());
			
			// seta o sequencial do documento de cobrança
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(12, 21).trim());
			
			// seta o código do tipo de documento
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(21, 23).trim());
			
			// não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento.substring(23, 24).trim());
		}
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 06/11/2008
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_CLIENTE(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		//seta o código da localidade
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento
				.substring(0, 3).trim());
		// seta o id do cliente
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento
				.substring(3, 11).trim());
		// não está sendo utilizado
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento
				.substring(11, 14).trim());
		// seta o código do tipo do debito
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento
				.substring(14, 17).trim());
		// seta o ano da emissão da guia de pagamento(AAAA)
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento
				.substring(17, 21).trim());
		// não está sendo utilizado
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento6(idPagamento
				.substring(21, 24).trim());
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 06/11/2008
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_FATURA_CLIENTE_RESPONSAVEL(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		//seta o código do cliente responsável
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento
				.substring(0, 9).trim());
		// não está sendo utilizado
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento
				.substring(9, 11).trim());
		// seta o mês e ano de referência da conta(MMAAAA)
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento
				.substring(11, 17).trim());
		// seta o digito verificador da conta no módulo 10
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento
				.substring(17, 18).trim());
		// sequencial de fatura do cliente responsável
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento6(idPagamento
				.substring(18, 24).trim());
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 *
	 * @author Raphael Rossiter
	 * @date 06/11/2008
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_DOCUMENTO_COBRANCA(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		//seta o código da localidade
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento
				.substring(0, 3).trim());
		// seta o código do cliente
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento
				.substring(3, 11).trim());
		// seta o sequencial do documento de cobrança
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento
				.substring(11, 20).trim());
		// seta o código do tipo de documento
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento
				.substring(20, 22).trim());
		// não está sendo utilizado
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento5(idPagamento
				.substring(22, 24).trim());
		
		return registroHelperCodigoBarrasTipoPagamento;
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0008] - Gerar
	 * Ocorrência na coleção de Avisos Bancários
	 * 
	 * Autor: Sávio Luiz, Bruno Barros 
	 * Data: 15/02/2006
	 */
	public AvisoBancario gerarOcorrenciaAvisoBancario(Integer idMovimento,
			RegistroHelperCodigoA registroHelperCodigoA,
			Date dataPrevistaCredito, String valorTotalRegistrosArquivo,
			Integer spAnoMesArrecadacao, String codigoBanco,
			BigDecimal valorArrecadacaoInf, BigDecimal valorArrecadacaoCalc,
			BigDecimal valorDevolucaoCalc, BigDecimal valorDevolucaoInf,
			Short numeroSequencialAvisoBancario, Integer idFormaArrecadacao, int indicadorDeAceitacaoDoMovimento,
			String codigoConvenio) throws ControladorException {
		
		AvisoBancario avisoBancario = new AvisoBancario();

		FiltroArrecadador filtro = new FiltroArrecadador();
		filtro.adicionarParametro(new ParametroSimples(FiltroArrecadador.CODIGO_AGENTE, new Integer(registroHelperCodigoA.getCodigoBanco())));
		Collection colArrecadadores = Fachada.getInstancia().pesquisar( filtro, Arrecadador.class.getName() );
		Arrecadador arrecadador = (Arrecadador) colArrecadadores.iterator().next();
		
		avisoBancario.setArrecadador(arrecadador);
		
		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, arrecadador.getId()));
		Collection<ArrecadadorContrato> colecaoArrecadadorContrato = Fachada.getInstancia().pesquisar(filtroArrecadadorContrato, ArrecadadorContrato.class.getName());
		
		ArrecadadorContratoTarifa arrecContratoTarifa = pesquisarArrecadadorContratoTarifa(idFormaArrecadacao, colecaoArrecadadorContrato);
		
		ContaBancaria contaBancaria = new ContaBancaria();
		if(arrecContratoTarifa != null)
			contaBancaria.setId(arrecContratoTarifa.getContaBancariaDepositoArrecadacao().getId());
		avisoBancario.setContaBancaria(contaBancaria);
		
		Date dataLancamento = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA
						.getDataGeracaoArquivo());
		avisoBancario.setDataLancamento(dataLancamento);
		avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
		avisoBancario.setDataPrevista(dataPrevistaCredito);
		avisoBancario.setDataRealizada(dataPrevistaCredito);
		if(indicadorDeAceitacaoDoMovimento==2){
			avisoBancario.setValorRealizado(valorArrecadacaoCalc);
			avisoBancario.setValorArrecadacaoCalculado(new BigDecimal("0.00"));
			/**
			 * @autor Adriana Muniz e Wellington Rocha
			 * @data 04/11/2013
			 * Correção do valor inserido no valor informado
			 * */
			avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
		}else{
			avisoBancario.setValorRealizado(valorArrecadacaoInf);
			avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
			avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalc);
		}
		avisoBancario.setValorDevolucaoCalculado(valorDevolucaoCalc);
		avisoBancario.setValorDevolucaoInformado(valorDevolucaoInf);
		avisoBancario.setValorContabilizado(new BigDecimal("0.00"));
		Integer anoMesDataCredito = Util.recuperaAnoMesDaData(dataPrevistaCredito);
		if (anoMesDataCredito.intValue() > spAnoMesArrecadacao.intValue()) {
			avisoBancario.setAnoMesReferenciaArrecadacao(anoMesDataCredito);
		} else {
			avisoBancario.setAnoMesReferenciaArrecadacao(spAnoMesArrecadacao);
		}
		avisoBancario.setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);
		avisoBancario.setNumeroDocumento(0);
		avisoBancario.setUltimaAlteracao(new Date());
		
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaArrecadacao);
		avisoBancario.setArrecadacaoForma(arrecadacaoForma);
		
		return avisoBancario;
	}

	/**Buscar o arrecadador contrato tarifa pelo id da forma de arrecadação e pelo arrecadador contrato
	 * 
	 * @param idFormaArrecadacao
	 * @param colecaoArrecadadorContrato
	 * @return
	 */
	public ArrecadadorContratoTarifa pesquisarArrecadadorContratoTarifa(Integer idFormaArrecadacao, Collection<ArrecadadorContrato> colecaoArrecadadorContrato) {
		if(!colecaoArrecadadorContrato.isEmpty()) {
			FiltroArrecadadorContratoTarifa filtroArrecadadorContratoTarifa = new FiltroArrecadadorContratoTarifa();
			filtroArrecadadorContratoTarifa.adicionarCaminhoParaCarregamentoEntidade("contaBancariaDepositoArrecadacao");
			filtroArrecadadorContratoTarifa.adicionarParametro(new ParametroSimples(FiltroArrecadadorContratoTarifa.ARRECADACAO_FORMA, idFormaArrecadacao));
			
			if (colecaoArrecadadorContrato.size() == 1) {
				ArrecadadorContrato arrecadadorContrato = (ArrecadadorContrato) colecaoArrecadadorContrato.iterator().next();
				filtroArrecadadorContratoTarifa.adicionarParametro(new ParametroSimples(filtroArrecadadorContratoTarifa.ARRECADADOR_CONTRATO_ID,  arrecadadorContrato.getId()));
				return (ArrecadadorContratoTarifa) 
						(Fachada.getInstancia().pesquisar(filtroArrecadadorContratoTarifa, ArrecadadorContratoTarifa.class.getName())).iterator().next();
			} else {
				for(ArrecadadorContrato arrecContrato : colecaoArrecadadorContrato) {
					filtroArrecadadorContratoTarifa.adicionarParametro(new ParametroSimples(filtroArrecadadorContratoTarifa.ARRECADADOR_CONTRATO_ID,  arrecContrato.getId()));
					return (ArrecadadorContratoTarifa) 
							(Fachada.getInstancia().pesquisar(filtroArrecadadorContratoTarifa, ArrecadadorContratoTarifa.class.getName())).iterator().next();
				}

			}
		}
		return null;
	}

	/**
	 * [UC0235] - Inserir Aviso Bancario Autor: Rhawi Dantas Data: 16/02/2006
	 */

	public Double pesquisarDeducoesAvisoBancario(String codigoAgente,
			Date dataLancamento, String numeroSequencial)
			throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarDeducoesAvisoBancario(
					codigoAgente, dataLancamento, numeroSequencial);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0235] - Inserir Aviso Bancario Autor: Rafael Corrêa Data: 24/03/2006
	 * [FS0003] Verificar existência de avisos bancários não realizados [FS0004]
	 * Verificar seleção de aviso Retorna o valor do maior número sequencial do
	 * arrecadador selecionado
	 */

	public Short pesquisarValorMaximoNumeroSequencial(Date dataLancamento,
			String idArrecadador) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarValorMaximoNumeroSequencial(
					dataLancamento, idArrecadador);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0010] - Gerar o
	 * arquivo de envio para o arrecadador com registros do Movimento Autor:
	 * Sávio Luiz Data: 15/02/2006
	 */
	public void gerarArquivoRegistrosTipoC(
			RegistroHelperCodigoA registroHelperCodigoA,
			RegistroHelperCodigoZ registroHelperCodigoZ,
			Collection colecaoRegistrosC,
			Integer numeroSequencialArquivoEnvioDebitoAutomatico,
			String descricaoOcorrencia, Integer indicadorAceitacaoRegistro,
			String idTipoMovimento) throws ControladorException {
		StringBuilder registrosC = new StringBuilder();
		// cria o header do código C para inserir o movimento arrecadador
		RegistroHelperCodigoA registroHelperHeaderC = new RegistroHelperCodigoA();
		// cria o trailler do código C para inserir o móvimento arrecadador
		RegistroHelperCodigoZ registroHelperTreillerC = new RegistroHelperCodigoZ();

		// inicializa com 1, pois já está contando com a linha do registro A
		int quantidadeRegistros = 1;

		registrosC.append("A");
		registroHelperHeaderC.setCodigoRegistro("A");
		registrosC.append("1");
		registroHelperHeaderC.setCodigoRemessa("1");
		// seta o código do convênio
		registrosC.append(Util.completaString(registroHelperCodigoA
				.getCodigoConvenio(), 20));
		registroHelperHeaderC.setCodigoConvenio(registroHelperCodigoA
				.getCodigoConvenio());
		// seta o nome da empresa
		registrosC.append(Util.completaString(registroHelperCodigoA
				.getNomeEmpresa(), 20));
		registroHelperHeaderC.setNomeEmpresa(registroHelperCodigoA
				.getNomeEmpresa());
		// seta o código do banco
		registrosC.append(Util.adicionarZerosEsquedaNumero(3,
				registroHelperCodigoA.getCodigoBanco()));
		registroHelperHeaderC.setCodigoBanco(registroHelperCodigoA
				.getCodigoBanco());
		// seta o nome do banco
		registrosC.append(Util.completaString(registroHelperCodigoA
				.getNomeBanco(), 20));
		registroHelperHeaderC
				.setNomeBanco(registroHelperCodigoA.getNomeBanco());
		// seta a data corrente
		String dataAtualString = Util.recuperaDataInvertida(new Date());
		registrosC.append(Util.completaString(dataAtualString, 8));
		registroHelperHeaderC.setDataGeracaoArquivo(dataAtualString);

		// seta numero sequencial da tabela Arrecadador_Contrato o campo
		// ARCT_NNNSAENVIODEBAUT + 1
		numeroSequencialArquivoEnvioDebitoAutomatico += 1;
		registrosC.append(Util.adicionarZerosEsquedaNumero(6, ""
				+ numeroSequencialArquivoEnvioDebitoAutomatico));
		registroHelperHeaderC.setNumeroSequencialArquivo(""
				+ numeroSequencialArquivoEnvioDebitoAutomatico);
		// seta a versão de layout
		registrosC.append(Util.adicionarZerosEsquedaNumero(2, ""
				+ registroHelperCodigoA.getVersaoLayout()));
		registroHelperHeaderC.setVersaoLayout(registroHelperCodigoA
				.getVersaoLayout());
		// tipo do movimento
		registrosC.append(Util.completaString(registroHelperCodigoA
				.getTipoMovimento(), 17));
		registroHelperHeaderC.setTipoMovimento(registroHelperCodigoA
				.getTipoMovimento());

		// reservado para o futuro
		registrosC.append(Util.completaString("", 51));
		// reservado para o futuro
		registrosC.append(Util.completaString("*", 1));
		registroHelperHeaderC.setReservadoFuturo(registroHelperCodigoA
				.getReservadoFuturo());

		// parte do treiller criada para inserir no movimento arrecadador
		registroHelperTreillerC.setCodigoRegistro("Z");
		// o total de registros é a quantidade da coleção mais a header e o
		// treiller (1+1)
		registroHelperTreillerC.setTotalRegistrosArquivo(""
				+ (colecaoRegistrosC.size() + 2));

		registroHelperTreillerC.setValorTotalRegistrosArquivo("000");

		ArrecadadorMovimento arrecadadorMovimento = inserirMovimentoArrecadador(
				registroHelperHeaderC, registroHelperTreillerC, idTipoMovimento);

		// pula uma linha
		registrosC.append(System.getProperty("line.separator"));

		Iterator colecaoRegistrosCIterator = colecaoRegistrosC.iterator();
		while (colecaoRegistrosCIterator.hasNext()) {
			// cria uma string builder para pegar linha a linha da coleção
			// inserir o movimento arrecadador e depois inserir na string
			// builder do registrosC
			// para ser mandado para o banco.
			StringBuilder linhaRegistroC = new StringBuilder();
			// incrementa a quantidade de registros para cada registro da
			// coleção
			quantidadeRegistros = quantidadeRegistros + 1;
			// começa a criar a string com o registro do tipo c
			RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) colecaoRegistrosCIterator
					.next();
			linhaRegistroC.append("C");
			// Identificação do cliente na empresa
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC
					.getIdClienteEmpresa(), 25));
			// agencia para debito
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC
					.getAgenciaDebito(), 4));
			// Identificacao cliente banco
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC
					.getIdClienteBanco(), 14));
			// descricao ocorrencia movimento
			linhaRegistroC.append(Util.completaString(registroHelperCodigoC
					.getDescricaoOcorrenciaMovimento(), 40));
			// brancos
			linhaRegistroC.append(Util.completaString("", 40));
			// reservado para o futuro
			linhaRegistroC.append(Util.completaString("", 25));
			// agencia para debito
			linhaRegistroC.append(Util.adicionarZerosEsquedaNumero(1,
					registroHelperCodigoC.getCodigoMovimento()));

			// inseri o item do movimento arrecadador
			inserirItemMovimentoArrecadador(linhaRegistroC.toString(),
					arrecadadorMovimento.getId(), registroHelperCodigoC
							.getDescricaoOcorrenciaMovimento(),
					indicadorAceitacaoRegistro, null);
			registrosC.append(linhaRegistroC);
			registrosC.append(System.getProperty("line.separator"));
		}

		// incrementa a quantidade de registros para registro Z
		quantidadeRegistros = quantidadeRegistros + 1;

		registrosC.append("Z");
		// total de registros do arquivo
		registrosC.append(Util.adicionarZerosEsquedaNumero(6, ""
				+ quantidadeRegistros));
		// valor zero
		registrosC.append(Util.adicionarZerosEsquedaNumero(17, ""));
		// reservado para o futuro
		registrosC.append(Util.completaString("", 125));
		// reservado para o futuro
		registrosC.append(Util.completaString("*", 1));
		registrosC.append(System.getProperty("line.separator"));
		registrosC.append("\u0004");

		EnvioEmail envioEmail = getControladorCadastro().pesquisarEnvioEmail(
				EnvioEmail.REGISTRAR_MOVIMENTO_ARRECADADORES);

		String emailRemetente = envioEmail.getEmailRemetente();
		String tituloMensagem = envioEmail.getTituloMensagem();
		String corpoMensagem = envioEmail.getCorpoMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		mandaArquivoLeituraEmail(registrosC, emailReceptor, emailRemetente,
				tituloMensagem, corpoMensagem,numeroSequencialArquivoEnvioDebitoAutomatico);

	}

	protected void mandaArquivoLeituraEmail(StringBuilder arquivo,
			String emailReceptor, String emailRemetente, String tituloMensagem,
			String corpoMensagem,Integer numeroSequencialArquivoEnvioDebitoAutomatico) throws ControladorException {
		
		BufferedWriter out = null; 
		ZipOutputStream zos = null;
		try {
			
			String nomeZip = "registrar_movimento_arrecadador_retorno_sequencial_"+numeroSequencialArquivoEnvioDebitoAutomatico;
			
			File leitura = new File("gcom.txt");
			File compactado = new File(nomeZip + ".zip"); // nomeZip
			zos = new ZipOutputStream(new FileOutputStream(
					compactado));
			out = new BufferedWriter(new OutputStreamWriter(
					new FileOutputStream(leitura.getAbsolutePath())));
			out.write(arquivo.toString());
			out.flush();
			
			ZipUtil.adicionarArquivo(zos, leitura);
			
			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
					emailRemetente, tituloMensagem, corpoMensagem, leitura);
			leitura.delete();

		} catch (SendFailedException e) {
			throw new ControladorException("erro.sistema", e);
		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		} finally{
			IoUtil.fecharStream(out);
			IoUtil.fecharStream(zos);
		}
	}

	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores [SF0002] - Inserir o
	 * movimento do arrecadador Autor: Sávio Luiz Data: 31/01/2006
	 */

	public ArrecadadorMovimento inserirMovimentoArrecadador(
			RegistroHelperCodigoA registroHelperCodigoA,
			RegistroHelperCodigoZ registroHelperCodigoZ, String idTipoMovimento)
			throws ControladorException {

		Integer idMovimento = null;
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		// cria o objeto de arrecadador movimento para a inserção
		arrecadadorMovimento.setCodigoRemessa(new Short(registroHelperCodigoA
				.getCodigoRemessa()));
		arrecadadorMovimento.setCodigoConvenio(registroHelperCodigoA
				.getCodigoConvenio().trim());
		arrecadadorMovimento.setNomeEmpresa(registroHelperCodigoA
				.getNomeEmpresa().trim());
		arrecadadorMovimento.setCodigoBanco(new Short(registroHelperCodigoA
				.getCodigoBanco().trim()));
		arrecadadorMovimento.setNomeBanco(registroHelperCodigoA.getNomeBanco()
				.trim());
		Date dataGeracao = Util
				.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA
						.getDataGeracaoArquivo().trim());
		arrecadadorMovimento.setDataGeracao(dataGeracao);
		arrecadadorMovimento.setNumeroSequencialArquivo(new Integer(
				registroHelperCodigoA.getNumeroSequencialArquivo().trim()));
		arrecadadorMovimento.setNumeroVersaoLayout(new Integer(
				registroHelperCodigoA.getVersaoLayout().trim()));
		arrecadadorMovimento.setDescricaoIdentificacaoServico(idTipoMovimento
				.trim());
		arrecadadorMovimento.setNumeroRegistrosMovimento(new Integer(
				registroHelperCodigoZ.getTotalRegistrosArquivo().trim()));
		BigDecimal valorTotalRegistros = Util
				.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoZ
						.getValorTotalRegistrosArquivo().trim());
		arrecadadorMovimento.setValorTotalMovimento(valorTotalRegistros);
		arrecadadorMovimento.setUltimaAlteracao(new Date());

		try {
			idMovimento = (Integer) repositorioUtil
					.inserir(arrecadadorMovimento);
			arrecadadorMovimento.setId(idMovimento);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}
		return arrecadadorMovimento;
	}

	/**
	 * Este caso de uso cria um filtro do movimento dos arrecadadores
	 * 
	 * [UC0263] - Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Raphael Rossiter
	 * @date 23/02/2006
	 * 
	 * @param filtroArrecadadorMovimento
	 * @param movimentoOcorrencia
	 * @param movimentoAceito
	 * @param movimentoAbertoFechado
	 * @return Uma coleçao com os movimentos selecionados
	 * @throws ControladorException
	 */
	public FiltroArrecadadorMovimento filtrarMovimentoArrecadadores(
			FiltroArrecadadorMovimento filtroArrecadadorMovimento,
			String movimentoOcorrencia, String movimentoAceito,
			String movimentoAbertoFechado) throws ControladorException {

		Collection<ArrecadadorMovimento> retorno = new ArrayList();
		Collection<ArrecadadorMovimento> colecaoMovimentoArrecadadoresTotal = null;

		/*
		 * Movimento com/sem ítens em ocorrência
		 * 
		 * Caso seja selecionado "COM ÍTENS EM OCORRÊNCIA" selecionar os
		 * movimentos que tenham algum ítem em ocorrência (a partir da tabela
		 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_DSOCORRENCIA diferente de "OK"),
		 * caso seja selecionado "SEM ITENS EM OCORÊNCIA" selecionar os
		 * movimentos que não tenham itens em ocorrência (a partir da tabela
		 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_DSOCORRENCIA igual a "OK")
		 */
		if (movimentoOcorrencia != null
				&& !movimentoOcorrencia.equalsIgnoreCase("")
				&& !movimentoOcorrencia.equalsIgnoreCase(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			if (movimentoOcorrencia.equalsIgnoreCase(""
					+ ConstantesSistema.COM_ITENS)) {

				filtroArrecadadorMovimento
						.adicionarParametro(new ParametroSimplesColecaoDiferenteDe(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_DESCRICAO_OCORRENCIA,
								"OK"));
			} else {

				filtroArrecadadorMovimento
						.adicionarParametro(new ParametroSimplesColecao(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_DESCRICAO_OCORRENCIA,
								"OK"));
			}
		}

		/*
		 * Movimento com/sem ítens que não foram aceitos
		 * 
		 * Caso seja selecionado "COM ITENS NÃO ACEITOS" selecionar os
		 * movimentos que tenham algum item não aceito (a partir da tabela
		 * ARRECADADOR_MOVIMENTO_ITEM com AMIT_ICACEITACAO igual de 2 (NÃO)),
		 * caso seja selecionado os movimentos em que todos os itens tenha sido
		 * aceitos (a partir da tabela ARRECADADOR_MOVIMENTO_ITEM com
		 * AMIT_ICACEITACAO igual de 1 (SIM))
		 */
		if (movimentoAceito != null
				&& !movimentoAceito.equalsIgnoreCase("")
				&& !movimentoAceito.equalsIgnoreCase(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			if (movimentoAceito.equalsIgnoreCase(""
					+ ConstantesSistema.COM_ITENS)) {

				filtroArrecadadorMovimento
						.adicionarParametro(new ParametroSimplesColecao(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_INDICADOR_ACEITACAO,
								ConstantesSistema.COM_ITENS));
			} else {

				filtroArrecadadorMovimento
						.adicionarParametro(new ParametroSimplesColecao(
								FiltroArrecadadorMovimento.ARRECADADOR_MOVIMENTO_ITEM_INDICADOR_ACEITACAO,
								ConstantesSistema.SEM_ITENS));
			}
		}

		/*
		 * Coleção com os movimentos abertos e fechados
		 */
		try {

			colecaoMovimentoArrecadadoresTotal = repositorioArrecadacao
					.filtrarMovimentoArrecadadores(filtroArrecadadorMovimento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Movimento aberto / fechado
		 * 
		 * Caso seja selecionado "ABERTOS", selecionar os movimentos com valor
		 * total diferente do valor da soma das arrecadações dos avisos
		 * bancários relacionados (ARMV_VLTOTALMOVIMENTO seja diferente da soma
		 * dos AVBC_VLARRECADACAO da tabela AVISO_BANCARIO com ARMV_ID = ARMV_ID
		 * da tabela ARRECADADOR_MOVIMENTO), caso seja selecionado "FECHADOS",
		 * selecionar os movimentos com valor total igual ao valor da soma das
		 * arrecadações dos avisos bancários relacionados (ARMV_VLTOTALMOVIMENTO
		 * seja igual da soma dos AVBC_VLARRECADACAO da tabela AVISO_BANCARIO
		 * com ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO)
		 */
		if (movimentoAbertoFechado != null
				&& !movimentoAbertoFechado.equalsIgnoreCase("")
				&& !movimentoAbertoFechado.equalsIgnoreCase(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			Iterator iteratorMovimentoArrecadadoresTotal = colecaoMovimentoArrecadadoresTotal
					.iterator();
			ArrecadadorMovimento arrecadadorMovimentoObjeto = null;
			BigDecimal valorTotalArrecadacaoAvisoBancario = null;

			while (iteratorMovimentoArrecadadoresTotal.hasNext()) {

				arrecadadorMovimentoObjeto = (ArrecadadorMovimento) iteratorMovimentoArrecadadoresTotal
						.next();
				valorTotalArrecadacaoAvisoBancario = null;

				/*
				 * Obtendo o valor total (AVBC_VLARRECADACAO) na tabela
				 * AVISO_BANCARIO para um determinado ARRECADADOR_MOVIMENTO
				 */
				try {

					valorTotalArrecadacaoAvisoBancario = repositorioArrecadacao
							.obterTotalArrecadacaoAvisoBancarioPorMovimentoArrecadadores(arrecadadorMovimentoObjeto);

				} catch (ErroRepositorioException ex) {
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				/*
				 * Selecionar os movimentos com valor total diferente do valor
				 * da soma das arrecadações dos avisos bancários relacionados
				 */
				if (movimentoAbertoFechado.equalsIgnoreCase(""
						+ ConstantesSistema.MOVIMENTO_ABERTO)) {

					if ((valorTotalArrecadacaoAvisoBancario == null || arrecadadorMovimentoObjeto
							.getValorTotalMovimento() == null)) {

						retorno.add(arrecadadorMovimentoObjeto);
					} else if (!arrecadadorMovimentoObjeto
							.getValorTotalMovimento().equals(
									valorTotalArrecadacaoAvisoBancario)) {

						retorno.add(arrecadadorMovimentoObjeto);
					}
				}
				/*
				 * Selecionar os movimentos com valor total igual ao valor da
				 * soma das arrecadações dos avisos bancários relacionados
				 */
				else if (movimentoAbertoFechado.equalsIgnoreCase(""
						+ ConstantesSistema.MOVIMENTO_FECHADO)
						&& (valorTotalArrecadacaoAvisoBancario != null && arrecadadorMovimentoObjeto
								.getValorTotalMovimento() != null)
						&& (arrecadadorMovimentoObjeto.getValorTotalMovimento()
								.equals(valorTotalArrecadacaoAvisoBancario))) {

					retorno.add(arrecadadorMovimentoObjeto);
				}
			}

		} else {

			retorno.addAll(colecaoMovimentoArrecadadoresTotal);
		}

		// [FS0005] - Nenhum registro encontrado
		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return filtroArrecadadorMovimento;
	}

	/**
	 * Obtém o número de registros em ocorrência de um determinado movimento
	 * (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com ARMV_ID =
	 * ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_DSOCORRENCIA diferente de
	 * "OK")
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Um integer que representa a quantidade de registros selecionados
	 * @throws ControladorException
	 */
	public Integer obterNumeroRegistrosEmOcorrenciaPorMovimentoArrecadadores(
			ArrecadadorMovimento arrecadadorMovimento,
			String descricaoOcorrencia) throws ControladorException {

		Integer retorno = new Integer(0);

		try {

			retorno = repositorioArrecadacao
					.obterNumeroRegistrosEmOcorrenciaPorMovimentoArrecadadores(
							arrecadadorMovimento, descricaoOcorrencia);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Obtém o número de registros que não foram aceitos de um determinado
	 * movimento (número de linhas da tabela ARRECADADOR_MOVIMENTO_ITEM com
	 * ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO e AMIT_ICACEITACAO
	 * igual a 2 (NÃO))
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Um integer que representa a quantidade de registros selecionados
	 * @throws ControladorException
	 */
	public Integer obterNumeroRegistrosNaoAceitosPorMovimentoArrecadadores(
			ArrecadadorMovimento arrecadadorMovimento, Short indicadorAceitacao)
			throws ControladorException {

		Integer retorno = new Integer(0);

		try {

			retorno = repositorioArrecadacao
					.obterNumeroRegistrosNaoAceitosPorMovimentoArrecadadores(
							arrecadadorMovimento, indicadorAceitacao);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Obtém o valor total dos avisos bancários de um determinado movimento
	 * (Total da soma do campo AVBC_VALORARRECADACAO da tabela AVISO_BANCARIO
	 * com ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Um BigDecimal que representa o total da soma dos avisos bancários
	 * @throws ControladorException
	 */
	public BigDecimal obterTotalArrecadacaoAvisoBancarioPorMovimentoArrecadadores(
			ArrecadadorMovimento arrecadadorMovimento)
			throws ControladorException {

		BigDecimal retorno = new BigDecimal(0);

		try {

			retorno = repositorioArrecadacao
					.obterTotalArrecadacaoAvisoBancarioPorMovimentoArrecadadores(arrecadadorMovimento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Caso o valor total do movimento (ARMV_VALORTOTALMOVIMENTO) seja diferente
	 * do valor da soma das arrecadações dos avisos bancários relacionados
	 * (ARMV_ID = ARMV_ID da tabela AVISO_BANCARIO e o campo para totalização
	 * será AVBC_VLARRECADACAO), a situação do movimento será "ABERTO". Caso
	 * contrário a situação do movimento será "FECHADO"
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Uma String que representa a situação do movimento
	 * @throws ControladorException
	 */
	public String obterSituacaoArrecadadorMovimento(
			ArrecadadorMovimento arrecadadorMovimento)
			throws ControladorException {

		String retorno = ConstantesSistema.FECHADO;
		BigDecimal valorTotalArrecadacaoAvisoBancario = null;
		Collection colecaoDiferencaArrecadadorMovimento = null;
		BigDecimal valorSomatorioAcertosArrecadacao = new BigDecimal("0.00");
		BigDecimal valorSomatorioAcertosDevolucao = new BigDecimal("0.00");

		/*
		 * Obtendo o valor total (AVBC_VLARRECADACAO) na tabela AVISO_BANCARIO
		 * para um determinado ARRECADADOR_MOVIMENTO
		 */
		try {

			valorTotalArrecadacaoAvisoBancario = repositorioArrecadacao
					.obterTotalArrecadacaoAvisoBancarioPorMovimentoArrecadadores(arrecadadorMovimento);
			colecaoDiferencaArrecadadorMovimento = repositorioArrecadacao
					.pesquisarValorAcertosArrecadadorMovimento(arrecadadorMovimento.getId());
			

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		if (colecaoDiferencaArrecadadorMovimento != null && !colecaoDiferencaArrecadadorMovimento.isEmpty()) {
			
			Object[] objetoDiferencaArrecadadorMovimento = (Object[]) Util.retonarObjetoDeColecao(colecaoDiferencaArrecadadorMovimento);
			
			// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
			// = 1
			// e AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela
			// AVISO_BANCARIO
			BigDecimal valorSomatorioAcertoCreditoArrecadacao = new BigDecimal(
					"0.00");
			// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
			// = 2
			// e AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela
			// AVISO_BANCARIO
			BigDecimal valorSomatorioAcertoDebitoArrecadacao = new BigDecimal(
					"0.00");
			// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
			// = 1
			// e AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela
			// AVISO_BANCARIO
			BigDecimal valorSomatorioAcertoCreditoDevolucao = new BigDecimal("0.00");
			// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
			// = 2
			// e AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela
			// AVISO_BANCARIO
			BigDecimal valorSomatorioAcertoDebitoDevolucao = new BigDecimal("0.00");
	
			if (objetoDiferencaArrecadadorMovimento[0] != null) {
				valorSomatorioAcertoCreditoArrecadacao = (BigDecimal) objetoDiferencaArrecadadorMovimento[0];
			}
			if (objetoDiferencaArrecadadorMovimento[1] != null) {
				valorSomatorioAcertoDebitoArrecadacao = (BigDecimal) objetoDiferencaArrecadadorMovimento[1];
			}
			if (objetoDiferencaArrecadadorMovimento[2] != null) {
				valorSomatorioAcertoCreditoDevolucao = (BigDecimal) objetoDiferencaArrecadadorMovimento[2];
			}
			if (objetoDiferencaArrecadadorMovimento[3] != null) {
				valorSomatorioAcertoDebitoDevolucao = (BigDecimal) objetoDiferencaArrecadadorMovimento[3];
			}
	
			valorSomatorioAcertosArrecadacao = valorSomatorioAcertoCreditoArrecadacao
												.subtract(valorSomatorioAcertoDebitoArrecadacao);
			
			valorSomatorioAcertosDevolucao = valorSomatorioAcertoCreditoDevolucao
												.subtract(valorSomatorioAcertoDebitoDevolucao);
		}	
		
		BigDecimal valorMovimentoComAcerto = arrecadadorMovimento.getValorTotalMovimento();
		
		if(valorMovimentoComAcerto != null){
			valorMovimentoComAcerto = valorMovimentoComAcerto.add(valorSomatorioAcertosArrecadacao.subtract(valorSomatorioAcertosDevolucao));
		}
		
		if ((valorTotalArrecadacaoAvisoBancario == null || arrecadadorMovimento
				.getValorTotalMovimento() == null)) {

			retorno = ConstantesSistema.ABERTO;
		} else if (!valorMovimentoComAcerto.equals(
				valorTotalArrecadacaoAvisoBancario)) {

			retorno = ConstantesSistema.ABERTO;
		}

		return retorno;
	}

	/**
	 * Lista os avisos bancários associados ao movimento com os seguintes dados:
	 * Data do Lançamento Sequencial do Aviso Tipo do Aviso Data do Crédito
	 * Valor do Crédito Valor da Arrecadação Valor Total dos pagamentos
	 * associados ao aviso Situação do Aviso
	 * 
	 * @author Raphael Rossiter
	 * @date 08/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Uma Collection<AvisoBancarioHelper> que representa a os avisos
	 *         bancários selecionados
	 * @throws ControladorException
	 */
	public Collection<AvisoBancarioHelper> obterColecaoAvisosBancariosPorArrecadadorMovimento(
			ArrecadadorMovimento arrecadadorMovimento)
			throws ControladorException {

		Collection<AvisoBancarioHelper> retorno = new ArrayList();
		Collection<AvisoBancario> colecaoAvisosBancarios = null;
		AvisoBancario avisoBancario = null;
		AvisoBancarioHelper avisoBancarioHelper = null;

		/*
		 * Seleciona os avisos bancários de um determinado movimento
		 */
		try {

			colecaoAvisosBancarios = repositorioArrecadacao
					.obterAvisosBancariosPorArrecadadorMovimento(arrecadadorMovimento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoAvisosBancarios != null && !colecaoAvisosBancarios.isEmpty()) {

			Iterator iteratorColecaoAvisosBancarios = colecaoAvisosBancarios
					.iterator();
			BigDecimal valorTotalPagamentos = null;

			while (iteratorColecaoAvisosBancarios.hasNext()) {

				avisoBancario = (AvisoBancario) iteratorColecaoAvisosBancarios
						.next();

				avisoBancarioHelper = new AvisoBancarioHelper();

				avisoBancarioHelper.setIdAvisoBancario(avisoBancario.getId());

				if (avisoBancario.getDataLancamento() != null) {
					avisoBancarioHelper.setDataLancamento(avisoBancario
							.getDataLancamento());
				}

				if (avisoBancario.getNumeroSequencial() != null) {
					avisoBancarioHelper.setNumeroSequencial(avisoBancario
							.getNumeroSequencial());
				}

				// CRÉDITO = 1 DÉBITO = 2
				if (avisoBancario.getIndicadorCreditoDebito() != null) {

					if (avisoBancario.getIndicadorCreditoDebito().equals(
							AvisoBancario.INDICADOR_CREDITO)) {
						avisoBancarioHelper
								.setDescricaoIndicadorCreditoDebito(AvisoBancario.SIGLA_CREDITO);
					} else {
						avisoBancarioHelper
								.setDescricaoIndicadorCreditoDebito(AvisoBancario.SIGLA_DEBITO);
					}
				}

				if (avisoBancario.getDataRealizada() != null) {
					avisoBancarioHelper.setDataRealizada(avisoBancario
							.getDataRealizada());
				}

				if (avisoBancario.getValorRealizado() != null) {
					avisoBancarioHelper.setValorRealizado(avisoBancario
							.getValorRealizado());
				}

				if (avisoBancario.getValorArrecadacaoCalculado() != null) {
					avisoBancarioHelper.setValorArrecadacao(avisoBancario
							.getValorArrecadacaoCalculado());
				}

				/*
				 * Calcula o valor total dos pagamentos associados a um
				 * determinado aviso bancário
				 */
				try {

					valorTotalPagamentos = repositorioArrecadacao
							.obterTotalPagamentoPorAvisoBancario(avisoBancario);

				} catch (ErroRepositorioException ex) {
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				avisoBancarioHelper
						.setValorTotalPagamento(valorTotalPagamentos);

				String situacaoAviso = this
						.obterSituacaoAvisoBancario(avisoBancario);
				avisoBancarioHelper.setSituacao(situacaoAviso);

				retorno.add(avisoBancarioHelper);
			}
		}

		return retorno;
	}

	/**
	 * Caso o valor total dos pagamentos seja igual ao valor da arrecadação
	 * (AVBC_VLARRECADACAO) e o valor total das devoluções seja igual ao valor
	 * da devolução (AVBC_VLDEVOLUCAO) a situação será "FECHADO"; Caso contrário
	 * será "ABERTO"
	 * 
	 * @author Raphael Rossiter
	 * @date 09/03/2006
	 * 
	 * @param avisoBancario
	 * @return Uma String que representa a situação do aviso
	 * @throws ControladorException
	 */
	public String obterSituacaoAvisoBancarioParaArrecadadorMovimento(
			AvisoBancario avisoBancario) throws ControladorException {

		String retorno = ConstantesSistema.FECHADO;
		BigDecimal valorTotalPagamentos = null;
		BigDecimal valorTotalDevolucoes = null;

		/*
		 * Calcula o valor total dos pagamentos associados a um determinado
		 * aviso bancário
		 */
		try {

			valorTotalPagamentos = repositorioArrecadacao
					.obterTotalPagamentoPorAvisoBancario(avisoBancario);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Calcula o valor total das devoluções associados a um determinado
		 * aviso bancário
		 */
		try {

			valorTotalDevolucoes = repositorioArrecadacao
					.obterTotalDevolucaoPorAvisoBancario(avisoBancario);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if (valorTotalPagamentos == null
				|| avisoBancario.getValorArrecadacaoCalculado() == null) {

			retorno = ConstantesSistema.ABERTO;

		} else if (valorTotalDevolucoes == null
				|| avisoBancario.getValorDevolucaoCalculado() == null) {

			retorno = ConstantesSistema.ABERTO;
		} else if (!valorTotalPagamentos.equals(avisoBancario
				.getValorArrecadacaoCalculado())
				|| !valorTotalDevolucoes.equals(avisoBancario
						.getValorDevolucaoCalculado())) {

			retorno = ConstantesSistema.ABERTO;
		}

		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * 
	 * O sistema seleciona os itens do movimento do arrecadador com os seguintes
	 * dados: 1 - Código do Registro 2 - Identificação do Imóvel/Cliente 3 -
	 * Ocorrência 4 - Indicador de Aceitação 5 - Descrição do Indicador de
	 * Aceitação
	 * 
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter
	 * @data 20/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItemHelper>
	 */
	public Collection<ArrecadadorMovimentoItemHelper> consultarItensMovimentoArrecadador(
			ArrecadadorMovimento arrecadadorMovimento, Integer idImovel,
			Short indicadorAceitacao, String descricaoOcorrencia)
			throws ControladorException {

		Collection<ArrecadadorMovimentoItemHelper> retorno = new ArrayList();
		Collection<ArrecadadorMovimentoItem> colecaoArrecadadorMovimentoItens = null;
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = null;
		ArrecadadorMovimentoItemHelper arrecadadorMovimentoItemHelper = null;

		/*
		 * Seleciona os itens de um determinado movimento
		 */
		try {

			colecaoArrecadadorMovimentoItens = repositorioArrecadacao
					.consultarItensMovimentoArrecadador(arrecadadorMovimento,
							idImovel, indicadorAceitacao, descricaoOcorrencia);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoArrecadadorMovimentoItens != null
				&& !colecaoArrecadadorMovimentoItens.isEmpty()) {

			Iterator iteratorColecaoArrecadadorMovimentoItens = colecaoArrecadadorMovimentoItens
					.iterator();

			while (iteratorColecaoArrecadadorMovimentoItens.hasNext()) {

				arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) iteratorColecaoArrecadadorMovimentoItens
						.next();

				arrecadadorMovimentoItemHelper = new ArrecadadorMovimentoItemHelper();

				arrecadadorMovimentoItemHelper.setId(arrecadadorMovimentoItem.getId());

				if(arrecadadorMovimentoItem.getImovel() != null && 
					arrecadadorMovimentoItem.getImovel().getId() != null){
					
					arrecadadorMovimentoItemHelper.setMatriculaImovel(""+arrecadadorMovimentoItem.getImovel().getId());
				}
				
				/*
				 * (RGCD_CDREGISTROCODIGO da tabela REGISTRO_CODIGO com RGCD_ID =
				 * RGCD_ID da tabela ARRECADADOR_MOVIMENTO_ITEM)
				 */
				if (arrecadadorMovimentoItem.getRegistroCodigo() != null) {
					arrecadadorMovimentoItemHelper
							.setCodigoRegistro(arrecadadorMovimentoItem
									.getRegistroCodigo().getCodigo());
				}

				/*
				 * Caso o código do registro corresponda a "B", "C", "E" ou "F",
				 * exibir a identificação do cliente na empresa retornada pelo
				 * [UC0262]
				 */
				if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_B)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoB
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoB(registroHelperCodigoB);
				} else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_C)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoC
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoC(registroHelperCodigoC);

				} else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_E)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoE registroHelperCodigoE = (RegistroHelperCodigoE) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoE
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoE(registroHelperCodigoE);

				} else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_F)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoF
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoF(registroHelperCodigoF);

					int tamanho = registroHelperCodigoF.getValorDebito()
							.length();

					String valorDebito = registroHelperCodigoF.getValorDebito()
							.substring(0, (tamanho - 2))
							+ "."
							+ registroHelperCodigoF.getValorDebito().substring(
									(tamanho - 2), tamanho);

					arrecadadorMovimentoItemHelper.setVlMovimento(Util
							.formatarMoedaReal(new BigDecimal(valorDebito)));
				}

				/*
				 * Caso o código do registro corresponda a "G"
				 * 
				 * Distribui os dados do código de barras [UC0264] - Distribuir
				 * Dados co Código de Barras passando o código de barras
				 * retornado pelo [UC0262]- Distribuir Dados do Registro de
				 * Movimento do Arrecadador.
				 * 
				 * Exibir o tipo de pagamento retornado pelo [UC0262] -
				 * Distribuir Dados co Código de Barras
				 */
				else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_G)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoG(registroHelperCodigoG);

					int tamanho = registroHelperCodigoG.getValorRecebido()
							.length();

					String valorRecebido = registroHelperCodigoG
							.getValorRecebido().substring(0, (tamanho - 2))
							+ "."
							+ registroHelperCodigoG.getValorRecebido()
									.substring((tamanho - 2), tamanho);

					arrecadadorMovimentoItemHelper.setVlMovimento(Util
							.formatarMoedaReal(new BigDecimal(valorRecebido)));
					
					/*
					 * Caso o tipo de pagamento corresponda a: Conta (valor =
					 * 3), Guia de Pagamento (valor = 4) ou Documento de
					 * Cobrança (valor = 5), exibir a matrícula do imóvel
					 * retornada pelo [UC0264]
					 */
					
					
					if (registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getTipoPagamento()
							.equals(
									String
											.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA))) {

						arrecadadorMovimentoItemHelper
								.setIdentificacao(registroHelperCodigoG
										.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento()
										.getIdPagamento2());

						arrecadadorMovimentoItemHelper
								.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);

					} else if (registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getTipoPagamento()
							.equals(
									String
											.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO))) {

						arrecadadorMovimentoItemHelper
								.setIdentificacao(registroHelperCodigoG
										.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento()
										.getIdPagamento2());
						arrecadadorMovimentoItemHelper
								.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
					} else if (registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getTipoPagamento()
							.equals(
									String
											.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA))) {

						arrecadadorMovimentoItemHelper
								.setIdentificacao(registroHelperCodigoG
										.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento()
										.getIdPagamento2());
						arrecadadorMovimentoItemHelper
								.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
					} else if (registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getTipoPagamento()
							.equals(
									String
											.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL))) {

						arrecadadorMovimentoItemHelper
								.setIdentificacao(registroHelperCodigoG
										.getRegistroHelperCodigoBarras()
										.getRegistroHelperCodigoBarrasTipoPagamento()
										.getIdPagamento2());
						arrecadadorMovimentoItemHelper
								.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);
					}

				}

				// (AMIT_DSOCORRENCIA)
				if (arrecadadorMovimentoItem.getDescricaoOcorrencia() != null) {
					arrecadadorMovimentoItemHelper
							.setOcorrencia(arrecadadorMovimentoItem
									.getDescricaoOcorrencia());
				}

				if (arrecadadorMovimentoItem.getIndicadorAceitacao() != null
						&& arrecadadorMovimentoItem
								.getIndicadorAceitacao()
								.equals(
										ArrecadadorMovimentoItem.INDICADOR_ACEITO)) {

					arrecadadorMovimentoItemHelper
							.setIndicadorAceitacao(arrecadadorMovimentoItem
									.getIndicadorAceitacao());

					// Colocado a pedido de Rosana em 08/04/2006
					if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
							&& !arrecadadorMovimentoItemHelper
									.getCodigoRegistro().equals(
											RegistroCodigo.CODIGO_C)) {

						arrecadadorMovimentoItemHelper
								.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
					}

				} else {

					arrecadadorMovimentoItemHelper
							.setIndicadorAceitacao(arrecadadorMovimentoItem
									.getIndicadorAceitacao());

					// Colocado a pedido de Rosana em 08/04/2006
					if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
							&& !arrecadadorMovimentoItemHelper
									.getCodigoRegistro().equals(
											RegistroCodigo.CODIGO_C)) {

						arrecadadorMovimentoItemHelper
								.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
					}

				}

				BigDecimal valorPagamento = null;
				try {
					valorPagamento = repositorioArrecadacao
							.recuperaValorPagamentoArrecadadorMovimentoItem(arrecadadorMovimentoItem
									.getId());
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}

				arrecadadorMovimentoItemHelper.setVlPagamento(Util
						.formatarMoedaReal(valorPagamento));
				
				retorno.add(arrecadadorMovimentoItemHelper);
				
		
			}
		}

		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;
	}

	/**
	 * [UC0262] - Distribuir dados do Registro de Movimento do Arrecadador
	 * Autor: Sávio Luiz Data: 30/01/2006
	 * 
	 * Caso a descrição de Ocorrencia venha nula então recupera o código
	 * registro da linha senão então seta o valor de código registro para 'C'
	 */

	public Object distribuirdadosRegistroMovimentoArrecadador(String linha,
			String descricaoOcorrencia) throws ControladorException {
		Object registroHelperCodigo = null;

		// inicializa a variavel como 0
		char codigoRegistro = '0';
		// se a descrição da ocorrencia for diferente de null
		// então é para setar o objeto registroHelperCodigoC
		if (descricaoOcorrencia != null) {
			codigoRegistro = 'C';
		} else {
			codigoRegistro = linha.substring(0, 1).toUpperCase().charAt(0);
		}

		switch (codigoRegistro) {

		case 'A':
			RegistroHelperCodigoA registroHelperCodigoA = new RegistroHelperCodigoA();
			// recupera o codigo do registro
			registroHelperCodigoA.setCodigoRegistro("" + codigoRegistro);
			// recupera o codigo da remessa
			registroHelperCodigoA
					.setCodigoRemessa(linha.substring(1, 2).trim());
			// recupera o código do convênio
			registroHelperCodigoA.setCodigoConvenio(linha.substring(2, 22)
					.trim());
			// recupera o nome da empresa
			registroHelperCodigoA
					.setNomeEmpresa(linha.substring(22, 42).trim());
			// recupera o codigo do banco
			registroHelperCodigoA
					.setCodigoBanco(linha.substring(42, 45).trim());
			// recupera o nome do banco
			registroHelperCodigoA.setNomeBanco(linha.substring(45, 65).trim());
			// recupera a data de geração do arquivo
			registroHelperCodigoA.setDataGeracaoArquivo(linha.substring(65, 73)
					.trim());
			// recupera o numero sequencial do arquivo(NSA)
			registroHelperCodigoA.setNumeroSequencialArquivo(linha.substring(
					73, 79).trim());
			// recupera a versão do layout
			registroHelperCodigoA.setVersaoLayout(linha.substring(79, 81)
					.trim());
			// recupera o tipo de movimento
			registroHelperCodigoA.setTipoMovimento(linha.substring(81, 98)
					.trim());
			
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoA.setReservadoFuturo(linha.substring(98,
						149).trim());
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoA.setReservadoFuturo(linha.substring(98,
						150).trim());
			}

			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoA;
			break;

		case 'B':
			RegistroHelperCodigoB registroHelperCodigoB = new RegistroHelperCodigoB();
			// recupera o codigo do registro
			registroHelperCodigoB.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoB.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoB.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoB.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a data de Opção/Exclusão
			registroHelperCodigoB.setDataOpcaoExclusao(linha.substring(44, 52)
					.trim());
			// recupera o reservado para o futuro
			registroHelperCodigoB.setReservadoFuturo(linha.substring(52, 149)
					.trim());
			// recupera a codigo movimento
			if (!linha.substring(149, 150).trim().equals("*")) {
				registroHelperCodigoB.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoB;
			break;

		case 'C':
			RegistroHelperCodigoC registroHelperCodigoC = new RegistroHelperCodigoC();
			// recupera o codigo do registro
			registroHelperCodigoC.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoC.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoC.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoC.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a descrição da ocorrencia do movimento
			registroHelperCodigoC
					.setDescricaoOcorrenciaMovimento(descricaoOcorrencia);
			// recupera os brancos
			registroHelperCodigoC.setBrancos(linha.substring(84, 124).trim());
			// recupera o reservado para o futuro
			registroHelperCodigoC.setReservadoFuturo(linha.substring(124, 149)
					.trim());
			if (!linha.substring(149, 150).trim().equals("*")) {
				// recupera a codigo movimento
				registroHelperCodigoC.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoC;
			break;

		case 'E':
			RegistroHelperCodigoE registroHelperCodigoE = new RegistroHelperCodigoE();
			// recupera o codigo do registro
			registroHelperCodigoE.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação do cliente na empresa
			registroHelperCodigoE.setIdClienteEmpresa(linha.substring(1, 26)
					.trim());
			// recupera a agencia para debito
			registroHelperCodigoE.setAgenciaDebito(linha.substring(26, 30)
					.trim());
			// recupera o identificação do cliente no banco
			registroHelperCodigoE.setIdClienteBanco(linha.substring(30, 44)
					.trim());
			// recupera a data do debito
			registroHelperCodigoE.setDataDebito(linha.substring(44, 52).trim());
			// recupera o valor debitado
			registroHelperCodigoE
					.setValorDebito(linha.substring(52, 67).trim());
			// recupera o codigo da moeda
			registroHelperCodigoE
					.setCodigoMoeda(linha.substring(67, 69).trim());
			// recupera o código de movimento
			registroHelperCodigoE.setAnoMesReferenciaConta(linha.substring(69,
					75).trim());
			// recupera o digito verificado no modulo dez(10) do ano e mes
			// da
			// contadebitada
			registroHelperCodigoE.setDigitoVerificadoAnoMesConta(linha
					.substring(75, 76).trim());
			// grupo de faturamento
			registroHelperCodigoE.setGruposFaturamento(linha.substring(76, 129)
					.trim());
			// recupera o reservado para o futuro
			registroHelperCodigoE.setReservadoFuturo(linha.substring(129, 149)
					.trim());
			if (!linha.substring(149, 150).trim().equals("*")) {
				// recupera o codigo do movimento enviado no registro de
				// código
				// E
				registroHelperCodigoE.setCodigoMovimento(linha.substring(149,
						150).trim());
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoE;
			break;

		case 'F':
			
			// faz um cast para o object
			registroHelperCodigo = this.distribuirDadosRegistroMovimentoArrecadadorTipoF(codigoRegistro, linha);
			break;

		case 'G':
			RegistroHelperCodigoG registroHelperCodigoG = new RegistroHelperCodigoG();
			// recupera o codigo do registro
			registroHelperCodigoG.setCodigoRegistro("" + codigoRegistro);
			// recupera a identificação da agencia /conta/digito creditada
			registroHelperCodigoG.setIdAgenciaContaDigito(linha
					.substring(1, 21).trim());
			// recupera a data de pagamento(AAAAMMDD)
			registroHelperCodigoG.setDataPagamento(linha.substring(21, 29)
					.trim());
			// recupera a data prevista para o credito(AAAAMMDD)
			registroHelperCodigoG.setDataPrevistaCredito(linha
					.substring(29, 37).trim());
			
			// recupera O CÓDIGO DE BARRAS
			//String codigoBarras = linha.substring(37, 81).trim();
			String codigoBarras = linha.substring(37, 93).trim();
			
			RegistroHelperCodigoBarras registroHelperCodigoBarras = distribuirDadosCodigoBarras(codigoBarras);
			// seta também o código de barra como string
			registroHelperCodigoG.setCodigoBarras(codigoBarras);
			registroHelperCodigoG
					.setRegistroHelperCodigoBarras(registroHelperCodigoBarras);
			// recupera o valor recebido
			registroHelperCodigoG.setValorRecebido(linha.substring(81, 93)
					.trim());
			// recupera o valor da tarifa
			registroHelperCodigoG.setValorTarifa(linha.substring(93, 100)
					.trim());
			// recupera o numero sequencial do registro(NRS)
			registroHelperCodigoG.setNumeroSeqRegistro(linha
					.substring(100, 108).trim());
			// recupera o codigo da agencia arrecadadora
			registroHelperCodigoG.setCodigoAgenciaArrecadadora(linha.substring(
					108, 116).trim());
			// recupera a foma de arrecadação/captura
			String codigoArrecadacaoForma = linha.substring(116, 117).trim();
			registroHelperCodigoG
					.setCodigoFormaArrecadacao(codigoArrecadacaoForma);
			String descricaoArrecadacaoForma = "";
			try {
				descricaoArrecadacaoForma = this.repositorioArrecadacao
						.recuperaDescricaoArrecadacaoForma(codigoArrecadacaoForma);
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
			}

			registroHelperCodigoG
					.setFormaArrecadacao(descricaoArrecadacaoForma);

			// recupera o numero de autenticação caixa ou código de
			// transação
			registroHelperCodigoG.setNumeroAutenticacao(linha.substring(117,
					140).trim());
			if (!linha.substring(140, 141).trim().equals("")) {
				// recupera a forma de pagamento
				registroHelperCodigoG.setFormaPagamento(linha.substring(140,
						141).trim());
			} else {
				// recupera a forma de pagamento
				registroHelperCodigoG.setFormaPagamento("1");
			}
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoG.setReservadoFuturo(linha.substring(141,
						149).trim());
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoG.setReservadoFuturo(linha.substring(141,
						150).trim());
			}

			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoG;
			break;

		case 'X':
			RegistroHelperCodigoX registroHelperCodigoX = new RegistroHelperCodigoX();
			// recupera o codigo do registro
			registroHelperCodigoX.setCodigoRegistro("" + codigoRegistro);
			// recupera o código agencia
			registroHelperCodigoX.setCodigoAgencia(linha.substring(1, 5));
			// recupera o nome da agencia
			registroHelperCodigoX.setNomeAgencia(linha.substring(5, 35));
			// recupera o nome do logradouro
			registroHelperCodigoX.setNomelogradouro(linha.substring(35, 65));
			// recupera o numero
			registroHelperCodigoX.setNumero(linha.substring(65, 70));
			// recupera o código do cep
			registroHelperCodigoX.setCodigoCep(linha.substring(70, 75));
			// recupera o sufixo do cep
			registroHelperCodigoX.setSufixoCep(linha.substring(75, 78));
			// recupera o nome da cidade
			registroHelperCodigoX.setNomeCidade(linha.substring(78, 98));
			// recupera a sigla da unidade federação
			registroHelperCodigoX.setSiglaUnidadeFederacao(linha.substring(98,
					100));
			// recupera a situação da agencia
			registroHelperCodigoX.setSituacaoAgencia(linha.substring(100, 101));
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoX.setReservadoFuturo(linha.substring(101,
						149));
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoX.setReservadoFuturo(linha.substring(101,
						150));
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoX;
			break;

		case 'Z':
			RegistroHelperCodigoZ registroHelperCodigoZ = new RegistroHelperCodigoZ();
			// recupera o codigo do registro
			registroHelperCodigoZ.setCodigoRegistro("" + codigoRegistro);
			// recupera o total de registros do arquivo
			registroHelperCodigoZ.setTotalRegistrosArquivo(linha
					.substring(1, 7));
			// recupera o valor total recebido dos registrosdo arquivo
			registroHelperCodigoZ.setValorTotalRegistrosArquivo(linha
					.substring(7, 24));
			if (linha.substring(149, 150).trim().equals("*")) {
				// recupera o reservado para o futuro
				registroHelperCodigoZ.setReservadoFuturo(linha.substring(24,
						149));
			} else {
				// recupera o reservado para o futuro
				registroHelperCodigoZ.setReservadoFuturo(linha.substring(24,
						150));
			}
			// faz um cast para o object
			registroHelperCodigo = registroHelperCodigoZ;
			break;

		}
		return registroHelperCodigo;
	}
	
	
	/**
	 * [UC0262] - Distribuir dados do Registro de Movimento do Arrecadador
	 *
	 * @author Raphael Rossiter
	 * @date 18/09/2009
	 *
	 * @param codigoRegistro
	 * @param linha
	 * @return RegistroHelperCodigoF
	 */
	public RegistroHelperCodigoF distribuirDadosRegistroMovimentoArrecadadorTipoF(char codigoRegistro, String linha){
		
		RegistroHelperCodigoF registroHelperCodigoF = new RegistroHelperCodigoF();
		
		// CÓDIGO DO REGISTRO
		registroHelperCodigoF.setCodigoRegistro("" + codigoRegistro);
		
		// IDENTIFICAÇÃO DO CLIENTE NA EMPRESA
		registroHelperCodigoF.setIdClienteEmpresa(linha.substring(1, 26).trim());
		
		// AGÊNCIA PARA DÉBITO
		registroHelperCodigoF.setAgenciaDebito(linha.substring(26, 30).trim());
		
		//IDENTIFICAÇÃO DO CLIENTE NO BANCO
		registroHelperCodigoF.setIdClienteBanco(linha.substring(30, 44).trim());
		
		// DATA DO DÉBITO
		registroHelperCodigoF.setDataDebito(linha.substring(44, 52).trim());
		
		// VALOR DO DÉBITO
		registroHelperCodigoF.setValorDebito(linha.substring(52, 67).trim());
		
		// CÓDIGO DO RETORNO
		registroHelperCodigoF.setCodigoRetorno(linha.substring(67, 69).trim());
		
		// ANO E MÊS DE REFERÊNCIA DA CONTA
		registroHelperCodigoF.setAnoMesReferenciaConta(linha.substring(69,75).trim());
		
		//DÍGITO VERIFICADOR DO MÓDULO DEZ (10) DO ANO E MÊS DA  CONTA DEBITADA
		registroHelperCodigoF.setDigitoVerificadoAnoMesConta(linha.substring(75, 76).trim());
		
		/*
		 * Caso o ano e mês da conta não esteja informado no arquivo, será necessário recuperar
		 * a identificação da conta.
		 */
		if (registroHelperCodigoF.getAnoMesReferenciaConta().equals("")){
			
			//IDENTIFICAÇÃO DA CONTA
			registroHelperCodigoF.setReservadoFuturo(linha.substring(96, 110).trim());
		}
		else{
			
			//ESPAÇO RESERVADO PARA O FUTURO
			registroHelperCodigoF.setReservadoFuturo(linha.substring(129, 149).trim());
		}
		
		// GRUPO DE FATURAMENTO
		registroHelperCodigoF.setGruposFaturamento(linha.substring(76, 129).trim());
		
		if (!linha.substring(149, 150).trim().equals("*")) {
			
			// CÓDIGO DO MOVIMENTO ENVIADO NO REGISTRO DE CÓDIGO F
			registroHelperCodigoF.setCodigoMovimento(linha.substring(149, 150).trim());
		}
		
		return registroHelperCodigoF;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * 
	 * O sistema captura os dados referentes ao conteúdo do registro de
	 * Movimento do arrecadador
	 * 
	 * [SF0002] Apresentar Dados do Conteúdo do Registro de Movimento do
	 * Arrecadador
	 * 
	 * @author Raphael Rossiter
	 * @data 21/03/2006
	 * 
	 * @param arrecadadorMovimentoItem
	 * @return DadosConteudoRegistroMovimentoArrecadador
	 */
	public DadosConteudoRegistroMovimentoArrecadadorHelper apresentarDadosConteudoRegistroMovimentoArrecadador(
			ArrecadadorMovimentoItem arrecadadorMovimentoItem)
					throws ControladorException {

		DadosConteudoRegistroMovimentoArrecadadorHelper retorno = new DadosConteudoRegistroMovimentoArrecadadorHelper();

		FiltroArrecadadorMovimentoItem filtroArrecadadorMovimentoItem = new FiltroArrecadadorMovimentoItem();

		filtroArrecadadorMovimentoItem
		.adicionarCaminhoParaCarregamentoEntidade("registroCodigo");

		filtroArrecadadorMovimentoItem.adicionarParametro(new ParametroSimples(
				FiltroArrecadadorMovimentoItem.ID, arrecadadorMovimentoItem
				.getId()));

		Collection colecaoArrecadadorMovimentoItem = getControladorUtil()
				.pesquisar(filtroArrecadadorMovimentoItem,
						ArrecadadorMovimentoItem.class.getName());

		ArrecadadorMovimentoItem arrecadadorMovimentoItemCompleto = (ArrecadadorMovimentoItem) Util
				.retonarObjetoDeColecao(colecaoArrecadadorMovimentoItem);

		/*
		 * Caso o código do registro corresponda a: "B" ou "C", apresentar os
		 * seguintes campos:
		 * 
		 * Código do registro Identificação do cliente na empresa Agência para
		 * débito Identificação do cliente no banco Data de opção/exclusão
		 * Código do movimento (1 - EXCLUSÃO, 2 - INCLUSÃO) Ocorrência Indicador
		 * de Aceitação
		 */
		if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_B)) {

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) this
					.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto
							.getConteudoRegistro(), null);

			retorno
			.setCodigoRegistro(registroHelperCodigoB
					.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoB
					.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoB.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoB
					.getIdClienteBanco());
			retorno
			.setDataOpcaoExclusao(Util
					.formatarData(registroHelperCodigoB
							.getDataOpcaoExclusao()));

			if (registroHelperCodigoB.getCodigoMovimento().equals(
					ConstantesSistema.CODIGO_MOVIMENTO_EXCLUSAO.toString())) {

				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_EXCLUSAO);
			} else {
				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_INCLUSAO);
			}

			if (arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null) {
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto
						.getDescricaoOcorrencia());
			}

			retorno.setNomeAgencia( arrecadadorMovimentoItem.getArrecadadorMovimento().getNomeBanco() );

			if (arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() != null
					&& arrecadadorMovimentoItemCompleto.getIndicadorAceitacao()
					.equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)) {

				retorno
				.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			} else {
				retorno
				.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}

		} else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_C)) {

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) this
					.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto
							.getConteudoRegistro(), null);

			retorno
			.setCodigoRegistro(registroHelperCodigoC
					.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoC
					.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoC.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoC
					.getIdClienteBanco());

			retorno.setNomeAgencia( arrecadadorMovimentoItem.getArrecadadorMovimento().getNomeBanco() );

			if (registroHelperCodigoC.getCodigoMovimento().equals(
					ConstantesSistema.CODIGO_MOVIMENTO_EXCLUSAO.toString())) {

				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_EXCLUSAO);
			} else {
				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_INCLUSAO);
			}

			if (arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null) {
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto
						.getDescricaoOcorrencia());
			}

			retorno.setIndicadorAceitacao("");

		}
		/*
		 * Caso o código do registro corresponda a: "E" ou "F", apresentar os
		 * seguintes campos:
		 * 
		 * Código do registro Identificação do cliente na empresa Agência para
		 * débito Identificação do cliente no banco Data do vencimento/débito
		 * Valor do débito Código da moeda ou código do retorno Mês e ano de
		 * rferencia da conta Dígito verificador da conta Código do movimento (0 -
		 * DÉBITO NORMAL, 1 - CANCELAMENTO) Ocorrência Indicador de Aceitação
		 */
		else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_E)) {

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoE registroHelperCodigoE = (RegistroHelperCodigoE) this
					.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto
							.getConteudoRegistro(), null);

			retorno
			.setCodigoRegistro(registroHelperCodigoE
					.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoE
					.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoE.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoE
					.getIdClienteBanco());
			retorno.setDataVencimentoDebito(Util
					.formatarData(registroHelperCodigoE.getDataDebito()));

			try {
				retorno
				.setValorDebito(Util
						.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoE
										.getValorDebito())));
			} catch (NumberFormatException ex) {
				retorno.setValorDebito(registroHelperCodigoE.getValorDebito());
			}

			retorno.setCodigoMoeda(registroHelperCodigoE.getCodigoMoeda());
			retorno.setMesAnoReferenciaConta(Util
					.formatarAnoMesParaMesAno(new Integer(registroHelperCodigoE
							.getAnoMesReferenciaConta()).intValue()));
			retorno.setDigitoVerificadorConta(registroHelperCodigoE
					.getDigitoVerificadoAnoMesConta());

			if (registroHelperCodigoE.getCodigoMovimento()
					.equals(
							ConstantesSistema.CODIGO_MOVIMENTO_DEBITO_NORMAL
							.toString())) {

				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_DEBITO_NORMAL);
			} else {
				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_CANCELAMENTO);
			}

			retorno.setNomeAgencia( arrecadadorMovimentoItem.getArrecadadorMovimento().getNomeBanco() );

			if (arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null) {
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto
						.getDescricaoOcorrencia());
			}

			if (arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() != null
					&& arrecadadorMovimentoItemCompleto.getIndicadorAceitacao()
					.equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)) {

				retorno
				.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			} else {
				retorno
				.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}
		} else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_F)) {

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this
					.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto
							.getConteudoRegistro(), null);

			retorno
			.setCodigoRegistro(registroHelperCodigoF
					.getCodigoRegistro());
			retorno.setIdentificacaoClienteEmpresa(registroHelperCodigoF
					.getIdClienteEmpresa());
			retorno.setAgenciaDebito(registroHelperCodigoF.getAgenciaDebito());
			retorno.setIdentificacaoClienteBanco(registroHelperCodigoF
					.getIdClienteBanco());
			retorno.setDataVencimentoDebito(Util
					.formatarData(registroHelperCodigoF.getDataDebito()));

			try {
				retorno
				.setValorDebito(Util
						.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoF
										.getValorDebito())));
			} catch (NumberFormatException ex) {
				retorno.setValorDebito(registroHelperCodigoF.getValorDebito());
			}

			if (registroHelperCodigoF.getAnoMesReferenciaConta() != null &&
					!registroHelperCodigoF.getAnoMesReferenciaConta().equals("")){

				retorno.setMesAnoReferenciaConta(Util.formatarAnoMesParaMesAno(new Integer(registroHelperCodigoF
						.getAnoMesReferenciaConta()).intValue()));
			}

			if (registroHelperCodigoF.getDigitoVerificadoAnoMesConta() != null &&
					!registroHelperCodigoF.getDigitoVerificadoAnoMesConta().equals("")){

				retorno.setDigitoVerificadorConta(registroHelperCodigoF
						.getDigitoVerificadoAnoMesConta());
			}


			if (registroHelperCodigoF.getCodigoMovimento()
					.equals(
							ConstantesSistema.CODIGO_MOVIMENTO_DEBITO_NORMAL
							.toString())) {

				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_DEBITO_NORMAL);
			} else {
				retorno
				.setDescricaoMovimento(ConstantesSistema.DESCRICAO_MOVIMENTO_CANCELAMENTO);
			}

			if (arrecadadorMovimentoItemCompleto.getDescricaoOcorrencia() != null) {
				retorno.setOcorrencia(arrecadadorMovimentoItemCompleto
						.getDescricaoOcorrencia());
			}

			if (arrecadadorMovimentoItemCompleto.getIndicadorAceitacao() != null
					&& arrecadadorMovimentoItemCompleto.getIndicadorAceitacao()
					.equals(ArrecadadorMovimentoItem.INDICADOR_ACEITO)) {

				retorno
				.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
			} else {
				retorno
				.setIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
			}

			/*
			 * Caso o código do registro corresponda a "F" apresentar a
			 * descrição do código de retorno
			 * (DURC_DSDEBITOAUTOMATICORETORNOCODIGO da tabela
			 * DEBITO_AUTOMATICO_RETORNO_COD com DURC_ID = código de retorno)
			 */
			FiltroDebitoAutomaticoRetornoCodigo filtroDebitoAutomaticoRetornoCodigo = new FiltroDebitoAutomaticoRetornoCodigo();

			filtroDebitoAutomaticoRetornoCodigo
			.adicionarParametro(new ParametroSimples(
					FiltroDebitoAutomaticoRetornoCodigo.ID,
					new Integer(registroHelperCodigoF
							.getCodigoRetorno())));

			Collection colecaoDebitoAutomaticoRetornoCodigo = getControladorUtil()
					.pesquisar(filtroDebitoAutomaticoRetornoCodigo,
							DebitoAutomaticoRetornoCodigo.class.getSimpleName());

			DebitoAutomaticoRetornoCodigo debitoAutomaticoRetornoCodigo = (DebitoAutomaticoRetornoCodigo) Util
					.retonarObjetoDeColecao(colecaoDebitoAutomaticoRetornoCodigo);

			if (debitoAutomaticoRetornoCodigo != null) {
				retorno.setCodigoRetorno(debitoAutomaticoRetornoCodigo
						.getDescricaoDebitoAutomaticoRetornoCodigo());
			}

			retorno.setNomeAgencia( arrecadadorMovimentoItem.getArrecadadorMovimento().getNomeBanco() );

			/*
			 * Lista de pagamentos relacionados ao ítem do movimento
			 */
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.setConsultaSemLimites(true);

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");

			filtroPagamento.adicionarParametro(new ParametroSimples(
					FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
					arrecadadorMovimentoItemCompleto.getId()));

			Collection colecaoPagamentos = getControladorUtil().pesquisar(
					filtroPagamento, Pagamento.class.getName());

			retorno.setColecaoPagamentos(colecaoPagamentos);

		}
		/*
		 * Caso o código do registro corresponda a: "G", apresentar os seguintes
		 * campos:
		 * 
		 * Código do registro Identificação da agência/conta/dígito creditada
		 * Data pagamento Data prevista para o crédito Código de Barras [SB003 -
		 * Apresentar Dados do Conteúdo do Código de Barras] com os dados
		 * retornados pelo [UC0264] Valor recebido Valor da tarifa NSR - Número
		 * sequencial de registro Código da agência arrecadadora Forma de
		 * arrecadação/captura Número de autenticação caixa ou código de
		 * transação Forma de pagamento
		 */
		else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_G)) {

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this
					.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto
							.getConteudoRegistro(), null);

			retorno
			.setCodigoRegistro(registroHelperCodigoG
					.getCodigoRegistro());
			retorno
			.setIdentificacaoAgenciaContaDigitoCreditada(registroHelperCodigoG
					.getIdAgenciaContaDigito());
			retorno.setDataPagamento(Util.formatarData(registroHelperCodigoG
					.getDataPagamento()));
			retorno.setDataPrevistaCredito(Util
					.formatarData(registroHelperCodigoG
							.getDataPrevistaCredito()));

			// [SB0003] - Apresentar Dados do Conteúdo do Código de Barras
			DadosConteudoCodigoBarrasHelper dadosConteudoCodigoBarrasHelper = this
					.apresentarDadosConteudoCodigoBarras(registroHelperCodigoG);

			retorno
			.setDadosConteudoCodigoBarrasHelper(dadosConteudoCodigoBarrasHelper);

			try {
				retorno
				.setValorRecebido(Util
						.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG
										.getValorRecebido())));
			} catch (NumberFormatException ex) {
				retorno.setValorRecebido(registroHelperCodigoG
						.getValorRecebido());
			}

			try {
				retorno
				.setValorTarifa(Util
						.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG
										.getValorTarifa())));
			} catch (NumberFormatException ex) {
				retorno.setValorTarifa(registroHelperCodigoG.getValorTarifa());
			}

			retorno.setNsr(registroHelperCodigoG.getNumeroSeqRegistro());
			retorno.setCodigoAgenciaArrecadadora(registroHelperCodigoG
					.getCodigoAgenciaArrecadadora());			

			retorno.setNomeAgencia( arrecadadorMovimentoItem.getArrecadadorMovimento().getNomeBanco() );			

			retorno.setFormaArrecadacaoCaptura(registroHelperCodigoG
					.getFormaArrecadacao());
			retorno
			.setNumeroAutenticacaoCaixaOUCodigoTransacao(registroHelperCodigoG
					.getNumeroAutenticacao());
			retorno
			.setFormaPagamento(registroHelperCodigoG
					.getFormaPagamento());

			/*
			 * Lista de pagamentos relacionados ao ítem do movimento
			 */
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.setConsultaSemLimites(true);

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");
			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");

			filtroPagamento.adicionarParametro(new ParametroSimples(
					FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
					arrecadadorMovimentoItemCompleto.getId()));

			Collection colecaoPagamentos = getControladorUtil().pesquisar(
					filtroPagamento, Pagamento.class.getName());

			retorno.setColecaoPagamentos(colecaoPagamentos);
		}
		/*
		 * Caso o código do registro corresponda a: "X", apresentar os seguintes
		 * campos:
		 * 
		 * Código do registro Código da agência Nome da agência Nome do
		 * logradouro Número Código do CEP Sufixo do CEP Nome da cidade Sigla da
		 * unidade da federação Situação da agência ("A" = Ativa, "B" = em
		 * regime de encerramento)
		 */
		else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_X)) {

			// [UC0262] - Distribuir Dados do Registro de Movimento do
			// Arrecadador
			RegistroHelperCodigoX registroHelperCodigoX = (RegistroHelperCodigoX) this
					.distribuirdadosRegistroMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto
							.getConteudoRegistro(), null);

			retorno
			.setCodigoRegistro(registroHelperCodigoX
					.getCodigoRegistro());
			retorno.setCodigoAgencia(registroHelperCodigoX.getCodigoAgencia());
			retorno.setNomeAgencia(registroHelperCodigoX.getNomeAgencia());
			retorno
			.setNomeLogradouro(registroHelperCodigoX
					.getNomelogradouro());
			retorno.setNumero(registroHelperCodigoX.getNumero());
			retorno.setCodigoCep(registroHelperCodigoX.getCodigoCep());
			retorno.setSufixoCep(registroHelperCodigoX.getSufixoCep());
			retorno.setNomeCidade(registroHelperCodigoX.getNomeCidade());
			retorno.setSiglaUnidadeFederacao(registroHelperCodigoX
					.getSiglaUnidadeFederacao());

			retorno.setNomeAgencia( arrecadadorMovimentoItem.getArrecadadorMovimento().getNomeBanco() );

			if (registroHelperCodigoX.getSituacaoAgencia().equals(
					ConstantesSistema.CODIGO_SITUACAO_AGENCIA_ATIVO)) {

				retorno
				.setSituacaoAgencia(ConstantesSistema.DESCRICAO_SITUACAO_AGENCIA_ATIVO);
			} else {

				retorno
				.setSituacaoAgencia(ConstantesSistema.DESCRICAO_SITUACAO_AGENCIA_EM_REGIME_ENCERRAMENTO);
			}
		}

		/*
		 * Alterado por Vivianne Sousa em 28/01/2008 - Analista: Adriano
		 *
		 * Caso o código do registro corresponda a: "W", apresentar os seguintes
		 * campos:
		 * 
		 * Código do registro
		 * Identificação da agencia/conta/digito creditado
		 * Data de pagamento
		 * Data prevista para o crédito
		 * Código de barras
		 * Valor recebido
		 * NSR-Número Sequencial de Registro
		 * Forma de arrecadação/captura
		 * Número de autenticação caixa ou código de transação
		 * Forma de Pagamento
		 */
		else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_W)) {

			// Distribuir Dados do Registro W de Movimento do Arrecadador
			RegistroHelperCodigoW registroHelperCodigoW =  this
					.distribuirdadosRegistroWMovimentoArrecadador(
							arrecadadorMovimentoItemCompleto.getConteudoRegistro());

			retorno.setCodigoRegistro("W");

			retorno.setIdentificacaoAgenciaContaDigitoCreditada(
					registroHelperCodigoW.getIdentificacaoAgenciaContaDigitoCreditada());

			if(registroHelperCodigoW.getDataVencimentoTitulo() != null &&
					new Integer(registroHelperCodigoW.getDataVencimentoTitulo()).compareTo(0) > 0){
				retorno.setDataPagamento(Util.converterDataSemBarraParaDataComBarra(
						registroHelperCodigoW.getDataVencimentoTitulo()));
			}

			retorno.setDataPrevistaCredito(Util.converterDataSemBarraParaDataComBarra(
					registroHelperCodigoW.getDataEfetivacaoCredito()));

			retorno.setValorRecebido(Util.formatarMoedaReal(Util
					.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
							registroHelperCodigoW.getValorPagoSacado())));

			retorno.setFormaArrecadacaoCaptura("Ficha de Compensação");

			//[SB0004] - Apresentar Dados do Conteúdo do Código de Barras
			DadosConteudoCodigoBarrasHelper dadosConteudoCodigoBarrasHelper = 
					apresentarDadosConteudoCodigoBarrasFichaCompensacao(registroHelperCodigoW);

			retorno.setDadosConteudoCodigoBarrasHelper(dadosConteudoCodigoBarrasHelper);

			/*
			 * Lista de pagamentos relacionados ao ítem do movimento
			 */
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.setConsultaSemLimites(true);

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");

			filtroPagamento
			.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");

			filtroPagamento.adicionarParametro(new ParametroSimples(
					FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
					arrecadadorMovimentoItemCompleto.getId()));

			Collection colecaoPagamentos = getControladorUtil().pesquisar(
					filtroPagamento, Pagamento.class.getName());

			retorno.setColecaoPagamentos(colecaoPagamentos);

		} else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_CARTAO_CREDITO_TIPO_2.toString())) {

			FiltroMovimentoCartaoRejeita filtroMovimentoCartaoRejeita = new FiltroMovimentoCartaoRejeita();

			filtroMovimentoCartaoRejeita.adicionarParametro(new ParametroSimples(FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
					arrecadadorMovimentoItemCompleto.getId()));

			Collection colecaoMovimentoCartaoRejeita = getControladorUtil().pesquisar(
					filtroMovimentoCartaoRejeita, MovimentoCartaoRejeita.class.getName());

			if (colecaoMovimentoCartaoRejeita != null && !colecaoMovimentoCartaoRejeita.isEmpty()){

				MovimentoCartaoRejeita movimentoCartaoRejeita = (MovimentoCartaoRejeita) Util.retonarObjetoDeColecao(colecaoMovimentoCartaoRejeita);

				retorno.setNumeroCartao(Util.decrypt(movimentoCartaoRejeita.getNumeroCartao()));

				retorno.setDataTransacao(Util.formatarData(movimentoCartaoRejeita.getDataCompra()));

				try {

					retorno.setValorTransacao(Util.formatarMoedaReal(movimentoCartaoRejeita.getValorVenda()));

				} catch (NumberFormatException ex) {}

				retorno.setNumeroParcela(movimentoCartaoRejeita.getNumeroParcela().toString());

				retorno.setNumeroParcelaDebito(movimentoCartaoRejeita.getNumeroParcelaDebito().toString());
			}
		} else if (arrecadadorMovimentoItemCompleto.getRegistroCodigo() != null
				&& arrecadadorMovimentoItemCompleto.getRegistroCodigo()
				.getCodigo().equals(RegistroCodigo.CODIGO_K)) {

			if(arrecadadorMovimentoItemCompleto.getConteudoRegistro() != null) {
				RegistroFichaCompensacaoTipo7Helper registroTipo7 = 
						new RegistroFichaCompensacaoTipo7Helper(arrecadadorMovimentoItemCompleto.getConteudoRegistro());

				retorno.setCodigoRegistro("K");

				retorno.setIdentificacaoAgenciaContaDigitoCreditada(
						registroTipo7.getDigitoVerificadorContaCorrenteCedente());

				if(registroTipo7.getDataVencimento() != null &&
						new Integer(registroTipo7.getDataVencimento()).compareTo(0) > 0){
					retorno.setDataPagamento(registroTipo7.getDataVencimento());
				}

				retorno.setDataPrevistaCredito(registroTipo7.getDataCreditoFormatadoComBarra());

				retorno.setValorRecebido(Util.formatarMoedaReal(registroTipo7.getValorRecebidoFormatado()));

				retorno.setFormaArrecadacaoCaptura("Ficha de Compensação");

				DadosConteudoCodigoBarrasHelper dadosConteudoCodigoBarrasHelper = 
						apresentarDadosConteudoCodigoBarrasFichaCompensacaoNovo(registroTipo7);

				retorno.setDadosConteudoCodigoBarrasHelper(dadosConteudoCodigoBarrasHelper);

				FiltroPagamento filtroPagamento = new FiltroPagamento();
				filtroPagamento.setConsultaSemLimites(true);

				filtroPagamento
				.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");

				filtroPagamento
				.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");

				filtroPagamento
				.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");

				filtroPagamento.adicionarParametro(new ParametroSimples(
						FiltroPagamento.ARRECADADOR_MOVIMENTO_ITEM_ID,
						arrecadadorMovimentoItemCompleto.getId()));

				Collection colecaoPagamentos = getControladorUtil().pesquisar(
						filtroPagamento, Pagamento.class.getName());

				retorno.setColecaoPagamentos(colecaoPagamentos);

			} 
		}


		return retorno;
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * 
	 * O sistema captura os dados referentes ao conteúdo do do código de barras
	 * 
	 * [SF0003] Apresentar Dados do Conteúdo do Código de Barras
	 * 
	 * @author Raphael Rossiter
	 * @data 22/03/2006
	 * 
	 * @param registroHelperCodigoG
	 * @return DadosConteudoCodigoBarrasHelper
	 */
	public DadosConteudoCodigoBarrasHelper apresentarDadosConteudoCodigoBarras(
			RegistroHelperCodigoG registroHelperCodigoG)
			throws ControladorException {

		DadosConteudoCodigoBarrasHelper retorno = new DadosConteudoCodigoBarrasHelper();

		retorno.setIdentificacaoProduto(registroHelperCodigoG
				.getRegistroHelperCodigoBarras().getIdProduto());
		retorno.setIdentificacaoSegmento(registroHelperCodigoG
				.getRegistroHelperCodigoBarras().getIdSegmento());
		retorno.setIdentificacaoValorRealOUReferencia(registroHelperCodigoG
				.getRegistroHelperCodigoBarras().getIdValorReal());
		retorno.setDigitoVerificadorGeral(registroHelperCodigoG
				.getRegistroHelperCodigoBarras().getDigitoVerificadorGeral());
		retorno
				.setValorPagamento(Util
						.formatarMoedaReal(Util
								.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(registroHelperCodigoG
										.getRegistroHelperCodigoBarras()
										.getValorPagamento())));

		String tipoPagamento = registroHelperCodigoG
				.getRegistroHelperCodigoBarras().getTipoPagamento();


		if (tipoPagamento != null
				&& tipoPagamento
						.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA
								.toString())) {

			retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);

			retorno.setCodigoLocalidade(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento1()).toString());

			retorno.setMatriculaImovel(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2()).toString());

			retorno
					.setMesAnoReferenciaConta(Util
							.formatarMesAnoSemBarraParaMesAnoComBarra(registroHelperCodigoG
									.getRegistroHelperCodigoBarras()
									.getRegistroHelperCodigoBarrasTipoPagamento()
									.getIdPagamento4()));

			retorno.setDigitoVerificadorContaModulo10(new Integer(
					registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento5()).toString());

		} else if (tipoPagamento != null
				&& tipoPagamento
						.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO
								.toString())) {

			retorno
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);

			retorno.setCodigoLocalidade(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento1()).toString());
			retorno.setMatriculaImovel(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2()).toString());
			retorno.setCodigoTipoDebito(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento4()).toString());
			retorno.setAnoEmissaoGuiaPagamento(new Integer(
					registroHelperCodigoG.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento5()).toString());

		} else if (tipoPagamento != null
				&& tipoPagamento
						.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA
								.toString())) {

			retorno
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);

			retorno.setMatriculaImovel(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2()).toString());
			retorno.setSequencialDocumentoCobranca(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento3());
			retorno.setCodigoTipoDocumento(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento4());

		} else if (tipoPagamento != null
				&& tipoPagamento
						.equals(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL
								.toString())) {

			retorno
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);

			retorno.setCodigoCliente(new Integer(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2()).toString());
			retorno.setMesAnoReferenciaConta(Util
					.formatarAnoMesParaMesAno(new Integer(registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2()).intValue()));
			retorno.setDigitoVerificadorContaModulo10(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento5());
			retorno.setSequencialFaturaClienteResponsavel(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento6());

		}

		return retorno;

	}

	// Método que verifica (no InserirAvisoBancario) se a conta bancária
	// selecionada existe para depósito da arrecadação
	public void verificarExistenciaContaParaAvisoBancario(String idArrecadador,
			String idConta) throws ControladorException {

		Collection arrecadadorContratoEncontrado = null;

		if (idConta != null && !idConta.equals("")) {
			FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
			filtroArrecadadorContrato
					.adicionarParametro(new ParametroSimples(
							FiltroArrecadadorContrato.ID_DEPOSITO_ARRECADACAO,
							idConta));
			filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(
					FiltroArrecadadorContrato.ARRECADADOR_ID, idArrecadador));
			filtroArrecadadorContrato.adicionarParametro(new ParametroNulo(
					FiltroArrecadadorContrato.DATA_CONTRATO_ENCERRAMENTO));

			try {

				arrecadadorContratoEncontrado = repositorioUtil.pesquisar(
						filtroArrecadadorContrato, ArrecadadorContrato.class
								.getName());

			} catch (ErroRepositorioException ex) {
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

			if (arrecadadorContratoEncontrado == null
					|| arrecadadorContratoEncontrado.isEmpty()) {
				throw new ControladorException(
						"atencao.arrecadador.conta.inexistente");
			}

		}

	}

	/**
	 * Método que atualiza o aviso bancario, adiciona as deducoes e acertos
	 * novas e remove as deducoes e os acertos que forma para remover
	 * 
	 * @author thiago
	 * @date 14/03/2006
	 * 
	 * @param avisoBancario
	 * @param duducoes
	 * @param deducoesParaRemover
	 * @param acertos
	 * @param acertosParaRemover
	 */
	public void atualizarAvisoBancario(AvisoBancario avisoBancario,
			Collection deducoes, Collection deducoesParaRemover,
			Collection acertos, Collection acertosParaRemover,
			Usuario usuarioLogado)
			throws ControladorException {
		try {

			BigDecimal arrecadacao = new BigDecimal("0.00");
			BigDecimal devolucao = new BigDecimal("0.00");
			BigDecimal deducao = new BigDecimal("0.00");

			if (avisoBancario.getValorArrecadacaoInformado() != null)
				arrecadacao = avisoBancario.getValorArrecadacaoInformado();

			if (avisoBancario.getValorDevolucaoInformado() != null)
				devolucao = avisoBancario.getValorDevolucaoInformado();

			if (deducoes != null) {
				Iterator it = deducoes.iterator();
				while (it.hasNext()) {
					AvisoDeducoes avisoDeducoes = (AvisoDeducoes) it.next();
					if (avisoDeducoes.getValorDeducao() != null)
						deducao = deducao.add(avisoDeducoes.getValorDeducao());
				}
			}
			BigDecimal valorAvido = arrecadacao.subtract(devolucao);
			BigDecimal valorTela = valorAvido.subtract(deducao);

			if (avisoBancario.getIndicadorCreditoDebito() == 1
					&& (valorTela.compareTo(new BigDecimal("0.00")) == -1)) {
				throw new ControladorException(
						"atencao.avisoBancario.credito.menor.que.zero", null,
						Util.formatarMoedaReal(valorTela));
			} else if (avisoBancario.getIndicadorCreditoDebito() == 2
					&& (valorTela.compareTo(new BigDecimal("0.00")) == 1)) {
				throw new ControladorException(
						"atencao.avisoBancario.debito.maior.que.zero", null,
						Util.formatarMoedaReal(valorTela));
			}


			avisoBancario.setUltimaAlteracao(new Date(System
					.currentTimeMillis()));
			
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(
					Operacao.OPERACAO_ATUALIZAR_AVISO_BANCARIO, avisoBancario.getId(), avisoBancario.getId(),
					new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
			registradorOperacao.registrarOperacao(avisoBancario);
			getControladorTransacao().registrarTransacao(avisoBancario);

			repositorioUtil.atualizar(avisoBancario);

			// removendo as
			if (deducoesParaRemover != null) {
				Iterator it = deducoesParaRemover.iterator();
				while (it.hasNext()) {
					AvisoDeducoes aviso = (AvisoDeducoes) it.next();
					if (aviso.getComp_id() != null) {
						repositorioUtil.remover(aviso);
					}
				}
			}

			// adicionando as deducoes novas
			if (deducoes != null) {
				Iterator it = deducoes.iterator();
				while (it.hasNext()) {
					AvisoDeducoes aviso = (AvisoDeducoes) it.next();
					if (aviso.getComp_id() == null) {
						AvisoDeducoesPK pk = new AvisoDeducoesPK();
						pk.setAvisoBancarioId(avisoBancario.getId());
						pk.setDeducaoTipoId(aviso.getDeducaoTipo().getId());

						aviso.setComp_id(pk);
						aviso.setAvisoBancario(avisoBancario);
						aviso.setUltimaAlteracao(new Date(System
								.currentTimeMillis()));

						repositorioUtil.inserir(aviso);
					} else {
						repositorioUtil.atualizar(aviso);
					}
				}
			}

			// removendo os acertos
			if (acertosParaRemover != null) {
				Iterator it = acertosParaRemover.iterator();
				while (it.hasNext()) {
					AvisoAcerto aviso = (AvisoAcerto) it.next();
					if (aviso.getId() != null) {
						repositorioUtil.remover(aviso);
					}
				}
			}

			// adicionando as deducoes novas
			if (acertos != null) {
				Iterator it = acertos.iterator();
				while (it.hasNext()) {
					AvisoAcerto aviso = (AvisoAcerto) it.next();
					if (aviso.getId() == null) {

						aviso.setAvisoBancario(avisoBancario);
						aviso.setUltimaAlteracao(new Date(System
								.currentTimeMillis()));

						repositorioUtil.inserir(aviso);
					} else {
						repositorioUtil.atualizar(aviso);
					}
				}
			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			sessionContext.setRollbackOnly();
			throw new ControladorException(ex.getMessage(), ex);
		}

	}

	
	/**
	 * Faz a pesquisa de devolução fazendo os carregamentos de clienteContas,
	 * clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * 
	 * @param FiltroDevolucao
	 * @return Collection<Devolucao>
	 * @throws ControladorException
	 */
	public Collection<Devolucao> pesquisarDevolucao(
			FiltroDevolucao filtroDevolucao) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarDevolucao(filtroDevolucao);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamentoImovel
	 * 
	 * @author Tiago Moreno, Roberta Costa,Rafael Santos
	 * @date 12/06/06,06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoImovel(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial, 
            String valorPagamentoFinal ) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoImovel(idImovel,
					idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, valorPagamentoInicial,
                    valorPagamentoFinal );
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0235] - Inserir Aviso Bancario Autor: Rhawi Dantas Data: 16/02/2006
	 */

	/**
	 * [UC0239] Filtrar Aviso Bancário
	 * 
	 * Validar Filtrar Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 18/03/2006
	 * 
	 * @param dataLancamentoInicio
	 * @param dataLancamentoFim
	 * @param periodoArrecadacaoInicio
	 * @param periodoArrecadacaoFim
	 * @param dataPrevisaoCreditoDebitoInicio
	 * @param dataPrevisaoCreditoDebitoFim
	 * @param intervaloValorPrevistoInicio
	 * @param intervaloValorPrevistoFim
	 * @param dataRealizacaoCreditoDebitoInicio
	 * @param dataRealizacaoCreditoDebitoFim
	 * @param intervaloValorRealizadoInicio
	 * @param intervaloValorRealizadoFim
	 * 
	 * return void
	 * @throws ControladorException
	 */
	public void validacaoFinal(Date dataLancamentoInicio,
			Date dataLancamentoFim, Integer periodoArrecadacaoInicio,
			Integer periodoArrecadacaoFim,
			Date dataPrevisaoCreditoDebitoInicio,
			Date dataPrevisaoCreditoDebitoFim,
			BigDecimal intervaloValorPrevistoInicio,
			BigDecimal intervaloValorPrevistoFim,
			Date dataRealizacaoCreditoDebitoInicio,
			Date dataRealizacaoCreditoDebitoFim,
			BigDecimal intervaloValorRealizadoInicio,
			BigDecimal intervaloValorRealizadoFim) throws ControladorException {

		getControladorUtil().validarDataMenorDataAtual(dataLancamentoInicio,
				"atencao.data.lancamento.posterior");
		getControladorUtil().validarDataMenorDataAtual(dataLancamentoFim,
				"atencao.data.lancamento.posterior");
		if ((periodoArrecadacaoInicio != null)
				&& (periodoArrecadacaoInicio.toString().length() < 6 || Util
						.validarAnoMes(Util
								.formatarMesAnoReferencia(periodoArrecadacaoInicio)))) {
			throw new ControladorException(
					"atencao.arrecadacao_referencia_invalido", null);
		}
		if ((periodoArrecadacaoFim != null)
				&& (periodoArrecadacaoFim.toString().length() < 6 || Util
						.validarAnoMes(Util
								.formatarMesAnoReferencia(periodoArrecadacaoFim)))) {
			throw new ControladorException(
					"atencao.arrecadacao_referencia_invalido", null);
		}
		getControladorUtil().validarAnoMesMenorAnoMesAtual(
				periodoArrecadacaoInicio, "atencao.referencia.posterior");
		getControladorUtil().validarAnoMesMenorAnoMesAtual(
				periodoArrecadacaoFim, "atencao.referencia.posterior");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(
				dataLancamentoInicio, dataLancamentoFim,
				"atencao.data_fim_menor_inicio");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(
				periodoArrecadacaoInicio, periodoArrecadacaoFim,
				"atencao.referenciafinal.menorque");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(
				dataPrevisaoCreditoDebitoInicio, dataPrevisaoCreditoDebitoFim,
				"atencao.data_fim_menor_inicio");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(
				intervaloValorPrevistoInicio, intervaloValorPrevistoFim,
				"atencao.valorprevistofinal.menorque");
		getControladorUtil()
				.validarCampoFinalMaiorIgualCampoInicial(
						dataRealizacaoCreditoDebitoInicio,
						dataRealizacaoCreditoDebitoFim,
						"atencao.data_fim_menor_inicio");
		getControladorUtil().validarCampoFinalMaiorIgualCampoInicial(
				intervaloValorRealizadoInicio, intervaloValorRealizadoFim,
				"atencao.valorrealizadofinal.menorque");

	}

	/**
	 * [UC0239] Filtrar Aviso Bancário
	 * 
	 * Filtrar Aviso Bancário de acordo com a opção Aberto / Fechado
	 * 
	 * @author Vivianne Sousa
	 * @date 18/03/2006
	 * 
	 * @param collectionAvisoBancario
	 * @param indicadorAbertoFechado
	 * @param tipoAviso
	 * 
	 * return collection<AvisoBancario>
	 * @throws ControladorException
	 */
	public Collection<AvisoBancarioHelper> filtrarAvisoBancarioAbertoFechado(
			Collection collectionAvisoBancario, String indicadorAbertoFechado,
			String tipoAviso) throws ControladorException {

		Collection<AvisoBancarioHelper> collectionAvisoBancarioNovo = new ArrayList();
		Iterator iterator = collectionAvisoBancario.iterator();

		AvisoBancario avisoBancario = null;
		AvisoBancarioHelper avisoBancarioHelper = null;

		while (iterator.hasNext()) {
			avisoBancario = (AvisoBancario) iterator.next();

			avisoBancarioHelper = new AvisoBancarioHelper();
			avisoBancarioHelper.setAvisoBancario(avisoBancario);

			short indicadorCreditoDebito = avisoBancario
					.getIndicadorCreditoDebito();

			if ((obterSituacaoAvisoBancario(avisoBancario)
					.equals(ConstantesSistema.FECHADO))
					&& (!indicadorAbertoFechado.trim().equals("2"))) {

				if ((!tipoAviso.trim().equals("2"))
						&& (indicadorCreditoDebito == 1)) {
					// tipo de aviso: Crédito ou Todos
					avisoBancarioHelper.setTipoAviso(ConstantesSistema.FECHADO);
					collectionAvisoBancarioNovo.add(avisoBancarioHelper);
				} else if ((!tipoAviso.trim().equals("1"))
						&& (indicadorCreditoDebito == 2)) {
					// tipo de aviso: Débito ou Todos
					avisoBancarioHelper.setTipoAviso(ConstantesSistema.FECHADO);
					collectionAvisoBancarioNovo.add(avisoBancarioHelper);
				}
			} else if ((obterSituacaoAvisoBancario(avisoBancario)
					.equals(ConstantesSistema.ABERTO))
					&& (!indicadorAbertoFechado.trim().equals("3"))) {

				if ((!tipoAviso.trim().equals("2"))
						&& (indicadorCreditoDebito == 1)) {
					// tipo de aviso: Crédito ou Todos
					avisoBancarioHelper.setTipoAviso(ConstantesSistema.ABERTO);
					collectionAvisoBancarioNovo.add(avisoBancarioHelper);
				} else if ((!tipoAviso.trim().equals("1"))
						&& (indicadorCreditoDebito == 2)) {
					// tipo de aviso: Débito ou Todos
					avisoBancarioHelper.setTipoAviso(ConstantesSistema.ABERTO);
					collectionAvisoBancarioNovo.add(avisoBancarioHelper);
				}

			}

		}

		return collectionAvisoBancarioNovo;

	}

	/**
	 * Método que recebe um array de Integer e remove os Avisos Bancarios dos
	 * ids passado, caso exista um Aviso Bancario que tenha um relacionamento
	 * com outra tabela entao nao remove nenhum. Outra tabela fora aviso_deducao
	 * e aviso_acerto
	 * 
	 * 
	 * @author Thiago Toscano
	 * @date 20/03/2006
	 * 
	 * @param ids
	 * @throws ControladorException
	 */
	public void removerAvisosBancarios(Integer[] ids,
			OperacaoEfetuada operacaoEfetuada,
			Collection<UsuarioAcaoUsuarioHelper> acaoUsuarioHelper)
			throws ControladorException {

		if (ids != null && ids.length > 0) {
			for (int i = 0; i < ids.length; i++) {
				Integer id = ids[i];

				try {

					// alterado por Vivianne Sousa dia 18/01/2007
					// pesquisa os pagamentos associados ao aviso bancario
					Collection colecaoPagamentoAvisoBancario = null;
					try {
						colecaoPagamentoAvisoBancario = repositorioArrecadacao
								.pesquisarPagamentoPorAvisoBancario(id);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema");
					}

					if (colecaoPagamentoAvisoBancario != null
							&& !colecaoPagamentoAvisoBancario.isEmpty()) {

						Iterator iteratorPagamentoAvisoBancario = colecaoPagamentoAvisoBancario
								.iterator();

						while (iteratorPagamentoAvisoBancario.hasNext()) {
							Pagamento pagamento = (Pagamento) iteratorPagamentoAvisoBancario
									.next();

							// remover pagamento
							getControladorUtil().removerUm(
									pagamento.getId().intValue(),
									Pagamento.class.getSimpleName(),
									operacaoEfetuada, acaoUsuarioHelper);
						}
					}

					getControladorUtil().removerUm(id.intValue(),
							AvisoBancario.class.getSimpleName(),
							operacaoEfetuada, acaoUsuarioHelper);

				} catch (ControladorException e) {
					sessionContext.setRollbackOnly();
					e.getCause();
					if (e != null
							&& e.getMessage() != null
							&& "atencao.dependencias.existentes"
									.equalsIgnoreCase(e.getMessage())) {
						throw new ControladorException(
								"atencao.avisoBancario.com.vinculo");
					}

					throw e;
				}
			}
		}
	}

	/**
	 * Remove os pagamentos
	 * 
	 * @author Pedro Alexandre
	 * @date 22/03/2006
	 * 
	 * @param idsPagamentos
	 * @param usuarioLogado
	 * 
	 * @throws ControladorException
	 */
	public void removerPagamentos(String[] idsPagamentos, Usuario usuarioLogado)
			throws ControladorException {

		try{
			
			//------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(
			Operacao.OPERACAO_PAGAMENTO_REMOVER,
			new UsuarioAcaoUsuarioHelper(usuarioLogado,
			UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
	
			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_PAGAMENTO_REMOVER);
	
			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			
			//------------ REGISTRAR TRANSAÇÃO ----------------
	
			if (idsPagamentos != null && idsPagamentos.length > 0) {
	
				BigDecimal valorArrecadacao = null;
				AvisoBancario avisoBancario = null;
		
				for (int i = 0; i < idsPagamentos.length; i++) {
					
					String idPagamento = idsPagamentos[i];
			
					FiltroPagamento filtroPagamento = new FiltroPagamento();
			
					filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, idPagamento));
		
					filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAtual");
					filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("pagamentoSituacaoAnterior");
					filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");
					filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.CONTA);
					filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.GUIA_PAGAMENTO);
					filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.DEBITO_A_COBRAR_);
			
					Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento,Pagamento.class.getSimpleName());
		
					Pagamento pagamento;
		
					if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {
						
						pagamento = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);
		
						// Alterado por Bruno Barros data: 08/04/2009
						if ( valorArrecadacao == null ){
							
							valorArrecadacao = pagamento.getAvisoBancario().getValorArrecadacaoCalculado();
							avisoBancario = pagamento.getAvisoBancario();
						}
						
						// [FS0001]
						if (pagamento.getPagamentoSituacaoAtual() != null && 
							pagamento.getPagamentoSituacaoAnterior() != null) {
							
							throw new ControladorException(
									"atencao.pagamento.situacoes.preenchidas",
									null, 
									pagamento.getPagamentoSituacaoAnterior().getDescricao(), 
									pagamento.getPagamentoSituacaoAtual().getDescricao());
						}		
		
						//Alterado por Sávio Luiz data:16/03/2007
						valorArrecadacao = valorArrecadacao.subtract(pagamento.getValorPagamento());
		
						//------------ REGISTRAR TRANSAÇÃO ----------------
						pagamento.setOperacaoEfetuada(operacaoEfetuada);
						pagamento.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
						registradorOperacao.registrarOperacao(pagamento);
						//------------ REGISTRAR TRANSAÇÃO ----------------
				
						getControladorUtil().remover(pagamento);
		
						//Alterado por Francisco - 28/05/08, por conta do Resumo de Ações de cobrança
						//Analista: Ana Breda
						getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(
								pagamento,CobrancaDebitoSituacao.PENDENTE);
						
						//CRC2725 - alterado por Vivianne Sousa - 14/09/2009 analista:Fátima
						//O sistema verifica se há relação do pagamento com itens de negativação
						//[SB0007] - Verifica Associação do Pagamento com Itens de Negativação.
						getControladorSpcSerasa().verificaAssociacaoPagamentoComItensNegativacao(pagamento);
						
					} else {
						
						throw new ControladorException("atencao.registro_remocao_nao_existente");
					}
				}
	
				if ( valorArrecadacao != null ){
					avisoBancario.setValorArrecadacaoCalculado(valorArrecadacao);
					getControladorUtil().atualizar(avisoBancario);
				}
			}
		
		} catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw e;
		}catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Fechado : avisos bancarios com o valor da arrecadação calculado - o valor
	 * da arrecadação informado + (Somatório dos acertos de credito para
	 * arrecadação)- (Somatório dos acertos de debitos para arrecadação) =
	 * avisos bancarios com o valor da devolução calculado - o valor da
	 * devolução informado + (Somatório dos acertos de credito para devolução)-
	 * (Somatório dos acertos de debitos para devolução)
	 * 
	 * @author Viviane Sousa, Raphael Rossiter
	 * @date 23/03/2006
	 * 
	 * @param avisoBancario
	 * @return Uma String que representa a situação do aviso
	 * @throws ControladorException
	 */
	public String obterSituacaoAvisoBancario(AvisoBancario avisoBancario)
			throws ControladorException {

		String retorno = ConstantesSistema.ABERTO;
		BigDecimal vlArrecadacaoCalculado = new BigDecimal("0.00");
		BigDecimal vlArrecadacaoInformado = new BigDecimal("0.00");
		BigDecimal vlAcertosArrecadacao1 = new BigDecimal("0.00");
		BigDecimal vlAcertosArrecadacao2 = new BigDecimal("0.00");
		BigDecimal vlArrecadacaoFinal = new BigDecimal("0.00");

		BigDecimal vlDevolucaoCalculado = new BigDecimal("0.00");
		BigDecimal vlDevolucaoInformado = new BigDecimal("0.00");
		BigDecimal vlAcertosDevolucao1 = new BigDecimal("0.00");
		BigDecimal vlAcertosDevolucao2 = new BigDecimal("0.00");
		BigDecimal vlDevolucaoFinal = new BigDecimal("0.00");

		Object[] objeto = null;
		try {
			objeto = repositorioArrecadacao
					.pesquisarAvisoBancarioAvisoAcertos(avisoBancario.getId());
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		if (objeto[0] != null) {
			vlArrecadacaoCalculado = (BigDecimal) objeto[0];
		}

		if (objeto[1] != null) {
			vlArrecadacaoInformado = (BigDecimal) objeto[1];
		}

		if (objeto[2] != null) {
			vlAcertosArrecadacao1 = (BigDecimal) objeto[2];
		}

		if (objeto[3] != null) {
			vlAcertosArrecadacao2 = (BigDecimal) objeto[3];
		}

		if (objeto[4] != null) {
			vlDevolucaoCalculado = (BigDecimal) objeto[4];
		}

		if (objeto[5] != null) {
			vlDevolucaoInformado = (BigDecimal) objeto[5];
		}

		if (objeto[6] != null) {
			vlAcertosDevolucao1 = (BigDecimal) objeto[6];
		}

		if (objeto[7] != null) {
			vlAcertosDevolucao2 = (BigDecimal) objeto[7];
		}

		vlArrecadacaoFinal = (vlArrecadacaoCalculado
				.subtract(vlArrecadacaoInformado))
				.subtract(vlAcertosArrecadacao1.subtract(vlAcertosArrecadacao2));

		vlDevolucaoFinal = (vlDevolucaoCalculado
				.subtract(vlDevolucaoInformado))
				.subtract(vlAcertosDevolucao1.subtract(vlAcertosDevolucao2));

		if (vlArrecadacaoFinal.compareTo(vlDevolucaoFinal) == 0) {
			retorno = ConstantesSistema.FECHADO;
		}

		return retorno;

	}

	/**
	 * Este caso de uso apresenta a análise do aviso bancário e os
	 * pagamentos/devoluções associados.
	 * 
	 * [UC0267] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Raphael Rossiter,Vivianne Sousa
	 * @date 23/03/2006
	 * 
	 * @param avisoBancario
	 * @return AvisoBancarioHelper
	 */
	public AvisoBancarioHelper apresentarAnaliseAvisoBancario(
			AvisoBancario avisoBancario) throws ControladorException {

		AvisoBancarioHelper retorno = new AvisoBancarioHelper();

		Integer idAvisoBancario = avisoBancario.getId();

		Object[] dadosAvisoBancario = null;
		try {
			dadosAvisoBancario = repositorioArrecadacao
					.pesquisarAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}

		AvisoBancario avisoBancarioCompleto = (AvisoBancario) dadosAvisoBancario[0];

		Short codigoAgenteArrecadador = null;
		String nomeCliente = "";
		Integer idMovimentoArrecadador = null;
		Integer idBancoContaBancaria = (Integer) dadosAvisoBancario[4];
		String codigoAgenciaContaBancaria = (String) dadosAvisoBancario[5];
		String numeroContaBancaria = (String) dadosAvisoBancario[6];
		String descricaoArrecadacaoForma = "";

		if (dadosAvisoBancario[1] != null) {
			codigoAgenteArrecadador = (Short) dadosAvisoBancario[1];
		}
		if (dadosAvisoBancario[2] != null) {
			nomeCliente = (String) dadosAvisoBancario[2];
		}
		if (dadosAvisoBancario[3] != null) {
			idMovimentoArrecadador = (Integer) dadosAvisoBancario[3];
		}
		if (dadosAvisoBancario[7] != null) {
			descricaoArrecadacaoForma = (String) dadosAvisoBancario[7];
		}

		retorno.setCodigoAgenteArrecadador(codigoAgenteArrecadador);
		retorno.setNomeCliente(nomeCliente);
		retorno.setIdMovimentoArrecadador(idMovimentoArrecadador);
		retorno.setIdBancoContaBancaria(idBancoContaBancaria);
		retorno.setCodigoAgenciaContaBancaria(codigoAgenciaContaBancaria);
		retorno.setNumeroContaBancaria(numeroContaBancaria);
		retorno.setDescricaoArrecadacaoForma(descricaoArrecadacaoForma);

		// somatorio do valor das deduções existentes para o aviso bancario
		BigDecimal valorSomatorioDeducoes = null;
		try {
			valorSomatorioDeducoes = repositorioArrecadacao
					.pesquisarSomatorioDeducoesAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}
		retorno.setValorSomatorioDeducoes(valorSomatorioDeducoes);

		Object[] objetoValorAcertosAvisoBancario = null;
		try {
			objetoValorAcertosAvisoBancario = repositorioArrecadacao
					.pesquisarValorAcertosAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}
		// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
		// = 1
		// e AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela
		// AVISO_BANCARIO
		BigDecimal valorSomatorioAcertoCreditoArrecadacao = new BigDecimal(
				"0.00");
		// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
		// = 2
		// e AVAC_ICARRECADACAODEVOLUCAO = 1 com AVBC_ID = AVBC da tabela
		// AVISO_BANCARIO
		BigDecimal valorSomatorioAcertoDebitoArrecadacao = new BigDecimal(
				"0.00");
		// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
		// = 1
		// e AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela
		// AVISO_BANCARIO
		BigDecimal valorSomatorioAcertoCreditoDevolucao = new BigDecimal("0.00");
		// somatorio (AVAC_VLACERTO) da tabela AVISO_Acertos com AVAC_ICCREDITO
		// = 2
		// e AVAC_ICARRECADACAODEVOLUCAO = 2 com AVBC_ID = AVBC da tabela
		// AVISO_BANCARIO
		BigDecimal valorSomatorioAcertoDebitoDevolucao = new BigDecimal("0.00");

		if (objetoValorAcertosAvisoBancario[0] != null) {
			valorSomatorioAcertoCreditoArrecadacao = (BigDecimal) objetoValorAcertosAvisoBancario[0];
		}
		if (objetoValorAcertosAvisoBancario[1] != null) {
			valorSomatorioAcertoDebitoArrecadacao = (BigDecimal) objetoValorAcertosAvisoBancario[1];
		}
		if (objetoValorAcertosAvisoBancario[2] != null) {
			valorSomatorioAcertoCreditoDevolucao = (BigDecimal) objetoValorAcertosAvisoBancario[2];
		}
		if (objetoValorAcertosAvisoBancario[3] != null) {
			valorSomatorioAcertoDebitoDevolucao = (BigDecimal) objetoValorAcertosAvisoBancario[3];
		}

		retorno
				.setValorSomatorioAcertosArrecadacao(valorSomatorioAcertoCreditoArrecadacao
						.subtract(valorSomatorioAcertoDebitoArrecadacao));
		retorno
				.setValorSomatorioAcertosDevolucao(valorSomatorioAcertoCreditoDevolucao
						.subtract(valorSomatorioAcertoDebitoDevolucao));

		BigDecimal valorArrecadacaoCalculado = avisoBancarioCompleto
				.getValorArrecadacaoCalculado();
		BigDecimal valorArrecadacaoInformado = avisoBancarioCompleto
				.getValorArrecadacaoInformado();
		BigDecimal valorDevolucaoCalculado = avisoBancarioCompleto
				.getValorDevolucaoCalculado();
		BigDecimal valorDevolucaoInformado = avisoBancarioCompleto
				.getValorDevolucaoInformado();

		// (valor da Arrecadação calculado - valor da Arrecadação informado +
		// Somatório dos Acertos da Arrecadação)-
		// (valor da Devolução calculado - valor da Devolução informado +
		// Somatório dos Acertos da Devolução)
		BigDecimal valorDiferencaArrecadacaoDevolucao = new BigDecimal("0.00");
		valorDiferencaArrecadacaoDevolucao = (valorArrecadacaoCalculado
				.subtract(valorArrecadacaoInformado))
				.subtract(valorSomatorioAcertoCreditoArrecadacao
						.subtract(valorSomatorioAcertoDebitoArrecadacao));
		valorDiferencaArrecadacaoDevolucao = valorDiferencaArrecadacaoDevolucao
				.subtract(
						valorDevolucaoCalculado
								.subtract(valorDevolucaoInformado)).subtract(
						valorSomatorioAcertoCreditoDevolucao
								.subtract(valorSomatorioAcertoDebitoDevolucao));
		retorno
				.setValorDiferencaArrecadacaoDevolucao(valorDiferencaArrecadacaoDevolucao);

		retorno.setAvisoBancario(avisoBancarioCompleto);

		if (valorDiferencaArrecadacaoDevolucao
				.compareTo(new BigDecimal("0.00")) == 0) {
			retorno.setSituacao(ConstantesSistema.FECHADO);
		} else {
			retorno.setSituacao(ConstantesSistema.ABERTO);
		}

		// Tipo de aviso ("CRÉDITO", caso AVBC_ICCREDITODEBITO = 1,
		// caso contrário, "DÉBITO")
		if (avisoBancarioCompleto.getIndicadorCreditoDebito().equals(
				AvisoBancario.INDICADOR_CREDITO)) {
			retorno.setTipoAviso(AvisoBancario.CREDITO);
		} else {
			retorno.setTipoAviso(AvisoBancario.DEBITO);
		}

		/*
		 * Lista de pagamentos relacionados ao aviso bancário
		 */
		Collection colecaoDadosPagamentos = null;
		try {
			colecaoDadosPagamentos = repositorioArrecadacao
					.pesquisarPagamentoAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}
		Collection<Pagamento> colecaoPagamentos = new ArrayList<Pagamento>();

		if (colecaoDadosPagamentos != null) {

			Iterator iter = colecaoDadosPagamentos.iterator();

			while (iter.hasNext()) {

				Object[] dadosPagamentos = (Object[]) iter.next();
				Pagamento pagamento = new Pagamento();

				DocumentoTipo documentoTipo = new DocumentoTipo();
				Localidade localidade = new Localidade();
				Imovel imovel = new Imovel();
				Cliente cliente = new Cliente();
				DebitoTipo debitoTipo = new DebitoTipo();
				PagamentoSituacao pagamentoSituacaoAtual = new PagamentoSituacao();

				documentoTipo
						.setDescricaoAbreviado((String) dadosPagamentos[0]);
				pagamento.setDocumentoTipo(documentoTipo);

				pagamento.setDataPagamento((Date) dadosPagamentos[1]);

				localidade.setId((Integer) dadosPagamentos[2]);
				pagamento.setLocalidade(localidade);

				imovel.setId((Integer) dadosPagamentos[3]);
				pagamento.setImovel(imovel);

				cliente.setId((Integer) dadosPagamentos[4]);
				pagamento.setCliente(cliente);

				pagamento
						.setAnoMesReferenciaPagamento((Integer) dadosPagamentos[5]);

				debitoTipo.setId((Integer) dadosPagamentos[6]);
				pagamento.setDebitoTipo(debitoTipo);

				pagamento.setValorPagamento((BigDecimal) dadosPagamentos[7]);

				pagamentoSituacaoAtual
						.setDescricaoAbreviada((String) dadosPagamentos[8]);
				pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

				colecaoPagamentos.add(pagamento);
			}

			retorno.setColecaoPagamentos(colecaoPagamentos);
			
		}
		/**
		 * Alteração feita por Arthur Carvalho
		 * @date 12/05/2010
		 */
		
		Collection colecaoDadosPagamentoHistorico = null;
		try {
			colecaoDadosPagamentoHistorico = repositorioArrecadacao
					.pesquisarPagamentoHistoricoAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}
		
		if (colecaoDadosPagamentoHistorico != null) {

			Iterator iter = colecaoDadosPagamentoHistorico.iterator();

			while (iter.hasNext()) {

				Object[] dadosPagamentos = (Object[]) iter.next();
				Pagamento pagamento = new Pagamento();

				DocumentoTipo documentoTipo = new DocumentoTipo();
				Localidade localidade = new Localidade();
				Imovel imovel = new Imovel();
				Cliente cliente = new Cliente();
				DebitoTipo debitoTipo = new DebitoTipo();
				PagamentoSituacao pagamentoSituacaoAtual = new PagamentoSituacao();

				documentoTipo
						.setDescricaoAbreviado((String) dadosPagamentos[0]);
				pagamento.setDocumentoTipo(documentoTipo);

				pagamento.setDataPagamento((Date) dadosPagamentos[1]);

				localidade.setId((Integer) dadosPagamentos[2]);
				pagamento.setLocalidade(localidade);

				imovel.setId((Integer) dadosPagamentos[3]);
				pagamento.setImovel(imovel);

				cliente.setId((Integer) dadosPagamentos[4]);
				pagamento.setCliente(cliente);

				pagamento
						.setAnoMesReferenciaPagamento((Integer) dadosPagamentos[5]);
				
				debitoTipo.setId((Integer) dadosPagamentos[6]);
				pagamento.setDebitoTipo(debitoTipo);

				pagamento.setValorPagamento((BigDecimal) dadosPagamentos[7]);

				pagamentoSituacaoAtual
						.setDescricaoAbreviada((String) dadosPagamentos[8]);
				pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
				//Usado no relatorio para informar os pagamentos historicos.
				pagamento.setIndicadorPagamento(ConstantesSistema.SIM);

				colecaoPagamentos.add(pagamento);
			}

			retorno.setColecaoPagamentos(colecaoPagamentos);
			
		}
		
		

		/*
		 * Lista das devoluções relacionados ao aviso bancário
		 */

		Collection colecaoDadosDevolucoes = null;
		try {
			colecaoDadosDevolucoes = repositorioArrecadacao
					.pesquisarDevolucaoAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}

		if (colecaoDadosDevolucoes != null) {
			Collection<Devolucao> colecaoDevolucoes = new ArrayList<Devolucao>();

			Iterator iter = colecaoDadosDevolucoes.iterator();

			while (iter.hasNext()) {

				Object[] dadosDevolucoes = (Object[]) iter.next();
				Devolucao devolucao = new Devolucao();

				GuiaDevolucao guiaDevolucao = new GuiaDevolucao();
				DocumentoTipo documentoTipo = new DocumentoTipo();
				Localidade localidade = new Localidade();
				Imovel imovel = new Imovel();
				Cliente cliente = new Cliente();
				DebitoTipo debitoTipo = new DebitoTipo();
				DevolucaoSituacao devolucaoSituacaoAtual = new DevolucaoSituacao();

				documentoTipo
						.setDescricaoAbreviado((String) dadosDevolucoes[0]);
				guiaDevolucao.setDocumentoTipo(documentoTipo);
				devolucao.setGuiaDevolucao(guiaDevolucao);

				devolucao.setDataDevolucao((Date) dadosDevolucoes[1]);

				localidade.setId((Integer) dadosDevolucoes[2]);
				devolucao.setLocalidade(localidade);

				imovel.setId((Integer) dadosDevolucoes[3]);
				devolucao.setImovel(imovel);

				cliente.setId((Integer) dadosDevolucoes[4]);
				devolucao.setCliente(cliente);

				devolucao
						.setAnoMesReferenciaDevolucao((Integer) dadosDevolucoes[5]);

				debitoTipo.setId((Integer) dadosDevolucoes[6]);
				devolucao.setDebitoTipo(debitoTipo);

				devolucao.setValorDevolucao((BigDecimal) dadosDevolucoes[7]);

				devolucaoSituacaoAtual
						.setDescricaoAbreviado((String) dadosDevolucoes[8]);
				devolucao.setDevolucaoSituacaoAtual(devolucaoSituacaoAtual);

				colecaoDevolucoes.add(devolucao);
			}

			retorno.setColecaoDevolucoes(colecaoDevolucoes);

		}

		return retorno;
	}

	/**
	 * Seleciona os pagamentos histórios de um aviso
	 * 
	 * @author Rafael Corrêa
	 * @date 23/04/2007
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoHistoricoAvisoBancario(
			Integer idAvisoBancario) throws ControladorException {

		Collection colecaoPagamentosHistoricos = new ArrayList();
		Collection colecaoDadosPagamentos = null;
		try {
			colecaoDadosPagamentos = repositorioArrecadacao
					.pesquisarPagamentoHistoricoAvisoBancario(idAvisoBancario);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema");
		}

		if (colecaoDadosPagamentos != null) {

			Iterator iter = colecaoDadosPagamentos.iterator();

			while (iter.hasNext()) {

				Object[] dadosPagamentos = (Object[]) iter.next();
				PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

				DocumentoTipo documentoTipo = new DocumentoTipo();
				Localidade localidade = new Localidade();
				Imovel imovel = new Imovel();
				Cliente cliente = new Cliente();
				DebitoTipo debitoTipo = new DebitoTipo();
				PagamentoSituacao pagamentoSituacaoAtual = new PagamentoSituacao();

				documentoTipo
						.setDescricaoAbreviado((String) dadosPagamentos[0]);
				pagamentoHistorico.setDocumentoTipo(documentoTipo);

				pagamentoHistorico.setDataPagamento((Date) dadosPagamentos[1]);

				localidade.setId((Integer) dadosPagamentos[2]);
				pagamentoHistorico.setLocalidade(localidade);

				imovel.setId((Integer) dadosPagamentos[3]);
				pagamentoHistorico.setImovel(imovel);

				cliente.setId((Integer) dadosPagamentos[4]);
				pagamentoHistorico.setCliente(cliente);

				pagamentoHistorico
						.setAnoMesReferenciaPagamento((Integer) dadosPagamentos[5]);

				debitoTipo.setId((Integer) dadosPagamentos[6]);
				pagamentoHistorico.setDebitoTipo(debitoTipo);

				pagamentoHistorico
						.setValorPagamento((BigDecimal) dadosPagamentos[7]);

				pagamentoSituacaoAtual
						.setDescricaoAbreviada((String) dadosPagamentos[8]);
				pagamentoHistorico
						.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

				colecaoPagamentosHistoricos.add(pagamentoHistorico);
			}

		}

		return colecaoPagamentosHistoricos;

	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Pesquisa o débito a cobrar do imóvel informado pelo usuário
	 * 
	 * [FS0024] - Verificar existência do débito a cobrar
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param idImovel
	 * @param idDebitoACobrar
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrar pesquisarDebitoACobrarDigitado(String idImovel,
			String idDebitoACobrar) throws ControladorException {

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrar debitoACobrarDigitado = null;

		// Cria o filtro de débito a cobrar e seta todos os parâmetros para
		// pesquisar o débito a cobrar do imóvel
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.ID, idDebitoACobrar));
		filtroDebitoACobrar
				.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrar
				.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(
				filtroDebitoACobrar, DebitoACobrar.class.getName());

		// Caso exista o débito a cobrar para o imóvel informado cadastrado no
		// sistema
		// Retorna para o usuário o débito a cobrar retornado pela pesquisa
		// Caso contrário retorna um objeto nulo
		if (colecaoDebitoACobrar == null || colecaoDebitoACobrar.isEmpty()) {
			throw new ControladorException("atencao.pesquisa_inexistente",
					null, "Débito a Cobrar");
		}
		debitoACobrarDigitado = (DebitoACobrar) Util
				.retonarObjetoDeColecao(colecaoDebitoACobrar);

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrarDigitado;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Pesquisa a guia de pagamento do imóvel informado pelo usuário
	 * 
	 * [FS0022] - Verificar existência da guia de pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param idImovel
	 * @param idCliente
	 * @param idGuiaPagamento
	 * @return
	 * @throws ControladorException
	 */
	public GuiaPagamento pesquisarGuiaPagamentoDigitada(String idImovel,
			String idCliente, String idGuiaPagamento)
			throws ControladorException {

		// Cria a variável que vai armazenar a guia de pagamento pequisada
		GuiaPagamento guiaPagamentoDigitada = null;

		// Cria o filtro de guia de pagamento
		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();

		// Caso o usuário tenha informado o imóvel, seta o código do imóvel no
		// filtro
		// Caso contrário, o usuário tenha informado o cliente seta o código do
		// cliente no filtro
		// Caso o usuário não tenha informado nem o imóvel nem o cliente levanta
		// uma exceção
		// para o usuário informando que tem de informar o cliente ou o imóvel
		if (idImovel != null && !idImovel.trim().equalsIgnoreCase("")) {
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.IMOVEL_ID, idImovel));
		} else if (idCliente != null && !idCliente.trim().equalsIgnoreCase("")) {
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.CLIENTE_ID, idCliente));
		} else {
			throw new ControladorException("atencao.naoinformado", null,
					"Imóvel ou Cliente");
		}

		// Pesquisa a guia de pagamento de acordo com os parâmetros no filtro
		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
				FiltroGuiaPagamento.ID, idGuiaPagamento));

		filtroGuiaPagamento
				.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroGuiaPagamento
				.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(
				filtroGuiaPagamento, GuiaPagamento.class.getName());

		// Caso exista a guia de pagamento para o imóvel ou o cliente informado
		// cadastrado no sistema
		// Retorna para o usuário a guia de pagamento retornada pela pesquisa
		// Caso contrário retorna um objeto nulo
		if (colecaoGuiaPagamento == null || colecaoGuiaPagamento.isEmpty()) {
			throw new ControladorException("atencao.pesquisa_inexistente",
					null, "Guia de Pagamento");
		}
		guiaPagamentoDigitada = (GuiaPagamento) Util
				.retonarObjetoDeColecao(colecaoGuiaPagamento);

		// Retorna a guia de pagamento encontrada ou nulo se não existir aa guia
		// de pagamento
		return guiaPagamentoDigitada;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica se o usuário informou o código da guia de pagamento e o tipo de
	 * débito, só pode ser informado um dos dois
	 * 
	 * [FS0021] Verificar preenchimento da guia de pagamento e do tipo de débito
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param idGuiaPagamento
	 * @param idTipoDebito
	 * @throws ControladorException
	 */
	public void verificarPreeenchimentoGuiaPagamentoETipoDebito(
			String idGuiaPagamento, String idTipoDebito)
			throws ControladorException {

		// Caso o usuário não informou a guia de pagamento
		if (idGuiaPagamento == null
				|| idGuiaPagamento.trim().equalsIgnoreCase("")) {
			// Caso o usuário não informou o tipo de débito, levanta uma exceção
			// para o usário
			// indicando que o usuário precisa informar ou a guia ou o tipo de
			// débito
			if (idTipoDebito == null
					|| idTipoDebito.trim().equalsIgnoreCase("")) {
				throw new ControladorException("atencao.naoinformado", null,
						"Guia Pagamento ou Tipo de Débito");
			}
		} else {
			// Caso o usuário informou a guia de pagamento e o tipo de débito,
			// levanta uma exceção para o usário indicando que o usuário
			// informou a guia e o tipo de débito
			if (idTipoDebito != null
					&& !idTipoDebito.trim().equalsIgnoreCase("")) {
				throw new ControladorException(
						"atencao.guia_pagamento_tipo_debito_informado");
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica se o usuário informou o código do débito a cobrar e o tipo de
	 * débito, só pode ser informado um dos dois
	 * 
	 * [FS0023] Verificar preenchimento do débito a cobrar e do tipo de débito
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param idDebitoACobrar
	 * @param idTipoDebito
	 * @throws ControladorException
	 */
	public void verificarPreeenchimentoDebitoACobrarETipoDebito(
			String idDebitoACobrar, String idTipoDebito)
			throws ControladorException {

		// Caso o usuário não informou o débito a cobrar
		if (idDebitoACobrar == null
				|| idDebitoACobrar.trim().equalsIgnoreCase("")) {
			// Caso o usuário não informou o tipo de débito, levanta uma exceção
			// para o usário
			// indicando que o usuário precisa informar ou o débito a cobrar ou
			// o tipo de débito
			if (idTipoDebito == null
					|| idTipoDebito.trim().equalsIgnoreCase("")) {
				throw new ControladorException("atencao.naoinformado", null,
						"Débito a Cobrar ou Tipo de Débito");
			}
		} else {
			// Caso o usuário informou o débito a cobrar e o tipo de débito,
			// levanta uma exceção
			// para o usário indicando que o usuário informou o débito a cobrar
			// e o tipo de débito
			if (idTipoDebito != null
					&& !idTipoDebito.trim().equalsIgnoreCase("")) {
				throw new ControladorException(
						"atencao.debto_a_cobrar_tipo_debito_informado");
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica se a localidade informada é a mesma da guia de pagamento
	 * 
	 * [FS0014] Verificar localidade da guia de pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param guiaPagamento
	 * @param idLocalidade
	 * @throws ControladorException
	 */
	public void verificarLocalidadeGuiaPagamento(GuiaPagamento guiaPagamento,
			String idLocalidade) throws ControladorException {

		// Caso o usuário tenha informado a localidade
		if (idLocalidade != null && !idLocalidade.trim().equalsIgnoreCase("")) {
			// Caso a localidade da guia de pagamento seja diferente da
			// localidade informada
			if (!guiaPagamento.getLocalidade().getId().equals(
					new Integer(idLocalidade))) {

				// Cria a mensagem que vai ser exibida ao usuário
				// e levanta a exceção
				String mensagem = "A Localidade da Guia de Pagamento "
						+ guiaPagamento.getLocalidade().getId()
						+ " é diferente da Localidade informada "
						+ idLocalidade;
				throw new ControladorException(
						"atencao.localidade_guia_pagamento_diferente", null,
						mensagem);
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica se a localidade informada é a mesma do débito a cobrar
	 * 
	 * [FS0017] Verificar localidade do débito a cobrar
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param debitoACobrar
	 * @param idLocalidade
	 * @throws ControladorException
	 */
	public void verificarLocalidadeDebitoACobrar(DebitoACobrar debitoACobrar,
			String idLocalidade) throws ControladorException {
		// Caso o usuário tenha informado a localidade
		if (idLocalidade != null && !idLocalidade.trim().equalsIgnoreCase("")) {

			// Caso a localidade do débito a cobrar seja diferente da localidade
			// informada
			if (!debitoACobrar.getLocalidade().getId().equals(
					new Integer(idLocalidade))) {

				// Cria a mensagem que vai ser exibida ao usuário
				// e levanta a exceção
				String mensagem = "A Localidade do Débito a Cobrar "
						+ debitoACobrar.getLocalidade().getId()
						+ " é diferente da Localidade informada "
						+ idLocalidade;
				throw new ControladorException(
						"atencao.localidade_debito_a_cobrar_diferente", null,
						mensagem);
			}
		}
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica a existência de débito a cobrar com o tipo de débito e o imóvel
	 * informados
	 * 
	 * [FS0016] Verificar existência de débito a cobrar com tipo de débito
	 * informado
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param tipoDebito
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrar verificarExistenciaDebitoACobrarComTipoDebito(
			DebitoTipo tipoDebito, String idImovel, BigDecimal valorInformado) throws ControladorException {

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrar debitoACobrar = null;

		// Cria o filtro de débito a cobrar, e seta os parâmetros para pesquisar
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.DEBITO_TIPO_ID, tipoDebito.getId()));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
				DebitoCreditoSituacao.NORMAL));

		// Pesquisa o débito a cobrar no sistema
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(
				filtroDebitoACobrar, DebitoACobrar.class.getName());
		
		Collection colecaoComValor = new ArrayList();

		// Caso exista débito a cobrar cadastrado com o tipo de débito informado
		if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {

			// Caso exista mais que um débito a cobrar cadastrado para o tipo de
			// débito
			// Monta a mensagem para o usuário e levanta a exceção
			if (colecaoDebitoACobrar.size() > 1) {
				Iterator iteratorColecao = colecaoDebitoACobrar.iterator();
				
				while(iteratorColecao.hasNext()){
					DebitoACobrar debitoACobrarColecao = (DebitoACobrar)iteratorColecao.next(); 
					
					BigDecimal valorFaltaDebito = BigDecimal.ZERO;
				      
					BigDecimal valorDebito = debitoACobrarColecao.getValorDebito();
				    short numeroPrestacaoDebito = debitoACobrarColecao.getNumeroPrestacaoDebito();
				    short numeroPrestacaoCobrada = debitoACobrarColecao.getNumeroPrestacaoCobradas();
				      
				    valorDebito = valorDebito.divide(new BigDecimal(numeroPrestacaoDebito+""));
				      
				    valorFaltaDebito = valorFaltaDebito.add(debitoACobrarColecao.getValorDebito());
				    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
				      
				    valorFaltaDebito = valorFaltaDebito.multiply(new BigDecimal(numeroPrestacaoCobrada+""));
			      
			      
				  if(valorInformado.equals(valorFaltaDebito)){
					
					  colecaoComValor.add(debitoACobrarColecao);
			      }
				}
				
				if(colecaoComValor.size() > 1){
					String mensagem = "Há mais de um Débito a Cobrar com o tipo de débito "
						+ tipoDebito.getDescricao()
						+ " para o Imóvel "
						+ idImovel;
					throw new ControladorException("atencao.descricao_concatenada",
						null, mensagem);
				}
				debitoACobrar = (DebitoACobrar) Util
				.retonarObjetoDeColecao(colecaoComValor);
			} else {
				// Caso só exista apenas um débito a cobrar cadastrado para o
				// tipo de débito
				debitoACobrar = (DebitoACobrar) Util
						.retonarObjetoDeColecao(colecaoDebitoACobrar);
				
				BigDecimal valorFaltaDebito = BigDecimal.ZERO;
			      
				BigDecimal valorDebito = debitoACobrar.getValorDebito();
			    short numeroPrestacaoDebito = debitoACobrar.getNumeroPrestacaoDebito();
			    short numeroPrestacaoCobrada = debitoACobrar.getNumeroPrestacaoCobradas();
			      
			    valorDebito = valorDebito.divide(new BigDecimal(numeroPrestacaoDebito+""));
			      
			    valorFaltaDebito = valorFaltaDebito.add(debitoACobrar.getValorDebito());
			    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
			      
			    valorFaltaDebito = valorFaltaDebito.multiply(new BigDecimal(numeroPrestacaoCobrada+""));
		      
		      
		      if(!valorInformado.equals(valorFaltaDebito)){
		    	  debitoACobrar = null;
		      }
			}
		}

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrar;
	}

	/**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica a existência de guia de pagamento com o tipo de débito e o
	 * imóvel informados
	 * 
	 * [FS0013] Verificar existência de guia de pagamento com tipo de débito
	 * informado
	 * 
	 * @author Pedro Alexandre
	 * @date 16/02/2006
	 * 
	 * @param tipoDebito
	 * @param idImovel
	 * @param idCliente
	 * @return
	 * @throws ControladorException
	 */
	public GuiaPagamento verificarExistenciaGuiaPagamentoComTipoDebito(
			DebitoTipo tipoDebito, String idImovel, String idCliente)
			throws ControladorException {

		// Cria a variável que vai armazenar a guia de pagamento pesquisada
		GuiaPagamento guiaPagamento = null;

		// Cria o filtro de guia de pagamento, e seta os parâmetros para
		// pesquisar
		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
				FiltroGuiaPagamento.DEBITO_TIPO_ID, tipoDebito.getId()));
		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
				FiltroGuiaPagamento.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
				DebitoCreditoSituacao.NORMAL));

		// Caso o usuário tenha informado a matrícula do imóvel,
		// seta a metrículo do imóvel no filtro
		// Caso contrário seta o códigodo cliente no filtro
		if (idImovel != null && !idImovel.trim().equalsIgnoreCase("")) {
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.IMOVEL_ID, idImovel));
		} else {
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.CLIENTE_ID, idCliente));
		}

		// Pesquisa as guias de pagamento no sistema
		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(
				filtroGuiaPagamento, GuiaPagamento.class.getName());

		// Caso exista guia de pagamento cadastrada no sistema com os parâmetros
		// informados no filtro
		if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {

			// Caso exista mais que uma guia de pagamento cadastrada
			if (colecaoGuiaPagamento.size() > 1) {

				// Cria a variável que vai armazenar a mensagem que vai ser
				// exibida ao usuário
				String mensagem = null;

				// Caso a pequisa foi para imóvel
				// Cria a mensagem para imóvel
				// Caso contrário cria a mensagem para cliente
				if (idImovel != null && !idImovel.trim().equalsIgnoreCase("")) {
					mensagem = "Há mais de uma Guia de Pagamento com o tipo de débito "
							+ tipoDebito.getDescricao()
							+ " para o Imóvel "
							+ idImovel
							+ ". Efetue uma pesquisa para selecionar a Guia";
				} else {
					mensagem = "Há mais de uma Guia de Pagamento com o tipo de débito "
							+ tipoDebito.getDescricao()
							+ " para o Cliente "
							+ idCliente
							+ ". Efetue uma pesquisa para selecionar a Guia";
				}

				// levanta a exceção para o usuário com a mensagem criada
				throw new ControladorException("atencao.descricao_concatenada",
						null, mensagem);

			}
			// Caso só exista apenas uma guia de pagamento cadastrada para o
			// tipo de débito
			guiaPagamento = (GuiaPagamento) Util
					.retonarObjetoDeColecao(colecaoGuiaPagamento);
		}

		// Retorna a guia de pagamento encontrada ou nulo se não existir a guia
		// de pagamento
		return guiaPagamento;
	}

	/**
	 * Responsável pela manutenção das informações de pagamento
	 * 
	 * [UC0266] Manter Pagamentos
	 * [SB0001] Atualizar Pagamento
	 * 
	 * @param pagamento
	 * @throws ControladorException
	 */
	public void atualizarPagamento(Pagamento pagamento) throws ControladorException {

		try{
			FiltroPagamento filtroPagamento = new FiltroPagamento();
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, pagamento.getId()));
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("contaGeral.conta");
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade("guiaPagamento");
			filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.CONTA_HISTORICO);
			
			Pagamento pagamentoNaBase = (Pagamento) ((List) (getControladorUtil().pesquisar(filtroPagamento, Pagamento.class.getName()))).get(0);
	
			// [FS0017] Atualização realizada por outro usuário
			// Caso o usuário esteja tentando atualizar um pagamento e o mesmo já tenha
			// sido atualizado durante a manutençaõ corrente
			if (pagamentoNaBase.getUltimaAlteracao().after(pagamento.getUltimaAlteracao())) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("atencao.atualizacao.timestamp");
			}
	
			if (!pagamento.getValorPagamento().equals(pagamentoNaBase.getValorPagamento())) {
	
				BigDecimal valorAModificar = pagamento.getValorPagamento().subtract(pagamentoNaBase.getValorPagamento());
	
				AvisoBancario avisoBancario = pagamento.getAvisoBancario();
				BigDecimal valorArrecadacao = avisoBancario.getValorArrecadacaoCalculado();
				valorArrecadacao = valorArrecadacao.add(valorAModificar);
				avisoBancario.setValorArrecadacaoCalculado(valorArrecadacao);
				avisoBancario.setUltimaAlteracao(new Date());
	
				getControladorUtil().atualizar(avisoBancario);
			}
	
			pagamento.setUltimaAlteracao(new Date());
	
			getControladorUtil().atualizar(pagamento);
			
			getControladorSpcSerasa().verificaAssociacaoPagamentoComItensNegativacao(pagamento, pagamentoNaBase);

		} catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw e;
		}catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	protected ControladorBatchLocal getControladorBatch() {
		ControladorBatchLocalHome localHome = null;
		ControladorBatchLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorBatchLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_BATCH_SEJB);
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}

	}
	
	private ControladorTransacaoLocal getControladorTransacao() {
		ControladorTransacaoLocalHome localHome = null;
		ControladorTransacaoLocal local = null;

		// pega a instância do ServiceLocator.

		ServiceLocator locator = null;

		try {
			locator = ServiceLocator.getInstancia();

			localHome = (ControladorTransacaoLocalHome) locator
					.getLocalHome(ConstantesJNDI.CONTROLADOR_TRANSACAO_SEJB);
			// guarda a referencia de um objeto capaz de fazer chamadas
			// objetos remotamente
			local = localHome.create();

			return local;
		} catch (CreateException e) {
			throw new SistemaException(e);
		} catch (ServiceLocatorException e) {
			throw new SistemaException(e);
		}

	}
	
	/**
	 * Gera os dados diários da arrecadação acumulando a quantidade e o valor
	 * dos pagamentos
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 11/04/2006, 08/12/2006
	 * 
	 * @throws ControladorException
	 */
	public void gerarDadosDiariosArrecadacao(int idFuncionalidadeIniciada,
			Collection<Integer> colecaoIdsLocalidades)
 throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.LOCALIDADE, (Integer) Util.retonarObjetoDeColecao(colecaoIdsLocalidades));

		Collection colecaoDadosDiariosArrecadacaoInserir = null;

		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

		int anoMesArrecadacaoSistemaParametro = getSistemaParametro().getAnoMesArrecadacao();

		ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;
		DevolucaoDadosDiarios devolucaoDadosDiarios = null;

		Imovel imovel = null;
		Localidade localidade = null;
		SetorComercial setorComercial = null;
		Rota rota = null;
		Quadra quadra = null;
		int codigoSetorComercial = 0;
		int numeroQuadra = 0;
		ImovelPerfil perfilImovel = null;
		LigacaoAguaSituacao situacaoLigacaoAgua = null;
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = null;
		Categoria principalCategoria = null;
		EsferaPoder esferaPoder = null;
		Short indicadorHidrometro = null;
		BigDecimal somaValor = null;
		Integer quantidade = null;
		AvisoBancario avisoBancario = null;
		Arrecadador arrecadador = null;
		UnidadeNegocio unidadeNegocio = null;
		GerenciaRegional gerenciaRegional = null;
		DocumentoTipo documentoTipo = null;
		ArrecadacaoForma arrecadacaoForma = null;
		Date dataPagamento = null;
		Date dataDevolucao = null;
		DocumentoTipo documentoTipoAgregador = null;

		Integer qtdDocumentosAgregados = null;

		Collection colecaoDadosPagamentos = null;
		Collection colecaoDadosDevolucoes = null;
		boolean concluiuComSucesso = false;

		try {

			if (colecaoIdsLocalidades != null && !colecaoIdsLocalidades.isEmpty()) {
				int cont = 0;
				for (Integer idLocalidade : colecaoIdsLocalidades) {

					Collection<Integer> colecaoAnoMesReferenciaPagamentos = repositorioArrecadacao
							.pesquisarAnoMesArrecadacaoPagamentoMaiorIgualAnoMesArrecadacaoAtual(anoMesArrecadacaoSistemaParametro, idLocalidade);

					if (colecaoAnoMesReferenciaPagamentos != null && !colecaoAnoMesReferenciaPagamentos.isEmpty()) {

						colecaoDadosDiariosArrecadacaoInserir = new ArrayList();

						for (Integer anoMesArrecadacaoAtual : colecaoAnoMesReferenciaPagamentos) {

							logger.info("Ano mes arrecadacao: " + anoMesArrecadacaoAtual);
							repositorioArrecadacao.excluirDadosDiariosArrecadacaoPorAnoMesArrecadacaoPorLocalidade(anoMesArrecadacaoAtual, idLocalidade);

							localidade = new Localidade();
							localidade.setId(idLocalidade);
							cont = 0;

							gerarDadosDiariosArrecadacaoAuxiliar(idLocalidade, anoMesArrecadacaoAtual);

							colecaoDadosPagamentos = repositorioArrecadacao.acumularQuantidadeEValorPagamentoPorAnoMesArrecadacao(anoMesArrecadacaoAtual, localidade.getId());

							if (colecaoDadosPagamentos != null) {

								for (Object dadosPagamento : colecaoDadosPagamentos) {

									Object[] arrayDadosPagamento = (Object[]) dadosPagamento;

									if (arrayDadosPagamento != null) {
										if (arrayDadosPagamento[0] != null) {
											imovel = new Imovel((Integer) arrayDadosPagamento[0]);
										} else {
											imovel = null;
										}

										if (arrayDadosPagamento[1] != null) {
											somaValor = (BigDecimal) arrayDadosPagamento[1];
										} else {
											somaValor = null;
										}

										if (arrayDadosPagamento[2] != null) {
											quantidade = (Integer) arrayDadosPagamento[2];
										} else {
											quantidade = null;
										}

										if (arrayDadosPagamento[3] != null) {
											setorComercial = new SetorComercial((Integer) arrayDadosPagamento[3]);
										} else {
											setorComercial = null;
										}

										if (arrayDadosPagamento[4] != null) {
											codigoSetorComercial = (Integer) arrayDadosPagamento[4];
										} else {
											codigoSetorComercial = 0;
										}

										if (arrayDadosPagamento[5] != null) {
											rota = new Rota((Integer) arrayDadosPagamento[5]);
										} else {
											rota = null;
										}

										if (arrayDadosPagamento[6] != null) {
											quadra = new Quadra((Integer) arrayDadosPagamento[6]);
										} else {
											quadra = null;
										}

										if (arrayDadosPagamento[7] != null) {
											numeroQuadra = (Integer) arrayDadosPagamento[7];
										} else {
											numeroQuadra = 0;
										}

										if (arrayDadosPagamento[8] != null) {
											perfilImovel = new ImovelPerfil((Integer) arrayDadosPagamento[8]);
										} else {
											perfilImovel = null;
										}

										if (arrayDadosPagamento[9] != null) {
											situacaoLigacaoAgua = new LigacaoAguaSituacao((Integer) arrayDadosPagamento[9]);
										} else {
											situacaoLigacaoAgua = null;
										}

										if (arrayDadosPagamento[10] != null) {
											situacaoLigacaoEsgoto = new LigacaoEsgotoSituacao((Integer) arrayDadosPagamento[10]);
										} else {
											situacaoLigacaoEsgoto = null;
										}

										if (arrayDadosPagamento[11] != null) {
											gerenciaRegional = new GerenciaRegional((Integer) arrayDadosPagamento[11]);
										} else {
											gerenciaRegional = null;
										}

										if (arrayDadosPagamento[12] != null) {
											avisoBancario = new AvisoBancario((Integer) arrayDadosPagamento[12]);
										} else {
											avisoBancario = null;
										}

										if (arrayDadosPagamento[13] != null) {
											arrecadador = new Arrecadador((Integer) arrayDadosPagamento[13]);
										} else {
											arrecadador = null;
										}

										if (arrayDadosPagamento[14] != null) {
											documentoTipo = new DocumentoTipo((Integer) arrayDadosPagamento[14]);
										} else {
											documentoTipo = null;
										}

										if (arrayDadosPagamento[15] != null) {
											arrecadacaoForma = new ArrecadacaoForma((Integer) arrayDadosPagamento[15]);
										} else {
											arrecadacaoForma = null;
										}

										if (arrayDadosPagamento[16] != null) {
											dataPagamento = (Date) arrayDadosPagamento[16];
										} else {
											dataPagamento = null;
										}

										if (arrayDadosPagamento[17] != null) {
											unidadeNegocio = new UnidadeNegocio((Integer) arrayDadosPagamento[17]);
										} else {
											unidadeNegocio = null;
										}

										if (arrayDadosPagamento != null && arrayDadosPagamento[18] != null) {
											Integer idDocumentoTipoAgregador = (Integer) arrayDadosPagamento[18];
											if (!idDocumentoTipoAgregador.equals(new Integer(0))) {
												documentoTipoAgregador = new DocumentoTipo(idDocumentoTipoAgregador);
											} else {
												documentoTipoAgregador = null;
											}

										}

										if (arrayDadosPagamento != null && arrayDadosPagamento[19] != null) {
											qtdDocumentosAgregados = (Integer) arrayDadosPagamento[19];
										}

										// Caso o imóvel esteja preenchido no pagamento
										if (imovel != null) {

											principalCategoria = getControladorImovel().obterPrincipalCategoriaImovel(imovel.getId());

											Integer idEsferaPoder = repositorioArrecadacao.pesquisarEsferaPoderClienteResponsavelPeloImovel(imovel.getId());

											if (idEsferaPoder != null) {
												esferaPoder = new EsferaPoder(idEsferaPoder);
											} else {
												esferaPoder = null;
											}

											String indicadorHidrometroString = new Integer(getControladorImovel().obterIndicadorExistenciaHidrometroImovel(imovel.getId())).toString();
											indicadorHidrometro = new Short(indicadorHidrometroString);
										} else {
											perfilImovel = new ImovelPerfil(ImovelPerfil.NORMAL);
											principalCategoria = new Categoria(Categoria.RESIDENCIAL);
										}

										if (indicadorHidrometro == null) {
											indicadorHidrometro = new Short("2");
										}

										ArrecadadorContratoTarifa arrecadadorContratoTarifa = null;
										if (arrecadador != null && arrecadacaoForma != null) {
											arrecadadorContratoTarifa = repositorioArrecadacao.pesquisarArrecadadorContratoTarifa(arrecadador.getId(), arrecadacaoForma.getId());
										}

										arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();
										arrecadacaoDadosDiarios.setAnoMesReferenciaArrecadacao(anoMesArrecadacaoAtual);
										arrecadacaoDadosDiarios.setArrecadador(arrecadador);
										arrecadacaoDadosDiarios.setUnidadeNegocio(unidadeNegocio);
										arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
										arrecadacaoDadosDiarios.setLocalidade(localidade);
										arrecadacaoDadosDiarios.setSetorComercial(setorComercial);
										arrecadacaoDadosDiarios.setRota(rota);
										arrecadacaoDadosDiarios.setQuadra(quadra);
										arrecadacaoDadosDiarios.setCodigoSetorComercial(codigoSetorComercial);
										arrecadacaoDadosDiarios.setNumeroQuadra(numeroQuadra);
										arrecadacaoDadosDiarios.setImovelPerfil(perfilImovel);
										arrecadacaoDadosDiarios.setLigacaoAguaSituacao(situacaoLigacaoAgua);
										arrecadacaoDadosDiarios.setLigacaoEsgotoSituacao(situacaoLigacaoEsgoto);
										arrecadacaoDadosDiarios.setCategoria(principalCategoria);
										arrecadacaoDadosDiarios.setEsferaPoder(esferaPoder);
										arrecadacaoDadosDiarios.setIndicadorHidrometro(indicadorHidrometro);
										arrecadacaoDadosDiarios.setDocumentoTipo(documentoTipo);
										arrecadacaoDadosDiarios.setArrecadacaoForma(arrecadacaoForma);
										arrecadacaoDadosDiarios.setDataPagamento(dataPagamento);
										arrecadacaoDadosDiarios.setQuantidadePagamentos(quantidade);
										arrecadacaoDadosDiarios.setValorPagamentos(somaValor);
										arrecadacaoDadosDiarios.setQuantidadeDocumentos(qtdDocumentosAgregados);
										arrecadacaoDadosDiarios.setDocumentoTipoAgregador(documentoTipoAgregador);
										arrecadacaoDadosDiarios.setUltimaAlteracao(new Date());

										if (arrecadadorContratoTarifa != null) {
											arrecadacaoDadosDiarios.setValorUnitarioTarifa(arrecadadorContratoTarifa.getValorTarifa());
											arrecadacaoDadosDiarios.setNumeroDiasFloat(arrecadadorContratoTarifa.getNumeroDiaFloat());

											if (arrecadacaoDadosDiarios.getValorUnitarioTarifa() != null
													&& arrecadacaoDadosDiarios.getQuantidadeDocumentos() != null) {
												arrecadacaoDadosDiarios.setValorTotalTarifas(arrecadacaoDadosDiarios.getValorUnitarioTarifa().multiply(
														new BigDecimal(arrecadacaoDadosDiarios.getQuantidadeDocumentos())));
											}
										}
										cont++;
										colecaoDadosDiariosArrecadacaoInserir.add(arrecadacaoDadosDiarios);

										principalCategoria = null;
										esferaPoder = null;
										indicadorHidrometro = null;
									}
								}
								colecaoDadosPagamentos.clear();
							}

							repositorioArrecadacao.excluirDadosDiariosDevolucaoPorAnoMesArrecadacaoPorLocalidade(anoMesArrecadacaoAtual, idLocalidade);

							// Acumula a quantidade e o valor das devolucoes
							colecaoDadosDevolucoes = repositorioArrecadacao.acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacao(anoMesArrecadacaoAtual,
									localidade.getId());

							if (colecaoDadosDevolucoes != null) {

								for (Object dadosDevolucao : colecaoDadosDevolucoes) {

									Object[] arrayDadosDevolucao = (Object[]) dadosDevolucao;

									// ID IMOVEL
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[0] != null) {
										imovel = new Imovel();
										imovel.setId((Integer) arrayDadosDevolucao[0]);
									} else {
										imovel = null;
									}

									// SOMA DO VALOR
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[1] != null) {
										somaValor = (BigDecimal) arrayDadosDevolucao[1];
									} else {
										somaValor = null;
									}

									// QUANTIDADE DEVOLUCOES
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[2] != null) {
										quantidade = (Integer) arrayDadosDevolucao[2];
									} else {
										quantidade = null;
									}

									// ID SETOR COMERCIAL
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[3] != null) {
										setorComercial = new SetorComercial();
										setorComercial.setId((Integer) arrayDadosDevolucao[3]);
									} else {
										setorComercial = null;
									}

									// CODIGO SETOR COMERCIAL
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[4] != null) {
										codigoSetorComercial = (Integer) arrayDadosDevolucao[4];
									} else {
										codigoSetorComercial = 0;
									}

									// ID DA ROTA
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[5] != null) {
										rota = new Rota();
										rota.setId((Integer) arrayDadosDevolucao[5]);
									} else {
										rota = null;
									}

									// ID QUADRA
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[6] != null) {
										quadra = new Quadra();
										quadra.setId((Integer) arrayDadosDevolucao[6]);
									} else {
										quadra = null;
									}

									// NUMERO QUADRA
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[7] != null) {
										numeroQuadra = (Integer) arrayDadosDevolucao[7];
									} else {
										numeroQuadra = 0;
									}

									// ID IMOVEL PERFIL
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[8] != null) {
										perfilImovel = new ImovelPerfil();
										perfilImovel.setId((Integer) arrayDadosDevolucao[8]);
									} else {
										perfilImovel = null;
									}

									// ID LIGACAO AGUA SITUACAO
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[9] != null) {
										situacaoLigacaoAgua = new LigacaoAguaSituacao();
										situacaoLigacaoAgua.setId((Integer) arrayDadosDevolucao[9]);
									} else {
										situacaoLigacaoAgua = null;
									}

									// ID LIGACAO ESGOTO SITUACAO
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[10] != null) {
										situacaoLigacaoEsgoto = new LigacaoEsgotoSituacao();
										situacaoLigacaoEsgoto.setId((Integer) arrayDadosDevolucao[10]);
									} else {
										situacaoLigacaoEsgoto = null;
									}

									// ID GERENCIA REGIONAL
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[11] != null) {
										gerenciaRegional = new GerenciaRegional();
										gerenciaRegional.setId((Integer) arrayDadosDevolucao[11]);
									} else {
										gerenciaRegional = null;
									}

									// ID AVISO BANCARIO
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[12] != null) {
										avisoBancario = new AvisoBancario();
										avisoBancario.setId((Integer) arrayDadosDevolucao[12]);
									} else {
										avisoBancario = null;
									}

									// ID ARRECADADOR
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[13] != null) {
										arrecadador = new Arrecadador();
										arrecadador.setId((Integer) arrayDadosDevolucao[13]);
									} else {
										arrecadador = null;
									}

									documentoTipo = new DocumentoTipo();
									documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);

									// ID ARRECADACAO FORMA
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[14] != null) {
										arrecadacaoForma = new ArrecadacaoForma();
										arrecadacaoForma.setId((Integer) arrayDadosDevolucao[14]);
									} else {
										arrecadacaoForma = null;
									}

									// DATA DE DEVOLUCAO
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[15] != null) {
										dataDevolucao = (Date) arrayDadosDevolucao[15];
									} else {
										dataDevolucao = null;
									}

									// ID UNIDADE DE NEGOCIO
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[16] != null) {
										unidadeNegocio = new UnidadeNegocio();
										unidadeNegocio.setId((Integer) arrayDadosDevolucao[16]);
									} else {
										unidadeNegocio = null;
									}

									// TIPO DE DEVOLUCAO
									String tipoDevolucao = "";
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[19] != null) {
										tipoDevolucao = (String) arrayDadosDevolucao[19];
										if (tipoDevolucao.equals("N")) {
											documentoTipoAgregador = documentoTipo;
										}
									}

									// TIPO DE DOCUMENTO AGREGADOR
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[17] != null) {
										Integer idDocumentoTipoAgregador = (Integer) arrayDadosDevolucao[17];
										if (!tipoDevolucao.equals("N")) {
											if (!idDocumentoTipoAgregador.equals(new Integer(0))) {
												documentoTipoAgregador = new DocumentoTipo();
												documentoTipoAgregador.setId(idDocumentoTipoAgregador);
											} else {
												documentoTipoAgregador = null;
											}
										}
									}

									// QTD DE DOCUMENTOS AGREGADOS
									if (arrayDadosDevolucao != null && arrayDadosDevolucao[18] != null) {
										qtdDocumentosAgregados = (Integer) arrayDadosDevolucao[18];
									}

									// Caso o imóvel esteja preenchido na
									// devolucao
									if (imovel != null) {

										// [UC0306] Obter principal categoria do
										// imóvel
										principalCategoria = getControladorImovel().obterPrincipalCategoriaImovel(imovel.getId());

										Integer idEsferaPoder = repositorioArrecadacao.pesquisarEsferaPoderClienteResponsavelPeloImovel(imovel.getId());

										if (idEsferaPoder != null) {
											esferaPoder = new EsferaPoder();
											esferaPoder.setId(idEsferaPoder);
										} else {
											esferaPoder = null;
										}

										// [UC0307] - Obter Indicador de
										// Existência
										// de
										// Hidrômetro
										String indicadorHidrometroString = new Integer(getControladorImovel().obterIndicadorExistenciaHidrometroImovel(
												imovel.getId())).toString();
										indicadorHidrometro = new Short(indicadorHidrometroString);
									}

									// Caso indicador de hidrômetro esteja nulo
									// Seta 2(dois) = NÃO no indicador de
									// hidrômetro
									if (indicadorHidrometro == null) {
										indicadorHidrometro = new Short("2");
									}

									// Cria o objeto DevolucaoDadosDiarios e
									// seta
									// os
									// dados
									// necessários para inclusão
									devolucaoDadosDiarios = new DevolucaoDadosDiarios();
									devolucaoDadosDiarios.setAnoMesReferencia(anoMesArrecadacaoAtual);
									devolucaoDadosDiarios.setArrecadador(arrecadador);
									devolucaoDadosDiarios.setUnidadeNegocio(unidadeNegocio);
									devolucaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
									devolucaoDadosDiarios.setLocalidade(localidade);
									devolucaoDadosDiarios.setSetorComercial(setorComercial);
									devolucaoDadosDiarios.setRota(rota);
									devolucaoDadosDiarios.setQuadra(quadra);
									devolucaoDadosDiarios.setCodigoSetorComercial(codigoSetorComercial);
									devolucaoDadosDiarios.setNumeroQuadra(numeroQuadra);
									devolucaoDadosDiarios.setImovelPerfil(perfilImovel);
									devolucaoDadosDiarios.setLigacaoAguaSituacao(situacaoLigacaoAgua);
									devolucaoDadosDiarios.setLigacaoEsgotoSituacao(situacaoLigacaoEsgoto);
									devolucaoDadosDiarios.setCategoria(principalCategoria);
									devolucaoDadosDiarios.setEsferaPoder(esferaPoder);
									devolucaoDadosDiarios.setIndicadorHidrometro(indicadorHidrometro);
									devolucaoDadosDiarios.setDocumentoTipo(documentoTipo);
									devolucaoDadosDiarios.setArrecadacaoForma(arrecadacaoForma);
									devolucaoDadosDiarios.setDataDevolucao(dataDevolucao);
									devolucaoDadosDiarios.setQuantidadeDevolucoes(quantidade);
									devolucaoDadosDiarios.setValorDevolucoes(somaValor);
									devolucaoDadosDiarios.setQuantidadeDocumentos(qtdDocumentosAgregados);
									devolucaoDadosDiarios.setDocumentoTipoAgregador(documentoTipoAgregador);
									devolucaoDadosDiarios.setDevolucaoTipo(tipoDevolucao);
									devolucaoDadosDiarios.setDataUltimaAlteracao(new Date());
									cont++;

									colecaoDadosDiariosArrecadacaoInserir.add(devolucaoDadosDiarios);
								}

								colecaoDadosDevolucoes.clear();

							}

						}
					}

					getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDadosDiariosArrecadacaoInserir);
					colecaoDadosDiariosArrecadacaoInserir = null;

				}
			}
			concluiuComSucesso = true;

		} catch (Exception e) {
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);
			e.printStackTrace();

			throw new EJBException(e);
		} finally {
			if (concluiuComSucesso) {
				getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);
			}
		}
	}

	/**
	 * Este caso de uso permite classificar os pagamentos e as devoluções no mês
	 * de arrecadação corrente
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 18/04/2006, 06/12/2006
	 * 
	 * @param colecaoIdsLocalidades
	 * @param idFuncionalidadeIniciada
	 * @return void
	 */
	public void classificarPagamentosDevolucoes(Collection<Integer> colecaoIdsLocalidades, int idFuncionalidadeIniciada) throws ControladorException {

		Imovel imovel = null;

		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.LOCALIDADE,
				((Integer) Util.retonarObjetoDeColecao(colecaoIdsLocalidades)));

		try {

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			/**
			 * Caso exista os parâmetros do sistema cadastrados.
			 */
			if (getSistemaParametro() != null) {

				// Recupera o ano/mês de arrecadação atual.
				Integer anoMesArrecadacao = getSistemaParametro().getAnoMesArrecadacao();
				Integer anoMesFaturamento = getSistemaParametro().getAnoMesFaturamento();

				
			//	colecaoIdsLocalidades = new ArrayList<Integer>();
			//	colecaoIdsLocalidades.add(new Integer(5));
				/**
				 * Caso a coleção de ids de localidade não esteja vazia
				 * classifica os pagamentos por localidade.
				 */
				if (colecaoIdsLocalidades != null && !colecaoIdsLocalidades.isEmpty()) {

					for (Integer idLocalidade : colecaoIdsLocalidades) {
						boolean flagTerminou = false;
						final int quantidadeRegistros = 500;
						int numeroIndice = 0;

						/**
						 * Detalhar classificação de
						 * documentos inexistentes
						 * 
						 * @author Wellington Rocha
						 * @date 01/08/2012
						 */
						Collection colecaoPagamentosDocumentoInexistenteDebitoPrescrito = new ArrayList();
						Collection colecaoPagamentosDocumentoInexistenteContaParcelada = new ArrayList();
						Collection colecaoPagamentosDocumentoInexistenteContaCancelada = new ArrayList();
						Collection colecaoPagamentosDocumentoInexistenteErroProcessamento = new ArrayList();

						/**
						 * Verifica se a flag que indica que a paginação
						 * terminou
						 */
						while (!flagTerminou) {

							try {

								/**
								 * Recupera os ids de imóveis para a localidade
								 * Recupera os ids por páginação de 500
								 * registros por pesquisa.
								 */
								Collection<Integer> colecaoIdsImoveis = repositorioArrecadacao.pesquisarIdsImovelPorLocalidade(idLocalidade, numeroIndice,
										quantidadeRegistros);

								if (colecaoIdsImoveis != null && !colecaoIdsImoveis.isEmpty()) {

									/**
									 * Instância as variáveis
									 */
									Collection colecaoPagamentosDuplicidade = new ArrayList();
									Collection colecaoPagamentosAtualizar = new ArrayList();
									Collection colecaoPagamentosConta = null;

									Map<Integer, Collection> mapPagamentosProcessados = new HashMap();
									Map<Integer, Collection> mapPagamentosValorNaoConfere = new HashMap();
									Collection colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo = new ArrayList();
									Collection colecaoPagamentoClassificado = new ArrayList();
									Collection colecaoPagamentoEmDuplicidade = new ArrayList();
									Collection colecaoPagamentoAtualizarValorExcedente = new ArrayList();

									/**
									 * Classifica os pagamentos por imóvel para
									 * os pagamentos de conta.
									 */
									for (Integer idImovel : colecaoIdsImoveis) {
										imovel = new Imovel();
										imovel.setId(idImovel);

										Collection<Integer> colecaoAnoMesPagamento = null;

										/**
										 * Pesquisa o ano/mês de ref. de pag para o imóvel para o ano/mês da arrecadação e tipo de documento = conta.
										 */
										colecaoAnoMesPagamento = repositorioArrecadacao.pesquisarAnoMesReferenciaPagamentoParaImovel(anoMesArrecadacao, idImovel);

										if (colecaoAnoMesPagamento != null && !colecaoAnoMesPagamento.isEmpty()) {

											for (Integer anoMesReferenciaPagamento : colecaoAnoMesPagamento) {

												/*
												 * O sistema seleciona os pagamentos com ano/mês de referência da arrecadação igual o ano/mês de referência
												 * da arrecadação corrente (seleciona a partir da tabela PAGAMENTO para PGMT_AMREFERENCIAARRECADACAO
												 * igual ou menor ao PARM_AMREFERENCIAARRECADACAO)
												 */
												colecaoPagamentosConta = repositorioArrecadacao.pesquisarPagamentosPorConta(anoMesArrecadacao, idLocalidade,
														idImovel, anoMesReferenciaPagamento);

												/**
												 * Caso a pesquisa de pagamentos para conta do imóvel informado e com o ano/mês de arrecadação do pagamento 
												 * não esteja nula Classifica os pagamentos selecionados.
												 */
												if (colecaoPagamentosConta != null && !colecaoPagamentosConta.isEmpty()) {

													/**
													 * Chama o metódo para classificar os pagamentos do imóvel para o tipo conta, retornando um
													 * array com os pagamentos classificados. 
													 * 0 - Coleção de pagamentos para atualizar a situação e o valor excedente. 
													 * 1 - Map com os pagamentos para ser processados junto com a respectiva conta. 
													 * 2 - Array com 4 coleções de pagamentos para atualizar.
													 */
													Object[] arrayDadosProcessarContas = this.classificarPagamentosConta(colecaoPagamentosConta, imovel,
															anoMesArrecadacao, anoMesFaturamento, anoMesReferenciaPagamento);

													if (arrayDadosProcessarContas[5] != null) {
														colecaoPagamentosDocumentoInexistenteDebitoPrescrito.addAll((Collection) arrayDadosProcessarContas[5]);
													}

													if (arrayDadosProcessarContas[6] != null) {
														colecaoPagamentosDocumentoInexistenteContaCancelada.addAll((Collection) arrayDadosProcessarContas[6]);
													}

													if (arrayDadosProcessarContas[7] != null) {
														colecaoPagamentosDocumentoInexistenteContaParcelada.addAll((Collection) arrayDadosProcessarContas[7]);
													}

													if (arrayDadosProcessarContas[8] != null) {
														colecaoPagamentosDocumentoInexistenteErroProcessamento
																.addAll((Collection) arrayDadosProcessarContas[8]);
													}

													if (arrayDadosProcessarContas[0] != null) {
														colecaoPagamentosAtualizar.addAll((Collection) arrayDadosProcessarContas[0]);
													}

													if (arrayDadosProcessarContas[3] != null) {
														colecaoPagamentosDuplicidade.addAll((Collection) arrayDadosProcessarContas[3]);
													}

													if (arrayDadosProcessarContas[1] != null) {
														mapPagamentosProcessados.putAll((Map) arrayDadosProcessarContas[1]);
													}

													if (arrayDadosProcessarContas[2] != null) {

														Object[] arrayDadosProcessarPagamentosConta = (Object[]) arrayDadosProcessarContas[2];

														if (arrayDadosProcessarPagamentosConta != null) {
															if (arrayDadosProcessarPagamentosConta[0] != null) {
																mapPagamentosValorNaoConfere.putAll((Map) arrayDadosProcessarPagamentosConta[0]);
															}
															if (arrayDadosProcessarPagamentosConta[1] != null) {
																colecaoPagamentoClassificado.addAll((Collection) arrayDadosProcessarPagamentosConta[1]);
															}
															if (arrayDadosProcessarPagamentosConta[2] != null) {
																colecaoPagamentoEmDuplicidade.addAll((Collection) arrayDadosProcessarPagamentosConta[2]);
															}
															if (arrayDadosProcessarPagamentosConta[3] != null) {
																colecaoPagamentoAtualizarValorExcedente
																		.addAll((Collection) arrayDadosProcessarPagamentosConta[3]);
															}
															if (arrayDadosProcessarPagamentosConta[4] != null) {
																colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
																		.addAll((Collection) arrayDadosProcessarPagamentosConta[4]);
															}
														}
													}
												}
											}
										}
									}

									/**
									 * Detalhar
									 * classificação de documentos inexistentes
									 * 
									 * @author Wellington Rocha
									 * @date 01/08/2012
									 */
									if (colecaoPagamentosDocumentoInexistenteContaCancelada != null
											&& !colecaoPagamentosDocumentoInexistenteContaCancelada.isEmpty()) {
										repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDocumentoInexistenteContaCancelada,
												PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA);
									}
									colecaoPagamentosDocumentoInexistenteContaCancelada = new ArrayList();

									if (colecaoPagamentosDocumentoInexistenteContaParcelada != null
											&& !colecaoPagamentosDocumentoInexistenteContaParcelada.isEmpty()) {
										repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDocumentoInexistenteContaParcelada,
												PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA);
									}
									colecaoPagamentosDocumentoInexistenteContaParcelada = new ArrayList();

									if (colecaoPagamentosDocumentoInexistenteDebitoPrescrito != null
											&& !colecaoPagamentosDocumentoInexistenteDebitoPrescrito.isEmpty()) {
										repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDocumentoInexistenteDebitoPrescrito,
												PagamentoSituacao.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO);
									}
									colecaoPagamentosDocumentoInexistenteDebitoPrescrito = new ArrayList();

									if (colecaoPagamentosDocumentoInexistenteErroProcessamento != null
											&& !colecaoPagamentosDocumentoInexistenteErroProcessamento.isEmpty()) {
										repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(
												colecaoPagamentosDocumentoInexistenteErroProcessamento,
												PagamentoSituacao.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO);
									}
									colecaoPagamentosDocumentoInexistenteErroProcessamento = new ArrayList();

									/**
									 * Atualiza a situação e o valor excedente
									 * dos pagamentos.
									 */
									if (colecaoPagamentosAtualizar != null && !colecaoPagamentosAtualizar.isEmpty()) {
										repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosAtualizar,
												PagamentoSituacao.DOCUMENTO_INEXISTENTE);
									}

									/**
									 * Atualiza a situação e o valor excedente
									 * dos pagamentos em duplicidade.
									 */
									if (colecaoPagamentosDuplicidade != null && !colecaoPagamentosDuplicidade.isEmpty()) {
										repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoPagamentosDuplicidade,
												PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
									}

									/**
									 * Processa os pagamentos e suas respectivas
									 * contas.
									 */
									if (mapPagamentosProcessados != null && !mapPagamentosProcessados.isEmpty()) {
										repositorioArrecadacao.processarPagamentoConta(mapPagamentosProcessados);
									}

									/**
									 * Atualiza a situação dos pagamentos com
									 * valor igual a valor não confere.
									 */
									if (mapPagamentosValorNaoConfere != null && !mapPagamentosValorNaoConfere.isEmpty()) {
										this.repositorioArrecadacao.processarPagamentoValorNaoConfereConta(mapPagamentosValorNaoConfere);
									}

									/**
									 * Atualiza a situação dos pagamentos para
									 * valor não confere e seta o CNTA_ID,
									 * GPAG_ID E DBAC_ID para nulo.
									 */
									if (colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo != null
											&& !colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo.isEmpty()) {
										this.repositorioArrecadacao
												.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo(colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo);
									}

									/**
									 * Atualiza a situação dos pagamentos com
									 * valor igual a pagamento classificado.
									 */
									if (colecaoPagamentoClassificado != null && !colecaoPagamentoClassificado.isEmpty()) {
										this.repositorioArrecadacao.atualizarSituacaoPagamentoClassificado(colecaoPagamentoClassificado);
									}

									/**
									 * Atualiza a situação dos pagamentos com
									 * valor igual a pagamento em duplicidade.
									 */
									if (colecaoPagamentoEmDuplicidade != null && !colecaoPagamentoEmDuplicidade.isEmpty()) {
										this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE,
												colecaoPagamentoEmDuplicidade);
									}

									/**
									 * Atualiza o valor excedente dos
									 * pagamentos.
									 */
									if (colecaoPagamentoAtualizarValorExcedente != null && !colecaoPagamentoAtualizarValorExcedente.isEmpty()) {
										repositorioArrecadacao.atualizarValorExcedentePagamento(colecaoPagamentoAtualizarValorExcedente);
									}
								}

								/**
								 * Incrementa o nº do indice da páginação
								 */
								numeroIndice = numeroIndice + quantidadeRegistros;

								/**
								 * Caso a coleção de imoveis retornados for
								 * menor que a quantidade de registros seta a
								 * flag indicando que a paginação terminou.
								 */
								if (colecaoIdsImoveis != null && colecaoIdsImoveis.size() < quantidadeRegistros) {
									flagTerminou = true;
								}
								colecaoIdsImoveis = null;

							} catch (ErroRepositorioException e) {
								throw new ControladorException("erro.sistema", e);
							}
						}

						/**
						 * Pesquisa as coleções de pagamentos para guia de
						 * pagamento e para pagamentos de débito a cobrar para
						 * classificar.
						 */
						// alterado por Vivianne Sousa 25/11/2008
						// analista: Aryed

						Collection colecaoPagamentosGuiaPagamentoPreenchidaRefContabilMaiorIgualRefFaturamento = repositorioArrecadacao
								.pesquisarPagamentosPorGuiaPagamentoComGuiaInformadaRefContabilMaiorIgualRefFaturamento(anoMesArrecadacao, idLocalidade,
										anoMesFaturamento);

						if (colecaoPagamentosGuiaPagamentoPreenchidaRefContabilMaiorIgualRefFaturamento != null
								&& !colecaoPagamentosGuiaPagamentoPreenchidaRefContabilMaiorIgualRefFaturamento.isEmpty()) {

							Iterator iteratorColecaoPagamentosGuiaPagamento = colecaoPagamentosGuiaPagamentoPreenchidaRefContabilMaiorIgualRefFaturamento
									.iterator();

							GuiaPagamento guiaPagamento = null;
							Integer idGuiaPagamento = null;
							BigDecimal valorPagamento = null;
							Pagamento pagamento = null;
							Collection colecaoGuiaPagamentoAtualizarSituacaoEValorExcedentePagamento = new ArrayList();

							while (iteratorColecaoPagamentosGuiaPagamento.hasNext()) {
								Object[] pagamentoArray = (Object[]) iteratorColecaoPagamentosGuiaPagamento.next();

								if (pagamentoArray[1] != null) {
									idGuiaPagamento = (Integer) pagamentoArray[1];
									guiaPagamento = new GuiaPagamento();
									guiaPagamento.setId(idGuiaPagamento);
								} else {
									idGuiaPagamento = null;
								}

								if (pagamentoArray[2] != null) {
									valorPagamento = (BigDecimal) pagamentoArray[2];
								} else {
									valorPagamento = null;
								}

								pagamento = new Pagamento();
								pagamento.setId((Integer) pagamentoArray[0]);
								pagamento.setGuiaPagamento(guiaPagamento);
								pagamento.setValorExcedente(valorPagamento);
								colecaoGuiaPagamentoAtualizarSituacaoEValorExcedentePagamento.add(pagamento);
							}
							if (colecaoGuiaPagamentoAtualizarSituacaoEValorExcedentePagamento != null
									&& !colecaoGuiaPagamentoAtualizarSituacaoEValorExcedentePagamento.isEmpty()) {
								repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoGuiaPagamentoAtualizarSituacaoEValorExcedentePagamento,
										PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);
							}

						}

						Integer anoMesArrecadaoMaisDois = Util.somaMesAnoMesReferencia(anoMesArrecadacao, 2);

						Collection colecaoPagamentosGuiaPagamentoPreenchida = repositorioArrecadacao
								.pesquisarPagamentosPorGuiaPagamentoComGuiaInformadaRefContabilMenorRefFaturamento(anoMesArrecadaoMaisDois, idLocalidade,
										anoMesFaturamento);

						Collection colecaoPagamentosGuiaPagamentoNaoPreenchida = repositorioArrecadacao.pesquisarPagamentosPorGuiaPagamentoSemGuiaInformada(
								anoMesArrecadaoMaisDois, idLocalidade);

						if ((colecaoPagamentosGuiaPagamentoPreenchida != null && !colecaoPagamentosGuiaPagamentoPreenchida.isEmpty())
								|| (colecaoPagamentosGuiaPagamentoNaoPreenchida != null && !colecaoPagamentosGuiaPagamentoNaoPreenchida.isEmpty())) {

							Object[] arrayDadosProcessarGuiasPagamento = this.classificarPagamentosGuiaPagamento(colecaoPagamentosGuiaPagamentoPreenchida,
									colecaoPagamentosGuiaPagamentoNaoPreenchida, anoMesFaturamento);

							if (arrayDadosProcessarGuiasPagamento != null) {
								if (arrayDadosProcessarGuiasPagamento[0] != null) {
									this.repositorioArrecadacao.processarPagamentoGuiaPagamento((Map) arrayDadosProcessarGuiasPagamento[0]);
								}
								if (arrayDadosProcessarGuiasPagamento[1] != null) {
									this.repositorioArrecadacao.processarPagamentoValorNaoConfereGuiaPagamento((Map) arrayDadosProcessarGuiasPagamento[1]);
								}
								if (arrayDadosProcessarGuiasPagamento[2] != null) {
									this.repositorioArrecadacao.atualizarSituacaoPagamentoClassificado((Collection) arrayDadosProcessarGuiasPagamento[2]);
								}
								if (arrayDadosProcessarGuiasPagamento[3] != null) {
									this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE,
											(Collection) arrayDadosProcessarGuiasPagamento[3]);
								}
								if (arrayDadosProcessarGuiasPagamento[4] != null) {
									this.repositorioArrecadacao.atualizarValorExcedentePagamento((Collection) arrayDadosProcessarGuiasPagamento[4]);
								}

								if (arrayDadosProcessarGuiasPagamento[5] != null) {
									this.repositorioArrecadacao
											.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo((Collection) arrayDadosProcessarGuiasPagamento[5]);
								}
							}
						}

						Collection colecaoPagamentosDebitoACobrarPreenchidaRefContabilMaiorIgualRefFaturamento = repositorioArrecadacao
								.pesquisarPagamentosPorDebitoACobrarComDebitoInformadoRefContabilMaiorIgualRefFaturamento(anoMesArrecadacao, idLocalidade,
										anoMesFaturamento);

						if (colecaoPagamentosDebitoACobrarPreenchidaRefContabilMaiorIgualRefFaturamento != null
								&& !colecaoPagamentosDebitoACobrarPreenchidaRefContabilMaiorIgualRefFaturamento.isEmpty()) {

							Iterator iteratorColecaoPagamentosDebitoACobrar = colecaoPagamentosDebitoACobrarPreenchidaRefContabilMaiorIgualRefFaturamento
									.iterator();

							DebitoACobrarGeral debitoACobrarGeral = null;
							Integer idDebitoACobrar = null;
							BigDecimal valorPagamento = null;
							Pagamento pagamento = null;
							Collection colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento = new ArrayList();

							while (iteratorColecaoPagamentosDebitoACobrar.hasNext()) {
								Object[] pagamentoArray = (Object[]) iteratorColecaoPagamentosDebitoACobrar.next();

								if (pagamentoArray[1] != null) {
									idDebitoACobrar = (Integer) pagamentoArray[1];
									debitoACobrarGeral = new DebitoACobrarGeral();
									debitoACobrarGeral.setId(idDebitoACobrar);
								} else {
									idDebitoACobrar = null;
								}

								if (pagamentoArray[2] != null) {
									valorPagamento = (BigDecimal) pagamentoArray[2];
								} else {
									valorPagamento = null;
								}

								pagamento = new Pagamento();
								pagamento.setId((Integer) pagamentoArray[0]);
								pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
								pagamento.setValorExcedente(valorPagamento);

								colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento.add(pagamento);
							}
							if (colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento != null
									&& !colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento.isEmpty()) {
								repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento,
										PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);
								colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento.clear();
							}

						}

						Integer anoMesArrecadacaoMaisDois = Util.somaMesAnoMesReferencia(anoMesArrecadacao, 2);
						Collection colecaoPagamentosDebitoACobrarPreenchido = repositorioArrecadacao
								.pesquisarPagamentosPorDebitoACobrarComDebitoInformadoRefContabilMenorRefFaturamento(anoMesArrecadacaoMaisDois, idLocalidade,
										anoMesFaturamento);

						Collection colecaoPagamentosDebitoACobrarNaoPreenchido = repositorioArrecadacao.pesquisarPagamentosPorDebitoACobrarSemDebitoInformada(
								anoMesArrecadacaoMaisDois, idLocalidade);

						// 4.1.2.2.Caso o débito a cobrar tenha sido encontrado
						// no histórico de débito a cobrar
						Collection colecaoPagamentosDebitoACobrarHistoricoPreenchidaRefContabilMaiorIgualRefFaturamento = repositorioArrecadacao
								.pesquisarPagamentosPorDebitoACobrarHistoricoComDebitoInformadoRefContabil(anoMesArrecadacao, idLocalidade);

						if (colecaoPagamentosDebitoACobrarHistoricoPreenchidaRefContabilMaiorIgualRefFaturamento != null
								&& !colecaoPagamentosDebitoACobrarHistoricoPreenchidaRefContabilMaiorIgualRefFaturamento.isEmpty()) {
							Iterator iteratorColecaoPagamentosDebitoACobrarHistorico = colecaoPagamentosDebitoACobrarHistoricoPreenchidaRefContabilMaiorIgualRefFaturamento
									.iterator();

							DebitoACobrarGeral debitoACobrarGeral = null;
							Integer idDebitoACobrar = null;
							BigDecimal valorPagamento = null;
							Pagamento pagamento = null;
							Collection colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento = new ArrayList();

							while (iteratorColecaoPagamentosDebitoACobrarHistorico.hasNext()) {
								Object[] pagamentoArray = (Object[]) iteratorColecaoPagamentosDebitoACobrarHistorico.next();

								// pagamento não corresponda a baixar valor
								// excedente
								if (!PagamentoSituacao.VALOR_A_BAIXAR.equals((pagamentoArray[3] != null ? (Integer) pagamentoArray[3] : -1))) {
									if (pagamentoArray[1] != null) {
										idDebitoACobrar = (Integer) pagamentoArray[1];
										debitoACobrarGeral = new DebitoACobrarGeral();
										debitoACobrarGeral.setId(idDebitoACobrar);
									} else {
										idDebitoACobrar = null;
									}

									if (pagamentoArray[2] != null) {
										valorPagamento = (BigDecimal) pagamentoArray[2];
									} else {
										valorPagamento = null;
									}

									pagamento = new Pagamento();
									pagamento.setId((Integer) pagamentoArray[0]);
									pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
									pagamento.setValorExcedente(valorPagamento);

									colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento.add(pagamento);
								}
							}

							if (colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento != null
									&& !colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento.isEmpty()) {
								repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(colecaoDebitoACobrarAtualizarSituacaoEValorExcedentePagamento,
										PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
							}
						}

						if ((colecaoPagamentosDebitoACobrarPreenchido != null && !colecaoPagamentosDebitoACobrarPreenchido.isEmpty())
								|| (colecaoPagamentosDebitoACobrarNaoPreenchido != null && !colecaoPagamentosDebitoACobrarNaoPreenchido.isEmpty())) {

							Object[] arrayDadosProcessarDebitosACobrar = arrayDadosProcessarDebitosACobrar = this.classificarPagamentosDebitoACobrar(
									colecaoPagamentosDebitoACobrarPreenchido, colecaoPagamentosDebitoACobrarNaoPreenchido, anoMesFaturamento);
							/*
							 * Chama o metódo de classificar pagamentos para
							 * débito a cobrar o metódo retorna um array
							 * contendo: 0 - Map com os pagamentos para ser
							 * processados junto com o respectivo débito a
							 * cobrar. 1 - Pagamentos com situação igual a valor
							 * não confere. 2 - Pagamentos com situação igual
							 * pagamentos classificados. 3 - Pagamentos com
							 * situação igual pagamentos em duplicidade. 4 -
							 * Pagamentos para atualizar valor execedente.
							 */
							if (arrayDadosProcessarDebitosACobrar != null) {
								if (arrayDadosProcessarDebitosACobrar[0] != null) {
									this.repositorioArrecadacao.processarPagamentoDebitoACobrar((Map) arrayDadosProcessarDebitosACobrar[0]);
								}
								if (arrayDadosProcessarDebitosACobrar[1] != null) {
									this.repositorioArrecadacao.processarPagamentoValorNaoConfereDebitoACobrar((Map) arrayDadosProcessarDebitosACobrar[1]);
								}
								if (arrayDadosProcessarDebitosACobrar[2] != null) {
									this.repositorioArrecadacao.atualizarSituacaoPagamentoClassificado((Collection) arrayDadosProcessarDebitosACobrar[2]);
								}
								if (arrayDadosProcessarDebitosACobrar[3] != null) {
									this.repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE,
											(Collection) arrayDadosProcessarDebitosACobrar[3]);
								}
								if (arrayDadosProcessarDebitosACobrar[4] != null) {
									this.repositorioArrecadacao.atualizarValorExcedentePagamento((Collection) arrayDadosProcessarDebitosACobrar[4]);
								}

								if (arrayDadosProcessarDebitosACobrar[5] != null) {
									this.repositorioArrecadacao
											.processarPagamentoValorNaoConfereIdentificadorDocumentoIgualANulo((Collection) arrayDadosProcessarDebitosACobrar[5]);
								}
							}
						}

						Collection colecaoDevolucoesDuplicidadeExcesso = null;
						Collection colecaoDevolucoesCobradasIndevidamente = null;

						colecaoDevolucoesDuplicidadeExcesso = repositorioArrecadacao.pesquisarDevolucoesEmDuplicidadeOUExcesso(anoMesArrecadacao, idLocalidade);
						colecaoDevolucoesCobradasIndevidamente = repositorioArrecadacao.pesquisarDevolucoesCobradasIndevidamente(anoMesArrecadacao,
								idLocalidade);

						if ((colecaoDevolucoesDuplicidadeExcesso != null && !colecaoDevolucoesDuplicidadeExcesso.isEmpty())
								|| (colecaoDevolucoesCobradasIndevidamente != null && !colecaoDevolucoesCobradasIndevidamente.isEmpty())) {

							this.classificarDevolucoesDuplicidadeExcesso(colecaoDevolucoesDuplicidadeExcesso);
							this.classificarDevolucoesCobradasIndevidamente(colecaoDevolucoesCobradasIndevidamente);
						}

						reclassificarPagamentosValorNaoConfere(anoMesArrecadacao, idLocalidade);
					}
					
					
				}// if localidade

				// --------------------------------------------------------
				//
				// Registrar o fim da execução da Unidade de Processamento
				//
				// --------------------------------------------------------
				getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);

			}// if sistema parametro
		} catch (Exception e) {
			// Este catch serve para interceptar qualquer exceção que o processo
			// batch venha a lançar e garantir que a unidade de processamento do
			// batch será atualizada com o erro ocorrido
			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);

			throw new EJBException(e);
		}
	}

	private void reclassificarPagamentosValorNaoConfere(Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException {
		Collection<PagamentoHelper> pagamentos = repositorioArrecadacao.pesquisarValoresPagamentos(PagamentoSituacao.VALOR_NAO_CONFERE, idLocalidade, 
																									anoMesReferenciaArrecadacao);
		for (PagamentoHelper pagamentoHelper : pagamentos) {
			if(possuiDiferencaAte2(pagamentoHelper) && possuiImovel(pagamentoHelper)){
				repositorioArrecadacao.atualizarSituacaoPagamento(PagamentoSituacao.PAGAMENTO_CLASSIFICADO, pagamentoHelper.getIdPagamento());
			}
		}
		
		
	}

	private boolean possuiImovel(PagamentoHelper pagamentoHelper) {
		return pagamentoHelper.getIdImovel() != null; 
	}

	private boolean possuiDiferencaAte2(PagamentoHelper pagamentoHelper) {
		if(pagamentoHelper.getValorPagamento() == null || pagamentoHelper.getValorDocumento() == null){
			return false;
		}
		
		BigDecimal diferenca = pagamentoHelper.getValorPagamento().subtract(pagamentoHelper.getValorDocumento());
		
		if (diferenca.doubleValue() <= 2.00 && diferenca.doubleValue() >= -2.00){
			return true;
		}else{
			return false;
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * O sistema seleciona a conta correspondente ao pagamento através do imóvel
	 * e ano/mês de referência do pagamento (a partir da tabela CONTA com
	 * IMOV_ID = IMOV_ID da tabela PAGAMENTO, PGMT_AMREFERENCIAPAGAMENTO da
	 * tabela PAGAMENTO e DCST_IDATUAL com o valor correspondente a normal,
	 * retificada ou incluída, da tabela DEBTIO_CREDITO_SITUACAO)
	 * 
	 * [SB0001] Selecionar Conta pelo Imóvel e Ano/Mês de Referência
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 28/11/2006, 05/06/2007, 02/10/2007, 15/01/2008
	 * 
	 * @param imovel
	 * @param anoMesReferenciaPagamento
	 * @param anoMesFaturamento
	 * 
	 * @return Object
	 */
	private Object selecionarContaPorImovelAnoMesReferencia(Imovel imovel,
			Integer anoMesReferenciaPagamento, Integer anoMesFaturamento)
			throws ControladorException {
		
		IConta conta = null;
		
		if (imovel != null && anoMesReferenciaPagamento != null){
			
			try {
				
				Object[] dadosConta = repositorioArrecadacao.selecionarContaPorImovelAnoMesReferencia(imovel,anoMesReferenciaPagamento, anoMesFaturamento);
				conta = new Conta();
				
				if(dadosConta == null){
					dadosConta = repositorioArrecadacao.selecionarContaHistoricoPorImovelAnoMesReferencia(imovel,anoMesReferenciaPagamento, anoMesFaturamento);
					conta = new ContaHistorico();
				}
				
				/*
				 * Caso o array dos dados da conta esteja preenchido 
				 * 0 - id da conta 
				 * 1 - valor da água 
				 * 2 - valor do esgoto 
				 * 3 - valor dos débitos 
				 * 4 - valor dos créditos 
				 * 5 - valor dos impostos 
				 * 6 - ano/mês referência contábil
				 * 7 - dcst
				 */
				if(dadosConta != null){
					conta.setId((Integer) dadosConta[0]);
					conta.setValorAgua((BigDecimal) dadosConta[1]);
					conta.setValorEsgoto((BigDecimal) dadosConta[2]);
					conta.setValorDebitos((BigDecimal) dadosConta[3]);
					conta.setValorCreditos((BigDecimal) dadosConta[4]);
					conta.setValorImposto((BigDecimal) dadosConta[5]);
					conta.setReferenciaContabil((Integer) dadosConta[6]);
					DebitoCreditoSituacao dcst = new DebitoCreditoSituacao();
					dcst.setId((Integer) dadosConta[7]);
					conta.setDebitoCreditoSituacaoAtual(dcst);
				}else{
					conta = null;
				}
				
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}
		}
		
		return conta;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Processa os pagamentos da conta
	 * 
	 * [SF0002] Processar Pagamento de Conta
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre Santos
	 * @date 19/04/2006, 06/12/2006
	 * 
	 * @param conta
	 * @param colecaoPagamentos
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] processarPagamentoConta(Conta conta,
			Collection<Pagamento> colecaoPagamentos)
			throws ControladorException {

		/**
		 * Declaração das variáveis
		 */
		Object[] retorno = new Object[2];
		Map mapPagamentosProcessados = new HashMap();
		Object[] arrayColecoesPagamentosAtualizar = null;

		// Atribuir o valor da conta ao valor do documento
		BigDecimal valorDocumento = conta.getValorTotal();

		/*
		 * [SF0007] Calcular Valor Total dos Pagamentos
		 */
		BigDecimal valorTotalPagamentosConta = this
				.calcularValorTotalPagamentos(colecaoPagamentos);

		/*
		 * Caso valor total dos pagamentos da conta seja igual ao valor do
		 * documento atualizar a situação atual dos pagamentos (PGST_IDATUAL)
		 * com valor correspondente a pagamento classificado (tabela
		 * PAGAMENTO_SITUACAO) e atualizar o id da conta nos pagamentos (seta
		 * CNTA_ID da tabela PAGAMENTO para CNTA_ID da tabela CONTA);
		 */
		// recurepa o valor absoluto da diferença entre o total dos pagamentos e
		// o valor documento
		BigDecimal diferenca = (valorTotalPagamentosConta
				.subtract(valorDocumento)).abs();

		// o limite permitido entre a diferença
		BigDecimal limitePermitido = new BigDecimal("0.03");

		// caso a diferença não seja maior que o limite permitido
		if (!(diferenca.compareTo(limitePermitido) > 0)) {
			mapPagamentosProcessados.put(conta.getId(), colecaoPagamentos);
		}

		/*
		 * Caso contrário, verifica pagamento a maior ou a menor [SB0008 -
		 * Processar Pagamento a Maior ou a Menor]
		 */
		else {
			/*
			 * [SF0008] Processar Pagamento a Maior ou a Menor
			 */
			arrayColecoesPagamentosAtualizar = this
					.processarPagamentoAMenorOUAMaior(
							valorTotalPagamentosConta, valorDocumento,
							colecaoPagamentos, conta.getId());

			Collection colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];

			if (colecaoPagamentosClassificados != null
					&& !colecaoPagamentosClassificados.isEmpty()) {
				mapPagamentosProcessados.put(conta.getId(),
						colecaoPagamentosClassificados);
			}
		}

		/**
		 * O array de retorno vai conter : 0 - um map para processar os
		 * pagamentos 1 - um array com coleções de pagamento para atualizar.
		 */
		retorno[0] = mapPagamentosProcessados;
		retorno[1] = arrayColecoesPagamentosAtualizar;

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Calcula o valor total dos pagamentos para a conta
	 * 
	 * [SF0007] Calcular Valor Total dos Pagamentos
	 * 
	 * @author Raphael Rossiter
	 * @date 19/04/2006
	 * 
	 * @param conta,
	 *            colecaoPagamentos
	 * @return BigDecimal
	 */
	public BigDecimal calcularValorTotalPagamentos(
			Collection<Pagamento> colecaoPagamentos)
			throws ControladorException {

		BigDecimal valorTotalPagamentos = new BigDecimal("0.00");
		BigDecimal valorPagamentos = new BigDecimal("0.00");
		BigDecimal valorExcedente = new BigDecimal("0.00");

		Iterator iteratorColecaoPagamentos = colecaoPagamentos.iterator();
		Pagamento pagamento = null;

		while (iteratorColecaoPagamentos.hasNext()) {

			pagamento = (Pagamento) iteratorColecaoPagamentos.next();

			// Acumula o valor dos pagamentos (PGMT_VLPAGAMENTO) do conjunto que
			// está sendo processado
			if (pagamento.getValorPagamento() != null) {
				valorPagamentos = valorPagamentos.add(pagamento
						.getValorPagamento());
			}

			/*
			 * Acumula o valor excedente dos pagamentos (PGMT_VLEXCEDENTE) do
			 * conjunto que está sendo processado que tenha situação atual
			 * (PGST_IDATUAL) com valor correspondente a baixar valor excedente
			 * (tabela PAGAMENTO_SITUACAO)
			 */
			if (pagamento.getPagamentoSituacaoAtual() != null
					&& pagamento.getPagamentoSituacaoAtual().getId().equals(
							PagamentoSituacao.VALOR_A_BAIXAR)
					&& pagamento.getValorExcedente() != null) {
				valorExcedente = valorExcedente.add(pagamento
						.getValorExcedente());
			}
		}

		// Retorna o valor total dos pagamentos = valor dos pagamentos - valor
		// excedente dos pagamentos
		valorTotalPagamentos = valorPagamentos.subtract(valorExcedente);
		valorTotalPagamentos = valorTotalPagamentos.setScale(2);

		return valorTotalPagamentos;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Processar Pagamento a Maior ou a Menor
	 * 
	 * [SF0008] Processar Pagamento a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 19/04/2006, 12/12/2006
	 * 
	 * @param valorTotalPagamentos
	 * @param valorDocumento
	 * @param colecaoPagamentos
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] processarPagamentoAMenorOUAMaior(
			BigDecimal valorTotalPagamentos, BigDecimal valorDocumento,
			Collection<Pagamento> colecaoPagamentos,
			Integer identificadorDocumento) throws ControladorException {

		/**
		 * Declaração de variáveis
		 */
		Object[] arrayColecoesPagamentosAtualizar = new Object[5];
		Iterator iteratorColecaoPagamentos = colecaoPagamentos.iterator();
		Pagamento pagamento = null;
		Object[] dadosPagamento = null;
		Map<Integer, Collection> mapPagamentosValorNaoConfere = new HashMap();
		Collection colecaoPagamentoValorNaoConfere = new ArrayList();
		Collection colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo = new ArrayList();
		Collection colecaoPagamentoClassificado = new ArrayList();
		Collection colecaoPagamentoEmDuplicidade = new ArrayList();
		Collection colecaoPagamentoAtualizarValorExcedente = new ArrayList();
		boolean flagIndicadorExistePagamentoValorDocumento = false;

		/*
		 * Caso o valor total dos pagamentos seja menor que o valor do
		 * documento, atualizar a situacao atual dos pagamentos (PGST_IDATUAL)
		 * com valor correspondente a valor não confere (tabela
		 * PAGAMENTO_SITUACAO) e atualizar o identificador do documento no
		 * pagamento com o identificador do documento (CNTA_ID,GPAG_ID ou
		 * DBAC_ID conforme seja conta, guia de pagamento ou débito a cobrar
		 * respectivamente,no pagamento)
		 */
		if (valorTotalPagamentos.compareTo(valorDocumento) == -1) {

			colecaoPagamentoValorNaoConfere.addAll(colecaoPagamentos);
			mapPagamentosValorNaoConfere.put(identificadorDocumento,
					colecaoPagamentoValorNaoConfere);

		} else {

			BigDecimal saldoDevido = valorDocumento;
			Collection colecaoPagamentosValorIgual = new ArrayList();
			Collection colecaoPagamentosValorDiferente = new ArrayList();

			while (iteratorColecaoPagamentos.hasNext()) {
				pagamento = (Pagamento) iteratorColecaoPagamentos.next();

				if (pagamento.getValorPagamento().equals(valorDocumento)) {
					colecaoPagamentosValorIgual.add(pagamento);
				} else {
					colecaoPagamentosValorDiferente.add(pagamento);
				}
			}

			// Para os pagamentos cujo valor (PGMT_VLPAGAMENTO) seja igual ao
			// valor do documento:
			if (colecaoPagamentosValorIgual != null
					&& !colecaoPagamentosValorIgual.isEmpty()) {

				flagIndicadorExistePagamentoValorDocumento = true;
				saldoDevido = BigDecimal.ZERO;

				/*
				 * Atualizar a situação atual do pagamento (PGST_IDATUAL), que
				 * tenha a data de pagamento mais antiga (PGMT_DTPAGAMENTO), com
				 * o valor correspondente a pagamento classificado (tabela
				 * PAGAMENTO_SITUACAO);
				 */
				Iterator iteratorColecaoPagamentosValorIgual = colecaoPagamentosValorIgual
						.iterator();
				Pagamento pagamentoDataPgMaisAntiga = null;

				while (iteratorColecaoPagamentosValorIgual.hasNext()) {

					pagamento = (Pagamento) iteratorColecaoPagamentosValorIgual
							.next();

					if (pagamentoDataPgMaisAntiga == null
							&& pagamento.getDataPagamento() != null) {
						pagamentoDataPgMaisAntiga = pagamento;
					} else if (pagamento.getDataPagamento() != null) {

						if (pagamentoDataPgMaisAntiga.getDataPagamento().after(
								pagamento.getDataPagamento())) {
							pagamentoDataPgMaisAntiga = pagamento;
						}
					}
				}

				colecaoPagamentoClassificado.add(pagamentoDataPgMaisAntiga);

				colecaoPagamentosValorIgual.remove(pagamentoDataPgMaisAntiga);

				/**
				 * Item 2.2.3 Para os outros pagamentos
				 */
				iteratorColecaoPagamentosValorIgual = colecaoPagamentosValorIgual
						.iterator();

				while (iteratorColecaoPagamentosValorIgual.hasNext()) {

					pagamento = (Pagamento) iteratorColecaoPagamentosValorIgual
							.next();

					/*
					 * Caso a situação atual (PGST_IDATUAL) esteja com valor
					 * diferente de baixar valor excedente (tabela
					 * PAGAMENTO_SITUACAO), atualizar a situação atual
					 * (PGST_IDATUAL) com o valor correspondente a pagamento em
					 * duplicidade/excesso (tabela PAGAMENTO_SITUACAO);
					 */
					if (pagamento.getPagamentoSituacaoAtual() == null
							|| !pagamento.getPagamentoSituacaoAtual().getId()
									.equals(PagamentoSituacao.VALOR_A_BAIXAR)) {
						colecaoPagamentoEmDuplicidade.add(pagamento);
					}

					/*
					 * [SF0009] Atualizar Valor Excedente do Pagamento
					 */
					dadosPagamento = this.atualizarValorExcedentePagamento(
							pagamento, saldoDevido);

					if (dadosPagamento != null) {
						saldoDevido = (BigDecimal) dadosPagamento[0];
						colecaoPagamentoAtualizarValorExcedente
								.add(dadosPagamento[1]);
					}
				}
			}

			// Para os pagamentos cujo valor (PGMT_VLPAGAMENTO) seja diferente
			// do valor do documento:
			if (colecaoPagamentosValorDiferente != null
					&& !colecaoPagamentosValorDiferente.isEmpty()) {

				Iterator iteratorColecaoPagamentosValorDiferente = colecaoPagamentosValorDiferente
						.iterator();

				while (iteratorColecaoPagamentosValorDiferente.hasNext()) {

					pagamento = (Pagamento) iteratorColecaoPagamentosValorDiferente
							.next();

					/*
					 * Item 2.3.1 Caso a situação atual (PGST_IDATUAL) esteja
					 * com o valor diferente de baixar valor excedente (tabela
					 * PAGAMENTO_SITUACAO), atualizar a situação atual dos
					 * pagamentos (PGST_IDATUAL) com o valor correspondente a
					 * valor não confere (tabela PAGAMENTO_SITUACAO)
					 */
					if (pagamento.getPagamentoSituacaoAtual() == null
							|| !pagamento.getPagamentoSituacaoAtual().getId()
									.equals(PagamentoSituacao.VALOR_A_BAIXAR)) {
						colecaoPagamentoValorNaoConfere.add(pagamento);
					}

					if (flagIndicadorExistePagamentoValorDocumento) {
						/*
						 * colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
						 * .addAll(colecaoPagamentoValorNaoConfere);
						 */
						colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
								.add(pagamento);
					} else {
						mapPagamentosValorNaoConfere.put(
								identificadorDocumento,
								colecaoPagamentoValorNaoConfere);
					}

					/*
					 * [SF0009] Atualizar Valor Excedente do Pagamento
					 */
					dadosPagamento = this.atualizarValorExcedentePagamento(
							pagamento, saldoDevido);

					if (dadosPagamento != null) {
						saldoDevido = (BigDecimal) dadosPagamento[0];
						colecaoPagamentoAtualizarValorExcedente
								.add(dadosPagamento[1]);
					}
				}
			}
		}

		/**
		 * Retorna um array contendo : 0 - Coleção de pagamentos para atualizar
		 * situação igual a valor não confere. 1 - Coleção de pagamentos para
		 * atualizar situação igual a pagamento classificado. 2 - Coleção de
		 * pagamentos para atualizar situação igual a pagamento em duplicidade.
		 * 3 - Coleção de pagamentos para atualizar valor excedente.
		 */
		arrayColecoesPagamentosAtualizar[0] = mapPagamentosValorNaoConfere;
		arrayColecoesPagamentosAtualizar[1] = colecaoPagamentoClassificado;
		arrayColecoesPagamentosAtualizar[2] = colecaoPagamentoEmDuplicidade;
		arrayColecoesPagamentosAtualizar[3] = colecaoPagamentoAtualizarValorExcedente;
		arrayColecoesPagamentosAtualizar[4] = colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo;

		return arrayColecoesPagamentosAtualizar;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Atualizar Valor Excedente do Pagamento
	 * 
	 * [SF0009] Atualizar Valor Excedente do Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 25/04/2006
	 * 
	 * @param pagamento
	 * @param saldoDevido
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] atualizarValorExcedentePagamento(Pagamento pagamento,
			BigDecimal saldoDevido) throws ControladorException {

		Object[] retorno = null;
		BigDecimal novoSaldoDevido = saldoDevido;

		if (pagamento.getValorPagamento() != null && saldoDevido != null) {

			retorno = new Object[2];
			/*
			 * Caso o valor do pagamento (PGMT_VLPAGAMENTO) seja menor que o
			 * saldo devido, atualizar o valor excedente do pagamento
			 * (PGMT_VLEXCEDENTE) com o valor zero e subtrair o valor do
			 * pagamento do saldo devido (saldo devido = saldo devido - valor do
			 * pagamento);
			 */
			if (pagamento.getValorPagamento().compareTo(saldoDevido) == -1) {
				pagamento.setValorExcedente(new BigDecimal("0.00"));
				novoSaldoDevido = novoSaldoDevido.subtract(pagamento
						.getValorPagamento());
			}
			/*
			 * Caso contrário, atualizar o valor excedente do pagamento
			 * (PGMT_VLEXCEDENTE) com o valor do pagamento menos o saldo devido
			 * (valor excedente do pagamento = valor do pagamento - saldo
			 * devido) e atribuir o valor zero ao saldo devido Para os
			 * pagamentos cujo valor (PGMT_VLPAGAMENTO) seja igual ao valor do
			 * documento: - Atualizar a situação atual do pagamento
			 * (PGST_IDATUAL), que tenha a data de pagamento mais antiga
			 * (PGMT_DTPAGAMENTO), com o valor correspondente a pagamento
			 * classificado (tabela PAGAMENTO_SITUACAO); - Atribuir o valor zero
			 * ao saldo devido; - Para os outros pagamentos: - Caso a situação
			 * atual (PGST_IDATUAL) esteja com valor diferente de baixar valor
			 * excedente (tabela PAGAMENTO_SITUACAO), atualizar a situação atual
			 * (PGST_IDATUAL) com o valor correspondente a pagamento em
			 * duplicidade/excesso (tabela PAGAMENTO_SITUACAO); - Atualizar o
			 * valor excedente [SB0009 - Atualizar Valor Excedente do
			 * Pagamento].
			 */
			else {
				BigDecimal vlExcedente = pagamento.getValorPagamento()
						.subtract(saldoDevido);
				pagamento.setValorExcedente(vlExcedente);
				novoSaldoDevido = new BigDecimal("0.00");
			}

			/**
			 * Retorna o array contendo: 0 - novo saldo devido. 1 - pagamento a
			 * ser atualizado.
			 */
			retorno[0] = novoSaldoDevido;
			retorno[1] = pagamento;
		}
		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Processar Pagamento de Guia de Pagamento
	 * 
	 * [SF0004] Processar Pagamento de Guia de Pagamento
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 26/04/2006, 08/12/2006
	 * 
	 * @param guiaPagamento
	 * @param colecaoPagamentos
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] processarPagamentoGuiaPagamento(
			GuiaPagamento guiaPagamento, Collection<Pagamento> colecaoPagamentos)
			throws ControladorException {

		// Atribuir o valor da guia de pagamento (GPAG_VLDEBITO) ao valor do
		// documento
		BigDecimal valorDocumento = guiaPagamento.getValorDebito();

		/**
		 * Declaração de variáveis.
		 */
		Object[] retorno = new Object[2];
		Map mapPagamentosProcessados = new HashMap();
		Object[] arrayColecoesPagamentosAtualizar = null;

		/*
		 * [SF0007] Calcular Valor Total dos Pagamentos
		 */
		BigDecimal valorTotalPagamentosGuiaPagamento = this
				.calcularValorTotalPagamentos(colecaoPagamentos);

		/*
		 * Caso valor total dos pagamentos para a guia de pagamento seja igual
		 * ao valor do documento atualizar a situação atual dos pagamentos
		 * (PGST_IDATUAL) com valor correspondente a pagamento classificado
		 * (tabela PAGAMENTO_SITUACAO) e atualizar o id da guia de pagamento nos
		 * pagamentos (seta GPAG_ID da tabela PAGAMENTO para GPAG_ID da tabela
		 * GUIA_PAGAMENTO);
		 */
		if (valorTotalPagamentosGuiaPagamento.equals(valorDocumento)) {
			mapPagamentosProcessados.put(guiaPagamento.getId(),
					colecaoPagamentos);
		} else {
			/*
			 * [SF0008] Processar Pagamento a Maior ou a Menor
			 */
			arrayColecoesPagamentosAtualizar = this
					.processarPagamentoAMenorOUAMaior(
							valorTotalPagamentosGuiaPagamento, valorDocumento,
							colecaoPagamentos, guiaPagamento.getId());

			Collection colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];

			if (colecaoPagamentosClassificados != null
					&& !colecaoPagamentosClassificados.isEmpty()) {
				mapPagamentosProcessados.put(guiaPagamento.getId(),
						colecaoPagamentosClassificados);
			}
		}

		/**
		 * retorna o array contendo: 0 - Map de pagamentos para processar com
		 * sua respectiva guia de pagamento. 1 - Array de coleções de pagamentos
		 * para atualizar.
		 */
		retorno[0] = mapPagamentosProcessados;
		retorno[1] = arrayColecoesPagamentosAtualizar;

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Processar Devoluções de Pagamento
	 * 
	 * [SF0011] Processar Devoluções de Pagamento
	 * 
	 * @author Raphael Rossiter
	 * @date 26/04/2006
	 * 
	 * @param Collection
	 *            <Devolucao>, Collection<Pagamento>
	 * @return void
	 */
	public void processarDevolucaoPagamento(
			Collection<Devolucao> colecaoDevolucao,
			Collection<Pagamento> colecaoPagamento) throws ControladorException {

		Devolucao devolucaoColecao = null;
		Pagamento pagamentoColecao = null;
		BigDecimal valorDevolucoes = new BigDecimal("0.00");
		BigDecimal valorExcedente = new BigDecimal("0.00");

		Iterator iteratorColecaoPagamento = null;
		Iterator iteratorColecaoDevolucao = null;
		String[] idPagamento = new String[1];
		String[] idDevolucao = new String[1];

		if (colecaoDevolucao != null && !colecaoDevolucao.isEmpty()) {

			iteratorColecaoDevolucao = colecaoDevolucao.iterator();

			while (iteratorColecaoDevolucao.hasNext()) {
				devolucaoColecao = (Devolucao) iteratorColecaoDevolucao.next();

				if (devolucaoColecao.getValorDevolucao() != null) {
					valorDevolucoes = valorDevolucoes.add(devolucaoColecao
							.getValorDevolucao());
				}
			}

		}

		if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {

			iteratorColecaoPagamento = colecaoPagamento.iterator();

			while (iteratorColecaoPagamento.hasNext()) {
				pagamentoColecao = (Pagamento) iteratorColecaoPagamento.next();

				if (pagamentoColecao.getValorExcedente() != null) {
					valorExcedente = valorExcedente.add(pagamentoColecao
							.getValorExcedente());
				}
			}

		}

		// Caso o valor total das devoluções seja igual ao valor total excedente
		// dos pagamentos
		if (valorDevolucoes.equals(valorExcedente)) {

			SistemaParametro sistemaParametro = this.getControladorUtil()
					.pesquisarParametrosDoSistema();

			if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {

				iteratorColecaoPagamento = colecaoPagamento.iterator();

				while (iteratorColecaoPagamento.hasNext()) {
					pagamentoColecao = (Pagamento) iteratorColecaoPagamento
							.next();

					idPagamento[0] = String.valueOf(pagamentoColecao.getId());

					try {

						repositorioArrecadacao
								.atualizarSituacaoPagamento(
										idPagamento,
										PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO);

					} catch (ErroRepositorioException ex) {
						ex.printStackTrace();
						throw new ControladorException("erro.sistema", ex);
					}

					if (pagamentoColecao.getAnoMesReferenciaArrecadacao() == getSistemaParametro()
							.getAnoMesArrecadacao().intValue()) {

						try {

							repositorioArrecadacao
									.atualizarSituacaoAnteriorPagamento(
											idPagamento,
											PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);

						} catch (ErroRepositorioException ex) {
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}
					}
				}
			}

			// Para todas a devoluções do conjunto que está sendo processado
			if (colecaoDevolucao != null && !colecaoDevolucao.isEmpty()) {

				iteratorColecaoDevolucao = colecaoDevolucao.iterator();

				while (iteratorColecaoDevolucao.hasNext()) {

					devolucaoColecao = (Devolucao) iteratorColecaoDevolucao
							.next();

					idDevolucao[0] = String.valueOf(devolucaoColecao.getId());

					if (devolucaoColecao.getGuiaDevolucao() != null) {

						try {

							repositorioArrecadacao.atualizarSituacaoDevolucao(
									idDevolucao,
									DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA);

						} catch (ErroRepositorioException ex) {
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}

					} else {

						try {

							repositorioArrecadacao
									.atualizarSituacaoDevolucao(
											idDevolucao,
											DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);

						} catch (ErroRepositorioException ex) {
							ex.printStackTrace();
							throw new ControladorException("erro.sistema", ex);
						}
					}
				}
			}
		} else {

			// [SB0013 - Processar Devolução a Maior ou a Menor]
			this.processarDevolucaoAMaiorOUAMenor(colecaoDevolucao,
					valorDevolucoes, colecaoPagamento, valorExcedente);
		}
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Processar Devolução a Maior ou a Menor
	 * 
	 * [SF0013] Processar Devolução a Maior ou a Menor
	 * 
	 * @author Raphael Rossiter,Pedro Alexandre
	 * @date 15/06/2006, 10/07/2007
	 * 
	 * @param colecaoDevolucao
	 * @param totalDevolucao
	 * @param colecaoPagamento
	 * @param totalExcedente
	 * @throws ControladorException
	 */
	public void processarDevolucaoAMaiorOUAMenor(
			Collection<Devolucao> colecaoDevolucao, BigDecimal totalDevolucao,
			Collection<Pagamento> colecaoPagamento, BigDecimal totalExcedente)
			throws ControladorException {

		// declaração de variáveis
		Iterator iteratorColecaoDevolucao = null;
		Iterator iteratorColecaoPagamento = null;
		Pagamento pagamentoColecao = null;
		Devolucao devolucaoColecao = null;
		Devolucao devolucaoSelecionada = null;
		String[] idPagamento = new String[1];
		String[] idDevolucao = new String[1];

		try {
			// verifica se existe alguma devolução com o vslor igual ao valor
			// excedente
			if (colecaoDevolucao != null && !colecaoDevolucao.isEmpty()) {

				iteratorColecaoDevolucao = colecaoDevolucao.iterator();

				while (iteratorColecaoDevolucao.hasNext()) {

					devolucaoColecao = (Devolucao) iteratorColecaoDevolucao
							.next();

					if ((devolucaoColecao.getValorDevolucao() != null && devolucaoColecao
							.getValorDevolucao().equals(totalExcedente))
							&& devolucaoSelecionada == null) {

						devolucaoSelecionada = devolucaoColecao;

					} else if ((devolucaoColecao.getValorDevolucao() != null && devolucaoColecao
							.getValorDevolucao().equals(totalExcedente))
							&& (devolucaoSelecionada != null)) {
						// [FS0004 - Verificar seleção de mais de uma devolução]
						if (devolucaoColecao.getDataDevolucao() != null
								&& devolucaoSelecionada.getDataDevolucao() != null
								&& devolucaoColecao.getDataDevolucao()
										.after(
												devolucaoSelecionada
														.getDataDevolucao())) {
							devolucaoSelecionada = devolucaoColecao;
						}
					}
				}
			}

			if (devolucaoSelecionada != null) {

				SistemaParametro sistemaParametro = this.getControladorUtil()
						.pesquisarParametrosDoSistema();

				if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {

					iteratorColecaoPagamento = colecaoPagamento.iterator();

					/*
					 * Para todos os pagamentos da lista, tualiza a situação
					 * atual do pagamento (PGST_IDATUAL) com o valor
					 * correspondente a duplicidade/excesso devolvido
					 */
					while (iteratorColecaoPagamento.hasNext()) {
						pagamentoColecao = (Pagamento) iteratorColecaoPagamento
								.next();

						idPagamento[0] = String.valueOf(pagamentoColecao
								.getId());

						repositorioArrecadacao
								.atualizarSituacaoPagamento(
										idPagamento,
										PagamentoSituacao.DUPLICIDADE_EXCESSO_DEVOLVIDO);

						/*
						 * Para os pagamentos da lista com ano/mês de
						 * arrecadação igual ao ano/mês de arrecadação corrente
						 * (PGMT_AMREFERENCIAARRECADACAO igual a
						 * PARM_AMREFERENCIAARRECADACAO), atualiza a situação
						 * anterior do pagamento (PGST_IDANTERIOR) com o valor
						 * correspondente a pagamento em duplicidade/excesso.
						 */
						if (pagamentoColecao.getAnoMesReferenciaArrecadacao() == getSistemaParametro()
								.getAnoMesArrecadacao().intValue()) {
							repositorioArrecadacao
									.atualizarSituacaoAnteriorPagamento(
											idPagamento,
											PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);
						}
					}
				}

				/*
				 * Caso a guia de devolução esteja preenchida (GDEV_ID com o
				 * valor diferente de nulo), atualiza a situação atual da
				 * devolução (DVST_IDATUAL) com o valor correspondente a
				 * devolução classificada. Caso contrário, atualiza a situação
				 * da devolução (DVST_IDATUAL) com o valor correspndente a guia
				 * de devolução não informada.
				 */
				if (devolucaoSelecionada.getGuiaDevolucao() != null) {
					idDevolucao[0] = String.valueOf(devolucaoSelecionada
							.getId());
					repositorioArrecadacao.atualizarSituacaoDevolucao(
							idDevolucao,
							DevolucaoSituacao.DEVOLUCAO_CLASSIFICADA);
				} else {
					idDevolucao[0] = String.valueOf(devolucaoSelecionada
							.getId());
					repositorioArrecadacao.atualizarSituacaoDevolucao(
							idDevolucao,
							DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);
				}

			} else {
				/*
				 * Caso não exista nenhuma devolução com o valor igual ao valor
				 * excedente atualiza a situação atual das devoluções
				 * (DVST_IDATUAL) com o valor correspondente a valor não
				 * confere.
				 */
				if (colecaoDevolucao != null && !colecaoDevolucao.isEmpty()) {

					iteratorColecaoDevolucao = colecaoDevolucao.iterator();

					while (iteratorColecaoDevolucao.hasNext()) {
						devolucaoColecao = (Devolucao) iteratorColecaoDevolucao
								.next();
						idDevolucao[0] = String.valueOf(devolucaoColecao
								.getId());
						repositorioArrecadacao.atualizarSituacaoDevolucao(
								idDevolucao,
								DevolucaoSituacao.VALOR_NAO_CONFERE);
					}
				}
			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e Débito
	 * Tipo
	 * 
	 * [SF0003] Selecionar Guia de Pagamento pela Localidade, Imóvel, Cliente e
	 * Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre, Pedro
	 *         Alexandre
	 * @date 26/04/2006, 14/03/2007, 05/06/2007, 02/10/2007
	 * 
	 * @param imovel
	 * @param cliente
	 * @param debitoTipo
	 * @param anoMesFaturamento
	 * 
	 * @return GuiaPagamento
	 */
	public GuiaPagamento selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(
			Imovel imovel, Cliente cliente, DebitoTipo debitoTipo,
			Integer anoMesFaturamento) throws ControladorException {

		GuiaPagamento guiaPagamento = null;
		Collection<GuiaPagamento> colecaoGuiaPagamento = null;

		try {

			colecaoGuiaPagamento = repositorioArrecadacao
					.selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(
							imovel, cliente, debitoTipo, anoMesFaturamento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Caso a guia de pagamento seja encontrada o sistema retorna a guia de
		 * pagamento [FS0002 - Verificar seleção de mais de uma guia de
		 * pagamento]
		 */
		if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {

			if (colecaoGuiaPagamento.size() == 1) {
				guiaPagamento = (GuiaPagamento) Util
						.retonarObjetoDeColecao(colecaoGuiaPagamento);
			} else {
				Iterator iteratorColecaoGuiaPagamento = colecaoGuiaPagamento
						.iterator();

				while (iteratorColecaoGuiaPagamento.hasNext()) {

					guiaPagamento = (GuiaPagamento) iteratorColecaoGuiaPagamento
							.next();

					if (guiaPagamento.getDataVencimento() != null) {
						break;
					}
				}
			}
		}

		return guiaPagamento;

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Processa os pagamentos de débito a cobrar
	 * 
	 * [SF0006] Processar Pagamento de Débito a Cobrar
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre
	 * @date 27/04/2006, 11/12/2006
	 * 
	 * @param debitoACobrar
	 * @param colecaoPagamentos
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] processarPagamentoDebitoACobrar(
			DebitoACobrar debitoACobrar, Collection<Pagamento> colecaoPagamentos)
			throws ControladorException {

		/**
		 * Declaração de variáveis.
		 */
		Object[] retorno = new Object[2];
		Map mapPagamentosProcessados = new HashMap();
		Object[] arrayColecoesPagamentosAtualizar = null;

        
        //alterado por Vivianne Sousa data:11/04/2008
        //analista:Aryed
        BigDecimal valorDocumento = debitoACobrar.getValorTotalComBonus();
        

		/*
		 * [SF0007] Calcular Valor Total dos Pagamentos
		 */
		BigDecimal valorTotalPagamentosDebitoACobrar = this
				.calcularValorTotalPagamentos(colecaoPagamentos);

		/*
		 * Caso valor total dos pagamentos para o débito a cobrar seja igual ao
		 * valor do documento atualizar a situação atual dos pagamentos
		 * (PGST_IDATUAL) com valor correspondente a pagamento classificado
		 * (tabela PAGAMENTO_SITUACAO) e atualizar o id do débito a cobrar nos
		 * pagamentos (seta DBAC_ID da tabela PAGAMENTO para DBAC_ID da tabela
		 * DEBITO_A_COBRAR);
		 */
		if (valorTotalPagamentosDebitoACobrar.equals(valorDocumento)) {
			mapPagamentosProcessados.put(debitoACobrar.getId(),
					colecaoPagamentos);
		} else {

			/*
			 * [SF0008] Processar Pagamento a Maior ou a Menor
			 */
			arrayColecoesPagamentosAtualizar = this
					.processarPagamentoAMenorOUAMaior(
							valorTotalPagamentosDebitoACobrar, valorDocumento,
							colecaoPagamentos, debitoACobrar.getId());

			Collection colecaoPagamentosClassificados = (Collection) arrayColecoesPagamentosAtualizar[1];

			if (colecaoPagamentosClassificados != null
					&& !colecaoPagamentosClassificados.isEmpty()) {
				mapPagamentosProcessados.put(debitoACobrar.getId(),
						colecaoPagamentosClassificados);
			}
		}

		/**
		 * Retorna um array contendo: 0 - Map com pagamentos para processar com
		 * seu respectivos débito a cobrar. 1 - Array de coleções de pagamentos
		 * para atualizar.
		 */
		retorno[0] = mapPagamentosProcessados;
		retorno[1] = arrayColecoesPagamentosAtualizar;

		return retorno;
	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Selecionar Débito a Cobrar pela Localidade, Imóvel e Débito Tipo
	 * 
	 * [SF0005] Selecionar Débito a Cobrar pela Localidade, Imóvel e Débito Tipo
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 26/04/2006, 05/06/2007, 02/10/2007
	 * 
	 * @param imovel
	 * @param debitoTipo
	 * @param anoMesFaturamento
	 * 
	 * @return DebitoACobrar
	 */
	private DebitoACobrar selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(
			Imovel imovel, DebitoTipo debitoTipo, Integer anoMesFaturamento)
			throws ControladorException {

		DebitoACobrar debitoACobrar = null;
		Collection<DebitoACobrar> colecaoDebitoACobrar = null;

		try {

			colecaoDebitoACobrar = repositorioArrecadacao
					.selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(
							imovel, debitoTipo, anoMesFaturamento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Caso o débito a cobrar seja encontrado o sistema retorna o débito a
		 * cobrar [FS0003 - Verificar seleção de mais de um débito a cobrar]
		 */
		if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {

			if (colecaoDebitoACobrar.size() == 1) {
				debitoACobrar = (DebitoACobrar) Util
						.retonarObjetoDeColecao(colecaoDebitoACobrar);
			} else {
				Iterator iteratorColecaoDebitoACobrar = colecaoDebitoACobrar
						.iterator();

				while (iteratorColecaoDebitoACobrar.hasNext()) {

					debitoACobrar = (DebitoACobrar) iteratorColecaoDebitoACobrar
							.next();

					if (debitoACobrar.getGeracaoDebito() != null) {
						break;
					}
				}
			}
		}

		return debitoACobrar;

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * Selecionar Pagamentos não Classificados de Conta
	 * 
	 * [SF0010] Selecionar Pagamentos não Classificados de Conta
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * 
	 * @param imovel,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosConta(
			Imovel imovel, Integer anoMesReferenciaDevolucao)
			throws ControladorException {

		Collection<Pagamento> colecaoPagamento = null;

		if (imovel != null && anoMesReferenciaDevolucao != null) {

			try {

				colecaoPagamento = repositorioArrecadacao
						.selecionarPagamentosNaoClassificadosConta(imovel,
								anoMesReferenciaDevolucao);

			} catch (ErroRepositorioException ex) {
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}
		}

		return colecaoPagamento;

	}

	/**
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * [SF0012] Selecionar Pagamentos não classificados de guia de pagamento ou
	 * débito a cobrar
	 * 
	 * @author Raphael Rossiter
	 * @date 15/06/2006
	 * 
	 * @param imovel,
	 *            anoMesReferenciaDevolucao
	 * @return Collection<Pagamento>
	 */
	public Collection<Pagamento> selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(
			Imovel imovel, Cliente cliente, DebitoTipo debitoTipo)
			throws ControladorException {

		Collection<Pagamento> colecaoPagamento = null;

		if ((imovel != null || cliente != null) && debitoTipo != null) {

			try {

				colecaoPagamento = repositorioArrecadacao
						.selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(
								imovel, cliente, debitoTipo);

			} catch (ErroRepositorioException ex) {
				ex.printStackTrace();
				throw new ControladorException("erro.sistema", ex);
			}

		}

		return colecaoPagamento;

	}

	/**
	 * Insere os aviso deduções no aviso bancário
	 * 
	 * [UC0000] Inserir Aviso Bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 18/04/2006
	 * 
	 * @throws ControladorException
	 */
	public void inserirAvisosDeducoes(AvisoDeducoes avisoDeducoes,
			AvisoBancario avisoBancario) throws ControladorException {

		FiltroAvisoDeducoes filtroAvisoDeducoes = new FiltroAvisoDeducoes();
		filtroAvisoDeducoes.adicionarParametro(new ParametroSimples(
				FiltroAvisoDeducoes.AVISO_BANCARIO_ID, avisoBancario.getId()));
		filtroAvisoDeducoes.adicionarParametro(new ParametroSimples(
				FiltroAvisoDeducoes.DEDUCAO_TIPO_ID, avisoDeducoes
						.getDeducaoTipo().getId()));
		filtroAvisoDeducoes
				.adicionarCaminhoParaCarregamentoEntidade("avisoBancario");
		filtroAvisoDeducoes
				.adicionarCaminhoParaCarregamentoEntidade("deducaoTipo");

		Collection colecaoAvisoDeducaoBase = getControladorUtil().pesquisar(
				filtroAvisoDeducoes, AvisoDeducoes.class.getName());

		if (colecaoAvisoDeducaoBase != null
				&& !colecaoAvisoDeducaoBase.isEmpty()) {
			Iterator colecaoAvisoDeducaoBaseIterator = colecaoAvisoDeducaoBase
					.iterator();

			// Remove os avisos deduçoes já existentes na base para fazer a
			// inserção dos novos avisos deduções
			while (colecaoAvisoDeducaoBaseIterator.hasNext()) {
				AvisoDeducoes avisoDeducoesBase = (AvisoDeducoes) colecaoAvisoDeducaoBaseIterator
						.next();

				getControladorUtil().remover(avisoDeducoesBase);
			}
		}

		getControladorUtil().inserir(avisoDeducoes);
	}


	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * pesquisa os movimentos de débito automático para o banco,referentes ao
	 * grupo e ano/mês de faturamento informados
	 * 
	 * [SB0002] - Carregar Lista de Bancos
	 * 
	 * @author Sávio Luiz
	 * @date 18/04/2006
	 * 
	 * @param idFaturamentoGrupo,anoMesReferenciaFaturamento,idBanco
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ControladorException
	 */

	public Map<Banco, Collection<DebitoAutomaticoMovimento>> pesquisaDebitoAutomaticoMovimento(
			Collection colecaoIdsFaturamentoGrupo,
			Integer anoMesReferenciaFaturamento) throws ControladorException {

		Map<Banco, Collection<DebitoAutomaticoMovimento>> debitosAutomaticoBancosMap = null;
		try {

			Collection colecaoidsBancos = repositorioArrecadacao
					.pesquisaBancosDebitoAutomatico();

			if (colecaoidsBancos != null && !colecaoidsBancos.isEmpty()) {

				Collection colecaoBancoDebitoAutomaticoMovimento = repositorioArrecadacao
						.pesquisaDebitoAutomaticoMovimento(
								colecaoIdsFaturamentoGrupo,
								anoMesReferenciaFaturamento, colecaoidsBancos);

				if (colecaoBancoDebitoAutomaticoMovimento != null
						&& !colecaoBancoDebitoAutomaticoMovimento.isEmpty()) {

					debitosAutomaticoBancosMap = new HashMap();

					Iterator iteCollBancoDebitoAutomaticoMovimento = colecaoBancoDebitoAutomaticoMovimento
							.iterator();

					boolean primeiraVez = true;
					Integer idBancoUltimo = null;
					Banco bancoInserir = null;
					Collection colecaoDebitoAutomaticoMovimento = new ArrayList();

					while (iteCollBancoDebitoAutomaticoMovimento.hasNext()) {
						Object[] bancoDebitoAutomaticoMovimento = (Object[]) iteCollBancoDebitoAutomaticoMovimento
								.next();
						if (bancoDebitoAutomaticoMovimento != null) {

							Banco banco = null;
							DebitoAutomaticoMovimento debitoAutomaticoMovimento = null;
							// banco
							if (bancoDebitoAutomaticoMovimento[0] != null) {
								banco = (Banco) bancoDebitoAutomaticoMovimento[0];
							}
							// Debito Automatico Movimento
							if (bancoDebitoAutomaticoMovimento[1] != null) {
								debitoAutomaticoMovimento = (DebitoAutomaticoMovimento) bancoDebitoAutomaticoMovimento[1];
							}

							if (primeiraVez) {
								
								//VERIFICANDO SE HOUVE MUDANÇA DE BANCO
								if (idBancoUltimo != null &&
									!idBancoUltimo.equals(banco.getId())) {
									
									//FINALIZANDO O MOVIMENTO DO BANCO
									debitosAutomaticoBancosMap.put(bancoInserir,
									colecaoDebitoAutomaticoMovimento);
									
									//INICIANDO O MOVIMENTO DO PROXIMO BANCO
									colecaoDebitoAutomaticoMovimento = new ArrayList();
								}
								
								idBancoUltimo = banco.getId();
								bancoInserir = banco;
								primeiraVez = false;
							}
							
							if (idBancoUltimo.equals(banco.getId())) {
								
								//ACUMULNADO OS MOVIMENTOS
								colecaoDebitoAutomaticoMovimento.add(debitoAutomaticoMovimento);
							} 
							else {
								
								//FINALIZANDO O MOVIMENTO DO BANCO
								debitosAutomaticoBancosMap.put(bancoInserir,
								colecaoDebitoAutomaticoMovimento);
								
								//INICIANDO O MOVIMENTO DO PROXIMO BANCO
								colecaoDebitoAutomaticoMovimento = new ArrayList();
								
								idBancoUltimo = banco.getId();
								bancoInserir = banco;
								
								colecaoDebitoAutomaticoMovimento.add(debitoAutomaticoMovimento);
								primeiraVez = true;

							}

						}
					}
					
					debitosAutomaticoBancosMap.put(bancoInserir, colecaoDebitoAutomaticoMovimento);

				}
			}
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		return debitosAutomaticoBancosMap;
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * 
	 * @author Vivianne Sousa
	 * @date 20/04/2006
	 * 
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Collection filtrarAvisoBancarioAbertoFechado(
			AvisoBancarioHelper avisoBancarioHelper)
			throws ControladorException {

		try {
			Collection colecaoAvisosBancario = this.repositorioArrecadacao
					.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			AvisoBancarioHelper avisoBancarioHelperNovo = null;
			Iterator iterator = colecaoAvisosBancario.iterator();

			Collection colecaoAvisosBancarioHelperFinal = new ArrayList();
			colecaoAvisosBancarioHelperFinal
					.removeAll(colecaoAvisosBancarioHelperFinal);

			while (iterator.hasNext()) {

				Object[] dadosAvisoBancario = (Object[]) iterator.next();
				AvisoBancario avisoBancario = new AvisoBancario();

				avisoBancarioHelperNovo = new AvisoBancarioHelper();

				avisoBancarioHelperNovo.setTipoAviso(avisoBancarioHelper
						.getTipoAviso());

				Arrecadador arrecadador = new Arrecadador();
				arrecadador.setId((Integer) dadosAvisoBancario[0]);
				avisoBancario.setArrecadador(arrecadador);

				avisoBancario.setDataLancamento((Date) dadosAvisoBancario[1]);

				avisoBancario
						.setNumeroSequencial((Short) dadosAvisoBancario[2]);

				avisoBancario
						.setIndicadorCreditoDebito((Short) dadosAvisoBancario[3]);

				avisoBancario.setDataPrevista((Date) dadosAvisoBancario[4]);

				avisoBancario.setDataRealizada((Date) dadosAvisoBancario[5]);

				avisoBancario
						.setValorRealizado((BigDecimal) dadosAvisoBancario[6]);

				avisoBancario.setId((Integer) dadosAvisoBancario[15]);

				avisoBancarioHelperNovo.setAvisoBancario(avisoBancario);

				BigDecimal vlArrecadacaoFinal = new BigDecimal("0.00");
				BigDecimal vlDevolucaoFinal = new BigDecimal("0.00");

				if (dadosAvisoBancario[7] != null) {
					// valor da Arrecadacao Calculado
					vlArrecadacaoFinal = (BigDecimal) dadosAvisoBancario[7];
				}

				if (dadosAvisoBancario[8] != null) {
					// vlArrecadacaoInformado
					vlArrecadacaoFinal = vlArrecadacaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[8]);
				}

				if (dadosAvisoBancario[9] != null) {
					// vlAcertosArrecadacao1
					vlArrecadacaoFinal = vlArrecadacaoFinal
							.add((BigDecimal) dadosAvisoBancario[9]);
				}

				if (dadosAvisoBancario[10] != null) {
					// vlAcertosArrecadacao2
					vlArrecadacaoFinal = vlArrecadacaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[10]);
				}

				if (dadosAvisoBancario[11] != null) {
					// vlDevolucaoCalculado
					vlDevolucaoFinal = (BigDecimal) dadosAvisoBancario[11];
				}

				if (dadosAvisoBancario[12] != null) {
					// vlDevolucaoInformado
					vlDevolucaoFinal = vlDevolucaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[12]);
				}

				if (dadosAvisoBancario[13] != null) {
					// vlAcertosDevolucao1
					vlDevolucaoFinal = vlDevolucaoFinal
							.add((BigDecimal) dadosAvisoBancario[13]);
				}

				if (dadosAvisoBancario[14] != null) {
					// vlAcertosDevolucao2
					vlDevolucaoFinal = vlDevolucaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[14]);
				}
                    
				String situacaoAbertoFechado = ConstantesSistema.ABERTO;
				String situacaoAbertoFechadoNumero = "2";
				if (vlArrecadacaoFinal.compareTo(vlDevolucaoFinal) == 0) {
					situacaoAbertoFechado = ConstantesSistema.FECHADO;
					situacaoAbertoFechadoNumero = "3";
				}

				if (avisoBancarioHelper.getTipoAviso() == null
						|| avisoBancarioHelper.getTipoAviso().equals(
								situacaoAbertoFechadoNumero)) {
					avisoBancarioHelperNovo.setTipoAviso(situacaoAbertoFechado);
					colecaoAvisosBancarioHelperFinal
							.add(avisoBancarioHelperNovo);
				}

			}
			return colecaoAvisosBancarioHelperFinal;
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * Movimento de débito automático em arquivo TXT gerado e enviado ao banco.
	 * 
	 * [SB0001] - Gerar Movimento para Debito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * 
	 * @param idFaturamentoGrupo,anoMesReferenciaFaturamento,idBanco
	 * @throws ControladorException
	 */

	public void gerarMovimentoDebitoAutomaticoBanco(Map<Banco, 
		Collection<DebitoAutomaticoMovimento>> debitosAutomaticoBancosMap,
		Usuario usuario) throws ControladorException {
		
		Collection colecaoGerarMovimentoDebitoAutomatico = new ArrayList();

		// cria uma coleção com a a chave(Banco) do Map
		Iterator debitosAutomaticoBancosIterator = 
			debitosAutomaticoBancosMap.keySet().iterator();

		ArrecadadorMovimento arrecadadorMovimento = null;
		try {

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			EnvioEmail envioEmail = 
				getControladorCadastro()
					.pesquisarEnvioEmail(EnvioEmail.GERAR_MOVIMENTO_AUTOMATICO_BANCO);

			Integer idGrupoFaturamento = null;
			Integer anoMesReferencia = null;
			boolean primeiraVez = true;

			while (debitosAutomaticoBancosIterator.hasNext()) {
				
				Banco banco = (Banco) debitosAutomaticoBancosIterator.next();
				
				// recupera a coleção de valores(DebitoAutomaticoMovimento) pelo
				// valor, no map
				Collection<DebitoAutomaticoMovimento> colecaoDebitoAutomaticoMovimento = 
					debitosAutomaticoBancosMap.get(banco);
				
				Iterator debitoAutomaticoMovimentoIterator = 
					colecaoDebitoAutomaticoMovimento.iterator();
				
				GerarMovimentoDebitoAutomaticoBancoHelper gerarMovimentoDebitoAutomaticoBancoHelper = 
					new GerarMovimentoDebitoAutomaticoBancoHelper();

				StringBuilder registrosTipoE = new StringBuilder();
				Integer idArrecadadorContrato = null;
				String codigoConvenio = null;
				Integer numeroSequencialArquivoEnvio = null;
				String descricaoEmail = null;
				Short tamanhoMaximoIdentificacaoImovel = null;

				Object[] arrecadadorContrato = null;

				try {

					arrecadadorContrato = repositorioArrecadacao.pesquisaCamposArrecadadorContrato(banco.getId());
					
					if (arrecadadorContrato[0] != null) {
						idArrecadadorContrato = (Integer) arrecadadorContrato[0];
					}
					
					if (arrecadadorContrato[1] != null) {
						codigoConvenio = (String) arrecadadorContrato[1];
					}
					
					if (arrecadadorContrato[2] != null) {
						numeroSequencialArquivoEnvio = (Integer) arrecadadorContrato[2];
					}
					
					if (arrecadadorContrato[3] != null) {
						descricaoEmail = (String) arrecadadorContrato[3];
					}
					
					if (arrecadadorContrato[4] != null) {
						tamanhoMaximoIdentificacaoImovel = (Short) arrecadadorContrato[4];
					}
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}
				
				// instancia um objeto arrecadador movimento
				arrecadadorMovimento = new ArrecadadorMovimento();
				
				// +2 referentes a A e Z
				Integer quantidadeRegistrosMap = colecaoDebitoAutomaticoMovimento.size() + 2;
				
				arrecadadorMovimento.setCodigoRemessa(new Short("1"));
				
				// Código do convênio do arrecadador contrato
				arrecadadorMovimento.setCodigoConvenio(codigoConvenio);
				arrecadadorMovimento.setNomeEmpresa(getSistemaParametro().getNomeAbreviadoEmpresa());
				arrecadadorMovimento.setCodigoBanco(new Short(""+ banco.getId()));
				arrecadadorMovimento.setNomeBanco(banco.getDescricao());
				arrecadadorMovimento.setDataGeracao(new Date());
				arrecadadorMovimento.setNumeroSequencialArquivo(numeroSequencialArquivoEnvio + 1);
				arrecadadorMovimento.setNumeroVersaoLayout(new Integer(""+ getSistemaParametro().getNumeroLayoutFebraban()));
				arrecadadorMovimento.setDescricaoIdentificacaoServico(ConstantesSistema.DEBITO_AUTOMATICO);
				arrecadadorMovimento.setNumeroRegistrosMovimento(quantidadeRegistrosMap);
				
				Collection colecaoArrecadadorMovimentoItem = new ArrayList();
				BigDecimal valorTotalDebitado = new BigDecimal("0.00");

				while (debitoAutomaticoMovimentoIterator.hasNext()) {
					DebitoAutomaticoMovimento debitoAutomaticoMovimento = 
						(DebitoAutomaticoMovimento) debitoAutomaticoMovimentoIterator.next();

					Conta conta = debitoAutomaticoMovimento.getContaGeral().getConta();

					if (primeiraVez) {
						
						idGrupoFaturamento = 
							debitoAutomaticoMovimento.getFaturamentoGrupo().getId();
						
						anoMesReferencia = conta.getReferencia();
					}

					try {
						BigDecimal valorDebito = new BigDecimal("0.00");
						valorDebito = valorDebito.add(conta.getValorAgua());
						valorDebito = valorDebito.add(conta.getValorEsgoto());
						valorDebito = valorDebito.add(conta.getDebitos());
						valorDebito = valorDebito.subtract(conta.getValorCreditos());

						/*
						 * Colocado por Raphael Rossiter em 03/07/2007
						 * (Analista: Rosana Carvalho) OBJETIVO: Retirar o valor
						 * dos impostos do valor total da conta
						 */
						if (conta.getValorImposto() != null) {
							valorDebito = valorDebito.subtract(conta.getValorImposto());
						}

						valorTotalDebitado = valorTotalDebitado.add(valorDebito);

						// atualiza o objeto debito automatico movimento
						debitoAutomaticoMovimento.setDataVencimento(conta.getDataVencimentoConta());
						debitoAutomaticoMovimento.setDataVencimento(conta.getDataVencimentoConta());
						debitoAutomaticoMovimento.setNumeroSequenciaArquivoEnviado(
							arrecadadorMovimento.getNumeroSequencialArquivo());
						debitoAutomaticoMovimento.setUltimaAlteracao(new Date());

						repositorioUtil.atualizar(debitoAutomaticoMovimento);

						StringBuilder linhaTipoE = 
							criarRegistroTipoE(banco,
								debitoAutomaticoMovimento, tamanhoMaximoIdentificacaoImovel);

						// inseri o item do movimento arrecadador
						ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();
						Integer idRegistroCodigo = 
							repositorioArrecadacao.pesquisarIdRegistroCodigo(RegistroCodigo.CODIGO_E);
						
						RegistroCodigo registroCodigo = new RegistroCodigo();
						registroCodigo.setId(idRegistroCodigo);
						arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);
						arrecadadorMovimentoItem.setConteudoRegistro(linhaTipoE.toString());
						arrecadadorMovimentoItem.setDescricaoOcorrencia("OK");
						arrecadadorMovimentoItem.setIndicadorAceitacao(new Short("1"));
						arrecadadorMovimentoItem.setUltimaAlteracao(new Date());
						
						colecaoArrecadadorMovimentoItem.add(arrecadadorMovimentoItem);

						registrosTipoE.append(linhaTipoE);
						registrosTipoE.append(System.getProperty("line.separator"));

					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}
				
				arrecadadorMovimento.setValorTotalMovimento(valorTotalDebitado);
				arrecadadorMovimento.setUltimaAlteracao(new Date());
				Integer idArrecadadorMovimento = null;
				try {
					idArrecadadorMovimento = 
						(Integer) repositorioUtil.inserir(arrecadadorMovimento);
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}
				
				arrecadadorMovimento.setId(idArrecadadorMovimento);
				gerarMovimentoDebitoAutomaticoBancoHelper.setArrecadadorMovimento(arrecadadorMovimento);
				
				Iterator iteratorArrecadadorMovimentoItem = colecaoArrecadadorMovimentoItem.iterator();
				
				while (iteratorArrecadadorMovimentoItem.hasNext()) {
					ArrecadadorMovimentoItem arrecadadorMovimentoItem = 
						(ArrecadadorMovimentoItem) iteratorArrecadadorMovimentoItem.next();
					
					arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);
					try {
						repositorioUtil.inserir(arrecadadorMovimentoItem);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}

				// chama o gerar arquivo TXT para envio do banco
				StringBuilder arquivoTXTEnvio = 
					gerarArquivoTxt(arrecadadorMovimento, registrosTipoE);

				// atualiza o numero sequencial do arquivo no arrecadador
				// contrato
				try {
					repositorioArrecadacao.atualizarNumeroSequencialArrecadadorContrato(
						idArrecadadorContrato, 
						arrecadadorMovimento.getNumeroSequencialArquivo());
					
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}

				String emailRemetente = envioEmail.getEmailRemetente();
				String situacaoEmail = null;
				String tituloMensagem = 
					envioEmail.getTituloMensagem() + " " + 
					(arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento.getNumeroSequencialArquivo(): "");
				
				String mesAnoReferenciaFormatada = Util.formatarAnoMesParaMesAnoCom2Digitos(anoMesReferencia);
				String nomeZip = 
					banco.getDescricaoAbreviada()+ idGrupoFaturamento + mesAnoReferenciaFormatada;


				String emailReceptor = envioEmail.getEmailReceptor();
				boolean mandouEmailBanco = false;
				
				BufferedWriter out = null;
				
				// pegar o arquivo, zipar pasta e arquivo e escrever no stream
				try {


					File leitura = new File(nomeZip + ".rem");
					out = new BufferedWriter(
							new OutputStreamWriter(new FileOutputStream(leitura
									.getAbsolutePath())));
					out.write(arquivoTXTEnvio.toString());
					out.flush();

					// se o email do arrecadador movimento for preenchido
					if (descricaoEmail != null) {

						ServicosEmail.enviarMensagemArquivoAnexado(
								descricaoEmail, emailRemetente, tituloMensagem,
								"", leitura);
						mandouEmailBanco = true;
						ServicosEmail.enviarMensagemArquivoAnexado(
								emailReceptor, emailRemetente, tituloMensagem,
								"", leitura);
						situacaoEmail = "Enviado";
					} else {
						ServicosEmail.enviarMensagemArquivoAnexado(
								emailReceptor, emailRemetente, tituloMensagem,
								"", leitura);
						situacaoEmail = "Não Enviado";
					}

				} catch (SendFailedException e) {
					if (mandouEmailBanco) {
						situacaoEmail = "Enviado";
					} else {
						situacaoEmail = "Não Enviado";
					}

				} catch (IOException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				} catch (Exception e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				} finally{
					IoUtil.fecharStream(out);
				}

				gerarMovimentoDebitoAutomaticoBancoHelper.setBanco(banco);
				gerarMovimentoDebitoAutomaticoBancoHelper.setArrecadadorMovimento(arrecadadorMovimento);
				gerarMovimentoDebitoAutomaticoBancoHelper.setDescricaoEmail(descricaoEmail);
				gerarMovimentoDebitoAutomaticoBancoHelper.setSituacaoEnvioEmail(situacaoEmail);
				
				colecaoGerarMovimentoDebitoAutomatico.add(gerarMovimentoDebitoAutomaticoBancoHelper);
			}

			// Parte que gera o relatório e envia por email
			// cria uma instância da classe do relatório
			// cria uma instância da classe do relatório
			RelatorioMovimentoDebitoAutomaticoBanco relatorioMovimentoDebitoAutomaticoBanco = 
				new RelatorioMovimentoDebitoAutomaticoBanco(usuario);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro(
				"colecaoGerarMovimentoDebitoAutomatico",colecaoGerarMovimentoDebitoAutomatico);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro(
				"tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
			
			byte[] relatorioGerado = 
				(byte[]) relatorioMovimentoDebitoAutomaticoBanco.executar();

			String emailRemetente = envioEmail.getEmailRemetente();
			String tituloMensagem = envioEmail.getTituloMensagem()
					+ " "
					+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
							.getNumeroSequencialArquivo()
							: "");

			String corpoMensagem = envioEmail.getCorpoMensagem();
			String emailReceptor = envioEmail.getEmailReceptor();

			ZipOutputStream zos = null;
			FileOutputStream out = null;
			
			try {
				//Alterado por Sávio Luiz Data:15/01/2008
				//Arquivo que é enviado para o e-mail também 
				//ficará no bin do servidor.
				String nomeZip = "gerar_movimento_banco_sequencial_"+arrecadadorMovimento.getNumeroSequencialArquivo();
				File leitura = new File("gcom.PDF");
				File compactado = new File(nomeZip + ".zip"); // nomeZip

				zos = new ZipOutputStream(new FileOutputStream(
						compactado));
				out = new FileOutputStream(leitura
						.getAbsolutePath());

				out.write(relatorioGerado);
				out.flush();
				
				ZipUtil.adicionarArquivo(zos, leitura);
				
				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
					emailRemetente, 
					tituloMensagem, 
					corpoMensagem, 
					leitura);

				leitura.delete();
			} catch (SendFailedException e) {
				throw new ControladorException("erro.sistema", e);
			} finally{
				IoUtil.fecharStream(out);
				IoUtil.fecharStream(zos);
			}

		} catch (Exception e) {

			e.printStackTrace();

			EnvioEmail envioEmail = 
				getControladorCadastro()
					.pesquisarEnvioEmail(EnvioEmail.GERAR_MOVIMENTO_AUTOMATICO_BANCO_COM_ERRO);

			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			
			if (inicioMensagem != null
					&& (!inicioMensagem[0].equals("erro") && !inicioMensagem[0]
							.equals("atencao"))) {
				mensagem = "erro.sistema";
			}

			String emailRemetente = envioEmail.getEmailRemetente();
			String tituloMensagem = envioEmail.getTituloMensagem()
					+ " "
					+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento
							.getNumeroSequencialArquivo()
							: "");
			String emailReceptor = envioEmail.getEmailReceptor();

			try {
				ServicosEmail.enviarMensagem(emailRemetente, 
					emailReceptor,
					tituloMensagem, 
					ConstantesAplicacao.get(mensagem));
				
			} catch (ErroEmailException e1) {

			}
			
			if(!(e instanceof SendFailedException)) {
				sessionContext.setRollbackOnly();
			}
			

		}

	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * Cria uma linha de 150 posições com o registro tipo E.
	 * 
	 * 
	 * [SB0001] - Gerar Movimento para Debito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * 
	 * @param banco,debitoAutomaticoMovimento
	 * @return StringBuilder
	 * @throws ControladorException
	 */
	protected StringBuilder criarRegistroTipoE(Banco banco,
			DebitoAutomaticoMovimento debitoAutomaticoMovimento, Short tamanhoMaximoIdentificacaoImovel)
			throws ControladorException {
		StringBuilder registroTipoE = new StringBuilder();
		
		Conta conta = debitoAutomaticoMovimento.getContaGeral().getConta();
		
		FiltroImovel filtroImovel = new FiltroImovel();
		
		filtroImovel.adicionarParametro(
				new ParametroSimples(FiltroImovel.ID,conta.getImovel().getId()));
		
		Collection colecaoImoveis = 
			this.getControladorUtil()
				.pesquisar(filtroImovel, Imovel.class.getName());
		
		Imovel imovel = (Imovel) colecaoImoveis.iterator().next();
		
		registroTipoE.append("E");
		
		// identificação do cliente na empresa
		String identificacaoCliente = Util.adicionarZerosEsquedaNumeroTruncando(tamanhoMaximoIdentificacaoImovel.intValue(), ""
				+ imovel.getCodigoDebitoAutomatico());
		registroTipoE.append(Util.completaString(identificacaoCliente, 25));

		String codigoAgencia = debitoAutomaticoMovimento.getDebitoAutomatico()
				.getAgencia().getCodigoAgencia();
		// agencia para débito
		registroTipoE
				.append(Util.adicionarZerosEsquedaNumero(4, codigoAgencia));

		// Identificação do cliente no Banco
		registroTipoE.append(Util.completaString(debitoAutomaticoMovimento
				.getDebitoAutomatico().getIdentificacaoClienteBanco(), 14));
		// data de vencimento(AAAAMMDD)
		String dataVencimento = Util.recuperaAnoMesDiaDaData(conta
				.getDataVencimentoConta());
		registroTipoE.append(dataVencimento);
		// Valor do débito
		BigDecimal valorDebito = new BigDecimal("0.00");
		valorDebito = valorDebito.add(conta.getValorAgua());
		valorDebito = valorDebito.add(conta.getValorEsgoto());
		valorDebito = valorDebito.add(conta.getDebitos());
		valorDebito = valorDebito.subtract(conta.getValorCreditos());

		/*
		 * Colocado por Sávio Luiz em 31/08/2007 (Analista: Rosana Carvalho)
		 * OBJETIVO: Retirar o valor dos impostos do valor total da conta
		 */
		if (conta.getValorImposto() != null) {
			valorDebito = valorDebito.subtract(conta.getValorImposto());
		}

		String valorDebitoString = ("" + valorDebito).replace(".", "");
		registroTipoE.append(Util.adicionarZerosEsquedaNumero(15,
				valorDebitoString));
		// Código da moeda
		registroTipoE.append("03");
		// inicio preenchido conforme segue abaixo(E.07)
		// Ano/Mês de referência da conta no formato AAAAMM
		registroTipoE.append(conta.getReferencia());
		// Digito verificador da conta
		registroTipoE.append(conta.getDigitoVerificadorConta());
		// Id da conta
		registroTipoE.append(Util.completaString("" + conta.getId(), 9));
		// id do grupo de faturamento
		registroTipoE.append(Util.completaString(""
				+ debitoAutomaticoMovimento.getFaturamentoGrupo().getId(), 2));
		// reservado para o futuro
		registroTipoE.append(Util.completaString("", 42));
		// fim preenchido conforme segue abaixo(E.07)

		// reservado para o futuro
		registroTipoE.append(Util.completaString("", 20));
		// Tipo do Movimento
		registroTipoE.append("0");

		return registroTipoE;
	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * Gera o arquivo TXT para envio.
	 * 
	 * [SB0004] - Gerar Arquivo TXT para Envio do Banco
	 * 
	 * @author Sávio Luiz
	 * @date 20/04/2006
	 * 
	 * @param arrecadadorMovimento,registrosTipoE
	 * @return StringBuilder
	 * @throws ControladorException
	 */
	protected StringBuilder gerarArquivoTxt(
			ArrecadadorMovimento arrecadadorMovimento,
			StringBuilder registrosTipoE) {
		
		StringBuilder arquivoTXTEnvio = new StringBuilder();

		// gera o header do arquivo(registroCódigoA)
		arquivoTXTEnvio.append("A");
		arquivoTXTEnvio.append(Util.completaString(""+ arrecadadorMovimento.getCodigoRemessa(), 1));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getCodigoConvenio(), 20));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getNomeEmpresa(), 20));
		
		//codigo agente
		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		filtroArrecadador.adicionarParametro(
			new ParametroSimples(
				FiltroArrecadador.ID, 
				arrecadadorMovimento.getCodigoBanco()));
		
		Collection colecaoArrecadador = 
			Fachada.getInstancia().pesquisar(filtroArrecadador, Arrecadador.class.getName());
		
		String codigoAgente = "";
		if(!colecaoArrecadador.isEmpty()){
			Arrecadador arrecadador = (Arrecadador)Util.retonarObjetoDeColecao(colecaoArrecadador);
			codigoAgente = arrecadador.getCodigoAgente().toString();
		}
		
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(3, ""+ codigoAgente));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getNomeBanco(), 20));
		String dataGeracaoArquivo = Util.recuperaAnoMesDiaDaData(arrecadadorMovimento.getDataGeracao());		
		arquivoTXTEnvio.append(dataGeracaoArquivo);
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(6, ""+ arrecadadorMovimento.getNumeroSequencialArquivo()));
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(2, ""+ arrecadadorMovimento.getNumeroVersaoLayout()));
		arquivoTXTEnvio.append(Util.completaString(arrecadadorMovimento.getDescricaoIdentificacaoServico(), 17));
		arquivoTXTEnvio.append(Util.completaString("", 51));
		arquivoTXTEnvio.append("*");

		arquivoTXTEnvio.append(System.getProperty("line.separator"));
		
		// recupera todos os registros do tipo E
		arquivoTXTEnvio.append(registrosTipoE);
		
		// gera o trailler(registro código "Z") do arquivo de envio
		arquivoTXTEnvio.append("Z");
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(6, ""+ arrecadadorMovimento.getNumeroRegistrosMovimento()));
		
		String valorSemVirgula = ("" + arrecadadorMovimento.getValorTotalMovimento()).replace(".", "");
		arquivoTXTEnvio.append(Util.adicionarZerosEsquedaNumero(17,valorSemVirgula));
		arquivoTXTEnvio.append(Util.completaString("", 125));
		arquivoTXTEnvio.append("*");
		arquivoTXTEnvio.append(System.getProperty("line.separator"));
		
		// fim de arquivo
		arquivoTXTEnvio.append("\u0004");

		return arquivoTXTEnvio;

	}

	/**
	 * [UC0319] Gerar Movimento de Débito Automático para o banco
	 * 
	 * Cria uma linha de 150 posições com o registro tipo E.
	 * 
	 * 
	 * [SB0003] - Regerar arquivo TXT para um movimento de débito automático
	 * gerado anteriormente
	 * 
	 * @author Sávio Luiz
	 * @date 25/04/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Object[]
	 * @throws ControladorException
	 */
	public void regerarArquivoTxtMovimentoDebitoAutomatico(
			ArrecadadorMovimento arrecadadorMovimento, String envioBanco,
			Usuario usuario) throws ControladorException {

		try {
			StringBuilder linhasParaGerarTxt = new StringBuilder();
			Collection colecaoArrecadadorMovimentoItem = null;
			String descricaoEmail = null;

			String estadoEmail = null;
			try {
				colecaoArrecadadorMovimentoItem = 
					repositorioArrecadacao.consultarItensMovimentoArrecadador(
						arrecadadorMovimento, null, null, null);

				descricaoEmail = 
					repositorioArrecadacao.pesquisarEmailArrecadadorContrato(
						arrecadadorMovimento.getCodigoBanco());

			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}
			
			Iterator iteratorArrecadadorMovimentoItem = 
				colecaoArrecadadorMovimentoItem.iterator();
			
			while (iteratorArrecadadorMovimentoItem.hasNext()) {
				ArrecadadorMovimentoItem arrecadadorMovimentoItem = 
					(ArrecadadorMovimentoItem) iteratorArrecadadorMovimentoItem.next();
				
				linhasParaGerarTxt.append(arrecadadorMovimentoItem.getConteudoRegistro());
				linhasParaGerarTxt.append(System.getProperty("line.separator"));
			}
			
			EnvioEmail envioEmail = 
				getControladorCadastro().pesquisarEnvioEmail(
					EnvioEmail.REGERAR_MOVIMENTO_AUTOMATICO_BANCO);
			
			// cria o arquivo txt para o envio
			StringBuilder arquivoTxtGerado = 
				gerarArquivoTxt(arrecadadorMovimento, 
					linhasParaGerarTxt);

			String emailRemetente = envioEmail.getEmailRemetente();
			String tituloMensagem = envioEmail.getTituloMensagem() 
				+ " " 
				+ (arrecadadorMovimento.getNumeroSequencialArquivo() != null ? arrecadadorMovimento.getNumeroSequencialArquivo(): "");
			String corpoMensagem = envioEmail.getCorpoMensagem();
			
			String emailReceptor = envioEmail.getEmailReceptor();
			boolean mandouEmailBanco = false;
			
			ZipOutputStream zos = null;
			BufferedWriter out = null;
			
			try {

				String nomeZip = 
					"regerar_movimento_banco_sequencial_"+ arrecadadorMovimento.getNumeroSequencialArquivo();
				
				File compactado = new File(nomeZip + ".zip");
				zos = new ZipOutputStream(new FileOutputStream(
						compactado));
				File leitura = new File(nomeZip+".txt");
				out = new BufferedWriter(new OutputStreamWriter(
						new FileOutputStream(leitura.getAbsolutePath())));
				out.write(arquivoTxtGerado.toString());
				out.flush();
				ZipUtil.adicionarArquivo(zos, leitura);
				
				leitura.delete();
				// caso o envio do banco seja igual a 1, então envia para o
				// banco
				if (envioBanco.equals("1")) {
					
					// se o email do arrecadador movimento for preenchido
					if (descricaoEmail != null) {

						ServicosEmail.enviarMensagemArquivoAnexado(descricaoEmail, 
							emailRemetente, 
							tituloMensagem,
							"", 
							leitura);
						
						mandouEmailBanco = true;
						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, 
							emailRemetente, 
							tituloMensagem,
							"Registros Regerados", 
							leitura);

						estadoEmail = "Enviado";
					} else {
						
						ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor, 
							emailRemetente, 
							tituloMensagem,
							"Registros Regerados", 
							leitura);

						estadoEmail = "Não Enviado";
					}

				} else {
					ServicosEmail.enviarMensagemArquivoAnexado(
						emailReceptor,
						emailRemetente, 
						tituloMensagem,
						"Registros Gerados", 
						leitura);

					estadoEmail = "Não Enviado";
				}
				
				leitura.delete();
				
			} catch (SendFailedException e) {
				if (mandouEmailBanco) {
					estadoEmail = "Enviado";
				} else {
					estadoEmail = "Não Enviado";
				}

			} catch (IOException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			} catch (Exception e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			} finally{
				IoUtil.fecharStream(out);
				IoUtil.fecharStream(zos);
			}

			// Parte que gera o relatório e envia por email
			// cria uma instância da classe do relatório
			// cria uma instância da classe do relatório
			RelatorioMovimentoDebitoAutomaticoBanco relatorioMovimentoDebitoAutomaticoBanco = 
				new RelatorioMovimentoDebitoAutomaticoBanco(usuario);
			
			GerarMovimentoDebitoAutomaticoBancoHelper gerarMovimentoDebitoAutomaticoBancoHelper = 
				new GerarMovimentoDebitoAutomaticoBancoHelper();
			
			FiltroBanco filtroBanco = new FiltroBanco();
			filtroBanco.adicionarParametro(
				new ParametroSimples(FiltroBanco.ID,
					new Integer(arrecadadorMovimento.getCodigoBanco())));
			
			Collection colecaoBanco = 
				getControladorUtil().pesquisar(filtroBanco, Banco.class.getName());
			
			Banco banco = null;
			if (colecaoBanco != null && !colecaoBanco.isEmpty()) {
				banco = (Banco) Util.retonarObjetoDeColecao(colecaoBanco);
			}
			
			gerarMovimentoDebitoAutomaticoBancoHelper.setBanco(banco);
			gerarMovimentoDebitoAutomaticoBancoHelper.setArrecadadorMovimento(arrecadadorMovimento);
			gerarMovimentoDebitoAutomaticoBancoHelper.setDescricaoEmail(descricaoEmail);
			gerarMovimentoDebitoAutomaticoBancoHelper.setSituacaoEnvioEmail(estadoEmail);
			
			Collection colecaogerarMovimentoDebitoAutomatico = new ArrayList();
			
			colecaogerarMovimentoDebitoAutomatico.add(gerarMovimentoDebitoAutomaticoBancoHelper);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro(
					"colecaoGerarMovimentoDebitoAutomatico",
					colecaogerarMovimentoDebitoAutomatico);

			relatorioMovimentoDebitoAutomaticoBanco.addParametro(
				"tipoFormatoRelatorio", 
				TarefaRelatorio.TIPO_PDF);
			
			byte[] relatorioGerado = 
				(byte[]) relatorioMovimentoDebitoAutomaticoBanco.executar();

			FileOutputStream out2 = null;
			
			try {
				// Alterado por Sávio Luiz Data:15/01/2008
				// Arquivo que é enviado para o e-mail também
				// ficará no bin do servidor.
				String nomeZip = "regerar_movimento_banco_PDF_sequencial_" + 
					arrecadadorMovimento.getNumeroSequencialArquivo();
				
				File leitura = new File(nomeZip+".PDF");
				File compactado = new File(nomeZip + ".zip");
				zos = new ZipOutputStream(new FileOutputStream(
						compactado));
				out2 = new FileOutputStream(leitura
						.getAbsolutePath());
				out2.write(relatorioGerado);
				out2.flush();

				ZipUtil.adicionarArquivo(zos, leitura);
				
				ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
						emailRemetente, tituloMensagem, corpoMensagem, leitura);

				leitura.delete();
				
			} catch (IOException e) {
				throw new ControladorException("erro.sistema", e);
			} finally {
				IoUtil.fecharStream(out2);
				IoUtil.fecharStream(zos);				
			}

		} catch (Exception e) {

			String mensagem = e.getMessage();
			String[] inicioMensagem = mensagem.split("\\.");
			if (inicioMensagem != null && 
				(!inicioMensagem[0].equals("erro") && !inicioMensagem[0].equals("atencao"))) {
				
				mensagem = "erro.sistema";
			}

			if(!(e instanceof SendFailedException)) {
				sessionContext.setRollbackOnly();
			}

		}
	}

	/**
	 * [UC0322] - Inserir Guia de Devolução
	 * 
	 * Insere uma Guia de Devolução
	 * 
	 * @author Rafael Corrêa, Pedro Alexandre
	 * @date 29/04/2006, 21/11/2006
	 * 
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer inserirGuiaDevolucao(GuiaDevolucao guiaDevolucao, Usuario usuarioLogado) 
		throws ControladorException {

		String idRegistroAtendimento = guiaDevolucao.getRegistroAtendimento().getId().toString();

		Integer id = null;
		RegistroAtendimento registroAtendimento = null;
		OrdemServico ordemServico = null;

		//Verificar as permissão especial para inserir uma devolução quando o
		//valor da devolucao é maior que o valor da guia da devolucao
		//Vivianne Sousa - 01/08/2007
		boolean temPermissaoIcluirDevolucaoMaiorValorMaximo = 
			getControladorPermissaoEspecial().verificarPermissaoIcluirDevolucaoMaiorValorMaximo(usuarioLogado);

		// Pesquisar nos parâmetros do sistema AnoMesFaturamento
		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();

		// recupera o ano/mês de referência da arrecadação
		int anoMesArrecadacaoSistemaParametro = getSistemaParametro().getAnoMesArrecadacao();

		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);

		Date dataAtual = new Date();
		Date dataValidade = Util.adicionarNumeroDiasDeUmaData(dataAtual, 30);

		FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
		filtroRegistroAtendimento.adicionarParametro(
			new ParametroSimples(
				FiltroRegistroAtendimento.ID, 
				idRegistroAtendimento));

		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.localidade");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.setorComercial");
		filtroRegistroAtendimento.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra");

		Collection colecaoRegistrosAtendimentos = 
			getControladorUtil().pesquisar(filtroRegistroAtendimento,RegistroAtendimento.class.getName());

		if (colecaoRegistrosAtendimentos != null && !colecaoRegistrosAtendimentos.isEmpty()) {

			registroAtendimento = (RegistroAtendimento) colecaoRegistrosAtendimentos.iterator().next();

			if (registroAtendimento.getImovel() != null) {

				if (guiaDevolucao.getDocumentoTipo().getId().equals( "" + DocumentoTipo.CONTA) || 
					guiaDevolucao.getDocumentoTipo().getId().equals("" + DocumentoTipo.DEBITO_A_COBRAR)) {

					throw new ControladorException("atencao.registro.atendimento.sem.imovel", null,idRegistroAtendimento);
				}
			}
		} else {
			throw new ControladorException("atencao.pesquisa_inexistente",null, "Registro de Atendimento");
		}

		if (ordemServico != null && registroAtendimento != null) {

			if (ordemServico.getRegistroAtendimento() != null && 
				!ordemServico.getRegistroAtendimento().getId().equals(registroAtendimento.getId())) {

				throw new ControladorException("atencao.ordem.servico.diferente.registro.atendimento",null, idRegistroAtendimento);
			}
		}

		if (guiaDevolucao.getLocalidade() != null) {

			FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
			filtroLocalidade.adicionarParametro(
				new ParametroSimples(
					FiltroLocalidade.ID, 
					guiaDevolucao.getLocalidade().getId().toString()));

			Collection colecaoLocalidade = 
				getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());

			if (colecaoLocalidade != null && !colecaoLocalidade.isEmpty()) {
			} else {
				throw new ControladorException("atencao.pesquisa_inexistente",null, "Localidade");
			}
		}

		if (guiaDevolucao.getDocumentoTipo() != null) {

			// [FS0008] - Verificar existência da conta
			if (guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.CONTA)) {

				if (guiaDevolucao.getConta() == null) {
					throw new ControladorException("atencao.Informe_entidade", null, "Conta");
				}

				
				//PESQUISANDO A CONTA (CONTA E CONTA_HISTORICO)
				Collection colecaoConta = this.pesquisarContaParaGuiaDevolucao(registroAtendimento.getImovel(), 
				guiaDevolucao.getConta().getReferencia());

				
				if (colecaoConta != null && !colecaoConta.isEmpty()) {

					// [FS0009] - Verificar localidade da conta
//					ContaGeral contaGeral = this.verificarLocalidadeContaGuiaDevolucao(colecaoConta, 
//					localidade.getId().toString());
					
					ContaGeral contaGeral = Fachada.getInstancia().retornaContaGeral(colecaoConta);

					//[FS0018] - Verificar valor da devolução 
					BigDecimal valorLimite = this.verificarValorDevolucao(contaGeral, null, null);

					if (guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0) {

						if (valorLimite.compareTo(BigDecimal.ZERO) > 0 && 
							!temPermissaoIcluirDevolucaoMaiorValorMaximo) {

							throw new ControladorException("atencao.valor. devolucao.superior.valor.pagamento",
								null, Util.formatarMoedaReal(valorLimite),"Conta");

						}
						throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
					}
					FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
					filtroCreditoTipo.adicionarParametro(
						new ParametroSimples(
							FiltroCreditoTipo.ID,
							CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));

					filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

					CreditoTipo creditoTipo = 
						(CreditoTipo) getControladorUtil().pesquisar(filtroCreditoTipo,CreditoTipo.class.getName()).iterator().next();

					// [FS00018] - Verificar valor da devolução
					if (guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0 && 
						!temPermissaoIcluirDevolucaoMaiorValorMaximo) {
						throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade",null);
					}

					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);

					int anoMesConta = guiaDevolucao.getConta().getReferencia();

					guiaDevolucao.setConta(contaGeral.getConta());
					guiaDevolucao.setImovel(registroAtendimento.getImovel());
					guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
					guiaDevolucao.setAnoMesReferenciaContabil(new Integer(anoMesArrecadacaoSistemaParametro));
					guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(new Integer(anoMesConta));
					guiaDevolucao.setDataEmissao(dataAtual);
					guiaDevolucao.setDataValidade(dataValidade);
					guiaDevolucao.setCreditoTipo(creditoTipo);
					guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
					guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
					guiaDevolucao.setDocumentoTipo(documentoTipo);
					guiaDevolucao.setUltimaAlteracao(new Date());

					/**
					 * alterado por pedro alexandre dia 21/11/2006 alteração
					 * feita para acoplar o controle de abrangência de
					 * usuário
					 */
					Abrangencia abrangencia = 
						new Abrangencia(usuarioLogado, guiaDevolucao.getLocalidade());

					if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
						
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.acesso.negado.abrangencia");
					}
					
					/**
					 * Alterado por Hugo Leonardo. Data: 27/05/2010
					 * [UC0322] - Inserir guia de devolução
					 * 		[FS0023] - Verificar crédito a realizar.
					 * 
					 * Analista: Ana Cristina.
					 */
					Integer existeCreditoARealizar = null;
					existeCreditoARealizar = verificarExistenciaCreditoARealizar(
							guiaDevolucao.getImovel().getId(), guiaDevolucao.getAnoMesReferenciaGuiaDevolucao());
					
					Integer existeCreditoARealizarHistorico = null;
					existeCreditoARealizarHistorico = verificarExistenciaCreditoARealizarHistorico(
							guiaDevolucao.getImovel().getId(), guiaDevolucao.getAnoMesReferenciaGuiaDevolucao());
					
					if(existeCreditoARealizar != null || existeCreditoARealizarHistorico != null){
						
						String msgAnoMes = Util.formatarAnoMesParaMesAno(guiaDevolucao.getAnoMesReferenciaGuiaDevolucao());
						String msgValor = Util.formatarMoedaReal(valorLimite);
						sessionContext.setRollbackOnly();
						throw new ControladorException("atencao.conta_ja_devolvida", null, msgAnoMes, msgValor);
					}
					/**
					 * Fim Alteração realizada por: Hugo Leonardo. Data: 27/05/2010.
					 */
					
					
					id = (Integer) getControladorUtil().inserir(guiaDevolucao);

				} else {
					throw new ControladorException("atencao.pesquisa_inexistente", null, "Conta");
				}
			} else if (guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.GUIA_PAGAMENTO)) {

				// [FS0010] - Verificar existência da guia de pagamento
				if (guiaDevolucao.getGuiaPagamento() != null) {

					RegistroAtendimentoSolicitante registroAtendimentoSolicitante = null;

					FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

					filtro.adicionarParametro(
						new ParametroSimples(
							FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
							registroAtendimento.getId()));

					filtro.adicionarParametro(
						new ParametroSimples(
							FiltroRegistroAtendimentoSolicitante.INDICADOR_SOLICITANTE_PRINCIPAL,
							ConstantesSistema.SIM));

					filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");

					// Pesquisa de acordo com os parâmetros informados no filtro
					Collection colecao = 
						this.getControladorUtil().pesquisar(filtro,RegistroAtendimentoSolicitante.class.getName());

					String idCliente = null;
					if (colecao != null && !colecao.isEmpty()) {
						registroAtendimentoSolicitante = 
							(RegistroAtendimentoSolicitante) Util.retonarObjetoDeColecao(colecao);
						idCliente = ""+ registroAtendimentoSolicitante.getCliente().getId();
					}

					
					//PESQUISANDO A GUIA DE PAGAMENTO (GUIA_PAGAMENTO E GUIA_PAGAMENTO_HISTORICO)
					Collection colecaoGuiaPagamento = 
						this.pesquisarGuiaPagamentoParaGuiaDevolucao(registroAtendimento.getImovel().getId(), 
							new Integer(idCliente), 
							guiaDevolucao.getGuiaPagamento().getId());
					

					// Caso a guia de pagamento esteja cadastrada no sistema
					// Seta os dados da guai de pagamento no form
					// Caso contrário seta os dados da guia para nulo e informa
					// ao
					// usuário que não existe guia de pagamento cadastrada no
					// sistema
					if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {
						
						//[FS0011] - Verificar imóvel ou cliente da guia de Pagamento
						GuiaPagamentoGeral guiaPagamentoGeral = 
							this.verificarGuiaPagamentoParaGuiaDevolucao(colecaoGuiaPagamento, 
								registroAtendimento, 
								new Integer(idCliente),
								null, 
								ordemServico);

						
						//[FS0018] - Verificar valor da devolução 
						BigDecimal valorLimite = 
							this.verificarValorDevolucao(null, null, guiaPagamentoGeral);

						if (guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0) {

							if (valorLimite.compareTo(new BigDecimal("0.00")) > 0 && 
								!temPermissaoIcluirDevolucaoMaiorValorMaximo) {

								throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento",
									null,
									Util.formatarMoedaReal(valorLimite),
									"Guia de Pagamento");

							}
							throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");

						}
						FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
						filtroCreditoTipo.adicionarParametro(
							new ParametroSimples(
								FiltroCreditoTipo.ID,
								CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));

						filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

						CreditoTipo creditoTipo = 
							(CreditoTipo) getControladorUtil().pesquisar(filtroCreditoTipo,
									CreditoTipo.class.getName()).iterator().next();

						// [FS00018] - Verificar valor da devolução
						if (guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0 && 
							!temPermissaoIcluirDevolucaoMaiorValorMaximo) {
							
							throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade",null);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);

						guiaDevolucao.setImovel(registroAtendimento.getImovel());

						guiaDevolucao.setAnoMesReferenciaContabil(new Integer(anoMesArrecadacaoSistemaParametro));
						guiaDevolucao.setDataEmissao(dataAtual);
						guiaDevolucao.setDataValidade(dataValidade);
						guiaDevolucao.setCreditoTipo(creditoTipo);
						guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
						guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
						guiaDevolucao.setDocumentoTipo(documentoTipo);
						
						
						if (guiaPagamentoGeral.getGuiaPagamento() != null){
							guiaDevolucao.setLocalidade(guiaPagamentoGeral.getGuiaPagamento().getLocalidade());
							guiaDevolucao.setDebitoTipo(guiaPagamentoGeral.getGuiaPagamento().getDebitoTipo());
						}
						else{
							guiaDevolucao.setLocalidade(guiaPagamentoGeral.getGuiaPagamentoHistorico().getLocalidade());
							guiaDevolucao.setDebitoTipo(guiaPagamentoGeral.getGuiaPagamentoHistorico().getDebitoTipo());
						}

						guiaDevolucao.setGuiaPagamento(guiaPagamentoGeral.getGuiaPagamento());
						guiaDevolucao.setUltimaAlteracao(new Date());

						/**
						 * alterado por pedro alexandre dia 21/11/2006
						 * alteração feita para acoplar o controle de
						 * abrangência de usuário
						 */
						Abrangencia abrangencia = 
							new Abrangencia(usuarioLogado, 
								guiaDevolucao.getLocalidade());

						if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
							
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.acesso.negado.abrangencia");
						}
						id = (Integer) getControladorUtil().inserir(guiaDevolucao);

					} else {
						throw new ControladorException("atencao.pesquisa_inexistente", null,"Guia de Pagamento");
					}

				} else {
					throw new ControladorException("atencao.Informe_entidade",null, "Guia de Pagamento");
				}

			} else if (guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.DEBITO_A_COBRAR)) {

				// [FS0013] - Verificar existência do débito a cobrar

				// Caso o usuário tenha informado o código do débito a cobrar
				if (guiaDevolucao.getDebitoACobrarGeral() != null) {

					
					//PESQUISANDO O DEBITO A COBRAR (DEBITO_A_COBRAR E DEBITO_A_COBRAR_HISTORICO)
					Collection colecaoDebitoACobrar = 
						this.pesquisarDebitoACobrarParaGuiaDevolucao(
							registroAtendimento.getImovel(), 
							guiaDevolucao.getDebitoACobrarGeral().getId());
					

					if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {
						
						/*
						 * [FS0014] - Verificar imóvel do débito a cobrar
						 * [FS0015] - Verificar localidade do débito a cobrar
						 */
						DebitoACobrarGeral debitoACobrarGeral = 
							this.verificarDebitoACobrarParaGuiaDevolucao(
								colecaoDebitoACobrar, 
								registroAtendimento.getImovel().getId(), 
								registroAtendimento.getImovel().getLocalidade().getId(), 
								ordemServico);

						//[FS0018] - Verificar valor da devolução 
						BigDecimal valorLimite = 
							this.verificarValorDevolucao(null, debitoACobrarGeral, null);

						if (guiaDevolucao.getValorDevolucao().compareTo(valorLimite) > 0) {

							if (valorLimite.compareTo(new BigDecimal("0.00")) > 0 && 
								!temPermissaoIcluirDevolucaoMaiorValorMaximo) {

								throw new ControladorException("atencao.valor.devolucao.superior.valor.pagamento",
									null,
									Util.formatarMoedaReal(valorLimite),
									"Débito a Cobrar");
							}
							throw new ControladorException("atencao.valor.devolucao.menor.igual.zero");
						}
						FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
						filtroCreditoTipo.adicionarParametro(
							new ParametroSimples(
								FiltroCreditoTipo.ID,
								CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));

						filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

						CreditoTipo creditoTipo = 
							(CreditoTipo) getControladorUtil().pesquisar(filtroCreditoTipo,CreditoTipo.class.getName()).iterator().next();

						// [FS00018] - Verificar valor da devolução
						if (guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0 && 
							!temPermissaoIcluirDevolucaoMaiorValorMaximo) {
							throw new ControladorException("atencao.valor.devolucao.superior.valor.limite.duplicidade",null);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);

						guiaDevolucao.setImovel(registroAtendimento.getImovel());
						guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
						guiaDevolucao.setAnoMesReferenciaContabil(new Integer(anoMesArrecadacaoSistemaParametro));
						guiaDevolucao.setDataEmissao(dataAtual);
						guiaDevolucao.setDataValidade(dataValidade);
						guiaDevolucao.setCreditoTipo(creditoTipo);
						guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
						guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
						guiaDevolucao.setDocumentoTipo(documentoTipo);
						
						if (debitoACobrarGeral.getDebitoACobrar() != null){
							guiaDevolucao.setDebitoTipo(debitoACobrarGeral.getDebitoACobrar().getDebitoTipo());
						}
						else{
							guiaDevolucao.setDebitoTipo(debitoACobrarGeral.getDebitoACobrarHistorico().getDebitoTipo());
						}
						
						
						guiaDevolucao.setDebitoACobrarGeral(debitoACobrarGeral);
						guiaDevolucao.setUltimaAlteracao(new Date());

						/**
						 * alterado por pedro alexandre dia 21/11/2006
						 * alteração feita para acoplar o controle de
						 * abrangência de usuário
						 */
						Abrangencia abrangencia = 
							new Abrangencia(usuarioLogado, guiaDevolucao.getLocalidade());

						if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
							
							sessionContext.setRollbackOnly();
							throw new ControladorException("atencao.acesso.negado.abrangencia");
						}
						id = (Integer) getControladorUtil().inserir(guiaDevolucao);
					} else {
						throw new ControladorException("atencao.pesquisa_inexistente", null,"Débito a Cobrar");
					}
				} else {
					throw new ControladorException("atencao.Informe_entidade",null, "Débito a Cobrar");
				}
			} else if (guiaDevolucao.getDocumentoTipo().getId().equals(DocumentoTipo.DEVOLUCAO_VALOR)) {

				if (registroAtendimento.getImovel() == null) {
					if (guiaDevolucao.getLocalidade() == null) {
						throw new ControladorException("atencao.Informe_entidade", null, "Localidade");
					}
					FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
					filtroLocalidade.adicionarParametro(
						new ParametroSimples(
							FiltroLocalidade.ID, 
							guiaDevolucao.getLocalidade().getId().toString()));

					Collection colecaoLocalidade = 
						getControladorUtil().pesquisar(filtroLocalidade,Localidade.class.getName());

					if (colecaoLocalidade == null || colecaoLocalidade.isEmpty()) {
						throw new ControladorException("atencao.pesquisa_inexistente", null,"Localidade");
					}
				} else {
					guiaDevolucao.setLocalidade(registroAtendimento.getImovel().getLocalidade());
				}
				if (ordemServico == null || ordemServico.getServicoTipo().getDebitoTipo() == null) {
					
					if (guiaDevolucao.getDebitoTipo() == null) {
						throw new ControladorException("atencao.Informe_entidade", null,"Tipo de Débito");
					}
					FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(
						new ParametroSimples(
							FiltroDebitoTipo.ID, 
							guiaDevolucao.getDebitoTipo().getId().toString()));

					Collection colecaoDebitoTipo = 
						getControladorUtil().pesquisar(filtroDebitoTipo,DebitoTipo.class.getName());

					if (colecaoDebitoTipo == null || colecaoDebitoTipo.isEmpty()) {
						throw new ControladorException("atencao.pesquisa_inexistente", null,"Tipo de Débito");
					}
				}

				FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
				filtroCreditoTipo.adicionarParametro(
					new ParametroSimples(
						FiltroCreditoTipo.ID,
						CreditoTipo.DEVOLUCAO_OUTROS_VALORES));

				filtroCreditoTipo.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");

				CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
						.pesquisar(filtroCreditoTipo,CreditoTipo.class.getName()).iterator().next();

				// [FS00018] - Verificar valor da devolução
				if (guiaDevolucao.getValorDevolucao().compareTo(creditoTipo.getValorLimite()) > 0 && 
					!temPermissaoIcluirDevolucaoMaiorValorMaximo) {
					
					throw new ControladorException("atencao.valor.devolucao.superior.valor.limite",null);
				}

				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);

				guiaDevolucao.setImovel(registroAtendimento.getImovel());

				guiaDevolucao.setLocalidade(guiaDevolucao.getLocalidade());
				guiaDevolucao.setAnoMesReferenciaContabil(new Integer(anoMesArrecadacaoSistemaParametro));
				guiaDevolucao.setDataEmissao(dataAtual);
				guiaDevolucao.setDataValidade(dataValidade);
				guiaDevolucao.setCreditoTipo(creditoTipo);
				guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
				guiaDevolucao.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
				guiaDevolucao.setDocumentoTipo(documentoTipo);
				guiaDevolucao.setDebitoTipo(guiaDevolucao.getDebitoTipo());
				guiaDevolucao.setUltimaAlteracao(new Date());

				/**
				 * alterado por pedro alexandre dia 21/11/2006 alteração feita
				 * para acoplar o controle de abrangência de usuário
				 */
				Abrangencia abrangencia = 
					new Abrangencia(usuarioLogado,guiaDevolucao.getLocalidade());

				if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
					
					sessionContext.setRollbackOnly();
					throw new ControladorException("atencao.acesso.negado.abrangencia");
				}
				id = (Integer) getControladorUtil().inserir(guiaDevolucao);
			}
		}

		return id;

	}

	/**
	 * Atualizar Devolucao
	 * 
	 * @author Fernanda Paiva
	 * @created 03/05/2006
	 * 
	 * @param valor
	 *            arrecadacao
	 * 
	 * @exception controladorException
	 *                controlador Exception
	 */
	public void atualizaValorArrecadacaoAvisoBancaraio(BigDecimal valor,
			Integer codigoAvisoBancario) throws ControladorException {
		try {
			repositorioArrecadacao.atualizaValorArrecadacaoAvisoBancaraio(
					valor, codigoAvisoBancario);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * Faz a pesquisa de guia de devolução para o relatório fazendo os
	 * carregamentos de clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 11/09/2006
	 * 
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ControladorException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucaoRelatorio(
			FiltroGuiaDevolucao filtroGuiaDevolucao)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarGuiaDevolucaoRelatorio(filtroGuiaDevolucao);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * [UC0324] - Filtrar Guia de Devolucao
	 * 
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * 
	 * Faz a pesquisa de guia de devolução fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * 
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ControladorException
	 */
	public Collection<GuiaDevolucao> pesquisarGuiaDevolucao(
			FiltroGuiaDevolucao filtroGuiaDevolucao, Integer numeroPagina)
			throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarGuiaDevolucao(
					filtroGuiaDevolucao, numeroPagina);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * [UC0324] - Filtrar Guia de Devolucao
	 * 
	 * [SF0001] - Seleciona Guias de Devolução do Cliente
	 * 
	 * Faz a pesquisa de guia de devolução fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date
	 * 
	 * @param FiltroGuiaDevolucao
	 * @return Collection<GuiaDevolucao>
	 * @throws ControladorException
	 */
	public Integer pesquisarGuiaDevolucaoCount(
			FiltroGuiaDevolucao filtroGuiaDevolucao)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarGuiaDevolucaoCount(filtroGuiaDevolucao);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0266] - Manter Guia de Devolução
	 * 
	 * [SB0001] - Atualizar Guia de Devolução
	 * 
	 * Atualiza uma Guia de Devolução e as Devoluções associadas a ela
	 * 
	 * @author Rafael Corrêa
	 * @date 09/05/2006
	 * 
	 * @throws ControladorException
	 */
	public void atualizarGuiaDevolucao(GuiaDevolucao guiaDevolucao,
			Usuario usuarioLogado) throws ControladorException {

		/*--<merge>--String idRegistroAtendimento = guiaDevolucao.getRegistroAtendimento()
		 .getId().toString();*/
		String idRegistroAtendimento = null;

		RegistroAtendimento registroAtendimento = null;
		OrdemServico ordemServico = null;
		Localidade localidade = null;

		Date dataAtual = new Date();
		Date dataValidade = guiaDevolucao.getDataValidade();
		Date dataLimite = Util.adicionarNumeroDiasDeUmaData(dataAtual, 30);

		/** ************************************************************************************ */
		/** Verificar as permissão especial para inserir uma devolução quando o * */
		/** valor da devolucao é maior que o valor da guia da devolucao * */
		/** Vivianne Sousa - 01/08/2007 * */
		boolean temPermissaoIcluirDevolucaoMaiorValorMaximo = getControladorPermissaoEspecial()
				.verificarPermissaoIcluirDevolucaoMaiorValorMaximo(
						usuarioLogado);
		/** ************************************************************************************ */

		if (dataValidade.after(dataLimite)) {
			throw new ControladorException(
					"atencao.data.validade.superior.data.corrente.adicionado.trinta.dias",
					null, Util.formatarData(dataLimite));
		}

		FiltroRegistroAtendimento filtroRegistroAtendimento = new FiltroRegistroAtendimento();
		filtroRegistroAtendimento.adicionarParametro(new ParametroSimples(
				FiltroRegistroAtendimento.ID, idRegistroAtendimento));

		filtroRegistroAtendimento
				.adicionarCaminhoParaCarregamentoEntidade("imovel.localidade");
		filtroRegistroAtendimento
				.adicionarCaminhoParaCarregamentoEntidade("imovel.setorComercial");
		filtroRegistroAtendimento
				.adicionarCaminhoParaCarregamentoEntidade("imovel.quadra");
		filtroRegistroAtendimento
				.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoRegistrosAtendimentos = getControladorUtil()
				.pesquisar(filtroRegistroAtendimento,
						RegistroAtendimento.class.getName());

		if (colecaoRegistrosAtendimentos != null
				&& !colecaoRegistrosAtendimentos.isEmpty()) {
			registroAtendimento = (RegistroAtendimento) colecaoRegistrosAtendimentos
					.iterator().next();

		} else {
			throw new ControladorException("atencao.pesquisa_inexistente",
					null, "Registro de Atendimento");
		}


		if (ordemServico != null && registroAtendimento != null) {
			if (ordemServico.getRegistroAtendimento() != null
					&& !ordemServico.getRegistroAtendimento().getId().equals(
							registroAtendimento.getId())) {
				throw new ControladorException(
						"atencao.ordem.servico.diferente.registro.atendimento",
						null, idRegistroAtendimento);
			}
		}

		if (guiaDevolucao.getLocalidade() != null) {
			FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
			filtroLocalidade.adicionarParametro(new ParametroSimples(
					FiltroLocalidade.ID, guiaDevolucao.getLocalidade().getId()
							.toString()));

			Collection colecaoLocalidade = getControladorUtil().pesquisar(
					filtroLocalidade, Localidade.class.getName());

			if (colecaoLocalidade != null && !colecaoLocalidade.isEmpty()) {
				localidade = (Localidade) colecaoLocalidade.iterator().next();

			} else {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Localidade");
			}
		}

		if (guiaDevolucao.getDocumentoTipo() != null) {

			// [FS0008] - Verificar existência da conta
			if (guiaDevolucao.getDocumentoTipo().getId().equals(
					DocumentoTipo.CONTA)) {
				if (guiaDevolucao.getConta() == null) {
					throw new ControladorException("atencao.Informe_entidade",
							null, "Conta");
				}

				// Cria o filtro de conta e seta todos os parâmetros para
				// pesquisar a
				// conta do imóvel
				FiltroConta filtroConta = new FiltroConta();
				filtroConta.adicionarParametro(new ParametroSimples(
						FiltroConta.IMOVEL_ID, registroAtendimento.getImovel()
								.getId().toString()));
				filtroConta.adicionarParametro(new ParametroSimples(
						FiltroConta.REFERENCIA, ""
								+ guiaDevolucao.getConta().getReferencia()));
				filtroConta
						.adicionarCaminhoParaCarregamentoEntidade("localidade");
				filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel");
				filtroConta
						.adicionarCaminhoParaCarregamentoEntidade("localidade");

				Collection colecaoConta = getControladorUtil().pesquisar(
						filtroConta, Conta.class.getName());

				if (colecaoConta != null && !colecaoConta.isEmpty()) {

					// Recupera a conta do imóvel com a referência informada
					Conta conta = (Conta) colecaoConta.iterator().next();

					// [FS0009] - Verificar localidade da conta
					if (!localidade.getId().equals(
							conta.getLocalidade().getId())) {
						throw new ControladorException(
								"atencao.imovel.localidade.diferente.conta.localidade",
								null, conta.getLocalidade().getId().toString(),
								registroAtendimento.getImovel().getLocalidade()
										.getId().toString(),
								registroAtendimento.getImovel().getId()
										.toString());
					}

					BigDecimal valorLimite = new BigDecimal("0.00");

					// Faz uma pesquisa em pagamento para somar o valor de
					// todos os pagamentos associados ao débito a cobrar,
					// depois subtraí-lo do valor total do débito e
					// verificar se o valor digitado é maior do que esse
					// valor
					FiltroPagamento filtroPagamento = new FiltroPagamento();
					filtroPagamento.adicionarParametro(new ParametroSimples(
							FiltroPagamento.CONTA_ID, conta.getId()));

					Collection colecaoPagamento = getControladorUtil()
							.pesquisar(filtroPagamento,
									Pagamento.class.getName());

					if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {
						Iterator colecaoPagamentoIterator = colecaoPagamento
								.iterator();

						while (colecaoPagamentoIterator.hasNext()) {
							Pagamento pagamento = (Pagamento) colecaoPagamentoIterator
									.next();
							valorLimite = valorLimite.add(pagamento
									.getValorPagamento());
						}

						valorLimite = valorLimite.subtract(conta
								.getValorTotal());

						FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
						filtroDevolucao
								.adicionarParametro(new ParametroSimples(
										FiltroDevolucao.GUIA_DEVOLUCAO_CONTA_ID,
										conta.getId()));

						Collection colecaoDevolucaoContas = getControladorUtil()
								.pesquisar(filtroDevolucao,
										Devolucao.class.getName());

						if (colecaoDevolucaoContas != null
								&& !colecaoDevolucaoContas.isEmpty()) {
							Iterator colecaoDevolucaoContasIterator = colecaoDevolucaoContas
									.iterator();
							while (colecaoDevolucaoContasIterator.hasNext()) {
								Devolucao devolucao = (Devolucao) colecaoDevolucaoContasIterator
										.next();
								valorLimite = valorLimite.subtract(devolucao
										.getValorDevolucao());
							}
						}

					} else {
						throw new ControladorException(
								"atencao.tipo.documento.sem.pagamentos.associados",
								null, "Conta "
										+ Util.formatarAnoMesParaMesAno(conta
												.getReferencia()) + " ");
					}

					if (guiaDevolucao.getValorDevolucao()
							.compareTo(valorLimite) > 0) {

						if (valorLimite.compareTo(new BigDecimal("0.00")) > 0
								&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {

							throw new ControladorException(
									"atencao.valor.devolucao.superior.valor.pagamento",
									null, Util.formatarMoedaReal(valorLimite),
									"Conta");

						}
						throw new ControladorException(
								"atencao.valor.devolucao.menor.igual.zero");
					}
					FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
					filtroCreditoTipo
							.adicionarParametro(new ParametroSimples(
									FiltroCreditoTipo.ID,
									CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
					filtroCreditoTipo
							.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
					CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
							.pesquisar(filtroCreditoTipo,
									CreditoTipo.class.getName()).iterator()
							.next();

					// [FS00018] - Verificar valor da devolução
					if (guiaDevolucao.getValorDevolucao().compareTo(
							creditoTipo.getValorLimite()) > 0
							&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {
						throw new ControladorException(
								"atencao.valor.devolucao.superior.valor.limite.duplicidade",
								null);
					}

					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.CONTA);

					int anoMesConta = guiaDevolucao.getConta()
							.getReferencia();

					guiaDevolucao.setDebitoTipo(null);

					guiaDevolucao.setConta(conta);
					guiaDevolucao
							.setImovel(registroAtendimento.getImovel());
					guiaDevolucao.setLocalidade(registroAtendimento
							.getImovel().getLocalidade());
					guiaDevolucao
							.setAnoMesReferenciaGuiaDevolucao(new Integer(
									anoMesConta));
					guiaDevolucao.setDataEmissao(dataAtual);
					guiaDevolucao.setDataValidade(dataValidade);
					guiaDevolucao.setCreditoTipo(creditoTipo);
					guiaDevolucao.setLancamentoItemContabil(creditoTipo
							.getLancamentoItemContabil());
					guiaDevolucao.setDocumentoTipo(documentoTipo);

				} else {
					throw new ControladorException(
							"atencao.pesquisa_inexistente", null, "Conta");
				}
			} else if (guiaDevolucao.getDocumentoTipo().getId().equals(
					DocumentoTipo.GUIA_PAGAMENTO)) {
				// [FS0010] - Verificar existência da guia de pagamento
				if (guiaDevolucao.getGuiaPagamento() != null) {
					// Pesquisa a guia de pagamento para o imóvel ou o cliente
					// informado verificando se o cliente ou o imóvel é nulo

					GuiaPagamento guiaPagamento = null;

					// Caso a guia de pagamento esteja cadastrada no sistema
					// Seta os dados da guai de pagamento no form
					// Caso contrário seta os dados da guia para nulo e informa
					// ao
					// usuário que não existe guia de pagamento cadastrada no
					// sistema
					if (guiaPagamento != null) {

						// [FS0011] - Verificar imóvel ou cliente da guia de
						// pagamento
						if (registroAtendimento.getImovel() != null) {
							if (guiaPagamento.getImovel() == null) {
								throw new ControladorException(
										"atencao.guia.pagamento.imovel.inexistente",
										null);
							}
							// Verifica se o id do imóvel do Registro de
							// Atendimento
							// é diferente do id do imovel da Guia de
							// Pagamento
							if (!(registroAtendimento.getImovel().getId()
									.equals(guiaPagamento.getImovel()
											.getId()))) {
								throw new ControladorException(
										"atencao.imovel.guia.pagamento.diferente.registro.atendimento.imovel",
										null, guiaPagamento.getImovel()
												.getId().toString(),
										registroAtendimento.getImovel()
												.getId().toString());
							}
							// Verifica se o id do localidade do imóvel
							// do
							// Registro de Atendimento
							// é diferente do id da localidade da Guia
							// de
							// Pagamento
							if (!(localidade.getId()
									.equals(guiaPagamento
											.getLocalidade().getId()))) {
								throw new ControladorException(
										"atencao.imovel.localidade.diferente.guia.pagamento.localidade",
										null, guiaPagamento
												.getLocalidade()
												.getId().toString(),
										localidade.getId().toString(),
										registroAtendimento.getImovel()
												.getId().toString());
							}
						} 

						if (ordemServico != null) {
							if (ordemServico.getServicoTipo().getDebitoTipo() != null) {
								if (!(guiaPagamento.getDebitoTipo().getId()
										.equals(ordemServico.getServicoTipo()
												.getDebitoTipo().getId()))) {
									throw new ControladorException(
											"atencao.debito.tipo.guia.pagamento.diferente.ordem.servico.debito.tipo",
											null, guiaPagamento.getDebitoTipo()
													.getDescricao(),
											ordemServico.getServicoTipo()
													.getDebitoTipo()
													.getDescricao());
								}
							}
						}

						BigDecimal valorLimite = new BigDecimal("0.00");

						// Faz uma pesquisa em pagamento para somar o valor de
						// todos os pagamentos associados ao débito a cobrar,
						// depois subtraí-lo do valor total do débito e
						// verificar se o valor digitado é maior do que esse
						// valor
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento
								.adicionarParametro(new ParametroSimples(
										FiltroPagamento.GUIA_PAGAMENTO_ID,
										guiaPagamento.getId()));

						Collection colecaoPagamento = getControladorUtil()
								.pesquisar(filtroPagamento,
										Pagamento.class.getName());

						if (colecaoPagamento != null
								&& !colecaoPagamento.isEmpty()) {
							Iterator colecaoPagamentoIterator = colecaoPagamento
									.iterator();

							while (colecaoPagamentoIterator.hasNext()) {
								Pagamento pagamento = (Pagamento) colecaoPagamentoIterator
										.next();
								valorLimite = valorLimite.add(pagamento
										.getValorPagamento());
							}

							valorLimite = valorLimite.subtract(guiaPagamento
									.getValorDebito());

							FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
							filtroDevolucao
									.adicionarParametro(new ParametroSimples(
											FiltroDevolucao.GUIA_DEVOLUCAO_GUIA_PAGAMENTO_ID,
											guiaDevolucao.getGuiaPagamento()
													.getId()));

							Collection colecaoDevolucaoGuiasPagamentos = getControladorUtil()
									.pesquisar(filtroDevolucao,
											Devolucao.class.getName());

							if (colecaoDevolucaoGuiasPagamentos != null
									&& !colecaoDevolucaoGuiasPagamentos
											.isEmpty()) {
								Iterator colecaoDevolucaoGuiasPagamentosIterator = colecaoDevolucaoGuiasPagamentos
										.iterator();
								while (colecaoDevolucaoGuiasPagamentosIterator
										.hasNext()) {
									Devolucao devolucao = (Devolucao) colecaoDevolucaoGuiasPagamentosIterator
											.next();
									valorLimite = valorLimite
											.subtract(devolucao
													.getValorDevolucao());
								}
							}

						} else {
							throw new ControladorException(
									"atencao.tipo.documento.sem.pagamentos.associados",
									null, "Guia Pagamento "
											+ guiaPagamento.getId().toString()
											+ " ");
						}

						if (guiaDevolucao.getValorDevolucao().compareTo(
								valorLimite) > 0) {

							if (valorLimite.compareTo(new BigDecimal("0.00")) > 0
									&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {

								throw new ControladorException(
										"atencao.valor.devolucao.superior.valor.pagamento",
										null,
										Util.formatarMoedaReal(valorLimite),
										"Guia de Pagamento");

							}
							throw new ControladorException(
									"atencao.valor.devolucao.menor.igual.zero");
						}
						FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
						filtroCreditoTipo
								.adicionarParametro(new ParametroSimples(
										FiltroCreditoTipo.ID,
										CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
						filtroCreditoTipo
								.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
						CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
								.pesquisar(filtroCreditoTipo,
										CreditoTipo.class.getName())
								.iterator().next();

						// [FS00018] - Verificar valor da devolução
						if (guiaDevolucao.getValorDevolucao().compareTo(
								creditoTipo.getValorLimite()) > 0
								&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {
							throw new ControladorException(
									"atencao.valor.devolucao.superior.valor.limite.duplicidade",
									null);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);

						guiaDevolucao.setImovel(registroAtendimento
								.getImovel());
						/*--<merge>--guiaDevolucao.setCliente(registroAtendimento
						 .getCliente());*/
						guiaDevolucao.setLocalidade(guiaPagamento
								.getLocalidade());
						guiaDevolucao
								.setAnoMesReferenciaGuiaDevolucao(null);
						guiaDevolucao.setDataValidade(dataValidade);
						guiaDevolucao.setCreditoTipo(creditoTipo);
						guiaDevolucao.setLancamentoItemContabil(creditoTipo
								.getLancamentoItemContabil());
						guiaDevolucao.setDocumentoTipo(documentoTipo);
						guiaDevolucao.setDebitoTipo(guiaPagamento
								.getDebitoTipo());

						guiaDevolucao.setGuiaPagamento(guiaPagamento);

					} else {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Guia de Pagamento");
					}

				} else {
					throw new ControladorException("atencao.Informe_entidade",
							null, "Guia de Pagamento");
				}

			} else if (guiaDevolucao.getDocumentoTipo().getId().equals(
					DocumentoTipo.DEBITO_A_COBRAR)) {
				// [FS0013] - Verificar existência do débito a cobrar

				// Caso o usuário tenha informado o código do débito a cobrar
				if (guiaDevolucao.getDebitoACobrarGeral() != null) {
					// Pesquisa o débito a cobrar para o imóvel informado
					DebitoACobrar debitoACobrar = this
							.pesquisarDebitoACobrarDigitado(registroAtendimento
									.getImovel().getId().toString(),
									guiaDevolucao.getDebitoACobrarGeral().getId()
											.toString());

					if (debitoACobrar != null) {
						if (!(registroAtendimento.getImovel().getId()
								.equals(debitoACobrar.getImovel().getId()))) {
							throw new ControladorException(
									"atencao.imovel.debito.a.cobrar.diferente.registro.atendimento.imovel",
									null, debitoACobrar.getImovel().getId()
											.toString(), registroAtendimento
											.getImovel().getId().toString());
						}
						// [FS0015] - Verificar localidade do débito a
						// cobrar
						if (!registroAtendimento.getImovel()
								.getLocalidade().getId().equals(
										debitoACobrar.getLocalidade()
												.getId())) {
							throw new ControladorException(
									"atencao.imovel.localidade.diferente.debito.a.cobrar.localidade",
									null, debitoACobrar.getLocalidade()
											.getId().toString(),
									registroAtendimento.getImovel()
											.getLocalidade().getId()
											.toString(),
									registroAtendimento.getImovel().getId()
											.toString());
						}

						if (ordemServico != null) {
							if (ordemServico.getServicoTipo().getDebitoTipo() != null) {
								if (!(debitoACobrar.getDebitoTipo().getId()
										.equals(ordemServico.getServicoTipo()
												.getDebitoTipo().getId()))) {
									throw new ControladorException(
											"atencao.debito.tipo.debito.a.cobrar.diferente.ordem.servico.debito.tipo",
											null, debitoACobrar.getDebitoTipo()
													.getDescricao(),
											ordemServico.getServicoTipo()
													.getDebitoTipo()
													.getDescricao());
								}
							}
						}

						BigDecimal valorLimite = new BigDecimal("0.00");

						// Faz uma pesquisa em pagamento para somar o valor de
						// todos os pagamentos associados ao débito a cobrar,
						// depois subtraí-lo do valor total do débito e
						// verificar se o valor digitado é maior do que esse
						// valor
						FiltroPagamento filtroPagamento = new FiltroPagamento();
						filtroPagamento
								.adicionarParametro(new ParametroSimples(
										FiltroPagamento.DEBITO_A_COBRAR,
										debitoACobrar.getId()));

						Collection colecaoPagamento = getControladorUtil()
								.pesquisar(filtroPagamento,
										Pagamento.class.getName());

						if (colecaoPagamento != null
								&& !colecaoPagamento.isEmpty()) {
							Iterator colecaoPagamentoIterator = colecaoPagamento
									.iterator();

							while (colecaoPagamentoIterator.hasNext()) {
								Pagamento pagamento = (Pagamento) colecaoPagamentoIterator
										.next();
								valorLimite = valorLimite.add(pagamento
										.getValorPagamento());
							}

							valorLimite = valorLimite.subtract(debitoACobrar
									.getValorTotal());

							FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
							filtroDevolucao
									.adicionarParametro(new ParametroSimples(
											FiltroDevolucao.GUIA_DEVOLUCAO_DEBITO_A_COBRAR_ID,
											guiaDevolucao.getDebitoACobrarGeral()
													.getId()));

							Collection colecaoDevolucaoDebitosACobrar = getControladorUtil()
									.pesquisar(filtroDevolucao,
											Devolucao.class.getName());

							if (colecaoDevolucaoDebitosACobrar != null
									&& !colecaoDevolucaoDebitosACobrar
											.isEmpty()) {
								Iterator colecaoDevolucaoDebitosACobrarIterator = colecaoDevolucaoDebitosACobrar
										.iterator();
								while (colecaoDevolucaoDebitosACobrarIterator
										.hasNext()) {
									Devolucao devolucao = (Devolucao) colecaoDevolucaoDebitosACobrarIterator
											.next();
									valorLimite = valorLimite
											.subtract(devolucao
													.getValorDevolucao());
								}
							}

						} else {
							throw new ControladorException(
									"atencao.tipo.documento.sem.pagamentos.associados",
									null, "Débito a Cobrar "
											+ debitoACobrar.getId().toString()
											+ " ");
						}

						if (guiaDevolucao.getValorDevolucao().compareTo(
								valorLimite) > 0) {

							if (valorLimite.compareTo(new BigDecimal("0.00")) > 0
									&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {

								throw new ControladorException(
										"atencao.valor.devolucao.superior.valor.pagamento",
										null,
										Util.formatarMoedaReal(valorLimite),
										"Débito a Cobrar");

							}
							throw new ControladorException(
									"atencao.valor.devolucao.menor.igual.zero");
						}
						FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
						filtroCreditoTipo
								.adicionarParametro(new ParametroSimples(
										FiltroCreditoTipo.ID,
										CreditoTipo.DEVOLUCAO_PAGAMENTOS_DUPLICIDADE));
						filtroCreditoTipo
								.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
						CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
								.pesquisar(filtroCreditoTipo,
										CreditoTipo.class.getName())
								.iterator().next();

						// [FS00018] - Verificar valor da devolução
						if (guiaDevolucao.getValorDevolucao().compareTo(
								creditoTipo.getValorLimite()) > 0
								&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {
							throw new ControladorException(
									"atencao.valor.devolucao.superior.valor.limite.duplicidade",
									null);
						}

						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
						
						DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
						debitoACobrarGeral.setId(debitoACobrar.getId());

						guiaDevolucao.setImovel(registroAtendimento.getImovel());
						guiaDevolucao.setLocalidade(debitoACobrar.getLocalidade());
						guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
						guiaDevolucao.setDataValidade(dataValidade);
						guiaDevolucao.setCreditoTipo(creditoTipo);
						guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
						guiaDevolucao.setDocumentoTipo(documentoTipo);
						guiaDevolucao.setDebitoTipo(debitoACobrar.getDebitoTipo());
						guiaDevolucao.setDebitoACobrarGeral(debitoACobrarGeral);
					} else {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Débito a Cobrar");
					}
				} else {
					throw new ControladorException("atencao.Informe_entidade",
							null, "Débito a Cobrar");
				}
			} else if (guiaDevolucao.getDocumentoTipo().getId().equals(
					DocumentoTipo.DEVOLUCAO_VALOR)) {

				if (registroAtendimento.getImovel() == null) {
					if (guiaDevolucao.getLocalidade() == null) {
						throw new ControladorException(
								"atencao.Informe_entidade", null, "Localidade");
					}
					FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
					filtroLocalidade
							.adicionarParametro(new ParametroSimples(
									FiltroLocalidade.ID, guiaDevolucao
											.getLocalidade().getId()
											.toString()));

					Collection colecaoLocalidade = getControladorUtil()
							.pesquisar(filtroLocalidade,
									Localidade.class.getName());

					if (colecaoLocalidade == null
							|| colecaoLocalidade.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Localidade");
					}
				} else {
					guiaDevolucao.setLocalidade(registroAtendimento.getImovel()
							.getLocalidade());
				}
				if (ordemServico == null
						|| ordemServico.getServicoTipo().getDebitoTipo() == null) {
					if (guiaDevolucao.getDebitoTipo() == null) {
						throw new ControladorException(
								"atencao.Informe_entidade", null,
								"Tipo de Débito");
					}
					FiltroDebitoTipo filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo
							.adicionarParametro(new ParametroSimples(
									FiltroDebitoTipo.ID, guiaDevolucao
											.getDebitoTipo().getId()
											.toString()));

					Collection colecaoDebitoTipo = getControladorUtil()
							.pesquisar(filtroDebitoTipo,
									DebitoTipo.class.getName());

					if (colecaoDebitoTipo == null
							|| colecaoDebitoTipo.isEmpty()) {
						throw new ControladorException(
								"atencao.pesquisa_inexistente", null,
								"Tipo de Débito");
					}
				}

				FiltroCreditoTipo filtroCreditoTipo = new FiltroCreditoTipo();
				filtroCreditoTipo.adicionarParametro(new ParametroSimples(
						FiltroCreditoTipo.ID,
						CreditoTipo.DEVOLUCAO_OUTROS_VALORES));
				filtroCreditoTipo
						.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
				CreditoTipo creditoTipo = (CreditoTipo) getControladorUtil()
						.pesquisar(filtroCreditoTipo,
								CreditoTipo.class.getName()).iterator().next();

				// [FS00018] - Verificar valor da devolução
				if (guiaDevolucao.getValorDevolucao().compareTo(
						creditoTipo.getValorLimite()) > 0
						&& !temPermissaoIcluirDevolucaoMaiorValorMaximo) {
					throw new ControladorException(
							"atencao.valor.devolucao.superior.valor.limite",
							null);
				}

				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);

				guiaDevolucao.setImovel(registroAtendimento.getImovel());
				guiaDevolucao.setLocalidade(guiaDevolucao.getLocalidade());
				guiaDevolucao.setAnoMesReferenciaGuiaDevolucao(null);
				guiaDevolucao.setDataValidade(dataValidade);
				guiaDevolucao.setCreditoTipo(creditoTipo);
				guiaDevolucao.setLancamentoItemContabil(creditoTipo.getLancamentoItemContabil());
				guiaDevolucao.setDocumentoTipo(documentoTipo);
				guiaDevolucao.setDebitoTipo(guiaDevolucao.getDebitoTipo());
			}
		}

		FiltroGuiaDevolucao filtroGuiaDevolucao = new FiltroGuiaDevolucao();
		filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
				FiltroGuiaDevolucao.ID, guiaDevolucao.getId()));

		Collection colecaoGuiaDevolucao = getControladorUtil().pesquisar(
				filtroGuiaDevolucao, GuiaDevolucao.class.getName());
		GuiaDevolucao guiaDevolucaoBase = null;

		if (colecaoGuiaDevolucao != null && !colecaoGuiaDevolucao.isEmpty()) {
			guiaDevolucaoBase = (GuiaDevolucao) colecaoGuiaDevolucao.iterator()
					.next();
		} else {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		if (guiaDevolucaoBase != null
				&& guiaDevolucaoBase.getUltimaAlteracao().after(
						guiaDevolucao.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		guiaDevolucao.setUltimaAlteracao(new Date());
		getControladorUtil().atualizar(guiaDevolucao);

		// Faz um filtro das Devoluções associadas à guia de devolução
		// atualizada para atualizá-las também
		FiltroDevolucao filtroDevolucao = new FiltroDevolucao();
		filtroDevolucao.adicionarParametro(new ParametroSimples(
				FiltroDevolucao.GUIA_DEVOLUCAO_ID, guiaDevolucao.getId()));

		Collection colecaoDevolucao = getControladorUtil().pesquisar(
				filtroDevolucao, Devolucao.class.getName());

		if (colecaoDevolucao != null && !colecaoDevolucao.isEmpty()) {
			Iterator colecaoDevolucaoIterator = colecaoDevolucao.iterator();

			while (colecaoDevolucaoIterator.hasNext()) {
				Devolucao devolucao = (Devolucao) colecaoDevolucaoIterator
						.next();

				// Seta os valores para atualizar as devoluções
				devolucao.setAnoMesReferenciaDevolucao(guiaDevolucao
						.getAnoMesReferenciaGuiaDevolucao());
				devolucao.setLocalidade(guiaDevolucao.getLocalidade());
				devolucao.setImovel(guiaDevolucao.getImovel());
				devolucao.setCliente(guiaDevolucao.getCliente());
				devolucao.setDebitoTipo(guiaDevolucao.getDebitoTipo());
				devolucao.setUltimaAlteracao(new Date());

				getControladorUtil().atualizar(devolucao);

			}
		}
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo do Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa, Diogo Peixoto
	 * @created 24/05/2006, 20/04/2011
	 * 
	 * @param opcaoTotalizacao
	 * @param mesAnoReferencia
	 * @param gerenciaRegional
	 * @param localidade
	 * @param unidadeNegocio
	 * @param municipio
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorio(String opcaoTotalizacao, int mesAnoReferencia,
			Integer gerenciaRegional, Integer localidade, Integer unidadeNegocio, Integer municipio)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoResumoArrecadacaoRelatorio = null;

		// Converter de mesAno para anoMes para que funcione nas consultas
		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);
		boolean consultarResumoArrecadacaoRelatorio = true;

		try {

			if (opcaoTotalizacao.equals("estado")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
						.consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia, false);

			} else if (opcaoTotalizacao.equals("estadoGerencia")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
						.consultarResumoArrecadacaoRelatorioPorEstadoPorGerenciaRegional(anoMesReferencia);

			} else if (opcaoTotalizacao.equals("estadoLocalidade")) {
				retorno = consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(anoMesReferencia);
				consultarResumoArrecadacaoRelatorio = false;

			} else if (opcaoTotalizacao.equals("estadoMunicipio")) {
				retorno = consultarResumoArrecadacaoRelatorioPorEstadoPorMunicipio(anoMesReferencia);
				consultarResumoArrecadacaoRelatorio = false;

			} else if (opcaoTotalizacao.equals("gerenciaRegional")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
						.consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
								anoMesReferencia, gerenciaRegional);

			} else if (opcaoTotalizacao.equals("gerenciaRegionalLocalidade")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
						.consultarResumoArrecadacaoRelatorioPorGerenciaRegionalPorLocalidade(
								anoMesReferencia, gerenciaRegional);

			} else if (opcaoTotalizacao.equals("localidade")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
						.consultarResumoArrecadacaoRelatorioPorLocalidade(
								anoMesReferencia, localidade);

			} else if (opcaoTotalizacao.equals("municipio")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorMunicipio(
						anoMesReferencia, municipio);

			} else if (opcaoTotalizacao.equals("estadoUnidadeNegocio")) {
				retorno = consultarResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio(anoMesReferencia);

				consultarResumoArrecadacaoRelatorio = false;

			} else if (opcaoTotalizacao.equals("unidadeNegocio")) {
				colecaoResumoArrecadacaoRelatorio = repositorioArrecadacao
						.consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
								anoMesReferencia, unidadeNegocio);

			}

			if (consultarResumoArrecadacaoRelatorio) {

				Iterator iterator = colecaoResumoArrecadacaoRelatorio
						.iterator();

				// Prepara cada linha do relatório

				String recebimentoTipo = null;
				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String descMunicipioAnterior = null;
				String idMunicipioAnterior = null;
				String codigoCentroCusto = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				Boolean agrupaPorGerencia = false;
				if (opcaoTotalizacao.equalsIgnoreCase("estadoGerencia")
						|| opcaoTotalizacao
								.equalsIgnoreCase("gerenciaRegional")) {
					agrupaPorGerencia = true;
				}

				Boolean agrupaPorLocalidade = false;
				if (opcaoTotalizacao.equalsIgnoreCase("estadoLocalidade")
						|| opcaoTotalizacao
								.equalsIgnoreCase("gerenciaRegionalLocalidade")
						|| opcaoTotalizacao.equalsIgnoreCase("localidade")) {
					agrupaPorLocalidade = true;
				}

				Boolean agrupaPorUnidadeNegocio = false;
				if (opcaoTotalizacao.equalsIgnoreCase("unidadeNegocio")
						|| opcaoTotalizacao
								.equalsIgnoreCase("estadoUnidadeNegocio")) {
					agrupaPorUnidadeNegocio = true;
				}

				Boolean agrupaPorMunicipio = false;
				if (opcaoTotalizacao.equalsIgnoreCase("municipio") || opcaoTotalizacao.equalsIgnoreCase("estadoMunicipio")) {
					agrupaPorMunicipio = true;
				}
				
				while (iterator.hasNext()) {
					Object[] element = null;
					String tempRecebimentoTipo = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;

					element = (Object[]) iterator.next();

					if (recebimentoTipo == null) {
						recebimentoTipo = (String) element[1];
						tipoLancamento = (String) element[2];
						itemLancamento = (String) element[3];
						itemContabel = (String) element[4];
					}

					tempRecebimentoTipo = (String) element[1];
					tempTipoLancamento = (String) element[2];
					tempItemLancamento = (String) element[3];
					tempItemContabel = (String) element[4];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if (recebimentoTipo.equals(tempRecebimentoTipo)
							&& tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)) {

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if (itemContabel == null
								&& tempItemContabel == null
								|| (itemContabel != null
										&& tempItemContabel != null && itemContabel
										.equals(tempItemContabel))) {

							// se for agrupado por gerencia
							// compara se o registro atual eh da
							// mesma gerencia regional do registro anterior
							if (!agrupaPorGerencia
									|| descGerenciaRegionalAnterior == null
									|| (agrupaPorGerencia && descGerenciaRegionalAnterior
											.equalsIgnoreCase((String) element[10]))) {

								switch (((Integer) element[9]).intValue()) {
								case 1:
									arrayValores[0] = (BigDecimal) element[0];
									break;
								case 2:
									arrayValores[1] = (BigDecimal) element[0];
									break;
								case 3:
									arrayValores[2] = (BigDecimal) element[0];
									break;
								case 4:
									arrayValores[4] = (BigDecimal) element[0];
									break;
								}
							} else {
								condicaoIgual = false;
							}

						} else {

							condicaoIgual = false;
						}

					} else {

						condicaoIgual = false;

					}

					if (!condicaoIgual) {

						// adiciona uma linha no relátorio
						ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
								arrayValores,
								(String) elementAnterior[1],
								(String) elementAnterior[2],
								(String) elementAnterior[3],
								(String) elementAnterior[4],
								(Short) elementAnterior[5],
								(Short) elementAnterior[6],
								(Integer) elementAnterior[7],
								(Integer) elementAnterior[8], false,
								descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior,
								descLocalidadeAnterior, idLocalidadeAnterior,
								descMunicipioAnterior, idMunicipioAnterior,
								descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior,
								idUnidadeNegocioAnterior,
								codigoCentroCusto);

						retorno.add(resumoArrecadacaoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch (((Integer) element[9]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}

					}

					elementAnterior[1] = element[1]; // descricaoTipoRecebimento
					elementAnterior[2] = element[2]; // descricaoTipoLancamento
					elementAnterior[3] = element[3]; // descricaoItemLancamento
					elementAnterior[4] = element[4]; // descricaoItemContabil
					elementAnterior[5] = element[5]; // indicadorImpressao
					elementAnterior[6] = element[6]; // indicadorTotal
					elementAnterior[7] = element[7]; // lancamentoTipo
					elementAnterior[8] = element[8]; // lancamentoTipoSuperior

					// identifica pelo que vai ser "quebrado" o relátorio
					if (agrupaPorGerencia) {
						// quebra página por Gerência Regional e não mostra a
						// Localidade
						descGerenciaRegionalAnterior = "" + element[10];
						idGerenciaRegionalAnterior = "" + element[11];
					}else if (agrupaPorLocalidade) {						
						if (opcaoTotalizacao
								.equalsIgnoreCase("estadoLocalidade")
								|| opcaoTotalizacao
										.equalsIgnoreCase("gerenciaRegionalLocalidade")) {
							// quebra a página por Localidade e mostra a
							// Gerência
							// Regional
							descGerenciaRegionalAnterior = "" + element[10];
							idGerenciaRegionalAnterior = "" + element[11];
							descLocalidadeAnterior = "" + element[12];
							idLocalidadeAnterior = "" + element[13];
							codigoCentroCusto = "" + element[17];
						} else {
							// quebra a página por Localidade e não mostra a
							// Gerência
							// Regional
							descLocalidadeAnterior = "" + element[10];
							idLocalidadeAnterior = "" + element[11];
							codigoCentroCusto = "" + element[15];
						}
					}else if (agrupaPorUnidadeNegocio) {
						descUnidadeNegocioAnterior = "" + element[10];
						idUnidadeNegocioAnterior = "" + element[11];
					}else if(agrupaPorMunicipio){
						descMunicipioAnterior = (String) element[10];
						idMunicipioAnterior = String.valueOf((Integer) element[11]);
					}

					recebimentoTipo = tempRecebimentoTipo;
					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;

				}

				if (colecaoResumoArrecadacaoRelatorio != null
						&& !colecaoResumoArrecadacaoRelatorio.isEmpty()) {
					// adiciona a ultima linha
					ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
							arrayValores,
							(String) elementAnterior[1],
							(String) elementAnterior[2],
							(String) elementAnterior[3],
							(String) elementAnterior[4],
							(Short) elementAnterior[5],
							(Short) elementAnterior[6],
							(Integer) elementAnterior[7],
							(Integer) elementAnterior[8], false,
							descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior,
							idLocalidadeAnterior, null, null,
							descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior,
							idUnidadeNegocioAnterior,
							codigoCentroCusto);

					retorno.add(resumoArrecadacaoRelatorioHelper);
				}

			}

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0339] - Consultar Dados Diarios da Arrecadacao
	 * 
	 * [SB0006] - Apresentar Dados Diarios da Arrecadacao por Perfil
	 * 
	 * Acumula os dados por Perfil de uma Colecao de Dados Diarios da
	 * Arrecadação
	 * 
	 * @author Fernanda Paiva
	 * @date 24/05/2006
	 * 
	 * @throws ControladorException
	 */

	public void acumularDadosArrecadacao(
			Collection colecaoArrecadacaoDadosDiarios,
			ArrecadacaoDadosDiarios arrecadacaoDadosDiarios, int indicador,
			String idElo, String idGerencia, String idLocalidade) {

		if (colecaoArrecadacaoDadosDiarios.isEmpty()) {
			colecaoArrecadacaoDadosDiarios.add(arrecadacaoDadosDiarios);
		} else {

			Iterator iteratorColecaoArrecadacaoDadosDiarios = colecaoArrecadacaoDadosDiarios
					.iterator();

			// int indice = 0;
			// int indiceAAcumular = 0;
			boolean acumular = false;
			ArrecadacaoDadosDiarios arrecadacaoDadosDiariosSubstituir = null;

			// ArrecadacaoDadosDiarios arrecadacaoDadosDiarios2 = null;
			boolean achou = true;
			while (iteratorColecaoArrecadacaoDadosDiarios.hasNext() && achou) {
				acumular = false;

				arrecadacaoDadosDiariosSubstituir = (ArrecadacaoDadosDiarios) iteratorColecaoArrecadacaoDadosDiarios
						.next();

				if (indicador == 1) {
					// se a gerencia for igual
					if (arrecadacaoDadosDiarios.getGerenciaRegional().getId()
							.equals(
									arrecadacaoDadosDiariosSubstituir
											.getGerenciaRegional().getId())) {
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if (indicador == 2) {
					// se a arrecadador for igual
					if (arrecadacaoDadosDiarios.getArrecadador().getId()
							.equals(
									arrecadacaoDadosDiariosSubstituir
											.getArrecadador().getId())) {
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if (indicador == 3
						&& arrecadacaoDadosDiarios.getCategoria() != null
						&& arrecadacaoDadosDiariosSubstituir.getCategoria() != null) {
					// se a categoria for igual
					if (arrecadacaoDadosDiarios.getCategoria().getId().equals(
							arrecadacaoDadosDiariosSubstituir.getCategoria()
									.getId())) {
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if (indicador == 4
						&& arrecadacaoDadosDiarios.getImovelPerfil() != null
						&& arrecadacaoDadosDiariosSubstituir.getImovelPerfil() != null) {
					// se o Imovel Perfil for igual
					if (arrecadacaoDadosDiarios.getImovelPerfil().getId()
							.equals(
									arrecadacaoDadosDiariosSubstituir
											.getImovelPerfil().getId())) {
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if (indicador == 5) {
					// se o Documento for igual
					if (arrecadacaoDadosDiarios.getDocumentoTipoAgregador() != null &&
							arrecadacaoDadosDiarios.getDocumentoTipoAgregador().getId()
							.equals(
									arrecadacaoDadosDiariosSubstituir
											.getDocumentoTipoAgregador().getId())) {
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				if (indicador == 6) {
					// se o Elo for igual
					if (arrecadacaoDadosDiarios.getLocalidade().getId().equals(
							arrecadacaoDadosDiariosSubstituir.getLocalidade()
									.getId())) {
						acumular = true;
						// indiceAAcumular = indice;
						// arrecadacaoDadosDiariosSubstituir =
						// arrecadacaoDadosDiariosSubstituir;
						achou = false;
					}
				}
				// indice++;
			}// fim while

			// verfica se é para acumular
			if (acumular) {

				arrecadacaoDadosDiariosSubstituir
						.setValorPagamentos(arrecadacaoDadosDiariosSubstituir
								.getValorPagamentos().add(
										arrecadacaoDadosDiarios
												.getValorPagamentos()));

				if (indicador == 5) {
					arrecadacaoDadosDiariosSubstituir
							.setQuantidadePagamentos(arrecadacaoDadosDiariosSubstituir
									.getQuantidadePagamentos()
									+ arrecadacaoDadosDiarios
											.getQuantidadePagamentos());
				}

				// ((ArrayList) colecaoArrecadacaoDadosDiarios).set(
				// indiceAAcumular, arrecadacaoDadosDiariosSubstituir);

			} else {
				// se for diferente
				colecaoArrecadacaoDadosDiarios.add(arrecadacaoDadosDiarios);
			}
		}
	}

	/**
	 * Consulta a qtde de registros ResumoArrecadacao para a geração do
	 * relatório '[UC0345] Gerar Relatório de Resumo do Arrecadacao' de acordo
	 * com a opção de totalização.
	 * 
	 * @author Vivianne Sousa, Diogo Peixoto
	 * @created 02/06/2006, 20/04/2011
	 * 
	 * @param opcaoTotalizacao
	 * @param mesAnoReferencia
	 * @param gerenciaRegional
	 * @param localidade
	 * @param municipio
	 * 
	 * @return Quantidade de registros do relatório
	 * @throws ControladorException
	 */
	public Integer consultarQtdeRegistrosResumoArrecadacaoRelatorio(
			String opcaoTotalizacao, int mesAnoReferencia,
			Integer gerenciaRegional, Integer localidade, Integer municipio)
			throws ControladorException {

		Integer retorno = null;

		// Converter de mesAno para anoMes para que funcione na consulta
		int anoMesReferencia = Util.formatarMesAnoParaAnoMes(mesAnoReferencia);

		try {

			retorno = this.repositorioArrecadacao.consultarQtdeRegistrosResumoArrecadacaoRelatorio(
					anoMesReferencia, localidade, gerenciaRegional, municipio, opcaoTotalizacao);

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * @param colecaoIdsLocalidades
	 * @throws ControladorException
	 */
	public void encerrarArrecadacaoMes(Collection<Integer> colecaoIdsLocalidades, int idFuncionalidadeIniciada) throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.LOCALIDADE,
				((Integer) Util.retonarObjetoDeColecao(colecaoIdsLocalidades)));

		try {

			Collection colecaoDadosLancamentosItemContabil = this.repositorioArrecadacao.pesquisarDadosLancamentosItemContabil();
			Collection<Integer> colecaoIdsCategorias = this.repositorioArrecadacao.pesquisarIdsCategorias();

			Collection<ResumoArrecadacao> colecaoResumoArrecadacao = new ArrayList();

			ResumoArrecadacao resumoArrecadacaoTemp = new ResumoArrecadacao();
			RecebimentoTipo recebimentoTipoTemp = new RecebimentoTipo();
			LancamentoTipo lancamentoTipoTemp = new LancamentoTipo();
			LancamentoItem lancamentoItemTemp = new LancamentoItem();
			Imovel imovel = null;
			Object[] arrayDadosContaImpostosDeduzidos = null;
			Object[] arrayDadosPagamento = null;
			Object[] arrayDadosDevolucao = null;
			BigDecimal valorDevolucao = null;
			BigDecimal valorImposto = null;
			BigDecimal valorPagamento = null;
			BigDecimal valorExcedente = null;
			Integer idImovel = null;

			// Seqüêncial de Tipo de Lançamento 1100
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = BigDecimal.ZERO;
			
			// Seqüêncial de Tipo de Lançamento 1600
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = BigDecimal.ZERO;
			
			// Seqüêncial de Tipo de Lançamento 2000
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 = BigDecimal.ZERO;
			
			// Seqüêncial de Tipo de Lançamento 2400
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 2460
			BigDecimal valorDiferencaSequenciaTipoLancamentoIgual2440e2450 = BigDecimal.ZERO;
			// Sequencial de tipo de Lancamento 2485
			BigDecimal valorAcumuladoSequenciaTipoLancamentoIgual2440e2470 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 2500
			BigDecimal valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 2800
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 3200
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 3300
			BigDecimal valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 3400
			BigDecimal diferencaEntreSequencialTipoIgual2500e3300 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 4500
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 4510
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 5000
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 5010
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 5400
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 5410
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 5700
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 6100
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 6200
			BigDecimal valorAcumuladoContasContabilizadasComoPerdas = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 6600
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = BigDecimal.ZERO;
			// Seqüêncial de Tipo de Lançamento 7000
			BigDecimal valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = BigDecimal.ZERO;

			// Seqüêncial de Tipo de Lançamento 1200
			Map<Integer, BigDecimal> mapValorIRPagamentosClassificadosConta = new HashMap();
			// Seqüêncial de Tipo de Lançamento 1300
			Map<Integer, BigDecimal> mapValorCSLLPagamentosClassificadosConta = new HashMap();
			// Seqüêncial de Tipo de Lançamento 1400
			Map<Integer, BigDecimal> mapValorCOFINSPagamentosClassificadosConta = new HashMap();
			// Seqüêncial de Tipo de Lançamento 1500
			Map<Integer, BigDecimal> mapValorPISPASEPPagamentosClassificadosConta = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2100
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2200
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2210
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2220
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2230
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2240
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2300
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2440
			Map<Integer, BigDecimal> mapValorDevolucaoDescontosPagamentoAVista = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2450
			Map<Integer, BigDecimal> mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2470
			Map<Integer, BigDecimal> mapValorDevolucaoDescontosCreditosARealizar = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2600
			Map<Integer, BigDecimal> mapValorDevolucaoSituacaoAtualDevolucaoClassificada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 2900
			Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado = new HashMap();
			// Seqüêncial de Tipo de Lançamento 3000
			Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 3100
			Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4600
			Map<Integer, BigDecimal> mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4650
			Map<Integer, BigDecimal> mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4700
			Map<Integer, BigDecimal> mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4750
			Map<Integer, BigDecimal> mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4800
			Map<Integer, BigDecimal> mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4850
			Map<Integer, BigDecimal> mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4900
			Map<Integer, BigDecimal> mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 4950
			Map<Integer, BigDecimal> mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5500
			Map<Integer, BigDecimal> mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5800
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5900
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5910
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5920
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5930
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 5940
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6000
			Map<Integer, BigDecimal> mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6200
			Map<Integer, BigDecimal> mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6300
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6350
			Map<Integer, BigDecimal> mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6360
			Map<Integer, BigDecimal> mapValorPagamentoAVistaCampanhaCriancaComDireitoDesconto = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6400
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6410
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6420
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6430
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6440
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6500
			Map<Integer, BigDecimal> mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6700
			Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6800
			Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada = new HashMap();
			// Seqüêncial de Tipo de Lançamento 6900
			Map<Integer, BigDecimal> mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere = new HashMap();

			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

			if (getSistemaParametro() == null) {
				throw new ControladorException("atencao.entidade_sem_dados_para_selecao", null, "Sistema Parâmetro");
			}

			Integer anoMesCorrente = Util.recuperaAnoMesDaData(new Date());
			Integer anoMesReferenciaArrecadacao = getSistemaParametro().getAnoMesArrecadacao();

			if (anoMesCorrente.intValue() <= anoMesReferenciaArrecadacao.intValue()) {
				throw new ControladorException("atencao.arrecadacao.nao.pode.ser.fechada");
			}

			if (colecaoIdsLocalidades != null && !colecaoIdsLocalidades.isEmpty()) {

				for (Integer idLocalidade : colecaoIdsLocalidades) {
					repositorioArrecadacao.excluirResumoArrecadacaoPorAnoMesArrecadacaoPorLocalidade(anoMesReferenciaArrecadacao, idLocalidade);

					Collection colecaoResumoArrecadacaoNaBase = repositorioArrecadacao.pesquisarResumoArrecadacaoPorAnoMesArrecadacao(
							anoMesReferenciaArrecadacao, idLocalidade);

					if (colecaoResumoArrecadacaoNaBase != null && !colecaoResumoArrecadacaoNaBase.isEmpty()) {
						throw new ControladorException("atencao.resumo.arrecadacao.ja.existe.dados");
					}

					Localidade localidade = new Localidade(idLocalidade);

					Integer idGerenciaRegional = this.getControladorLocalidade().pesquisarIdGerenciaParaLocalidade(idLocalidade);
					GerenciaRegional gerenciaRegional = new GerenciaRegional(idGerenciaRegional);

					localidade.setGerenciaRegional(gerenciaRegional);
					
					// Seqüêncial de Tipo de Lançamento 2700
					Map<Integer, Map> mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil = new HashMap();

					// Seqüêncial de Tipo de Lançamento 5600
					Map<Integer, Map> mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil = new HashMap();

					mapValorIRPagamentosClassificadosConta.putAll(obterValorImpostoPagamentosClassificadosConta(anoMesReferenciaArrecadacao, idLocalidade, ImpostoTipo.IR));
					mapValorCSLLPagamentosClassificadosConta.putAll(obterValorImpostoPagamentosClassificadosConta(anoMesReferenciaArrecadacao, idLocalidade, ImpostoTipo.CSLL));
					mapValorCOFINSPagamentosClassificadosConta.putAll(obterValorImpostoPagamentosClassificadosConta(anoMesReferenciaArrecadacao, idLocalidade, ImpostoTipo.COFINS));
					mapValorPISPASEPPagamentosClassificadosConta.putAll(obterValorImpostoPagamentosClassificadosConta(anoMesReferenciaArrecadacao, idLocalidade, ImpostoTipo.PIS_PASEP));

					
					// Seqüêncial de Tipo de Lançamento 2100 Para os pagamentos não classificados do mês com situação atual igual a pagamento em duplicidade 
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.putAll(
							obterPagamentosNaoClassificadosMesPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE));

					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.putAll(
							obterPagamentosNaoClassificadosMesPorSituacaoAnterior(anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE));
					
					// DOCUMENTO_INEXISTENTE - 2200
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.putAll(
							obterPagamentosNaoClassificadosSituacaoAtualDocumentoInexistente(anoMesReferenciaArrecadacao, idLocalidade));
					
					// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO - 2210
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito.putAll(
							obterPagamentosNaoClassificadosSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO));

					// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA - 2220
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada.putAll(obterPagamentosNaoClassificadosSituacaoAtual(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA));

					// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA - 2230
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada.putAll(obterPagamentosNaoClassificadosSituacaoAtual(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA));

					// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO - 2240
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento.putAll(obterPagamentosNaoClassificadosSituacaoAtual(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO));


					// DOCUMENTO_INEXISTENTE - 2200
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.putAll(
							obterPagamentosNaoClassificadosSituacaoAnteriorDocumentoInexistente(anoMesReferenciaArrecadacao, idLocalidade));

					// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO - 2210
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito.putAll(obterPagamentosNaoClassificadosSituacaoAnterior(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO));

					// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA - 2220
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada.putAll(obterPagamentosNaoClassificadosSituacaoAnterior(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA));

					// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA - 2230
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada.putAll(obterPagamentosNaoClassificadosSituacaoAnterior(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA));

					// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO - 2240
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento.putAll(obterPagamentosNaoClassificadosSituacaoAnterior(
							anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO));


					// Seqüêncial de Tipo de Lançamento 2300 Para os pagamentos não classificados do mês com situação atual igual a valor não confere \
					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.putAll(
							obterPagamentosNaoClassificadosMesPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.VALOR_NAO_CONFERE));

					mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.putAll(
							obterPagamentosNaoClassificadosMesPorSituacaoAnterior(anoMesReferenciaArrecadacao, idLocalidade, PagamentoSituacao.VALOR_NAO_CONFERE));
					
					// Seqüêncial de Tipo de Lançamento 2440 Para as devoluções do tipo desconto por pagamento a vista, 
					Collection colecaoDevolucoesDescontosPagamentoAVista = repositorioArrecadacao.pesquisarDevolucoesDescontosPagamentoAVista(
							anoMesReferenciaArrecadacao, idLocalidade);

					mapValorDevolucaoDescontosPagamentoAVista.putAll(agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesDescontosPagamentoAVista));

					Map<Integer, BigDecimal> mapValoresRecuperacaoCreditoDuplicidade = acumularValoresRecebimentosClassificadosRecuperacaoCredito(localidade, 
							anoMesReferenciaArrecadacao, PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_DUPLICIDADE);
					Map<Integer, BigDecimal> mapValoresRecuperacaoCreditoCancelado = acumularValoresRecebimentosClassificadosRecuperacaoCredito(localidade, 
							anoMesReferenciaArrecadacao, PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_CANCELADO);
					Map<Integer, BigDecimal> mapValoresRecuperacaoCreditoDuplicidadeMesesAnteriores = acumularValoresRecebimentosClassificadosRecuperacaoCreditoMesesAnteriores(localidade, 
							anoMesReferenciaArrecadacao, PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_DUPLICIDADE);
					Map<Integer, BigDecimal> mapValoresRecuperacaoCreditoCanceladoMesesAnteriores = acumularValoresRecebimentosClassificadosRecuperacaoCreditoMesesAnteriores(localidade, 
							anoMesReferenciaArrecadacao, PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_CANCELADO);
					
					//Seqüêncial de Tipo de Lançamento 2450 Para as devoluções do tipo desconto por pagamento a vista pela campanha da criança
					Integer idRDComPercentualDoacao = getControladorCobranca().pesquisarResolucaoDiretoriaComPercentualDoacao();

					if (idRDComPercentualDoacao != null) {

						Collection colecaoDevolucoesDescontosPagamentoAVistaCampanhaCrianca = repositorioArrecadacao
								.pesquisarDevolucoesDescontosPagamentoAVistaCampanhaCrianca(anoMesReferenciaArrecadacao, idLocalidade, idRDComPercentualDoacao);

						mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.putAll(agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesDescontosPagamentoAVistaCampanhaCrianca));
					}

					/* 
					 * Seqüêncial de Tipo de Lançamento 2470 Para as devoluções do tipo desconto por credito , caracterizadas pelo tipo de documento agregador 
					 * não nulo e credito a realizar nao nulo. Acumula o valor da devolução por categoria, obtém as categorias do imóvel da devolução 
					 * relacionada e para cada categoria retornada obtém o valor por categoria.
					 */
					Collection colecaoDevolucoesDescontosCreditos = repositorioArrecadacao.pesquisarDevolucoesDescontosCreditos(anoMesReferenciaArrecadacao,
							idLocalidade);

					mapValorDevolucaoDescontosCreditosARealizar.putAll(agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesDescontosCreditos));
					
					/*
					 * Seqüêncial de Tipo de Lançamento 2600 Para asdevoluções classificadas com situação atual igual a devolução classificada acumula o valor 
					 * da devolução por categoria, obtém as categorias do imóvel da devolução relacionada e para cada categoria retornada obtém o valor por
					 * categoria.
					 */
					Collection colecaoDevolucoesClassificadasSituacaoAtualDevolucaoClassificada = repositorioArrecadacao
							.pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoClassificada(anoMesReferenciaArrecadacao, idLocalidade);
					
					mapValorDevolucaoSituacaoAtualDevolucaoClassificada.putAll(agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesClassificadasSituacaoAtualDevolucaoClassificada));
					

					// Laço de lançamento de item contábil para armazenar num map os maps de categoria e valor para cada item contábil
					for (Object dadosLancamentoItemContabil : colecaoDadosLancamentosItemContabil) {

						Object[] arrayDadosLancamentoItemContabil = (Object[]) dadosLancamentoItemContabil;

						Integer idLancamentoItemContabil = (Integer) arrayDadosLancamentoItemContabil[0];

						Map<Integer, BigDecimal> mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores = new HashMap();

						/*
						 * Seqüêncial de Tipo de Lançamento 2700 Para as devoluções classificadas com situação atual igual a devolução de outros valores 
						 * acumula o valor da devolução por categoria, obtém as categorias do imóvel da devolução relacionada e para cada categoria
						 * retornada obtém o valor por categoria.
						 */
						Collection colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores = repositorioArrecadacao
								.pesquisarDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores(anoMesReferenciaArrecadacao, idLocalidade,
										idLancamentoItemContabil);

						if (colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores != null
								&& colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores.size() > 0) {

							mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.putAll(
									agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesClassificadasSituacaoAtualDevolucaoOutrosValores));
							
							mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil.put(idLancamentoItemContabil,
									mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 5600 Para as devoluções efetuadas em meses anteriores classificadas no mês com situação atual 
						 * igual a devolução de outros valores acumula o valor da devolução por categoria, obtém as categorias do imóvel da devolução 
						 * relacionada e para cada categoria retornada obtém o valor por categoria.
						 */
						Map<Integer, BigDecimal> mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores = new HashMap();

						Collection colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores = repositorioArrecadacao
								.pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores(
										anoMesReferenciaArrecadacao, idLocalidade, idLancamentoItemContabil);

						if (colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores != null
								&& colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores.size() > 0) {
							
							mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores.putAll(
									agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoOutrosValores));
							
							mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil.put(idLancamentoItemContabil,
									mapValorDevolucaoEfetuadaEmMesesClasificadaNoMesAnterioresSituacaoAtualDevolucaoOutrosValores);
							
						}
					}

					
					/*
					 * Seqüêncial de Tipo de Lançamento 2900 Para as devoluções
					 * não classificadas no mês com situação atual igual a
					 * pagamento em duplicidade não encontrado acumula o valor
					 * da devolução por categoria, obtém as categorias do imóvel
					 * da devolução relacionada e para cada categoria retornada
					 * obtém o valor por categoria.
					 */
					Collection colecaoDevolucoesNaoClassificadasMesSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado = repositorioArrecadacao
							.pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);

					mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.putAll(
							agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesNaoClassificadasMesSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado));
					
					
					/*
					 * Seqüêncial de Tipo de Lançamento 3000 Para as devoluções não classificadas no mês com situação atual igual a guia de devolução não 
					 * informada acumula o valor da devolução por categoria, obtém as categorias do imóvel da devolução relacionada e para cada categoria 
					 * retornada obtém o valor por categoria.
					 */
					Collection colecaoDevolucoesNaoClassificadasMesSituacaoAtualGuiaDevolucaoNaoInformada = repositorioArrecadacao
							.pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);

					mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.putAll(
							agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesNaoClassificadasMesSituacaoAtualGuiaDevolucaoNaoInformada));
					

					/*
					 * Seqüêncial de Tipo de Lançamento 3100 Para as devoluções não classificadas no mês com situação atual igual a valor não confere acumula 
					 * o valor da devolução por categoria, obtém as categorias do imóvel da devolução relacionada e para cada categoria retornada obtém o 
					 * valor por categoria.
					 */
					Collection colecaoDevolucoesNaoClassificadasMesSituacaoAtualValorNaoConfere = repositorioArrecadacao
							.pesquisarDevolucoesNaoClassificadasMesPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									DevolucaoSituacao.VALOR_NAO_CONFERE);

					mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.putAll(
							agruparValoresPorCategoriaParaContabilizar(colecaoDevolucoesNaoClassificadasMesSituacaoAtualValorNaoConfere));
					

					/*
					 * Seqüêncial de Tipo de Lançamento 4600 Para cada grupo de pagamento de contas efetuadas em meses anteriores classificados no mês com 
					 * tipo de impostoigual a IR acumula o valor do imposto por categoria, obtém as categorias do imóvel da conta imposto deduzido
					 * relacionada e para cada categoria retornada obtém o valor por categoria.
					 */
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.IR);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoIR) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorIRPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorIRPorCategoria.hasNext()) {

									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria.next();

									if (!mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria.getId())) {
										mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
											mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(categoria.getId()).add(valorIR));
								}
							} else {
								if (!mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 4700 Para cada grupo de
					 * pagamento de contas efetuadas em meses anteriores
					 * classificados no mês com tipo de impostoigual a CSLL
					 * acumula o valor do imposto por categoria, obtém as
					 * categorias do imóvel da conta imposto deduzido
					 * relacionada e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.CSLL);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCSLL) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorCSLLPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorCSLLPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorCSLL = (BigDecimal) iteratorColecaoValorCSLLPorCategoria.next();

									if (!mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria.getId())) {
										mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
											mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(categoria.getId()).add(valorCSLL));
								}
							} else {
								if (!mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 4800 Para cada grupo de
					 * pagamento de contas efetuadas em meses anteriores
					 * classificados no mês com tipo de impostoigual a COFINS
					 * acumula o valor do imposto por categoria, obtém as
					 * categorias do imóvel da conta imposto deduzido
					 * relacionada e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.COFINS);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoCOFINS) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorCOFINSPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorCOFINSPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorCOFINS = (BigDecimal) iteratorColecaoValorCOFINSPorCategoria.next();

									if (!mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria.getId())) {
										mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
											mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(categoria.getId()).add(valorCOFINS));
								}
							} else {
								if (!mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 4900 Para cada grupo de
					 * pagamento de contas efetuadas em meses anteriores
					 * classificados no mês com tipo de impostoigual a PIS/PASEP
					 * acumula o valor do imposto por categoria, obtém as
					 * categorias do imóvel da conta imposto deduzido
					 * relacionada e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.PIS_PASEP);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosEmMesesAnterioresClassificadosMesImpostoTipoPIS_PASEP) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorPISPASEPPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorPISPASEPPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorPISPASEP = (BigDecimal) iteratorColecaoValorPISPASEPPorCategoria.next();

									if (!mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(categoria.getId())) {
										mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(),
											mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(categoria.getId()).add(valorPISPASEP));
								}
							} else {
								if (!mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					/**
					 * Alterar na geração do resumo separando contas de meses
					 * anteriores a 12-2012 dos demais
					 * 
					 * @author Wellington Rocha
					 * */

					// Sequencial 4650
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoIR = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.IR);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoIR != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoIR.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoIR) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorIRPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorIRPorCategoria.hasNext()) {

									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorIR = (BigDecimal) iteratorColecaoValorIRPorCategoria.next();

									if (!mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(categoria.getId())) {
										mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(),
											mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.get(categoria.getId()).add(valorIR));
								}
							} else {
								if (!mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					// Sequencial 4750
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte201212ClassificadosMesImpostoTipoCSLL = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.CSLL);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte201212ClassificadosMesImpostoTipoCSLL != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte201212ClassificadosMesImpostoTipoCSLL.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte201212ClassificadosMesImpostoTipoCSLL) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorCSLLPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorCSLLPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorCSLL = (BigDecimal) iteratorColecaoValorCSLLPorCategoria.next();

									if (!mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(categoria.getId())) {
										mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(),
											mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.get(categoria.getId()).add(valorCSLL));
								}
							} else {
								if (!mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					// Sequencial 4850
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoCOFINS = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.COFINS);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoCOFINS != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoCOFINS.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoCOFINS) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorCOFINSPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorCOFINSPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorCOFINS = (BigDecimal) iteratorColecaoValorCOFINSPorCategoria.next();

									if (!mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(categoria.getId())) {
										mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(),
											mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.get(categoria.getId()).add(valorCOFINS));
								}
							} else {
								if (!mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					// Sequencial 4950
					Collection colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoPIS_PASEP = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesPorTipoImposto(idLocalidade,
									anoMesReferenciaArrecadacao, ImpostoTipo.PIS_PASEP);

					if (colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoPIS_PASEP != null
							&& colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoPIS_PASEP.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosContasEfetuadosAte122012ClassificadosMesImpostoTipoPIS_PASEP) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorPISPASEPPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorPISPASEPPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorPISPASEP = (BigDecimal) iteratorColecaoValorPISPASEPPorCategoria.next();

									if (!mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(categoria.getId())) {
										mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(),
											mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.get(categoria.getId()).add(valorPISPASEP));
								}
							} else {
								if (!mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(Categoria.RESIDENCIAL)) {
									mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.put(Categoria.RESIDENCIAL,
										mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.get(Categoria.RESIDENCIAL).add(valorImposto));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 5500 Para as devoluções
					 * efetuadas em meses anteriores classificados no mês com
					 * situação da devolução atual igual a devolução
					 * classificada acumula o valor da devolução por categoria,
					 * obtém as categorias do imóvel da devolução relacionada e
					 * para cada categoria retornada obtém o valor por
					 * categoria.
					 */
					Collection colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada = repositorioArrecadacao
							.pesquisarDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada(anoMesReferenciaArrecadacao,
									idLocalidade);

					if (colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada != null
							&& colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.size() > 0) {
						for (Object dadosDevolucao : colecaoDevolucoesEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada) {

							arrayDadosDevolucao = (Object[]) dadosDevolucao;

							valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
							idImovel = (Integer) arrayDadosDevolucao[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorDevolucaoEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoValorDevolucaoEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
												.hasNext()) {

									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									valorDevolucao = (BigDecimal) iteratorColecaoValorDevolucaoEfetuadasEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
											.next();

									if (!mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.containsKey(categoria
											.getId())) {
										mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(categoria.getId(),
												BigDecimal.ZERO);
									}

									mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(
											categoria.getId(),
											mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.get(
													categoria.getId()).add(valorDevolucao));
								}

							} else {
								if (!mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
										.containsKey(Categoria.RESIDENCIAL)) {
									mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(Categoria.RESIDENCIAL,
											BigDecimal.ZERO);
								}
								mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.put(
										Categoria.RESIDENCIAL,
										mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.get(
												Categoria.RESIDENCIAL).add(valorDevolucao));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 5800 Para os pagamentos
					 * não classificados com baixa comandada com situação
					 * anterior igual a pagamento em duplicidade acumula o valor
					 * excedente do pagamento por categoria, obtém as categorias
					 * do imóvel do pagamento relacionado e para cada categoria
					 * retornada obtém o valor por categoria.
					 */
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);

					if (colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade != null
							&& colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.size() > 0) {

						for (Object dadosPagamento : colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade) {

							arrayDadosPagamento = (Object[]) dadosPagamento;
							valorExcedente = (BigDecimal) arrayDadosPagamento[0];
							idImovel = (Integer) arrayDadosPagamento[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorExcedentePorCategoria = (BigDecimal) iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
											.next();

									if (!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
											.containsKey(categoria.getId())) {
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
												categoria.getId(), BigDecimal.ZERO);
									}

									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
											categoria.getId(),
											mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.get(
													categoria.getId()).add(valorExcedentePorCategoria));
								}

							} else {
								if (!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
										.containsKey(Categoria.RESIDENCIAL)) {
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
											Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(
										Categoria.RESIDENCIAL,
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.get(
												Categoria.RESIDENCIAL).add(valorExcedente));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 5900 Para os pagamentos
					 * não classificados com baixa comandada com situação
					 * anterior igual a documento inexistente acumula o valor
					 * excedente do pagamento por categoria, obtém as categorias
					 * do imóvel do pagamento relacionado e para cada categoria
					 * retornada obtém o valor por categoria.
					 */
					/**
					 * 
					 * 
					 * Detalhar contabilização de documentos inexistentes
					 * 
					 * @author Wellington Rocha
					 * @author Felipe Santos
					 * @date 02/08/2012
					 */
					// DOCUMENTO_INEXISTENTE - 5900
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE);

					// Autor: Bruno Leonardo Rodrigues Barros
					// Analista: Aryed
					// Data: 22/04/2009
					// Considerar tambem além do documento inexistente tambem os
					// documentos a contabilizar
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoAContabilizar = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

					if (colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoAContabilizar != null) {
						colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente
								.addAll(colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoAContabilizar);
					}
					// Fim alteração Bruno Barros

					mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente,
									colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente));

					// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO - 5910
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO);

					mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito,
									colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito));

					// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA - 5920
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA);

					mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada,
									colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada));

					// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA - 5930
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA);

					mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada,
									colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada));

					// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO - 5940
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO);

					mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento,
									colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento));

					// ****************************************************************

					/*
					 * Seqüêncial de Tipo de Lançamento 6000 Para os pagamentos
					 * não classificados com baixa comandada com situação
					 * anterior igual a valor não confere acumula o valor
					 * excedente do pagamento por categoria, obtém as categorias
					 * do imóvel do pagamento relacionado e para cada categoria
					 * retornada obtém o valor por categoria.
					 */
					Collection colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosComBaixaComandadaPorSituacaoAnterior(idLocalidade, anoMesReferenciaArrecadacao,
									PagamentoSituacao.VALOR_NAO_CONFERE);

					if (colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere != null
							&& colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.size() > 0) {

						for (Object dadosPagamento : colecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere) {

							arrayDadosPagamento = (Object[]) dadosPagamento;
							valorExcedente = (BigDecimal) arrayDadosPagamento[0];
							idImovel = (Integer) arrayDadosPagamento[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {

								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorExcedentePorCategoria = (BigDecimal) iteratorColecaoPagamentosNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
											.next();

									if (!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.containsKey(categoria
											.getId())) {
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(categoria.getId(),
												BigDecimal.ZERO);
									}

									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(categoria.getId(),
											mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.get(categoria.getId())
													.add(valorExcedentePorCategoria));
								}

							} else {
								if (!mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
										.containsKey(Categoria.RESIDENCIAL)) {
									mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(Categoria.RESIDENCIAL,
											BigDecimal.ZERO);
								}
								mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(Categoria.RESIDENCIAL,
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.get(Categoria.RESIDENCIAL)
												.add(valorExcedente));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 6200 Para cada grupo de
					 * pagamentos classificados no mês e meses anterioeres
					 * acumula o valor dos impostos para as contas já
					 * contabilizadas como perdas pesquisando as contas impostos
					 * duzidos, e obtém as categorias do imóvel da conta
					 * relacionada e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP = repositorioArrecadacao
							.pesquisarContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP(
									idLocalidade, anoMesReferenciaArrecadacao);

					if (colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP != null
							&& colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP
									.size() > 0) {

						for (Object dadosContaImpostosDeduzidos : colecaoContasImpostosDeduzidosPagamentosClassificadosNoMes_MesesAnterioresContaContabilizadasComoPerdasImpostoTipo_IR_CSLL_COFINS_PISPASEP) {

							arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;
							valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
							idImovel = (Integer) arrayDadosContaImpostosDeduzidos[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {

								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorImpostoPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel,
										valorImposto)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorImpostoPorCategoria.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									valorImposto = (BigDecimal) iteratorColecaoValorImpostoPorCategoria.next();

									if (!mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.containsKey(categoria.getId())) {
										mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(
											categoria.getId(),
											mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.get(categoria.getId()).add(
													valorImposto));
								}
							} else {
								if (!mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.containsKey(Categoria.RESIDENCIAL)) {
									mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(
										Categoria.RESIDENCIAL,
										mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.get(Categoria.RESIDENCIAL).add(
												valorImposto));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 6300 Para os pagamentos
					 * não classificados com situação atual igual a pagamento em
					 * duplicidade acumula o valor excedente do pagamento por
					 * categoria, obtém as categorias do imóvel do pagamento
					 * relacionado e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE);

					if (colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade != null
							&& colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.size() > 0) {

						for (Object dadosPagamento : colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade) {

							arrayDadosPagamento = (Object[]) dadosPagamento;
							valorExcedente = (BigDecimal) arrayDadosPagamento[0];
							idImovel = (Integer) arrayDadosPagamento[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {

								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualPagamentoEmDuplicidade = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualPagamentoEmDuplicidade
												.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorExcedentePagamento = (BigDecimal) iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualPagamentoEmDuplicidade
											.next();

									if (!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
											.containsKey(categoria.getId())) {
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(categoria.getId(),
												BigDecimal.ZERO);
									}

									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(categoria.getId(),
											mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.get(categoria.getId())
													.add(valorExcedentePagamento));
								}

							} else {
								if (!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
										.containsKey(Categoria.RESIDENCIAL)) {
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(Categoria.RESIDENCIAL,
											BigDecimal.ZERO);
								}

								mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(Categoria.RESIDENCIAL,
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.get(Categoria.RESIDENCIAL)
												.add(valorExcedente));
							}
						}
					}

					/*
					 * Autor: Vivianne sousa Data: 01/06/2009
					 * 
					 * Seqüêncial de Tipo de Lançamento 6350 Para os pagamentos
					 * de valores da campanha Solidariedade da Criança acumula o
					 * valor dos documentos de cobranca por categoria
					 */

					if (idRDComPercentualDoacao != null) {

						Collection colecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca = repositorioArrecadacao
								.pesquisarPagamentosMesEMesesAnterioresCampanhaSolidariedadeCrianca(anoMesReferenciaArrecadacao, idLocalidade,
										idRDComPercentualDoacao);

						if (colecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca != null
								&& colecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.size() > 0) {

							for (Object dadosPagamento : colecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca) {

								arrayDadosPagamento = (Object[]) dadosPagamento;
								valorPagamento = (BigDecimal) arrayDadosPagamento[0];
								idImovel = (Integer) arrayDadosPagamento[1];
								imovel = new Imovel();
								imovel.setId(idImovel);

								if (idImovel != null) {
									// [UC0108 - Obter Quantidade de Economias
									// por Categoria]
									Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
									Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

									// [UC0185 - Obter Valor por Categoria]
									Iterator iteratorcolecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca = (getControladorImovel()
											.obterValorPorCategoria(colecaoCategoriasImovel, valorPagamento)).iterator();

									while (iteratorColecaoCategoriasImovel.hasNext()
											&& iteratorcolecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.hasNext()) {
										Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

										valorPagamento = (BigDecimal) iteratorcolecaoPagamentosNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.next();

										if (!mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.containsKey(categoria.getId())) {
											mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.put(categoria.getId(), BigDecimal.ZERO);
										}

										mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.put(categoria.getId(),
												mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.get(categoria.getId()).add(valorPagamento));
									}

								} else {
									if (!mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.containsKey(Categoria.RESIDENCIAL)) {
										mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
									}

									mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.put(Categoria.RESIDENCIAL,
											mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.get(Categoria.RESIDENCIAL).add(valorPagamento));
								}
							}
						}

					}

					// DOCUMENTO_INEXISTENTE - 6400
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE);

					// Autor: Bruno Leonardo Rodrigues Barros
					// Analista: Aryed
					// Data: 22/04/2009
					// Considerar tambem além do documento inexistente tambem os
					// documentos a contabilizar
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoAContabilizar = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

					if (colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoAContabilizar != null) {
						colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente
								.addAll(colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoAContabilizar);
					}
					// Fim alteração Bruno Barros

					mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente,
									colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistente));

					// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO - 6410
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO);

					mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito,
									colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito));

					// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA - 6420
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA);

					mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada,
									colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada));

					// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA - 6430
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA);

					mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada,
									colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada));

					// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO - 6440
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO);

					mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento.putAll(this
							.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento,
									colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento));

					// ****************************************************************

					/*
					 * Seqüêncial de Tipo de Lançamento 6500 Para os pagamentos
					 * não classificados com situação atual igual a valor não
					 * confere acumula o valor excedente do pagamento por
					 * categoria, obtém as categorias do imóvel do pagamento
					 * relacionado e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere = repositorioArrecadacao
							.pesquisarPagamentosNaoClassificadosMesEMesesAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									PagamentoSituacao.VALOR_NAO_CONFERE);

					if (colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere != null
							&& colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere.size() > 0) {

						for (Object dadosPagamento : colecaoPagamentosNaoClassificadosMesEMesesAnterioresSituacaoAtualValorNaoConfere) {

							arrayDadosPagamento = (Object[]) dadosPagamento;
							valorExcedente = (BigDecimal) arrayDadosPagamento[0];
							idImovel = (Integer) arrayDadosPagamento[1];
							valorPagamento = (BigDecimal) arrayDadosPagamento[2];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (valorExcedente == null) {
								valorExcedente = valorPagamento;
							}

							if (idImovel != null) {

								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								Iterator iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorExcedente)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
												.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									BigDecimal valorExcedentePagamento = (BigDecimal) iteratorColecaoValorPagamentoNaoClassificadosMesEMesesAnterioresPorCategoriaSituacaoAtualDocumentoInexistente
											.next();

									if (!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(categoria.getId())) {
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(),
												BigDecimal.ZERO);
									}

									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
											categoria.getId(),
											mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(categoria.getId()).add(
													valorExcedentePagamento));
								}

							} else {
								if (!mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(Categoria.RESIDENCIAL)) {
									mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(Categoria.RESIDENCIAL,
											BigDecimal.ZERO);
								}

								mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
										Categoria.RESIDENCIAL,
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(Categoria.RESIDENCIAL).add(
												valorExcedente));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 6700 Para as devoluções
					 * não classificadas com situação atual igual a pagamento em
					 * duplicidade não confere acumula o valor da devolução por
					 * categoria, obtém as categorias do imóvel da devolução
					 * relacionada e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado = repositorioArrecadacao
							.pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);

					if (colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado != null
							&& colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.size() > 0) {

						for (Object dadosDevolucao : colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado) {

							arrayDadosDevolucao = (Object[]) dadosDevolucao;
							valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
							idImovel = (Integer) arrayDadosDevolucao[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {

								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									valorDevolucao = (BigDecimal) iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
											.next();

									if (!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
											.containsKey(categoria.getId())) {
										mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(
												categoria.getId(), BigDecimal.ZERO);
									}

									mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(
											categoria.getId(),
											mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(
													categoria.getId()).add(valorDevolucao));
								}

							} else {
								if (!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
										.containsKey(Categoria.RESIDENCIAL)) {
									mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(
											Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(
										Categoria.RESIDENCIAL,
										mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(
												Categoria.RESIDENCIAL).add(valorDevolucao));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 6800 Para as devoluções
					 * não classificadas com situação atual igual a guia de
					 * devolução não informada acumula o valor da devolução por
					 * categoria, obtém as categorias do imóvel da devolução
					 * relacionada e para cada categoria retornada obtém o valor
					 * por categoria.
					 */
					Collection colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada = repositorioArrecadacao
							.pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);

					if (colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada != null
							&& colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.size() > 0) {

						for (Object dadosDevolucao : colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada) {

							arrayDadosDevolucao = (Object[]) dadosDevolucao;
							valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
							idImovel = (Integer) arrayDadosDevolucao[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {

								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									valorDevolucao = (BigDecimal) iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
											.next();

									if (!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.containsKey(categoria
											.getId())) {
										mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(),
												BigDecimal.ZERO);
									}

									mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(),
											mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.get(categoria.getId())
													.add(valorDevolucao));
								}

							} else {
								if (!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
										.containsKey(Categoria.RESIDENCIAL)) {
									mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(Categoria.RESIDENCIAL,
											BigDecimal.ZERO);
								}
								mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(Categoria.RESIDENCIAL,
										mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.get(Categoria.RESIDENCIAL)
												.add(valorDevolucao));
							}
						}
					}

					/*
					 * Seqüêncial de Tipo de Lançamento 6900 Para as devoluções
					 * não classificadas com situação atual igual a valor não
					 * confere acumula o valor da devolução por categoria, obtém
					 * as categorias do imóvel da devolução relacionada e para
					 * cada categoria retornada obtém o valor por categoria.
					 */
					Collection colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere = repositorioArrecadacao
							.pesquisarDevolucoesNaoClassificadasMesEAnterioresPorSituacaoAtual(anoMesReferenciaArrecadacao, idLocalidade,
									DevolucaoSituacao.VALOR_NAO_CONFERE);

					if (colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere != null
							&& colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere.size() > 0) {

						for (Object dadosDevolucao : colecaoDevolucoesNaoClassificadasMesEAnterioresSituacaoAtualValorNaoConfere) {

							arrayDadosDevolucao = (Object[]) dadosDevolucao;
							valorDevolucao = (BigDecimal) arrayDadosDevolucao[0];
							idImovel = (Integer) arrayDadosDevolucao[1];
							imovel = new Imovel();
							imovel.setId(idImovel);

							if (idImovel != null) {
								// [UC0108 - Obter Quantidade de Economias por
								// Categoria]
								Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
								Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

								// [UC0185 - Obter Valor por Categoria]
								Iterator iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualValorNaoConfere = (getControladorImovel()
										.obterValorPorCategoria(colecaoCategoriasImovel, valorDevolucao)).iterator();

								while (iteratorColecaoCategoriasImovel.hasNext()
										&& iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualValorNaoConfere.hasNext()) {
									Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();

									valorDevolucao = (BigDecimal) iteratorColecaoValorDevolucaoNaoClassificadaMesEAnterioresSituacaoAtualValorNaoConfere.next();

									if (!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(categoria.getId())) {
										mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(), BigDecimal.ZERO);
									}

									mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
											categoria.getId(),
											mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(categoria.getId()).add(
													valorDevolucao));
								}

							} else {
								if (!mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(Categoria.RESIDENCIAL)) {
									mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
								}
								mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(
										Categoria.RESIDENCIAL,
										mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(Categoria.RESIDENCIAL).add(
												valorDevolucao));
							}
						}
					}

					// Laço para gerar os resumos da arrecadação por categoria
					for (Integer idCategoria : colecaoIdsCategorias) {

						Categoria categoria = new Categoria();
						categoria.setId(idCategoria);
						/*
						 * Seqüêncial de Tipo de Lançamento 100 Para os
						 * pagamento classificados de conta acumula o valor de
						 * água por categoria e gera o resumo da arrecadação
						 * caso o valor acumulado seja maior que 0(zero)
						 */

						Object[] arrayValorAguaEsgoto = repositorioArrecadacao.acumularValorAguaEsgotoPagamentosClassificadosConta(idLocalidade,
								anoMesReferenciaArrecadacao, idCategoria);

						if (arrayValorAguaEsgoto != null) {

							BigDecimal somaValorAguaPagamentosClassificadosContas = (BigDecimal) arrayValorAguaEsgoto[0];

							if (somaValorAguaPagamentosClassificadosContas != null && somaValorAguaPagamentosClassificadosContas.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.add(somaValorAguaPagamentosClassificadosContas);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								LancamentoItem lancamentoItem = new LancamentoItem(LancamentoItem.AGUA);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosContas(
										localidade, categoria, anoMesReferenciaArrecadacao, 
										somaValorAguaPagamentosClassificadosContas, lancamentoItem, null,  new Short("100"), new Short("0"));
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							BigDecimal somaValorEsgotoPagamentosClassificadosContas = (BigDecimal) arrayValorAguaEsgoto[1];

							if (somaValorEsgotoPagamentosClassificadosContas != null && somaValorEsgotoPagamentosClassificadosContas.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.add(somaValorEsgotoPagamentosClassificadosContas);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);	
								LancamentoItem lancamentoItem = new LancamentoItem(LancamentoItem.ESGOTO);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosContas(
										localidade, categoria, anoMesReferenciaArrecadacao, 
										somaValorEsgotoPagamentosClassificadosContas, lancamentoItem, null,  new Short("200"), new Short("0"));
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

						}

						/*
						 * Seqüêncial de Tipo de Lançamento 400 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * débitos cobrados por categoria para o tipo de
						 * financiamneto igual a parcelamento água e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade, anoMesReferenciaArrecadacao,
										idCategoria, FinanciamentoTipo.PARCELAMENTO_AGUA);

						if (somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua != null
								&& somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
									.add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.AGUA);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosParcelamentosCobrados(localidade, categoria, 
									anoMesReferenciaArrecadacao, somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoAgua, 
									lancamentoItemTemp, null, new Short("400"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 500 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * débitos cobrados por categoria para o tipo de
						 * financiamneto igual a parcelamento esgoto e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade, anoMesReferenciaArrecadacao,
										idCategoria, FinanciamentoTipo.PARCELAMENTO_ESGOTO);

						if (somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto != null
								&& somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
									.add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.ESGOTO);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosParcelamentosCobrados(localidade, categoria, 
									anoMesReferenciaArrecadacao, somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoEsgoto, 
									lancamentoItemTemp, null, new Short("500"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 700 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * débitos cobrados por categoria para o tipo de
						 * financiamneto igual a parcelamento de serviço e grupo
						 * de parcelamento igual a juros cobrados e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade, anoMesReferenciaArrecadacao,
										idCategoria, FinanciamentoTipo.JUROS_PARCELAMENTO);

						if (somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados != null
								&& somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
										.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
									.add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.JUROS);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosParcelamentosCobrados(localidade, categoria, 
									anoMesReferenciaArrecadacao, somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados, 
									lancamentoItemTemp, null, new Short("700"), new Short("0"));
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 800 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * créditos realizados por categoria para a origem do
						 * crédito igual a contas pagas em duplicidade/excesso e
						 * gera o resumo da arrecadação caso o valor acumulado
						 * seja maior que 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
										CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);

						if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso != null
								&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
									.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmDuplicidadeExcesso,
									lancamentoItemTemp, null, new Short("800"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							
						}

						/**
						 * Contabilizar créditos com crédito origem
						 * correspondente a Contas Pagas em Excesso
						 * 
						 * @author Wellington Rocha
						 * @date
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmExcesso = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
										CreditoOrigem.CONTAS_PAGAS_EM_EXCESSO);

						if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmExcesso != null
								&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmExcesso.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
									.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmExcesso);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.CONTAS_PAGAS_EM_EXCESSO);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);

							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoContasPagasEmExcesso,
									lancamentoItemTemp, null, new Short("800"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						resumoArrecadacaoTemp = this.contabilizarCreditosRealizadosRecuperacaoCredito(anoMesReferenciaArrecadacao, localidade, categoria,
								CreditoOrigem.RECUPERACAO_CREDITO_CONTA_CANCELADA, LancamentoItem.RECUPERACAO_CREDITO_CONTA_CANCELADA);

						if (resumoArrecadacaoTemp != null) {
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099.add(resumoArrecadacaoTemp
									.getValorItemArrecadacao());
						}

						
						resumoArrecadacaoTemp = this.contabilizarCreditosRealizadosRecuperacaoCredito(anoMesReferenciaArrecadacao, localidade, categoria,
								CreditoOrigem.RECUPERACAO_CREDITO_CONTA_PARCELADA, LancamentoItem.RECUPERACAO_CREDITO_CONTA_PARCELADA);

						if (resumoArrecadacaoTemp != null) {
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099.add(resumoArrecadacaoTemp
									.getValorItemArrecadacao());
						}
						
						RecebimentosClassificadosRecuperacaoCredito recebimentos = contabilizarRecebimentosClassificadosRecuperacaoCredito(localidade, 
								anoMesReferenciaArrecadacao, categoria, mapValoresRecuperacaoCreditoDuplicidade, mapValoresRecuperacaoCreditoCancelado,
								mapValoresRecuperacaoCreditoDuplicidadeMesesAnteriores, mapValoresRecuperacaoCreditoCanceladoMesesAnteriores);
						
						
						if (recebimentos.getRecuperacaoCreditoDuplicidade() != null) {
							colecaoResumoArrecadacao.add(recebimentos.getRecuperacaoCreditoDuplicidade());
							valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = valorAcumuladoSequenciaTipoLancamentoIgual2000e2400.add(recebimentos.getRecuperacaoCreditoDuplicidade().getValorItemArrecadacao());
						}
						
						if (recebimentos.getRecuperacaoCreditoCancelado() != null) {
							colecaoResumoArrecadacao.add(recebimentos.getRecuperacaoCreditoCancelado());
							valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = valorAcumuladoSequenciaTipoLancamentoIgual2000e2400.add(recebimentos.getRecuperacaoCreditoCancelado().getValorItemArrecadacao());
						}
						
						if (recebimentos.getRecuperacaoCreditoDuplicidadeMesesAnteriores() != null) {
							colecaoResumoArrecadacao.add(recebimentos.getRecuperacaoCreditoDuplicidadeMesesAnteriores());
						}
						
						if (recebimentos.getRecuperacaoCreditoCanceladoMesesAnteriores() != null) {
							colecaoResumoArrecadacao.add(recebimentos.getRecuperacaoCreditoCanceladoMesesAnteriores());
						}
						
						/*
						 * Seqüêncial de Tipo de Lançamento 1000 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * créditos realizados por categoria para a origem do
						 * crédito igual a descontos concedidos e gera o resumo
						 * da arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
										CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);

						if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento != null
								&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
									.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.DESCONTOS_CONCEDIDOS);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosConcedidosNoParcelamento,
									lancamentoItemTemp, null, new Short("1000"), new Short("0"));
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 1010 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * créditos realizados por categoria para a origem do
						 * crédito igual a descontos condicionais e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
										CreditoOrigem.DESCONTOS_CONDICIONAIS);

						if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais != null
								&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
									.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.DESCONTOS_CONDICIONAIS);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosCondicionais,
									lancamentoItemTemp, null, new Short("1010"), new Short("0"));
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 1020 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * créditos realizados por categoria para a origem do
						 * crédito igual a descontos incondicionais e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
										CreditoOrigem.DESCONTOS_INCONDICIONAIS);

						if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais != null
								&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
									.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem(LancamentoItem.DESCONTOS_INCONDICIONAIS);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoDescontosIncondicionais,
									lancamentoItemTemp, null, new Short("1020"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 1030 Para os
						 * pagamento classificados de conta acumula o valor dos
						 * créditos realizados por categoria para a origem do
						 * crédito igual a ajustes para zerar conta e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(idLocalidade, anoMesReferenciaArrecadacao, idCategoria,
										CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA);

						if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta != null
								&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
									.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoAjustesParaZerarConta,
									lancamentoItemTemp, null, new Short("1030"), new Short("0"));
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 1700 Para os
						 * pagamento classificados de guias de pagamento acumula
						 * o valor das entradas do parcelamento por categoria
						 * para tipo de financiamento igual a entrada de
						 * parcelamento e gera o resumo da arrecadação caso o
						 * valor acumulado seja maior que 0(zero)
						 */
						BigDecimal somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento = repositorioArrecadacao
								.acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoEntradaParcelamento(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria);

						if (somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento != null
								&& somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
									.add(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.ENTRADAS_PARCELAMENTO);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosGuiasPagamento(localidade, categoria,
									anoMesReferenciaArrecadacao, somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamento,
									lancamentoItemTemp, null, new Short("1700"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 3500 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor de água por
						 * categoria e gera o resumo da arrecadação caso o valor
						 * acumulado seja maior que 0(zero)
						 */

						arrayValorAguaEsgoto = null;

						arrayValorAguaEsgoto = repositorioArrecadacao.acumularValorAguaEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes(
								idLocalidade, anoMesReferenciaArrecadacao, idCategoria);

						if (arrayValorAguaEsgoto != null) {

							BigDecimal somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes = (BigDecimal) arrayValorAguaEsgoto[0];

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes != null
									&& somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes.doubleValue() > 0.00) {

								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.add(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.AGUA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3500"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorAguaPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 3600 Para os
							 * pagamentos de contas efetuados em meses
							 * anteriores classificados no mês acumula o valor
							 * de esgoto por categoria e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							BigDecimal somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes = (BigDecimal) arrayValorAguaEsgoto[1];

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes != null
									&& somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes.doubleValue() > 0.00) {

								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.add(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3600"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorEsgotoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMes);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/**
						 * Alteração para contabilar em contas diferentes
						 * valores arrecadados até 31/12/2012
						 * 
						 * @author Wellington Rocha
						 */

						// 3510
						arrayValorAguaEsgoto = null;

						arrayValorAguaEsgoto = repositorioArrecadacao.acumularValorAguaEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes(idLocalidade,
								anoMesReferenciaArrecadacao, idCategoria);

						if (arrayValorAguaEsgoto != null) {

							BigDecimal somaValorAguaPagamentosContasEfetuadosAte122012ClassificadosNoMes = (BigDecimal) arrayValorAguaEsgoto[0];

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorAguaPagamentosContasEfetuadosAte122012ClassificadosNoMes != null
									&& somaValorAguaPagamentosContasEfetuadosAte122012ClassificadosNoMes.doubleValue() > 0.00) {

								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorAguaPagamentosContasEfetuadosAte122012ClassificadosNoMes);

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.add(somaValorAguaPagamentosContasEfetuadosAte122012ClassificadosNoMes);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.AGUA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3510"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorAguaPagamentosContasEfetuadosAte122012ClassificadosNoMes);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							// 3610
							BigDecimal somaValorEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes = (BigDecimal) arrayValorAguaEsgoto[1];

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes != null
									&& somaValorEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes.doubleValue() > 0.00) {

								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes);

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.add(somaValorEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3610"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorEsgotoPagamentosContasEfetuadosAte122012ClassificadosNoMes);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 3800 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos débitos
						 * cobrados por categoria para tipo de financiamento
						 * igual a parcelamento de água e gera o resumo da
						 * arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.PARCELAMENTO_AGUA);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua != null
								&& somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua
										.doubleValue() > 0.00) {

							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua);

							// Seqüêncial de Tipo de Lançamento 5000
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.AGUA);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3800"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoAgua);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 3900 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos débitos
						 * cobrados por categoria para tipo de financiamento
						 * igual a parcelamento de esgoto e gera o resumo da
						 * arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.PARCELAMENTO_ESGOTO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto != null
								&& somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto
										.doubleValue() > 0.00) {

							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);

							// Seqüêncial de Tipo de Lançamento 5000
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3900"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4100 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos débitos
						 * cobrados por categoria para tipo de financiamento
						 * igual a parcelamento de serviços e grupo de
						 * parcelamento igual a juros cobrados e gera o resumo
						 * da arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.JUROS_PARCELAMENTO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados != null
								&& somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
										.doubleValue() > 0.00) {
							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);

							// Seqüêncial de Tipo de Lançamento 5000
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.JUROS_COBRADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4100"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4200 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos créditos
						 * realizados por categoria para origem do crédito igual
						 * a documentos pagos em duplicidade/excesso e gera o
						 * resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso
										.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4200"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/**
						 * Contabilizar créditos com crédito origem
						 * correspondente a Contas Pagas em Excesso
						 * 
						 * @author Wellington Rocha
						 * @date
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmExcesso = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.CONTAS_PAGAS_EM_EXCESSO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmExcesso != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmExcesso
										.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmExcesso);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.CONTAS_PAGAS_EM_EXCESSO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4200"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoContasPagasEmExcesso);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}
						/*
						 * Seqüêncial de Tipo de Lançamento 4400 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos créditos
						 * realizados por categoria para origem do crédito igual
						 * a descontos concedidos e gera o resumo da arrecadação
						 * caso o valor acumulado seja maior que 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos
										.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4400"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosConcedidos);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4410 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos créditos
						 * realizados por categoria para origem do crédito igual
						 * a descontos condicionais e gera o resumo da
						 * arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_CONDICIONAIS);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais
										.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4410"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosCondicionais);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4420 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos créditos
						 * realizados por categoria para origem do crédito igual
						 * a descontos incondicionais e gera o resumo da
						 * arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_INCONDICIONAIS);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais
										.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4420"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoDescontosIncondicionais);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4430 Para os
						 * pagamentos de contas efetuados em meses anteriores
						 * classificados no mês acumula o valor dos créditos
						 * realizados por categoria para origem do crédito igual
						 * a ajustes para zerar conta e gera o resumo da
						 * arrecadação caso o valor acumulado seja maior que
						 * 0(zero)
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta
										.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4430"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoAjustesParaZerarConta);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 5100 Para os
						 * pagamentos de guias de pagamento efetuadas em meses
						 * anteriores classificados no mês acumula o valor das
						 * entradas dos parcelamento por categoria com tipo de
						 * financiamento igual a entrada de parcelamento e gera
						 * o resumo da arrecadação caso o valor acumulado seja
						 * maior que 0(zero)
						 */
						BigDecimal somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento = repositorioArrecadacao
								.acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento(
										idLocalidade, anoMesReferenciaArrecadacao, idCategoria);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento != null
								&& somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento
										.doubleValue() > 0.00) {
							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
									.add(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
							lancamentoItemTemp.setId(LancamentoItem.ENTRADAS_PARCELAMENTO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5100"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoEntradaParcelamento);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/**
						 * Contabilizar em contas diferentes o valor arrecadado
						 * até 31/12/2012
						 * 
						 * @author Wellington Rocha
						 */
						BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoAgua = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.PARCELAMENTO_AGUA);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoAgua != null
								&& somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoAgua.doubleValue() > 0.00) {

							// Seqüêncial de Tipo de Lançamento 5410
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoAgua);

							// Seqüêncial de Tipo de Lançamento 5010
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoAgua);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.AGUA);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3810"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoAgua);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 3910
						BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.PARCELAMENTO_ESGOTO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto != null
								&& somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto.doubleValue() > 0.00) {

							// Seqüêncial de Tipo de Lançamento 5410
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);

							// Seqüêncial de Tipo de Lançamento 5010
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.ESGOTO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3910"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoEsgoto);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 4110
						BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, FinanciamentoTipo.JUROS_PARCELAMENTO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados != null
								&& somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados
										.doubleValue() > 0.00) {
							// Seqüêncial de Tipo de Lançamento 5410
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);

							// Seqüêncial de Tipo de Lançamento 5010
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
									.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.JUROS_COBRADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4110"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoIgualJurosCobrados);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 4210
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso
										.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4210"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmDuplicidadeExcesso);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						/**
						 * Contabilizar créditos com crédito origem
						 * correspondente a Contas Pagas em Excesso
						 * 
						 * @author Wellington Rocha
						 * @date
						 */
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmExcesso = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.CONTAS_PAGAS_EM_EXCESSO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmExcesso != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmExcesso.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmExcesso);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.CONTAS_PAGAS_EM_EXCESSO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4210"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoContasPagasEmExcesso);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}
						// 4440
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosConcedidos = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosConcedidos != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosConcedidos.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosConcedidos);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONCEDIDOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4440"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosConcedidos);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 4450
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosCondicionais = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_CONDICIONAIS);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosCondicionais != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosCondicionais
										.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosCondicionais);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CONDICIONAIS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4450"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosCondicionais);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 4460
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosIncondicionais = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.DESCONTOS_INCONDICIONAIS);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosIncondicionais != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosIncondicionais
										.doubleValue() > 0.00) {
							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosIncondicionais);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_INCONDICIONAIS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4460"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoDescontosIncondicionais);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 4470
						BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoAjustesParaZerarConta = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorOrigemCredito(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria, CreditoOrigem.AJUSTES_PARA_ZERAR_CONTA);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoAjustesParaZerarConta != null
								&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoAjustesParaZerarConta
										.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
									.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoAjustesParaZerarConta);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
							lancamentoItemTemp.setId(LancamentoItem.AJUSTES_PARA_ZERAR_CONTA);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4470"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoAjustesParaZerarConta);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// 5110
						BigDecimal somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento = repositorioArrecadacao
								.acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento(
										idLocalidade, anoMesReferenciaArrecadacao, idCategoria);

						// [FS0005] - Verificar valor acumulado igual a zero
						if (somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento != null
								&& somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento
										.doubleValue() > 0.00) {
							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
									.add(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento);
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
							lancamentoItemTemp.setId(LancamentoItem.ENTRADAS_PARCELAMENTO);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5110"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoEntradaParcelamento);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
						}

						// *********************************// Fim novo
						// recebimento tipo

						// Laço para gerar os resumos por lançamento de item
						// contábil
						for (Object dadosLancamentoItemContabil : colecaoDadosLancamentosItemContabil) {

							Object[] arrayDadosLancamentoItemContabil = (Object[]) dadosLancamentoItemContabil;
							Integer idLancamentoItemContabil = (Integer) arrayDadosLancamentoItemContabil[0];
							Short sequencialImpressao = (Short) arrayDadosLancamentoItemContabil[1];

							LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
							lancamentoItemContabil.setId(idLancamentoItemContabil);
							lancamentoItemContabil.setSequenciaImpressao(sequencialImpressao);
							/*
							 * Seqüêncial de Tipo de Lançamento 300 Para os
							 * pagamento classificados de conta acumula o valor
							 * dos débitos cobrados por categoria para tipo de
							 * financiamento igual a serviço e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							Collection<Integer> colecaoIdsTipoFinanciamentoSequencial300E3700 = new ArrayList();
							colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.SERVICO_NORMAL);
							colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.ARRASTO_AGUA);
							colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.ARRASTO_ESGOTO);
							colecaoIdsTipoFinanciamentoSequencial300E3700.add(FinanciamentoTipo.ARRASTO_SERVICO);

							BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade, anoMesReferenciaArrecadacao,
											idLancamentoItemContabil, idCategoria, colecaoIdsTipoFinanciamentoSequencial300E3700);

							if (somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico != null
									&& somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico);
								
								lancamentoItemTemp = new LancamentoItem(LancamentoItem.FINANCIAMENTOS_COBRADOS);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosContas(localidade, categoria, 
										anoMesReferenciaArrecadacao, somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoServico, 
										lancamentoItemTemp, lancamentoItemContabil, new Short("300"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 600 Para os
							 * pagamento classificados de conta acumula o valor
							 * dos débitos cobrados por categoria para tipo de
							 * financiamento igual a parcelamento de serviço e
							 * grupo de parrcelamento igual a juros cobrados e
							 * gera o resumo da arrecadação caso o valor
							 * acumulado seja maior que 0(zero)
							 */
							Collection<Integer> colecaoIdsTipoFinanciamentoSequencial600E4000 = new ArrayList();
							colecaoIdsTipoFinanciamentoSequencial600E4000.add(FinanciamentoTipo.PARCELAMENTO_SERVICO);

							BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosClassificadosContaPorFinanciamentoTipo(idLocalidade, anoMesReferenciaArrecadacao,
											idLancamentoItemContabil, idCategoria, colecaoIdsTipoFinanciamentoSequencial600E4000);

							if (somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados != null
									&& somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
											.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.FINANCIAMENTOS_COBRADOS);

								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosParcelamentosCobrados(localidade, categoria, 
										anoMesReferenciaArrecadacao, somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados, 
										lancamentoItemTemp, lancamentoItemContabil, new Short("600"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 900 Para os
							 * pagamento classificados de conta acumula o valor
							 * dos créditos realizados por categoria para origem
							 * de crédito igual a valores cobrados indevidamente
							 * e gera o resumo da arrecadação caso o valor
							 * acumulado seja maior que 0(zero)
							 */
							
							Collection<Integer> idsCreditosOrigem = new ArrayList<Integer>();
							idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_AGUA);
							idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_TARIFA_ESGOTO);
							idsCreditosOrigem.add(CreditoOrigem.SERVICOS_INDIRETOS_PAGOS_INDEVIDAMENTE);
//							idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO);
							
							BigDecimal somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente = repositorioArrecadacao
									.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente(idLocalidade,
											anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil, idsCreditosOrigem);

							if (somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente != null
									&& somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente.doubleValue() > 0.00) {
								valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099
										.add(somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente);

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.VALORES_COBRADOS_INDEVIDAMENTE);

								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
										anoMesReferenciaArrecadacao, somaValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente,
										lancamentoItemTemp, lancamentoItemContabil, new Short("900"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							idsCreditosOrigem = new ArrayList<Integer>();
							idsCreditosOrigem.add(CreditoOrigem.DEVOLUCAO_JUROS_PARCELAMENTO);
							
							BigDecimal somaValorCreditoRealizadoBonusSocial = repositorioArrecadacao
									.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCreditoValoresCobradosIndevidamente(idLocalidade,
											anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil, idsCreditosOrigem);

							if (somaValorCreditoRealizadoBonusSocial != null && somaValorCreditoRealizadoBonusSocial.doubleValue() > 0.00) {
								valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = valorAcumuladoSequenciaTipoLancamentoEntre800e1099.add(somaValorCreditoRealizadoBonusSocial);

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.BONUS_SOCIAL);

								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
										anoMesReferenciaArrecadacao, somaValorCreditoRealizadoBonusSocial, lancamentoItemTemp, null,
										new Short("900"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
							
							
							/*
							 * Seqüêncial de Tipo de Lançamento 1550 Para os
							 * pagamento classificados de conta acumula o valor
							 * dos débitos cobrados por categoria para tipo de
							 * financiamento igual a doações gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							BigDecimal somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes(idLocalidade, anoMesReferenciaArrecadacao,
											idCategoria, idLancamentoItemContabil);

							if (somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes != null
									&& somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.add(somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes);

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.GRUPO_CONTABIL);

								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosDoacoes(localidade, categoria,
										anoMesReferenciaArrecadacao, somaValorDebitoCobradoPagamentosClassificadosContaFinanciamentoTipoDoacoes,
										lancamentoItemTemp, lancamentoItemContabil, new Short("1550"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 1800 Para os
							 * pagamento classificados de guias de pagamento
							 * acumula o valor das guias de pagamento por
							 * categoria com tipo de financiamento igual a
							 * serviço e gera o resumo da arrecadação caso o
							 * valor acumulado seja maior que 0(zero)
							 */
							BigDecimal somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico = repositorioArrecadacao
									.acumularValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico(idLocalidade,
											anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria);

							if (somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico != null
									&& somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
										.add(somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico);

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.GRUPO_CONTABIL);

								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosGuiasPagamento(localidade, categoria,
										anoMesReferenciaArrecadacao, somaValorEntradaParcelamentoPagamentosClassificadosGuiaPagamentoFinanciamentoTipoServico,
										lancamentoItemTemp, lancamentoItemContabil, new Short("1800"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 1900 Para os
							 * pagamento classificados de débitos a cobrar
							 * acumula o valor que falta ser cobrado por
							 * categoria dodébito a cobrar e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero) Esta pesquisa já retorna o valor que
							 * falta ser cobrado
							 */
							BigDecimal somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar = repositorioArrecadacao
									.acumularValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar(idLocalidade, anoMesReferenciaArrecadacao,
											idLancamentoItemContabil, idCategoria);

							if (somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar != null
									&& somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar.doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
										.add(somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar);

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.GRUPO_CONTABIL);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.DEBITOS_A_COBRAR);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosDebitosACobrar(localidade, categoria,
										anoMesReferenciaArrecadacao, somaValorQueFaltaSerCobradoPagamentosClassificadosDebitoACobrar,
										lancamentoItemTemp, lancamentoItemContabil, new Short("1900"), sequencialImpressao);
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 2700 Para as
							 * devoluções classificadas acumula o valor da
							 * devolução por categoria com situação atual igual
							 * a devolução de outros valores e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							if (mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil.containsKey(idLancamentoItemContabil)) {
								Map<Integer, BigDecimal> mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores = mapValorDevolucaoSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
										.get(idLancamentoItemContabil);

								if (mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.containsKey(idCategoria)) {

									if (mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(idCategoria).doubleValue() > 0.00) {

										// Seqüêncial de Tipo de Lançamento 2800
										valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 = valorAcumuladoSequenciaTipoLancamentoEntre2600e2799
												.add(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(idCategoria));
										recebimentoTipoTemp = new RecebimentoTipo();
										lancamentoTipoTemp = new LancamentoTipo();
										lancamentoItemTemp = new LancamentoItem();

										resumoArrecadacaoTemp = new ResumoArrecadacao();
										recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_CLASSIFICADAS);
										lancamentoTipoTemp.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
										lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
										resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
										resumoArrecadacaoTemp.setLocalidade(localidade);
										resumoArrecadacaoTemp.setCategoria(categoria);
										resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
										resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
										resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
										resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
										resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
										resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2700"));
										resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
										resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
										resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoSituacaoAtualDevolucaoOutrosValores.get(idCategoria));
										colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
									}
								}
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 5600 Para as
							 * devoluções efetuadas em meses anteriores
							 * classificadas no mês acumula o valor da devolução
							 * por categoria com situação atual igual a
							 * devolução de outros valores e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							if (mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
									.containsKey(idLancamentoItemContabil)) {
								Map<Integer, BigDecimal> mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores = mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValoresPorLancamentoContabil
										.get(idLancamentoItemContabil);

								if (mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores.containsKey(idCategoria)) {

									if (mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores.get(idCategoria).doubleValue() > 0.00) {

										// Seqüêncial de Tipo de Lançamento 5700
										valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 = valorAcumuladoSequenciaTipoLancamentoEntre5500e5699
												.add(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores.get(idCategoria));
										recebimentoTipoTemp = new RecebimentoTipo();
										lancamentoTipoTemp = new LancamentoTipo();
										lancamentoItemTemp = new LancamentoItem();

										resumoArrecadacaoTemp = new ResumoArrecadacao();
										recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
										lancamentoTipoTemp.setId(LancamentoTipo.VALORES_COBRADOS_INDEVIDAMENTE);
										lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
										resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
										resumoArrecadacaoTemp.setLocalidade(localidade);
										resumoArrecadacaoTemp.setCategoria(categoria);
										resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
										resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
										resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
										resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
										resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
										resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5600"));
										resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
										resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
										resumoArrecadacaoTemp
												.setValorItemArrecadacao(mapValorDevolucaoEfetuadasEmMesesAtenrioresSituacaoAtualDevolucaoOutrosValores
														.get(idCategoria));
										colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
									}
								}
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 3700 Para os
							 * pagamentos em conta efetuados em meses anteriores
							 * classificados no mês acumula o valor dos débitos
							 * cobrados por categoria para tipo de financiamento
							 * igual a serviço e gera o resumo da arrecadação
							 * caso o valor acumulado seja maior que 0(zero)
							 */
							BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
											anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria, colecaoIdsTipoFinanciamentoSequencial300E3700);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico != null
									&& somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3700"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 4000 Para os
							 * pagamentos de contas efetuados em meses
							 * anteriores classificados no mês acumula o valor
							 * dos débitos cobrados por categoria e item
							 * contábil para tipo de financiamento igual a
							 * parcelamento de serviços e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
											anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria, colecaoIdsTipoFinanciamentoSequencial600E4000);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados != null
									&& somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
											.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4000"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 4950 Para os
							 * pagamentos de contas efetuados em meses
							 * anteriores classificados no mês acumula o valor
							 * dos débitos cobrados por categoria e item
							 * contábil para tipo de financiamento igual doações
							 * e gera o resumo da arrecadação caso o valor
							 * acumulado seja maior que 0(zero)
							 */
							BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes(
											idLocalidade, anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes != null
									&& somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes);

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.DOACOES_RECEBIDAS_EM_CONTA);
								lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4950"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoDoacoes);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 4300 Para os
							 * pagamentos de contas efetuados em meses
							 * anteriores classificados no mês acumula o valor
							 * dos créditos realizados por categoria e item
							 * contábil para origem do crédito igual a valores
							 * cobrados indevidamente e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente = repositorioArrecadacao
									.acumularValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente(
											idLocalidade, anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente != null
									&& somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente
											.doubleValue() > 0.00) {
								valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4200e4499
										.add(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente);
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.VALORES_COBRADOS_INDEVIDAMENTE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4300"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosEmMesesAnterioresClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 5200 Para os
							 * pagamentos de guias de pagamento efetuados em
							 * meses anteriores classificados no mês acumula o
							 * valor das guias de pagamento por categoria e item
							 * contábil para tipo de financiamento serviço e
							 * gera o resumo da arrecadação caso o valor
							 * acumulado seja maior que 0(zero)
							 */
							BigDecimal somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico = repositorioArrecadacao
									.acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico(
											idLocalidade, anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico != null
									&& somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico
											.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
								lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5200"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosEmMesesAnterioresClassificadosNoMesFinanciamentoTipoServico);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/*
							 * Seqüêncial de Tipo de Lançamento 5300 Para os
							 * pagamentos de débitos a cobrar efetuados em meses
							 * anteriores classificados no mês acumula o valor
							 * que falta ser cobrado dos débitos a cobrar por
							 * categoria e item contábil e para tipo de
							 * financiamento igual a serviço e gera o resumo da
							 * arrecadação caso o valor acumulado seja maior que
							 * 0(zero)
							 */
							BigDecimal somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores = repositorioArrecadacao
									.acumularValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores(idLocalidade,
											anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores != null
									&& somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.add(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores);
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.DEBITOS_A_COBRAR);
								lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5300"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosEmMesesAnteriores);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							/**
							 * Alterações para contabilizar em contas diferentes
							 * valores arrecadados até 31/12/2012
							 * 
							 * @author: Wellington Rocha
							 */
							// 3710
							BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
											anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria, colecaoIdsTipoFinanciamentoSequencial300E3700);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico != null
									&& somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico);

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3710"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							// 4010
							BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesPorFinanciamentoTipo(idLocalidade,
											anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria, colecaoIdsTipoFinanciamentoSequencial600E4000);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados != null
									&& somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados
											.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.PARCELAMENTOS_COBRADOS_SUP_CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.FINANCIAMENTOS_COBRADOS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4010"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoParcelamentoServicoGrupoParcelamentoDiferenteJurosCobrados);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							// 4960
							BigDecimal somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes = repositorioArrecadacao
									.acumularValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes(idLocalidade,
											anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes != null
									&& somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes);

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.add(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes);

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.DOACOES_RECEBIDAS_EM_CONTA);
								lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4960"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorDebitoCobradoPagamentosContasEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoDoacoes);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							// 4310
							BigDecimal somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente = repositorioArrecadacao
									.acumularValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente(
											idLocalidade, anoMesReferenciaArrecadacao, idCategoria, idLancamentoItemContabil);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente != null
									&& somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente
											.doubleValue() > 0.00) {
								valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = valorAcumuladoSequenciaTipoLancamentoEntre4210e4499
										.add(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente);
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.CREDITOS_REALIZADOS_SUP_CONTAS);
								lancamentoItemTemp.setId(LancamentoItem.VALORES_COBRADOS_INDEVIDAMENTE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4310"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorCreditoRealizadoPagamentosContasEfetuadosAte122012ClassificadosNoMesOrigemCreditoValoresCobradosIndevidamente);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							// 5210
							BigDecimal somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico = repositorioArrecadacao
									.acumularValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico(
											idLocalidade, anoMesReferenciaArrecadacao, idLancamentoItemContabil, idCategoria);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico != null
									&& somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico
											.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico);
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.GUIAS_PAGAMENTO);
								lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5210"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(somaValorEntradaParcelamentoPagamentosGuiaPagamentoEfetuadosAte122012ClassificadosNoMesFinanciamentoTipoServico);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}

							// 5310
							BigDecimal somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012 = repositorioArrecadacao
									.acumularValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012(idLocalidade, anoMesReferenciaArrecadacao,
											idLancamentoItemContabil, idCategoria);

							// [FS0005] - Verificar valor acumulado igual a zero
							if (somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012 != null
									&& somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.add(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012);
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.DEBITOS_A_COBRAR);
								lancamentoItemTemp.setId(LancamentoItem.GRUPO_CONTABIL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(lancamentoItemContabil);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5310"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(sequencialImpressao);
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(somaValorQueFaltaSerCobradoPagamentosDebitoACobrarEfetuadosAte122012);
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}// FIM LANÇAMENTO ITEM CONTÁBIL

						// ***************************************************************************
						// Fim do novo recebimento tipo/

						if (mapValorIRPagamentosClassificadosConta.containsKey(idCategoria)) {
							if (mapValorIRPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00) {
								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.subtract(mapValorIRPagamentosClassificadosConta.get(idCategoria));

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.IMPOSTO_RENDA);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosImpostosRetidos(localidade, categoria,
										anoMesReferenciaArrecadacao, mapValorIRPagamentosClassificadosConta.get(idCategoria),
										lancamentoItemTemp, null, new Short("1200"), new Short("0"));
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						if (mapValorCSLLPagamentosClassificadosConta.containsKey(idCategoria)) {
							if (mapValorCSLLPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.subtract(mapValorCSLLPagamentosClassificadosConta.get(idCategoria));

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.CSLL);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosImpostosRetidos(localidade, categoria,
										anoMesReferenciaArrecadacao, mapValorCSLLPagamentosClassificadosConta.get(idCategoria),
										lancamentoItemTemp, null, new Short("1300"), new Short("0"));
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						if (mapValorCOFINSPagamentosClassificadosConta.containsKey(idCategoria)) {
							if (mapValorCOFINSPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.subtract(mapValorCOFINSPagamentosClassificadosConta.get(idCategoria));
								lancamentoItemTemp = new LancamentoItem(LancamentoItem.COFINS);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosImpostosRetidos(localidade, categoria,
										anoMesReferenciaArrecadacao, mapValorCOFINSPagamentosClassificadosConta.get(idCategoria),
										lancamentoItemTemp, null, new Short("1400"), new Short("0"));
								
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						if (mapValorPISPASEPPagamentosClassificadosConta.containsKey(idCategoria)) {
							if (mapValorPISPASEPPagamentosClassificadosConta.get(idCategoria).doubleValue() > 0.00) {

								valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
										.subtract(mapValorPISPASEPPagamentosClassificadosConta.get(idCategoria));
								
								lancamentoItemTemp = new LancamentoItem(LancamentoItem.PIS_PASEP);

								//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
								//lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_RECEBIDAS);
								
								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosImpostosRetidos(localidade, categoria,
										anoMesReferenciaArrecadacao, mapValorPISPASEPPagamentosClassificadosConta.get(idCategoria),
										lancamentoItemTemp, null, new Short("1500"), new Short("0"));

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2100 Caso o map onde
						 * foi armazenado o valor do pagamento por categoria do
						 * grupo de pagamentos classificados do mês, com
						 * situação atual igual a pagamento em duplicidade não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.containsKey(idCategoria)) {
							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.get(idCategoria));

								lancamentoItemTemp = new LancamentoItem(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE);

								resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosNaoClassificadosDuplicidade(localidade, categoria,
										anoMesReferenciaArrecadacao, mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.get(idCategoria),
										lancamentoItemTemp, null, new Short("2100"), new Short("0"));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2440 Caso o map onde
						 * foi armazenado o valor do descontos por pagamento a
						 * vista não estiver vazio, gera o resumo da arrecadação
						 * para cada categoria retornada pelo imóvel com seu
						 * respectivo valor.
						 */
						if (mapValorDevolucaoDescontosPagamentoAVista.containsKey(idCategoria)) {
							if (mapValorDevolucaoDescontosPagamentoAVista.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2440
								valorAcumuladoSequenciaTipoLancamentoIgual2440e2470 = valorAcumuladoSequenciaTipoLancamentoIgual2440e2470
										.add(mapValorDevolucaoDescontosPagamentoAVista.get(idCategoria));
								valorDiferencaSequenciaTipoLancamentoIgual2440e2450 = valorDiferencaSequenciaTipoLancamentoIgual2440e2450
										.add(mapValorDevolucaoDescontosPagamentoAVista.get(idCategoria));
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2450 Caso o map onde
						 * foi armazenado o valor do descontos por pagamento a
						 * vista pela campanha da criança não estiver vazio,
						 * gera o resumo da arrecadação para cada categoria
						 * retornada pelo imóvel com seu respectivo valor.
						 */

						if (mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.containsKey(idCategoria)) {
							if (mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria).doubleValue() > 0.00) {

								valorDiferencaSequenciaTipoLancamentoIgual2440e2450 = valorDiferencaSequenciaTipoLancamentoIgual2440e2450
										.subtract(mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DESCONTOS);
								lancamentoTipoTemp.setId(LancamentoTipo.DESCONTOS_PAGAMENTO_A_VISTA);
								lancamentoItemTemp.setId(LancamentoItem.PELA_CAMPANHA_DA_CRIANCA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);

								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2450"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2465 Caso o map onde
						 * foi armazenado o valor do descontos por pagamento a
						 * vista não estiver vazio, gera o resumo da arrecadação
						 * para cada categoria retornada pelo imóvel com seu
						 * respectivo valor.
						 */
						if (mapValorDevolucaoDescontosPagamentoAVista.containsKey(idCategoria)) {
							if (mapValorDevolucaoDescontosPagamentoAVista.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2465

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DESCONTOS);
								lancamentoTipoTemp.setId(LancamentoTipo.DESCONTOS_PAGAMENTO_A_VISTA);
								lancamentoItemTemp.setId(LancamentoItem.TOTAL_POR_PAGAMENTO_A_VISTA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2465"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoDescontosPagamentoAVista.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2470 Caso o map onde
						 * foi armazenado o valor do descontos por creditos não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorDevolucaoDescontosCreditosARealizar.containsKey(idCategoria)) {
							if (mapValorDevolucaoDescontosCreditosARealizar.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2470
								valorAcumuladoSequenciaTipoLancamentoIgual2440e2470 = valorAcumuladoSequenciaTipoLancamentoIgual2440e2470
										.add(mapValorDevolucaoDescontosCreditosARealizar.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DESCONTOS);
								lancamentoTipoTemp.setId(LancamentoTipo.DESCONTOS_CREDITOS);
								lancamentoItemTemp.setId(LancamentoItem.DESCONTOS_CREDITOS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2470"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoDescontosCreditosARealizar.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2200 Caso o map onde
						 * foi armazenado o valor do pagamento por categoria do
						 * grupo de pagamentos classificados do mês, com
						 * situação atual igual a pagamento em duplicidade não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						/**
						 * 
						 * 
						 * Detalhar contabilização de documentos inexistentes
						 * 
						 * Retorna o resumo arrecadacao por RecebimentoTipo,
						 * LancamentoTipo, LancamentoItem e Sequência.
						 * 
						 * @author Wellington Rocha
						 * @author Felipe Santos
						 * @date 02/08/2012
						 */
						// DOCUMENTO INEXISTENTE
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.get(idCategoria));

								/**
								 * 
								 * 
								 * Retorna o resumo arrecadacao
								 * 
								 * @author Wellington Rocha
								 * @author Felipe Santos
								 * @date 02/08/2012
								 */
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS, LancamentoTipo.DOCUMENTO_INEXISTENTE,
										LancamentoItem.DOCUMENTO_INEXISTENTE, new Short("2200"),
										mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS, LancamentoTipo.DOCUMENTO_INEXISTENTE,
										LancamentoItem.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO, new Short("2210"),
										mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS, LancamentoTipo.DOCUMENTO_INEXISTENTE,
										LancamentoItem.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA, new Short("2220"),
										mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS, LancamentoTipo.DOCUMENTO_INEXISTENTE,
										LancamentoItem.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA, new Short("2230"),
										mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS, LancamentoTipo.DOCUMENTO_INEXISTENTE,
										LancamentoItem.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO, new Short("2240"),
										mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// ****************************************************************

						/*
						 * Seqüêncial de Tipo de Lançamento 2300 Caso o map onde
						 * foi armazenado o valor do pagamento por categoria do
						 * grupo de pagamentos classificados do mês, com
						 * situação atual igual a valor não confere e e para os
						 * pagamentos não classificados do mês com situação
						 * anterior igual a valor não confere, acumulou neste
						 * caso o valor do pagamento excedente, não estiver
						 * vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.containsKey(idCategoria)) {
							if (mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2400
								valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = valorAcumuladoSequenciaTipoLancamentoEntre2100e2399
										.add(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS);
								lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
								lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2300"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2600 Caso o map onde
						 * foi armazenado o valor das devoluções por categoria
						 * com situação atual igual a devolução classificada não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorDevolucaoSituacaoAtualDevolucaoClassificada.containsKey(idCategoria)) {

							if (mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 2800
								valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 = valorAcumuladoSequenciaTipoLancamentoEntre2600e2799
										.add(mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
								lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2600"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoSituacaoAtualDevolucaoClassificada.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 2900 Caso o map onde
						 * foi armazenado os maps com o valor das devoluções por
						 * categoria com situação atual igual a pagamento em
						 * duplicidade não encontrado não estiver vazio, gera
						 * para cada map armazenado o resumo da arrecadação para
						 * cada categoria retornada pelo imóvel com seu
						 * respectivo valor.
						 */
						if (mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.containsKey(idCategoria)) {

							if (mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 3200
								valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = valorAcumuladoSequenciaTipoLancamentoEntre2900e3199
										.add(mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
								lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2900"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 3000 Caso o map onde
						 * foi armazenado o valor das devoluções não
						 * classificadas do mês por categoria com situação atual
						 * igual a guia de devolução não informada não estiver
						 * vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.containsKey(idCategoria)) {

							if (mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 3200
								valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = valorAcumuladoSequenciaTipoLancamentoEntre2900e3199
										.add(mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.GUIA_DEVOLUCAO_NAO_INFORMADA);
								lancamentoItemTemp.setId(LancamentoItem.GUIA_DEVOLUCAO_NAO_INFORMADA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3000"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 3100 Caso o map onde
						 * foi armazenado o valor das devoluções não
						 * classificadas do mês por categoria com situação atual
						 * igual a valor não confere não estiver vazio, gera o
						 * resumo da arrecadação para cada categoria retornada
						 * pelo imóvel com seu respectivo valor.
						 */
						if (mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.containsKey(idCategoria)) {

							if (mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 3200
								valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = valorAcumuladoSequenciaTipoLancamentoEntre2900e3199
										.add(mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
								lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3100"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4600 Caso o map onde
						 * foi armazenado o valor do IR(imposto de renda) por
						 * categoria do grupo de pagamentos de contas efetuados
						 * em meses anteriores classificados no mês, não estiver
						 * vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)) {
							if (mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.subtract(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.subtract(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.IMPOSTO_RENDA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4600"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4700 Caso o map onde
						 * foi armazenado o valor do CSLL por categoria do grupo
						 * de pagamentos de contas efetuados em meses anteriores
						 * classificados no mês, não estiver vazio, gera o
						 * resumo da arrecadação para cada categoria retornada
						 * pelo imóvel com seu respectivo valor.
						 */
						if (mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)) {
							if (mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.subtract(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.subtract(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.CSLL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4700"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4800 Caso o map onde
						 * foi armazenado o valor do COFINS por categoria do
						 * grupo de pagamentos de contas efetuados em meses
						 * anteriores classificados no mês, não estiver vazio,
						 * gera o resumo da arrecadação para cada categoria
						 * retornada pelo imóvel com seu respectivo valor.
						 */
						if (mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)) {
							if (mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.subtract(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.subtract(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.COFINS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4800"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 4900 Caso o map onde
						 * foi armazenado o valor do PIS/PASEP por categoria do
						 * grupo de pagamentos de contas efetuados em meses
						 * anteriores classificados no mês, não estiver vazio,
						 * gera o resumo da arrecadação para cada categoria
						 * retornada pelo imóvel com seu respectivo valor.
						 */
						if (mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.containsKey(idCategoria)) {
							if (mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria).doubleValue() > 0.00) {

								// Seqüêncial de Tipo de Lançamento 5400
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
										.subtract(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5000
								valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
										.subtract(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.PIS_PASEP);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4900"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/**
						 * 
						 * Contabilizar em contas diferentes valores arrecadados
						 * até 31/12/2012
						 * 
						 * @author Wellington Rocha
						 * 
						 * */

						// 4610
						if (mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(idCategoria)) {
							if (mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.subtract(mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.subtract(mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.IMPOSTO_RENDA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4610"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// 4710
						if (mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(idCategoria)) {
							if (mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.subtract(mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.subtract(mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.CSLL);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4710"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// 4810
						if (mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(idCategoria)) {
							if (mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.subtract(mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.subtract(mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.COFINS);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4810"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// 4910
						if (mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.containsKey(idCategoria)) {
							if (mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria).doubleValue() > 0.00) {

								// Seqüêncial de Tipo de Lançamento 5410
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
										.subtract(mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								// Seqüêncial de Tipo de Lançamento 5010
								valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
										.subtract(mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.get(idCategoria));

								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.IMPOSTOS_RETIDOS_NAS_CONTAS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
								lancamentoItemTemp.setId(LancamentoItem.PIS_PASEP);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4910"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// ****Fim Impostos**********************
						/*
						 * Seqüêncial de Tipo de Lançamento 5500 Caso o map onde
						 * foi armazenado o valor das devoluções por categoria
						 * do grupo de devoluções efetuadas em meses anteriores
						 * classificadas no mês, com situação atual igual a
						 * devolução classificada não estiver vazio, gera o
						 * resumo da arrecadação para cada categoria retornada
						 * pelo imóvel com seu respectivo valor.
						 */
						if (mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.containsKey(idCategoria)) {

							if (mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 5700
								valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 = valorAcumuladoSequenciaTipoLancamentoEntre5500e5699
										.add(mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
								lancamentoTipoTemp.setId(LancamentoTipo.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
								lancamentoItemTemp.setId(LancamentoItem.DOCUMENTOS_PAGOS_EM_DUPLICIDADE_EXCESSO);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5500"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorDevolucaoEfetuadaEmMesesAnterioresClassificadasNoMesSituacaoAtualDevolucaoClassificada
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 5800 Caso o map onde
						 * foi armazenado o valor excedente dos pagamentos por
						 * categoria do grupo de pagamentos não classificados
						 * com baixa comandada, com situação anterior igual a
						 * pagamento em duplicidade não estiver vazio, gera o
						 * resumo da arrecadação para cada categoria retornada
						 * pelo imóvel com seu respectivo valor.
						 */
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
								lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE);
								lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5800"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 5900 Caso o map onde
						 * foi armazenado o valor excedente dos pagamentos por
						 * categoria do grupo de pagamentos não classificados
						 * com baixa comandada, com situação anterior igual a
						 * documento inexistente não estiver vazio, gera o
						 * resumo da arrecadação para cada categoria retornada
						 * pelo imóvel com seu respectivo valor.
						 */
						/**
						 * 
						 * 
						 * Detalhar contabilização de documentos inexistentes
						 * 
						 * Retorna o resumo arrecadacao por RecebimentoTipo,
						 * LancamentoTipo, LancamentoItem e Sequência.
						 * 
						 * @author Wellington Rocha
						 * @author Felipe Santos
						 * @date 02/08/2012
						 */

						// DOCUMENTO_INEXISTENTE
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE, new Short("5900"),
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito
								.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO, new Short("5910"),
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada
								.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA, new Short("5920"),
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada
								.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA, new Short("5930"),
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento
								.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento.get(
									idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO, new Short("5940"),
										mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6000 Caso o map onde
						 * foi armazenado o valor excedente dos pagamentos por
						 * categoria do grupo de pagamentos não classificados
						 * com baixa comandada, com situação anterior igual a
						 * valor não confere não estiver vazio, gera o resumo da
						 * arrecadação para cada categoria retornada pelo imóvel
						 * com seu respectivo valor.
						 */
						if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.containsKey(idCategoria)) {

							if (mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6100
								valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = valorAcumuladoSequenciaTipoLancamentoEntre5800e6099
										.add(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
								lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
								lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6000"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// Seqüêncial de Tipo de Lançamento 6200
						// O sequência 6200 acumula os valores dos sequências
						// 100 à 700
						// de 3500 à 4100
						// e acumula negativamente os valores dos sequências de
						// 8000 à
						// 1000, de 1200 à 1500,
						// de 4200 à 4400 e de 4600 à 4900.
						BigDecimal valorSequencial_100_200_3500_3600 = repositorioArrecadacao
								.acumularValorAgua_EsgotoPagamentosClassificadosNoMes_EfetuadosEmMesesAnterioresContaContabilizadasComoPerdas(idLocalidade,
										anoMesReferenciaArrecadacao, idCategoria);

						BigDecimal valorSequencial_300_400_500_600_700_3700_3800_3900_4000_4100 = repositorioArrecadacao
								.acumularValorDebitoCobradoPagamentosClassificadosNoMes_EfetuadosEmMesesAnterioresContaContabilizadaComoPerdasFinanciamentoTipoServico_ParcelamentoAgua_ParcelamentoEsgoto_ParcelamentoServico(
										idLocalidade, anoMesReferenciaArrecadacao, idCategoria);

						BigDecimal valorSequencial_800_900_1000_4200_4300_4400 = repositorioArrecadacao
								.acumularValorCreditoRealizadoPagamentosClassificadosNoMes_EfetuadosMesesAnterioresContaContabilizadaComoPerdasOrigemCredito_ContasPagasEmDuplicidadeExcesso_ValoresCobradosIndevidamente_DescontosConcedidos(
										idLocalidade, anoMesReferenciaArrecadacao, idCategoria);
						BigDecimal valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900 = null;

						if (mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.containsKey(idCategoria)) {
							valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900 = mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores
									.get(idCategoria);
						}

						if (valorSequencial_100_200_3500_3600 != null) {
							valorAcumuladoContasContabilizadasComoPerdas = valorAcumuladoContasContabilizadasComoPerdas.add(valorSequencial_100_200_3500_3600);
						}

						if (valorSequencial_300_400_500_600_700_3700_3800_3900_4000_4100 != null) {
							valorAcumuladoContasContabilizadasComoPerdas = valorAcumuladoContasContabilizadasComoPerdas
									.add(valorSequencial_300_400_500_600_700_3700_3800_3900_4000_4100);
						}

						if (valorSequencial_800_900_1000_4200_4300_4400 != null) {
							valorAcumuladoContasContabilizadasComoPerdas = valorAcumuladoContasContabilizadasComoPerdas
									.subtract(valorSequencial_800_900_1000_4200_4300_4400);
						}
						if (valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900 != null) {
							valorAcumuladoContasContabilizadasComoPerdas = valorAcumuladoContasContabilizadasComoPerdas
									.subtract(valorSequencial_1200_1300_1400_1500_4600_4700_4800_4900);
						}
						// fim do acumulador do sequêncial 6200

						/*
						 * Seqüêncial de Tipo de Lançamento 6300 Caso o map onde
						 * foi armazenado o valor excedente dos pagamentos por
						 * categoria do grupo de pagamentos não classificados ,
						 * com situação atual igual a pagamento em duplicidade
						 * não estiver vazio, gera o resumo da arrecadação para
						 * cada categoria retornada pelo imóvel com seu
						 * respectivo valor.
						 */
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
								lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE);
								lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6300"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6350 Caso o map onde
						 * foi armazenado o valor dos pagamentos da campanha
						 * Solidariedade da Criança , não estiver vazio, gera o
						 * resumo da arrecadação para cada categoria retornada
						 * pelo imóvel com seu respectivo valor.
						 */
						if (mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.containsKey(idCategoria)) {

							if (mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6350
								// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
								// =
								// valorAcumuladoSequenciaTipoLancamentoEntre6300e6599.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_DE_VALORES_DA_CAMPANHA_SOLIDARIEDADE_DA_CRIANCA);
								lancamentoTipoTemp.setId(LancamentoTipo.VALORES_DA_CAMPANHA_DA_CRIANCA);
								lancamentoItemTemp.setId(LancamentoItem.VALORES_DA_CAMPANHA_DA_CRIANCA);

								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6350"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								// resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.get(idCategoria));

								// Vivianne Sousa - 05/07/2009
								// Diminuir do valor acumulado o valor do
								// sequencial 2450(Desconto pela campanha da
								// criança)
								if (mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.containsKey(idCategoria)) {
									if (mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria).doubleValue() > 0.00) {
										resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.get(
												idCategoria).subtract(mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria)));
									} else {
										resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca
												.get(idCategoria));
									}
								} else {
									resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca
											.get(idCategoria));
								}

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// mapValorDevolucaoDescontosPagamentoAVistaCampanhaCriancaComDireitoDesconto
						/*
						 * Seqüêncial de Tipo de Lançamento 6360 Caso o map onde
						 * foi armazenado o valor dos pagamentos da campanha
						 * Solidariedade da Criança com Direito ao Desconto, não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */

						if (mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.containsKey(idCategoria)) {
							if (mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria).doubleValue() > 0.00) {

								// [SB0008] Obter perfil
								ParcelamentoPerfil parcelamentoPerfil = getControladorCobranca().obterPerfilParcelamento(null, null, null, null,
										idRDComPercentualDoacao, Categoria.RESIDENCIAL);

								if (parcelamentoPerfil != null) {

									BigDecimal valorCem = new BigDecimal("100.00");

									// PCPF_PCDESCONTOPAGAMENTOAVISTA da tabela
									// PARCELAMENTO_PERFIL
									BigDecimal parcentualDescontoAVista = parcelamentoPerfil.getPercentualDescontoPagamentoAVista();
									BigDecimal valorDevolucaoDesconto = mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.get(idCategoria);
									// [SB0009] - Calcula o valor com Direito ao
									// Desconto
									// O valor com direito ao desconto será
									// o devl_vldevolucao da tabela DEVOLUÇÃO x
									// 100 / PCPF_PCDESCONTOPAGAMENTOAVISTA da
									// tabela PARCELAMENTO_PERFIL.
									BigDecimal valorDevolucaoComDireitoDesconto = (valorDevolucaoDesconto.multiply(valorCem)).divide(parcentualDescontoAVista);
									valorDevolucaoComDireitoDesconto.setScale(2, BigDecimal.ROUND_DOWN);

									// Seqüêncial de Tipo de Lançamento 6360
									recebimentoTipoTemp = new RecebimentoTipo();
									lancamentoTipoTemp = new LancamentoTipo();
									lancamentoItemTemp = new LancamentoItem();

									resumoArrecadacaoTemp = new ResumoArrecadacao();
									recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_DE_VALORES_DA_CAMPANHA_SOLIDARIEDADE_DA_CRIANCA);
									lancamentoTipoTemp.setId(LancamentoTipo.VALORES_DA_CAMPANHA_DA_CRIANCA);
									lancamentoItemTemp.setId(LancamentoItem.VALOR_CAMPANHA_DA_CRIANCA_COM_DIREITO_AO_DESCONTO);

									resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
									resumoArrecadacaoTemp.setLocalidade(localidade);
									resumoArrecadacaoTemp.setCategoria(categoria);
									resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
									resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
									resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
									resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
									resumoArrecadacaoTemp.setLancamentoItemContabil(null);
									resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6360"));
									resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
									resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
									// resumoArrecadacaoTemp.setValorItemArrecadacao(valorDevolucaoComDireitoDesconto);
									resumoArrecadacaoTemp.setValorItemArrecadacao(valorDevolucaoComDireitoDesconto.subtract(valorDevolucaoDesconto));
									colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

								}
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6400 Caso o map onde
						 * foi armazenado o valor excedente dos pagamentos por
						 * categoria do grupo de pagamentos não classificados ,
						 * com situação atual igual a documento inexistente não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						/**
						 * Detalhar contabilização de documentos inexistentes
						 * 
						 * Retorna o resumo arrecadacao por RecebimentoTipo,
						 * LancamentoTipo, LancamentoItem e Sequência.
						 */

						// DOCUMENTO_INEXISTENTE
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE, new Short("6400"),
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_DEBITO_PRESCRITO, new Short("6410"),
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_CONTA_PARCELADA
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_CONTA_PARCELADA, new Short("6420"),
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_CONTA_CANCELADA
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_CONTA_CANCELADA, new Short("6430"),
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						// DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento
												.get(idCategoria));

								// Retorna o resumo arrecadacao
								resumoArrecadacaoTemp = this.retornarResumoArrecadacaoPorItem(idCategoria, gerenciaRegional, localidade, categoria,
										anoMesReferenciaArrecadacao, RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS,
										LancamentoTipo.DOCUMENTO_INEXISTENTE, LancamentoItem.DOCUMENTO_INEXISTENTE_ERRO_PROCESSAMENTO, new Short("6440"),
										mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento);

								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6500 Caso o map onde
						 * foi armazenado o valor excedente dos pagamentos por
						 * categoria do grupo de pagamentos não classificados ,
						 * com situação atual igual a valor não confere não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(idCategoria)) {

							if (mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 6600
								valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = valorAcumuladoSequenciaTipoLancamentoEntre6300e6599
										.add(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
								lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
								lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6500"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6700 Caso o map onde
						 * foi armazenado o valor da devolução por categoria do
						 * grupo de devoluções não classificadas , com situação
						 * atual igual a pagamento em duplicidade não encontrado
						 * não estiver vazio, gera o resumo da arrecadação para
						 * cada categoria retornada pelo imóvel com seu
						 * respectivo valor.
						 */
						if (mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.containsKey(idCategoria)) {

							if (mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.get(idCategoria)
									.doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 7000
								valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = valorAcumuladoSequenciaTipoLancamentoEntre6700e6999
										.add(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
												.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
								lancamentoItemTemp.setId(LancamentoItem.PAGAMENTO_EM_DUPLICIDADE_EXCESSO_NAO_ENCONTRADO);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6700"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6800 Caso o map onde
						 * foi armazenado o valor da devolução por categoria do
						 * grupo de devoluções não classificadas , com situação
						 * atual igual a guia de devolução não informada não
						 * estiver vazio, gera o resumo da arrecadação para cada
						 * categoria retornada pelo imóvel com seu respectivo
						 * valor.
						 */
						if (mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.containsKey(idCategoria)) {

							if (mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 7000
								valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = valorAcumuladoSequenciaTipoLancamentoEntre6700e6999
										.add(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.GUIA_DEVOLUCAO_NAO_INFORMADA);
								lancamentoItemTemp.setId(LancamentoItem.GUIA_DEVOLUCAO_NAO_INFORMADA);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6800"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp
										.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada
												.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						/*
						 * Seqüêncial de Tipo de Lançamento 6900 Caso o map onde
						 * foi armazenado o valor da devolução por categoria do
						 * grupo de devoluções não classificadas , com situação
						 * atual igual a valor não confere não estiver vazio,
						 * gera o resumo da arrecadação para cada categoria
						 * retornada pelo imóvel com seu respectivo valor.
						 */
						if (mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.containsKey(idCategoria)) {

							if (mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(idCategoria).doubleValue() > 0.00) {
								// Seqüêncial de Tipo de Lançamento 7000
								valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = valorAcumuladoSequenciaTipoLancamentoEntre6700e6999
										.add(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.get(idCategoria));
								recebimentoTipoTemp = new RecebimentoTipo();
								lancamentoTipoTemp = new LancamentoTipo();
								lancamentoItemTemp = new LancamentoItem();

								resumoArrecadacaoTemp = new ResumoArrecadacao();
								recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS);
								lancamentoTipoTemp.setId(LancamentoTipo.VALOR_NAO_CONFERE);
								lancamentoItemTemp.setId(LancamentoItem.VALOR_NAO_CONFERE);
								resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
								resumoArrecadacaoTemp.setLocalidade(localidade);
								resumoArrecadacaoTemp.setCategoria(categoria);
								resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
								resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
								resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
								resumoArrecadacaoTemp.setLancamentoItemContabil(null);
								resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6900"));
								resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
								resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
								resumoArrecadacaoTemp.setValorItemArrecadacao(mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere
										.get(idCategoria));
								colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);
							}
						}

						if (valorAcumuladoSequenciaTipoLancamentoEntre800e1099 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre800e1099.doubleValue() > 0.00) {

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599
									.subtract(valorAcumuladoSequenciaTipoLancamentoEntre800e1099);

							lancamentoItemTemp = new LancamentoItem(LancamentoItem.TOTAL_CREDITOS_REALIZADOS);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_CREDITOS_REALIZADOS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosTotalCreditos(localidade, categoria,
									anoMesReferenciaArrecadacao, valorAcumuladoSequenciaTipoLancamentoEntre800e1099,
									lancamentoItemTemp, null, new Short("1100"), new Short("0"));
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre800e1099 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 2000 (Seqüêncial de
						// Tipo de Lançamento 1600 + 1700 a 1999)
						valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 = valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999
								.add(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599);

						valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = valorAcumuladoSequenciaTipoLancamentoIgual2000e2400
								.add(valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999);

						if (valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999.doubleValue() > 0.00) {
							
							//recebimentoTipoTemp = new RecebimentoTipo(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp = new LancamentoTipo(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_CLASSIFICADOS);
							lancamentoItemTemp = new LancamentoItem(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_CLASSIFICADOS);

							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosTotal(localidade, categoria,
									anoMesReferenciaArrecadacao, valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999,
									lancamentoItemTemp, null, new Short("2000"), new Short("0"));
							
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599SomandoSequenciaEntre1700e1999 = BigDecimal.ZERO;
						}

						if (valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599.doubleValue() > 0.00) {
							lancamentoItemTemp = new LancamentoItem(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);

							//recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_CLASSIFICADOS);
							//lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
							
							resumoArrecadacaoTemp = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosTotalContas(localidade, categoria,
									anoMesReferenciaArrecadacao, valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599,
									lancamentoItemTemp, null, new Short("1600"), new Short("0"));
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre0e799Subtraindo1100eEntre1200e1599 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 2500 (Seqüêncial de
						// Tipo de
						// Lançamento 2000 e 2400)
						valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = valorAcumuladoSequenciaTipoLancamentoIgual2000e2400
								.add(valorAcumuladoSequenciaTipoLancamentoEntre2100e2399);

						// Seqüêncial de Tipo de Lançamento 2400
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre2100e2399.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_NAO_CLASSIFICADOS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2400"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre2100e2399);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre2100e2399 = BigDecimal.ZERO;
						}

						// Vivianne Sousa - 02/06/2009
						// Seqüêncial de Tipo de Lançamento 2460
						if (valorDiferencaSequenciaTipoLancamentoIgual2440e2450 != null
								&& valorDiferencaSequenciaTipoLancamentoIgual2440e2450.doubleValue() > 0.00) {

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DESCONTOS);
							lancamentoTipoTemp.setId(LancamentoTipo.DESCONTOS_PAGAMENTO_A_VISTA);
							lancamentoItemTemp.setId(LancamentoItem.OUTROS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2460"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorDiferencaSequenciaTipoLancamentoIgual2440e2450);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorDiferencaSequenciaTipoLancamentoIgual2440e2450 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 3400 (Seqüêncial de
						// Tipo de
						// Lançamento 2500 e 3300)

						valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = valorAcumuladoSequenciaTipoLancamentoIgual2000e2400
								.subtract(valorAcumuladoSequenciaTipoLancamentoIgual2440e2470);

						diferencaEntreSequencialTipoIgual2500e3300 = diferencaEntreSequencialTipoIgual2500e3300
								.add(valorAcumuladoSequenciaTipoLancamentoIgual2000e2400);

						// Seqüêncial de Tipo de Lançamento 2485
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoIgual2440e2470 != null
								&& valorAcumuladoSequenciaTipoLancamentoIgual2440e2470.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DESCONTOS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DESCONTOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DESCONTOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2485"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoIgual2440e2470);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoIgual2440e2470 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 2500
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 != null) {

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_RECEBIMENTOS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2500"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoIgual2000e2400); // diferencaEntreSequencialTipoIgual2500e2485);
																																// //
																																// totalRecebimentosMenosTotalDescontos);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoIgual2000e2400 = BigDecimal.ZERO;

						}

						// Seqüêncial de Tipo de Lançamento 3300 = (Seqüêncial
						// de Tipo
						// de Lançamento 2800 + Seqüêncial de Tipo de Lançamento
						// 3200)
						valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 = valorAcumuladoSequenciaTipoLancamentoIgual2800e3200
								.add(valorAcumuladoSequenciaTipoLancamentoEntre2600e2799);

						// Seqüêncial de Tipo de Lançamento 2800
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre2600e2799.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_CLASSIFICADAS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_CLASSIFICADAS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_CLASSIFICADAS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("2800"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre2600e2799);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre2600e2799 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 3300 = (Seqüêncial
						// de Tipo
						// de Lançamento 2800 + Seqüêncial de Tipo de Lançamento
						// 3200)
						valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 = valorAcumuladoSequenciaTipoLancamentoIgual2800e3200
								.add(valorAcumuladoSequenciaTipoLancamentoEntre2900e3199);

						// Seqüêncial de Tipo de Lançamento 3200
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre2900e3199.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_NAO_CLASSIFICADAS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3200"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre2900e3199);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre2900e3199 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 3400
						diferencaEntreSequencialTipoIgual2500e3300 = diferencaEntreSequencialTipoIgual2500e3300
								.subtract(valorAcumuladoSequenciaTipoLancamentoIgual2800e3200);

						// Seqüêncial de Tipo de Lançamento 3300
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 != null
								&& valorAcumuladoSequenciaTipoLancamentoIgual2800e3200.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.TOTAL_DEVOLUCOES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3300"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoIgual2800e3200);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoIgual2800e3200 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 3400
						// Neste caso não tem verificação do valor menor ou
						// igula a zero
						// porque , a diferença
						// pode ser negativa ou zero.
						if (diferencaEntreSequencialTipoIgual2500e3300 != null) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.ARRECADACAO_LIQUIDA);
							lancamentoTipoTemp.setId(LancamentoTipo.ARRECADACAO_LIQUIDA);
							lancamentoItemTemp.setId(LancamentoItem.ARRECADACAO_LIQUIDA);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("3400"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(diferencaEntreSequencialTipoIgual2500e3300);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							diferencaEntreSequencialTipoIgual2500e3300 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 4500
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre4200e4499.doubleValue() > 0.00) {

							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399
									.subtract(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499);

							// Seqüêncial de Tipo de Lançamento 5000
							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999
									.subtract(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_CREDITOS_REALIZADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_CREDITOS_REALIZADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4500"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre4200e4499);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre4200e4499 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 5000
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5000"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 5400
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5400"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre3500e4199Subtraindo4500eEntre4600e4999SomandoSequenciaEntre5100e5399 = BigDecimal.ZERO;
						}

						/**
						 * Alterações para contabilizar em contas diferentes
						 * valores arrecadados até 31/12/12
						 * 
						 * @author Wellington Rocha
						 */

						// Seqüêncial de Tipo de Lançamento 4510
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre4210e4499.doubleValue() > 0.00) {

							// Seqüêncial de Tipo de Lançamento 5400
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399
									.subtract(valorAcumuladoSequenciaTipoLancamentoEntre4210e4499);

							// Seqüêncial de Tipo de Lançamento 5000
							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999
									.subtract(valorAcumuladoSequenciaTipoLancamentoEntre4210e4499);

							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_CREDITOS_REALIZADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_CREDITOS_REALIZADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("4510"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre4210e4499);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre4210e4499 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 5010
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_CONTA_CLASSIFICADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5010"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 5410
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTO_MESES_ATE_31_12_2012_CLASSIFICADOS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_DE_MESES_ANTERIORES_CLASSIFICADOS_NO_MES);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5410"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp
									.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre3510e4199Subtraindo4510eEntre4610e4999SomandoSequenciaEntre5110e5399 = BigDecimal.ZERO;
						}

						/********************** Fim Alteração **************************************/

						// Seqüêncial de Tipo de Lançamento 5700
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre5500e5699.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.DEVOLUCOES_RECEBIMENTO_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_DE_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DAS_DEVOLUCOES_DE_MESES_ANTERIORES_CLASSIFICADAS_NO_MES);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("5700"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre5500e5699);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre5500e5699 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 6100
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre5800e6099.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.BAIXA_RECEBIMENTOS_NAO_CLASSIFICADOS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS_BAIXADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS_BAIXADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6100"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre5800e6099);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre5800e6099 = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 6200
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoContasContabilizadasComoPerdas != null && valorAcumuladoContasContabilizadasComoPerdas.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RECEBIMENTOS_VALORES_CONTABILIZADOS_COMO_PERDAS);
							lancamentoTipoTemp.setId(LancamentoTipo.VALORES_CONTABILIZADOS_COMO_PERDAS);
							lancamentoItemTemp.setId(LancamentoItem.VALORES_CONTABILIZADOS_COMO_PERDAS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6200"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoContasContabilizadasComoPerdas);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoContasContabilizadasComoPerdas = BigDecimal.ZERO;
						}

						// Seqüêncial de Tipo de Lançamento 6600
						// [FS0005] - Verificar valor acumulado igual a zero
						if (valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 != null
								&& valorAcumuladoSequenciaTipoLancamentoEntre6300e6599.doubleValue() > 0.00) {
							recebimentoTipoTemp = new RecebimentoTipo();
							lancamentoTipoTemp = new LancamentoTipo();
							lancamentoItemTemp = new LancamentoItem();

							resumoArrecadacaoTemp = new ResumoArrecadacao();
							recebimentoTipoTemp.setId(RecebimentoTipo.RESUMO_RECEBIMENTOS_NAO_CLASSIFICADOS);
							lancamentoTipoTemp.setId(LancamentoTipo.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
							lancamentoItemTemp.setId(LancamentoItem.TOTAL_DOS_RECEBIMENTOS_NAO_CLASSIFICADOS);
							resumoArrecadacaoTemp.setGerenciaRegional(gerenciaRegional);
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(recebimentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoTipo(lancamentoTipoTemp);
							resumoArrecadacaoTemp.setLancamentoItem(lancamentoItemTemp);
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("6600"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre6300e6599);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre6300e6599 = BigDecimal.ZERO;
						}

						if (valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 != null && valorAcumuladoSequenciaTipoLancamentoEntre6700e6999.doubleValue() > 0.00) {
							resumoArrecadacaoTemp = new ResumoArrecadacao();

							resumoArrecadacaoTemp.setGerenciaRegional(localidade.getGerenciaRegional());
							resumoArrecadacaoTemp.setLocalidade(localidade);
							resumoArrecadacaoTemp.setCategoria(categoria);
							resumoArrecadacaoTemp.setAnoMesReferencia(anoMesReferenciaArrecadacao);
							resumoArrecadacaoTemp.setRecebimentoTipo(new RecebimentoTipo(RecebimentoTipo.RESUMO_DEVOLUCOES_NAO_CLASSIFICADAS));
							resumoArrecadacaoTemp.setLancamentoTipo(new LancamentoTipo(LancamentoTipo.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS));
							resumoArrecadacaoTemp.setLancamentoItem(new LancamentoItem(LancamentoItem.TOTAL_DAS_DEVOLUCOES_NAO_CLASSIFICADOS));
							resumoArrecadacaoTemp.setLancamentoItemContabil(null);
							resumoArrecadacaoTemp.setSequenciaTipoLancamento(new Short("7000"));
							resumoArrecadacaoTemp.setSequenciaItemTipoLancamento(new Short("0"));
							resumoArrecadacaoTemp.setUltimaAlteracao(new Date());
							resumoArrecadacaoTemp.setValorItemArrecadacao(valorAcumuladoSequenciaTipoLancamentoEntre6700e6999);
							colecaoResumoArrecadacao.add(resumoArrecadacaoTemp);

							valorAcumuladoSequenciaTipoLancamentoEntre6700e6999 = BigDecimal.ZERO;
						}

						// Reseta os valores dentro dos maps
						// Seqüêncial de Tipo de Lançamento 1200
						mapValorIRPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 1300
						mapValorCSLLPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 1400
						mapValorCOFINSPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 1500
						mapValorPISPASEPPagamentosClassificadosConta.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 2100
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorPagamentoEmDuplicidade.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 2200
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistente.put(categoria.getId(), BigDecimal.ZERO);

						// Seqüêncial de Tipo de Lançamento 2210
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteDebitoPrescrito.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 2220
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaParcelada.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 2230
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteContaCancelada.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 2240
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorDocumentoInexistenteErroProcessamento.put(categoria.getId(), BigDecimal.ZERO);


						// Seqüêncial de Tipo de Lançamento 2300
						mapValorPagamentoNaoClassificadoNoMesSituacaoAtualESituacaoAnteriorValorNaoConfere.put(categoria.getId(), BigDecimal.ZERO);
						mapValorDevolucaoDescontosPagamentoAVista.put(categoria.getId(), BigDecimal.ZERO);
						mapValorDevolucaoDescontosCreditosARealizar.put(categoria.getId(), BigDecimal.ZERO);

						// Seqüêncial de Tipo de Lançamento 2600
						mapValorDevolucaoSituacaoAtualDevolucaoClassificada.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 2900
						mapValorDevolucaoNaoClassificadaSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 3000
						mapValorDevolucaoNaoClassificadaSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 3100
						mapValorDevolucaoNaoClassificadaSituacaoAtualValorNaoConfere.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4600
						mapValorIRPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4700
						mapValorCSLLPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4800
						mapValorCOFINSPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4900
						mapValorPISPASEPPagamentosContasEfetuadosMesesAterioresClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4610
						mapValorIRPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4710
						mapValorCSLLPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4810
						mapValorCOFINSPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 4910
						mapValorPISPASEPPagamentosContasEfetuadosAte122012ClassificadosMes.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 5800
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorPagamentoEmDuplicidade.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 5900
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistente.put(categoria.getId(), BigDecimal.ZERO);

						// Seqüêncial de Tipo de Lançamento 5910
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteDebitoPrescrito.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 5920
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaParcelada.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 5930
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteContaCancelada.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 5940
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorDocumentoInexistenteErroProcessamento.put(categoria.getId(),BigDecimal.ZERO);

						// Seqüêncial de Tipo de Lançamento 6000
						mapValorExcedentePagamentoNaoClassificadosComBaixaComandadaSituacaoAnteriorValorNaoConfere.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6200
						mapValorImpostosPagamentosContaClassificadosNoMes_EfetuadosEmMesesAnteriores.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6300
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidade.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6400
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistente.put(categoria.getId(), BigDecimal.ZERO);

						// Seqüêncial de Tipo de Lançamento 6410
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteDebitoPrescrito.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6420
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaParcelada.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6430
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteContaCancelada.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6440
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualDocumentoInexistenteErroProcessamento.put(categoria.getId(),BigDecimal.ZERO);

						// Seqüêncial de Tipo de Lançamento 6500
						mapValorPagamentoNaoClassificadoNoMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6700
						mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualPagamentoEmDuplicidadeNaoEncontrado.put(categoria.getId(),BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6800
						mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualGuiaDevolucaoNaoInformada.put(categoria.getId(), BigDecimal.ZERO);
						// Seqüêncial de Tipo de Lançamento 6900
						mapValorDevolucaoNaoClassificadaMesEMesesAnterioresSituacaoAtualValorNaoConfere.put(categoria.getId(), BigDecimal.ZERO);

						mapValorDevolucaoDescontosPagamentoAVistaCampanhaCrianca.put(categoria.getId(), BigDecimal.ZERO);
						mapValorPagamentoNoMesEMesesAnterioresCampanhaSolidariedadeCrianca.put(categoria.getId(), BigDecimal.ZERO);
						mapValorPagamentoAVistaCampanhaCriancaComDireitoDesconto.put(categoria.getId(), BigDecimal.ZERO);
						
						mapValoresRecuperacaoCreditoCancelado.put(categoria.getId(), BigDecimal.ZERO);
						mapValoresRecuperacaoCreditoDuplicidade.put(categoria.getId(), BigDecimal.ZERO);
						mapValoresRecuperacaoCreditoCanceladoMesesAnteriores.put(categoria.getId(), BigDecimal.ZERO);
						mapValoresRecuperacaoCreditoDuplicidadeMesesAnteriores.put(categoria.getId(), BigDecimal.ZERO);

					}// FIM POR CATEGORIA

					Integer idUnidadeNegocio = this.getControladorLocalidade().pesquisarIdUnidadeNegocioParaLocalidade(idLocalidade);
					UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId(idUnidadeNegocio);

					for (Iterator iter = colecaoResumoArrecadacao.iterator(); iter.hasNext();) {
						ResumoArrecadacao resumo = (ResumoArrecadacao) iter.next();
						resumo.setUnidadeNegocio(unidadeNegocio);
					}

					repositorioArrecadacao.inserirResumoArrecadacao(colecaoResumoArrecadacao);

					colecaoResumoArrecadacao = new ArrayList();
				}// FIM POR LOCALIDADE

				getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);

			}
		} catch (Exception e) {
			e.printStackTrace();

			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);

			throw new EJBException(e);
		}

	}

	private Map<Integer, BigDecimal> obterValorImpostoPagamentosClassificadosConta(Integer anoMesReferenciaArrecadacao, Integer idLocalidade, Integer tipoImposto) 
			throws ErroRepositorioException, ControladorException {
		
		Map<Integer, BigDecimal> mapValorImpostoPagamentos = new HashMap();
		Collection colecaoContas;
		
		colecaoContas = repositorioArrecadacao.pesquisarContasImpostosDeduzidosPagamentosClassificadosContaPorTipoImposto(idLocalidade, anoMesReferenciaArrecadacao,tipoImposto);
		
		if (colecaoContas != null && colecaoContas.size() > 0) {
			
			for (Object dadosContaImpostosDeduzidos : colecaoContas) {

				Object[] arrayDadosContaImpostosDeduzidos = (Object[]) dadosContaImpostosDeduzidos;

				BigDecimal valorImposto = (BigDecimal) arrayDadosContaImpostosDeduzidos[0];
				Imovel imovel = new Imovel((Integer) arrayDadosContaImpostosDeduzidos[1]);

				if (imovel.getId() != null) {

					Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
					Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();

					Iterator iteratorColecaoValorImpostoPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel, valorImposto)).iterator();

					while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorImpostoPorCategoria.hasNext()) {

						Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
						BigDecimal imposto = (BigDecimal) iteratorColecaoValorImpostoPorCategoria.next();

						if (!mapValorImpostoPagamentos.containsKey(categoria.getId())) {
							mapValorImpostoPagamentos.put(categoria.getId(), BigDecimal.ZERO);
						}

						mapValorImpostoPagamentos.put(categoria.getId(), mapValorImpostoPagamentos.get(categoria.getId()).add(imposto));
					}
				} else {
					if (!mapValorImpostoPagamentos.containsKey(Categoria.RESIDENCIAL)) {
						mapValorImpostoPagamentos.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
					}
					mapValorImpostoPagamentos.put(Categoria.RESIDENCIAL,mapValorImpostoPagamentos.get(Categoria.RESIDENCIAL).add(valorImposto));
				}
			}
		}
		
		return mapValorImpostoPagamentos;
	}

	private Map<Integer, BigDecimal> obterPagamentosNaoClassificadosSituacaoAtualDocumentoInexistente(Integer referenciaArrecadacao, Integer idLocalidade) 
			throws ErroRepositorioException, ControladorException {
	
		Map<Integer, BigDecimal> mapValorPagamento = new HashMap();
		
		Collection pagamentosDocumentoInexistente = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(referenciaArrecadacao, idLocalidade,
						PagamentoSituacao.DOCUMENTO_INEXISTENTE);

		Collection pagamentosDocumentoAContabilizar = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(referenciaArrecadacao, idLocalidade,
						PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

		if (pagamentosDocumentoAContabilizar != null) {
			pagamentosDocumentoInexistente.addAll(pagamentosDocumentoAContabilizar);
		}
		
			System.out.println("---------------------------");
			if (pagamentosDocumentoInexistente != null
					&& pagamentosDocumentoInexistente.size() > 0) {

				for (Object dadosPagamento : pagamentosDocumentoInexistente) {
					Object[] arrayDadosPagamento = (Object[]) dadosPagamento;
					Integer idImovel = (Integer) arrayDadosPagamento[1];
					System.out.println(idImovel);
				}
			}
			System.out.println("---------------------------");
		
		mapValorPagamento.putAll(this.retornarValorPagamentosSituacaoAtualPorPagamentoSituacao(mapValorPagamento,pagamentosDocumentoInexistente));
		
		return mapValorPagamento;
	}
	
	private Map<Integer, BigDecimal> obterPagamentosNaoClassificadosSituacaoAnteriorDocumentoInexistente(Integer referenciaArrecadacao, Integer idLocalidade) 
			throws ErroRepositorioException, ControladorException {
		
		Map<Integer, BigDecimal> mapValorPagamento = new HashMap();
		
		Collection pagamentosDocumentoInexistente = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(referenciaArrecadacao, idLocalidade,
						PagamentoSituacao.DOCUMENTO_INEXISTENTE);

		Collection pagamentosDocumentoAContabilizar = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(referenciaArrecadacao, idLocalidade,
						PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);

		if (pagamentosDocumentoAContabilizar != null) {
			pagamentosDocumentoInexistente.addAll(pagamentosDocumentoAContabilizar);
		}

		if (idLocalidade.equals(new Integer(5))) {
			System.out.println("---------------------------");
			if (pagamentosDocumentoInexistente != null
					&& pagamentosDocumentoInexistente.size() > 0) {

				for (Object dadosPagamento : pagamentosDocumentoInexistente) {
					Object[] arrayDadosPagamento = (Object[]) dadosPagamento;
					Integer idImovel = (Integer) arrayDadosPagamento[1];
					System.out.println(idImovel);
				}
			}
			System.out.println("---------------------------");
		}
		mapValorPagamento.putAll(this.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(mapValorPagamento,pagamentosDocumentoInexistente));
		
		return mapValorPagamento;
	}
	
	private Map<Integer, BigDecimal> obterPagamentosNaoClassificadosSituacaoAtual(Integer referenciaArrecadacao, Integer idLocalidade, Integer idPagamentoSituacao) 
			throws ErroRepositorioException, ControladorException {
		
		Map<Integer, BigDecimal> mapValorPagamento = new HashMap();
		
		Collection colecaoPagamentos = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(referenciaArrecadacao, idLocalidade,
				idPagamentoSituacao ); 

		mapValorPagamento.putAll(this.retornarValorPagamentosSituacaoAtualPorPagamentoSituacao(mapValorPagamento,colecaoPagamentos));
		
		return mapValorPagamento;
	}
	
	private Map<Integer, BigDecimal> obterPagamentosNaoClassificadosSituacaoAnterior(Integer referenciaArrecadacao, Integer idLocalidade, Integer idPagamentoSituacao) 
			throws ErroRepositorioException, ControladorException {
		
		Map<Integer, BigDecimal> mapValorPagamento = new HashMap();
		
		Collection colecaoPagamentos = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(referenciaArrecadacao, idLocalidade,
				idPagamentoSituacao);

		mapValorPagamento.putAll(this.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(mapValorPagamento,colecaoPagamentos));	
		
		return mapValorPagamento;
	}
	
	
	private Map<Integer, BigDecimal> obterPagamentosNaoClassificadosMesPorSituacaoAtual(Integer referenciaArrecadacao, Integer idLocalidade, Integer pagamentoSituacao) 
			throws ErroRepositorioException, ControladorException{
		
		Collection colecaoPagamentos = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAtual(referenciaArrecadacao, idLocalidade, pagamentoSituacao);
		return agruparValoresPorCategoriaParaContabilizar(colecaoPagamentos);
	}
	
	private Map<Integer, BigDecimal> obterPagamentosNaoClassificadosMesPorSituacaoAnterior(Integer referenciaArrecadacao, Integer idLocalidade, Integer idSituacaoAnterior) 
			throws ErroRepositorioException, ControladorException{
		
		Collection colecaoPagamentos = repositorioArrecadacao.pesquisarPagamentosNaoClassificadosMesPorSituacaoAnterior(referenciaArrecadacao, idLocalidade, idSituacaoAnterior);
		return agruparValoresPorCategoriaParaContabilizar(colecaoPagamentos);
	}
	
	private Map<Integer, BigDecimal> agruparValoresPorCategoriaParaContabilizar(Collection colecaoPagamentos) throws ControladorException {
		
		Map<Integer, BigDecimal> mapValorPagamentos = new HashMap();
		
		if (colecaoPagamentos != null && colecaoPagamentos.size() > 0) {
			
			for (Object dadosPagamento : colecaoPagamentos) {
				
				Object[] arrayDadosPagamento = (Object[]) dadosPagamento;
				
				BigDecimal valorPagamento = (BigDecimal) arrayDadosPagamento[0];
				Imovel imovel = new Imovel((Integer) arrayDadosPagamento[1]);
				
				if (imovel.getId() != null) {
					
					Collection colecaoCategoriasImovel = getControladorImovel().obterQuantidadeEconomiasCategoria(imovel);
					Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel.iterator();
					
					Iterator iteratorColecaoValorPagamentoPorCategoria = (getControladorImovel().obterValorPorCategoria(colecaoCategoriasImovel, valorPagamento)).iterator();
					
					while (iteratorColecaoCategoriasImovel.hasNext() && iteratorColecaoValorPagamentoPorCategoria.hasNext()) {
						Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel.next();
						
						valorPagamento = (BigDecimal) iteratorColecaoValorPagamentoPorCategoria.next();
						
						if (!mapValorPagamentos.containsKey(categoria.getId())) {
							mapValorPagamentos.put(categoria.getId(),BigDecimal.ZERO);
						}
						
						mapValorPagamentos.put(categoria.getId(),mapValorPagamentos.get(categoria.getId()).add(valorPagamento));
					}
					
				} else {
					if (!mapValorPagamentos.containsKey(Categoria.RESIDENCIAL)) {
						mapValorPagamentos.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
					}
					mapValorPagamentos.put(Categoria.RESIDENCIAL, mapValorPagamentos.get(Categoria.RESIDENCIAL).add(valorPagamento));
				}
			}
		}
		
		return mapValorPagamentos;
	
	}
	
	
	private ResumoArrecadacao contabilizarCreditosRealizadosRecuperacaoCredito(Integer referenciaArrecadacao, Localidade localidade, Categoria categoria, 
			Integer idCreditoOrigem, Integer idLancamentoItem) throws ErroRepositorioException {
		
		BigDecimal valorCreditos = repositorioArrecadacao.acumularValorCreditoRealizadoPagamentosClassificadosContaOrigemCredito(
						localidade.getId(), referenciaArrecadacao, categoria.getId(), idCreditoOrigem);
		
		ResumoArrecadacao resumoArrecadacao = null;
		if (valorCreditos != null && valorCreditos.doubleValue() > 0.00) {
			
			resumoArrecadacao = new ResumoArrecadacao();
			
			LancamentoItem lancamentoItem = new LancamentoItem(idLancamentoItem);
			
			resumoArrecadacao = ResumoArrecadacaoBuilder.buildResumoRecebimentosClassificadosCreditosRealizados(localidade, categoria,
					referenciaArrecadacao, valorCreditos, lancamentoItem, null, null, null);
		}
		
		return resumoArrecadacao;
	}
	
	private RecebimentosClassificadosRecuperacaoCredito contabilizarRecebimentosClassificadosRecuperacaoCredito(Localidade localidade , Integer referencia, 
			Categoria categoria, Map<Integer, BigDecimal> mapValoresRCDuplicidade, Map<Integer, BigDecimal> mapValoresRCCancelado, 
			Map<Integer, BigDecimal> mapValoresRCDuplicidadeMesesAnteriores, Map<Integer, BigDecimal> mapValoresRCCanceladoMesesAnteriores) 
			throws ErroRepositorioException, ControladorException {
		
		RecebimentosClassificadosRecuperacaoCreditoBuilder builder = new RecebimentosClassificadosRecuperacaoCreditoBuilder();
		
		builder.buildRecebimentosRecuperacaoCredito(localidade, categoria, referencia, mapValoresRCDuplicidade, mapValoresRCCancelado);
		builder.buildRecebimentosRecuperacaoCreditoMesesAnteriores(localidade, categoria, referencia, mapValoresRCDuplicidadeMesesAnteriores, mapValoresRCCanceladoMesesAnteriores);
		
		return builder.recebimentos;
	}
	
	private Map<Integer, BigDecimal> acumularValoresRecebimentosClassificadosRecuperacaoCredito(Localidade localidade , Integer referencia,
			Integer idPagamentoSituacao) throws ControladorException, ErroRepositorioException {
		
		Map<Integer, BigDecimal> mapValor = new HashMap();
		Collection contas = repositorioArrecadacao.pesquisarContasPagamentosClassificadosRecuperacaoCredito(localidade.getId(),referencia, idPagamentoSituacao);
		
		if (contas != null && contas.size() > 0) {
			mapValor.putAll(this.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(mapValor,contas));
		}
		
		return mapValor;
	}
	
	private Map<Integer, BigDecimal> acumularValoresRecebimentosClassificadosRecuperacaoCreditoMesesAnteriores(Localidade localidade , Integer referencia,
			Integer idPagamentoSituacao) throws ErroRepositorioException, ControladorException {

		Map<Integer, BigDecimal> mapValor = new HashMap();
		Collection contas = repositorioArrecadacao.pesquisarContasPagamentosClassificadosRecuperacaoCreditoMesesAnteriores(localidade.getId(),referencia, idPagamentoSituacao);
		
		if (contas != null && contas.size() > 0) {
			mapValor.putAll(this.retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(mapValor,contas));
		}
		
		return mapValor;
	}
	

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * Metodo responsável pela transferência das contas, guias de pagamento, pagamentos e devoluções para o histórico.
	 */
	public void gerarHistoricoParaEncerrarArrecadacaoMes(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
 int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.LOCALIDADE, idLocalidade);

		try {
			gerarHistoricoParaEncerrarArrecadacaoGuiaPagamento(anoMesReferenciaArrecadacao, idLocalidade);
			gerarHistoricoParaEncerrarArrecadacaoDebitoACobrar(anoMesReferenciaArrecadacao, idLocalidade);
			gerarHistoricoParaEncerrarArrecadacaoCreditoARealizar(anoMesReferenciaArrecadacao, idLocalidade);
			gerarHistoricoParaEncerrarArrecadacaoPagamento(anoMesReferenciaArrecadacao, idLocalidade);
			gerarHistoricoEncerrarArrecadacaoDevolucao(anoMesReferenciaArrecadacao, idLocalidade);

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);
		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e, idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	public void processarPagamentosDiferencaDoisReais(Integer referenciaArrecadacao, Localidade localidade, Integer idFuncionalidadeIniciada) throws Exception{
		
		int idUnidadeIniciada = 0;
		
		Integer idLocalidade = localidade.getId();

		try {
			
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada, UnidadeProcessamento.LOCALIDADE, idLocalidade);
		
			logger.info("Geracao de debito ou credito para pgtos classificados em " + referenciaArrecadacao + " da localidade " + idLocalidade);
			
			Collection<PagamentoHelper> pagamentos = repositorioArrecadacao.pesquisarValoresPagamentos(PagamentoSituacao.PAGAMENTO_CLASSIFICADO, 
					idLocalidade,
					referenciaArrecadacao);
			
			logger.info("    Qtd de pagamentos: " + pagamentos.size() + " na localidade: " + idLocalidade);
			
			Integer referenciaContabil = Util.somaMesAnoMesReferencia(referenciaArrecadacao, 1);

			for (PagamentoHelper pagamentoHelper : pagamentos) {
				if (pagamentoHelper.isPagamentoDeConta() && possuiDiferencaAte2(pagamentoHelper)) {
					
					BigDecimal diferenca = pagamentoHelper.getValorPagamento().subtract(pagamentoHelper.getValorDocumento());
					Conta novaConta = null;
					if (diferenca.doubleValue() > 0.0){
						CreditoARealizar credito = inserirCreditoARealizar(referenciaArrecadacao, referenciaContabil, pagamentoHelper, diferenca);
						novaConta = this.retificarContaComDebitoDiferenca2Reais(referenciaArrecadacao, pagamentoHelper, diferenca);
						
					}else if (diferenca.doubleValue() < 0.0){
						
						DebitoACobrar debito = inserirDebitoACobrar(referenciaContabil, referenciaArrecadacao, pagamentoHelper, diferenca.abs(), (short) 0);
						novaConta = this.retificarContaComCreditoDiferenca2Reais(referenciaArrecadacao, pagamentoHelper, diferenca);
					}
					
					if (novaConta != null) {
						Pagamento pagamento = this.pesquisarPagamentoDeConta(pagamentoHelper.getIdConta());
						this.alterarContaDoPagamento(pagamento, novaConta);
					}
				}
			}
			
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,idUnidadeIniciada, false);
		} catch (Exception ex) {
			logger.error("Erro no processamento da LOCALIDADE: " + idLocalidade + " - " + localidade.getDescricao(), ex);
			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex, idUnidadeIniciada, true);
			throw new EJBException(ex);
		}
	}
	
	private Conta retificarContaComDebitoDiferenca2Reais(Integer referenciaArrecadacao, PagamentoHelper pagamentoHelper, BigDecimal diferenca) throws Exception {
		Conta novaConta = null;
		
		DebitoACobrar debito = inserirDebitoACobrar(referenciaArrecadacao, referenciaArrecadacao, pagamentoHelper, diferenca.abs(), (short) 1);
		novaConta = getControladorFaturamento().incluirDebitoContaRetificadaPagamentosDiferenca2Reais(pagamentoHelper.getIdConta(), debito);
		
		return novaConta;
	}
	
	private Conta retificarContaComCreditoDiferenca2Reais(Integer referenciaArrecadacao, PagamentoHelper pagamentoHelper, BigDecimal diferenca) throws Exception {
		Conta novaConta = null;
		
		CreditoARealizar credito = inserirCreditoARealizar(referenciaArrecadacao, referenciaArrecadacao, pagamentoHelper, diferenca);
		novaConta = getControladorFaturamento().incluirCreditoContaRetificadaPagamentosDiferenca2Reais(pagamentoHelper.getIdConta(), credito);
		
		return novaConta;
	}
	
	private void alterarContaDoPagamento(Pagamento pagamento, Conta novaConta) throws ErroRepositorioException {
		if (pagamento != null && novaConta != null) {
			pagamento.setContaGeral(novaConta.getContaGeral());
			pagamento.setUltimaAlteracao(new Date());
			repositorioUtil.atualizar(pagamento);
		}
		
	}
	
	private DebitoACobrar inserirDebitoACobrar(Integer referenciaArrecadacao, Integer referenciaDebito, PagamentoHelper pagamentoHelper, BigDecimal valor, short qtdParcelasCobradas) throws Exception {
		
		Imovel imovel = null;
		if (pagamentoHelper.getIdImovel() != null){
			imovel = repositorioImovel.pesquisarDadosImovel(pagamentoHelper.getIdImovel());
		}
		
		DebitoTipo tipo = new DebitoTipo(DebitoTipo.VALOR_NAO_CONFERE);
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();

		return getControladorFaturamento().gerarDebitoACobrar(referenciaArrecadacao
				, sistemaParametro.getAnoMesFaturamento()
				, imovel
				, (short) 1, qtdParcelasCobradas
				, referenciaDebito
				, valor, tipo, null);
	}
	
	private int getAnoMesReferenciaContabil() throws ControladorException {
		SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
		int anoMesReferenciaContabil = sistemaParametro.getAnoMesFaturamento();
		int anoMesCorrente = Util.getAnoMesComoInt(new Date());

		if (sistemaParametro.getAnoMesFaturamento() < anoMesCorrente) {
			anoMesReferenciaContabil = anoMesCorrente;
		}
		return anoMesReferenciaContabil;
	}
	
	private CreditoARealizar inserirCreditoARealizar(Integer referenciaArrecadacao, Integer referenciaContabil, PagamentoHelper pagamentoHelper, BigDecimal valor) throws Exception {
		CreditoARealizar credito = new CreditoARealizar();
		credito.setGeracaoCredito(Calendar.getInstance().getTime());
		credito.setAnoMesReferenciaCredito(pagamentoHelper.getDataPagamento());
		credito.setAnoMesReferenciaContabil(referenciaContabil);
		credito.setAnoMesCobrancaCredito(referenciaArrecadacao);
		credito.setValorResidualMesAnterior(BigDecimal.ZERO);
		credito.setNumeroPrestacaoCredito((short) 1);
		
		if (referenciaArrecadacao.equals(referenciaContabil)) {
			credito.setNumeroPrestacaoRealizada((short) 1);
		} else {
			credito.setNumeroPrestacaoRealizada((short) 0);
		}
		credito.setValorCredito(valor.abs());
		
		CreditoTipo tipo = new CreditoTipo();
		tipo.setId(CreditoTipo.PAGAMENTO_NAO_CONFERE);
		credito.setCreditoTipo(tipo);
		
		LancamentoItemContabil lancamentoItemContabil = new LancamentoItemContabil();
		lancamentoItemContabil.setId(LancamentoItemContabil.OUTROS_SERVICOS_AGUA);
		credito.setLancamentoItemContabil(lancamentoItemContabil);
		
		CreditoOrigem creditoOrigem = new CreditoOrigem();
		creditoOrigem.setId(CreditoOrigem.CONTAS_PAGAS_EM_DUPLICIDADE_EXCESSO);
		credito.setCreditoOrigem(creditoOrigem);
		
		DebitoCreditoSituacao debitoCreditoSituacao = new DebitoCreditoSituacao();
		debitoCreditoSituacao.setId(DebitoCreditoSituacao.NORMAL);
		credito.setDebitoCreditoSituacaoAtual(debitoCreditoSituacao);
		
		Imovel imovel = null;
		if (pagamentoHelper.getIdImovel() != null){
			imovel = repositorioImovel.pesquisarDadosImovel(pagamentoHelper.getIdImovel());
			credito.setImovel(imovel);
			credito.setLocalidade(imovel.getLocalidade());
			credito.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
			credito.setNumeroLote(imovel.getLote());
			credito.setNumeroSubLote(imovel.getSubLote());
			credito.setQuadra(imovel.getQuadra());
			if (imovel.getQuadra() != null){
				credito.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			}
		}
		
		credito.setUltimaAlteracao(Calendar.getInstance().getTime());
		credito.setAnoMesReferenciaPrestacao(Util.somaMesAnoMesReferencia(referenciaArrecadacao, 1));
		
		Integer idCredito = getControladorFaturamento().gerarCreditoARealizar(credito, imovel, null);
		
		FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
		filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID, idCredito));
		Collection<CreditoARealizar> colecaoCreditoARealizar = getControladorUtil().pesquisar(filtroCreditoARealizar, CreditoARealizar.class.getName());

		return (CreditoARealizar) Util.retonarObjetoDeColecao(colecaoCreditoARealizar);
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 *
	 * <Identificador e nome do caso de uso>
	 *
	 * @author Pedro Alexandre
	 * @date 19/02/2008
	 *
	 * @param anoMesReferenciaArrecadacao
	 * @param idSetorComercial
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarHistoricoConta(Integer anoMesReferenciaArrecadacao,
			Integer idSetorComercial, int idFuncionalidadeIniciada)
			throws ControladorException {

		int idUnidadeIniciada = 0;

		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,
						UnidadeProcessamento.SETOR_COMERCIAL, idSetorComercial);

		try {
			Integer idLocalidade = repositorioArrecadacao
					.pesquisarIdLocalidadePorSetorComercial(idSetorComercial);
			
			/** CONTA */
			gerarHistoricoEncerrarArrecadacaoConta(anoMesReferenciaArrecadacao,
					idLocalidade, idSetorComercial);

			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,
					idUnidadeIniciada, false);

		} catch (Exception e) {
			sessionContext.setRollbackOnly();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(e,
					idUnidadeIniciada, true);
			throw new EJBException(e);
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 *
	 * <Identificador e nome do caso de uso>
	 *
	 * @author Pedro Alexandre
	 * @date 20/02/2008
	 *
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void gerarHistoricoEncerrarArrecadacaoDevolucao(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException, ControladorException {
		/** Devoluções Classificadas */
		List colecaoDevolucoesClassificadas = (List) repositorioArrecadacao
				.pesquisarDevolucoesClassificadasPorLocalidade(
						anoMesReferenciaArrecadacao, idLocalidade);

		if (colecaoDevolucoesClassificadas != null
				&& !colecaoDevolucoesClassificadas.isEmpty()) {
			int limiteSuperiorDevolucao;
			int limiteInferiorDevolucao;
			int limiteMaximoDevolucao = colecaoDevolucoesClassificadas.size();
			int quantidadeMaximaPorColecaoDevolucao = 50;

			for (int i = 0; i < limiteMaximoDevolucao; i = i
					+ quantidadeMaximaPorColecaoDevolucao) {

				if (limiteMaximoDevolucao < quantidadeMaximaPorColecaoDevolucao) {
					limiteInferiorDevolucao = 0;
					limiteSuperiorDevolucao = limiteMaximoDevolucao;
				} else {
					limiteInferiorDevolucao = i;
					limiteSuperiorDevolucao = i
							+ quantidadeMaximaPorColecaoDevolucao;

					if (limiteSuperiorDevolucao > limiteMaximoDevolucao) {
						limiteSuperiorDevolucao = limiteMaximoDevolucao;
					}
				}

				List colecaoDevolucoesTemporaria = new ArrayList();
				colecaoDevolucoesTemporaria
						.addAll(colecaoDevolucoesClassificadas.subList(
								limiteInferiorDevolucao,
								limiteSuperiorDevolucao));

				if (colecaoDevolucoesTemporaria != null
						&& !colecaoDevolucoesTemporaria.isEmpty()) {
					transferirDevolucaoParaHistorico(colecaoDevolucoesTemporaria);
				}

				colecaoDevolucoesTemporaria = null;
			}

			colecaoDevolucoesClassificadas = null;
		}
		/** Fim Devoluções Classificadas */
	}

	protected void gerarHistoricoParaEncerrarArrecadacaoPagamento(Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException,
			ControladorException {
		
		boolean flagTerminou = false;
		final int quantidadeRegistros = 500;
		int numeroIndice = 0; 

		while (!flagTerminou) {
			Collection<Integer> colecaoPagamentosClassificados = repositorioArrecadacao.pesquisarPagamentosClassificadosOuValorExcedenteBaixado(
					anoMesReferenciaArrecadacao, idLocalidade, numeroIndice, quantidadeRegistros);

			if (colecaoPagamentosClassificados == null || colecaoPagamentosClassificados.size() < quantidadeRegistros) {

				flagTerminou = true;
			}

			Iterator<Integer> iteratorPagamentos = colecaoPagamentosClassificados.iterator();
			while (iteratorPagamentos.hasNext()) {

				Integer idPagamento = iteratorPagamentos.next();

				Pagamento pagamento = this.repositorioArrecadacao.pesquisarPagamentoParaEncerrarArrecadacao(idPagamento);

				if (pagamento != null) {
					transferirPagamentoParaHistorico(Collections.singletonList(pagamento));
					iteratorPagamentos.remove();
					pagamento = null;
				}

			}
		}

		/** Fim Pagamentos Classificados */
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 *
	 * <Identificador e nome do caso de uso>
	 *
	 * @author Pedro Alexandre
	 * @date 19/02/2008
	 *
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @param idSetorComercial
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void gerarHistoricoEncerrarArrecadacaoConta(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade,
			Integer idSetorComercial) throws ErroRepositorioException,
			ControladorException {
		/** Contas */
		// Variáveis para a paginação
		boolean flagTerminou = false;
		final int quantidadeRegistros = 100;
		int numeroIndice = 0; // O indice nao esta sendo incrementado por que os objetos estao
							  // sendo excluidos da colecao durante o processo.

		while (!flagTerminou) {
			Collection<Integer> colecaoContas = repositorioArrecadacao
					.pesquisarContasDePagamentosClassificadosContaEPagamentosAnterioresContaClassificadosNoMes(
							anoMesReferenciaArrecadacao, idLocalidade,
							numeroIndice, quantidadeRegistros, idSetorComercial);

			if (colecaoContas == null
					|| colecaoContas.size() < quantidadeRegistros) {
				flagTerminou = true;
			}
			
			Iterator<Integer> iteratorContas = colecaoContas.iterator();
			while (iteratorContas.hasNext()) {

				Integer idConta = iteratorContas.next();

				Conta conta = this.repositorioArrecadacao
						.pesquisarConta(idConta);

				if (conta != null) {

					getControladorFaturamento().transferirContasParaHistorico(
							Collections.singletonList(conta),
							anoMesReferenciaArrecadacao);

					getControladorFaturamento()
							.atualizarIndicadorContaNoHistorico(
									Collections.singletonList(conta));
					
					iteratorContas.remove();
					conta = null;
				}

			}
		}
	}

	/**
	 * Envia coleção de guias de pagamento para o histórico
	 *
	 * [UC0276] Encerrar Arrecadação do Mês
	 *
	 * @author Pedro Alexandre
	 * @date 12/02/2008
	 *
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void gerarHistoricoParaEncerrarArrecadacaoGuiaPagamento(Integer anoMesReferenciaArrecadacao, Integer idLocalidade) throws ErroRepositorioException, ControladorException {
		/** Guias de Pagamento */
		List colecaoGuiasPagamento = (List) repositorioArrecadacao.pesquisarGuiasPagamentoDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(anoMesReferenciaArrecadacao, idLocalidade);

		if (colecaoGuiasPagamento != null && !colecaoGuiasPagamento.isEmpty()) {
			int limiteSuperiorGuia;
			int limiteInferiorGuia;
			int limiteMaximoGuia = colecaoGuiasPagamento.size();
			int quantidadeMaximaPorColecaoGuia = 50;

			for (int i = 0; i < limiteMaximoGuia; i = i	+ quantidadeMaximaPorColecaoGuia) {

				if (limiteMaximoGuia < quantidadeMaximaPorColecaoGuia) {
					limiteInferiorGuia = 0;
					limiteSuperiorGuia = limiteMaximoGuia;
				} else {
					limiteInferiorGuia = i;
					limiteSuperiorGuia = i + quantidadeMaximaPorColecaoGuia;

					if (limiteSuperiorGuia > limiteMaximoGuia) {
						limiteSuperiorGuia = limiteMaximoGuia;
					}
				}

				List colecaoGuiasTemporaria = new ArrayList();
				colecaoGuiasTemporaria.addAll(colecaoGuiasPagamento.subList(limiteInferiorGuia, limiteSuperiorGuia));

				if (colecaoGuiasTemporaria != null && !colecaoGuiasTemporaria.isEmpty()) {
					transferirGuiaPagamentoParaHistorico(colecaoGuiasTemporaria);
					atualizarIndicadorGuiaPagamentoNoHistorico(colecaoGuiasTemporaria);
					
					//CRC2725 - alterado por Vivianne Sousa - 25/09/2009 analista:Fátima
					getControladorSpcSerasa().verificarRelacaoDaTransfereciaPHistoricoComItensNegativacao(
							colecaoGuiasTemporaria);
				}

				colecaoGuiasTemporaria = null;
			}

			colecaoGuiasPagamento = null;

		}
		/** Fim Guias de Pagamento */
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 *
	 * <Identificador e nome do caso de uso>
	 *
	 * @author Pedro Alexandre
	 * @date 20/02/2008
	 *
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void gerarHistoricoParaEncerrarArrecadacaoDebitoACobrar(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException, ControladorException {
		// criar os histórico dos débitos a cobrar cancelados
		List debitosACobrar = (List) repositorioArrecadacao
				.pesquisarDebitosACobrarDePagamentosClassificadosGuiasPagamentoEPagamentosAnterioresGuiaPagamentoClassificadosNoMes(
						anoMesReferenciaArrecadacao, idLocalidade);

		if (debitosACobrar != null && !debitosACobrar.isEmpty()) {
			int limiteSuperiorDebito;
			int limiteInferiorDebito;
			int limiteMaximoDebito = debitosACobrar.size();
			int quantidadeMaximaPorColecaoDebito = 50;

			for (int i = 0; i < limiteMaximoDebito; i = i
					+ quantidadeMaximaPorColecaoDebito) {

				if (limiteMaximoDebito < quantidadeMaximaPorColecaoDebito) {
					limiteInferiorDebito = 0;
					limiteSuperiorDebito = limiteMaximoDebito;
				} else {
					limiteInferiorDebito = i;
					limiteSuperiorDebito = i + quantidadeMaximaPorColecaoDebito;

					if (limiteSuperiorDebito > limiteMaximoDebito) {
						limiteSuperiorDebito = limiteMaximoDebito;
					}
				}

				List colecaoDebitosTemporaria = new ArrayList();
				colecaoDebitosTemporaria.addAll(debitosACobrar.subList(
						limiteInferiorDebito, limiteSuperiorDebito));

				if (colecaoDebitosTemporaria != null
						&& !colecaoDebitosTemporaria.isEmpty()) {
					getControladorFaturamento()
							.transferirDebitosACobrarParaHistorico(
									colecaoDebitosTemporaria);
					getControladorFaturamento()
							.atualizarIndicadorDebitoACobrarNoHistorico(
									colecaoDebitosTemporaria);
				}

				colecaoDebitosTemporaria = null;
			}
			debitosACobrar = null;
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoClienteConta(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoClienteConta(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					Conta conta = null;

					// Id da Conta
					if (dadosPagamento[1] != null) {
						conta = new Conta();
						conta.setId((Integer) dadosPagamento[1]);
					}

					// Ano Mês Referência da Conta
					if (dadosPagamento[2] != null) {
						conta.setReferencia((Integer) dadosPagamento[2]);
					}

					// Valor da Água da Conta
					if (dadosPagamento[3] != null) {
						conta.setValorAgua((BigDecimal) dadosPagamento[3]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[4] != null) {
						conta.setValorEsgoto((BigDecimal) dadosPagamento[4]);
					}

					// Valor de Débitos
					if (dadosPagamento[5] != null) {
						conta.setDebitos((BigDecimal) dadosPagamento[5]);
					}

					// Valor dos Créditos
					if (dadosPagamento[6] != null) {
						conta.setValorCreditos((BigDecimal) dadosPagamento[6]);
					}
					
					ContaGeral contaGeral = new ContaGeral();					
					if (conta != null)
						contaGeral.setId(conta.getId());
					
					contaGeral.setConta(conta);
					pagamento.setContaGeral(contaGeral);

					// Data do Pagamento
					if (dadosPagamento[7] != null) {
						pagamento.setDataPagamento((Date) dadosPagamento[7]);
					}

					// Ano Mês do Pagamento
					if (dadosPagamento[8] != null) {
						pagamento
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[8]);
					}

					// Valor do Pagamento
					if (dadosPagamento[9] != null) {
						pagamento
								.setValorPagamento((BigDecimal) dadosPagamento[9]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[10] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[11] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[12] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[12]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[13]);
					}

					pagamento
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if (dadosPagamento[14] != null) {
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[14]);
						pagamento.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if (dadosPagamento[15] != null) {
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[15]);
						pagamento.setImovel(imovel);
					}

					retorno.add(pagamento);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoClienteGuiaPagamento(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal            )
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoClienteGuiaPagamento(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal );

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					GuiaPagamento guiaPagamento = null;

					// Id da Guia de Pagamento
					if (dadosPagamento[1] != null) {
						guiaPagamento = new GuiaPagamento();
						guiaPagamento.setId((Integer) dadosPagamento[1]);
					}

					// Id do Cliente
					if (dadosPagamento[2] != null) {
						Cliente cliente = new Cliente();
						cliente.setId((Integer) dadosPagamento[2]);
						pagamento.setCliente(cliente);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[3] != null) {
						guiaPagamento
								.setValorDebito((BigDecimal) dadosPagamento[3]);
					}

					// Data do Pagamento
					if (dadosPagamento[4] != null) {
						pagamento.setDataPagamento((Date) dadosPagamento[4]);
					}

					// Ano Mês do Pagamento
					if (dadosPagamento[5] != null) {
						pagamento
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[5]);
					}

					DebitoTipo debitoTipoGuia = null;

					// Id do Tipo de Débito da Guia de Pagamento
					if (dadosPagamento[6] != null) {
						debitoTipoGuia = new DebitoTipo();
						debitoTipoGuia.setId((Integer) dadosPagamento[6]);
					}

					// Descrição do Tipo de Débito da Guia de Pagamento
					if (dadosPagamento[7] != null) {
						debitoTipoGuia.setDescricao((String) dadosPagamento[7]);
					}

					if (guiaPagamento != null) {
						guiaPagamento.setDebitoTipo(debitoTipoGuia);
					}

					pagamento.setGuiaPagamento(guiaPagamento);

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if (dadosPagamento[8] != null) {
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[8]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if (dadosPagamento[9] != null) {
						debitoTipoPagamento
								.setDescricao((String) dadosPagamento[9]);
					}

					pagamento.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if (dadosPagamento[10] != null) {
						pagamento
								.setValorPagamento((BigDecimal) dadosPagamento[10]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[11] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[11]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[12] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[12]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[14] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[14]);
					}

					pagamento
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if (dadosPagamento[15] != null) {
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[15]);
						pagamento.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if (dadosPagamento[16] != null) {
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[16]);
						pagamento.setImovel(imovel);
					}

					retorno.add(pagamento);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoClienteDebitoACobrar(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoClienteDebitoACobrar(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					DebitoACobrar debitoACobrar = null;

					// Id do Imóvel do Pagamento
					if (dadosPagamento[1] != null) {
						Imovel imovelPagamento = new Imovel();
						imovelPagamento.setId((Integer) dadosPagamento[1]);
						pagamento.setImovel(imovelPagamento);
					}

					// Id do Débito a Cobrar
					if (dadosPagamento[2] != null) {
						debitoACobrar = new DebitoACobrar();
						debitoACobrar.setId((Integer) dadosPagamento[2]);
					}

					// Valor do Débito
					if (dadosPagamento[3] != null) {
						debitoACobrar
								.setValorDebito((BigDecimal) dadosPagamento[3]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[4] != null) {
						debitoACobrar
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[4]);
					}

					// Número de Prestações Débito
					if (dadosPagamento[5] != null) {
						debitoACobrar
								.setNumeroPrestacaoDebito((Short) dadosPagamento[5]);
					}

					// Data do Pagamento
					if (dadosPagamento[6] != null) {
						pagamento.setDataPagamento((Date) dadosPagamento[6]);
					}

					// Ano Mês do Pagamento
					if (dadosPagamento[7] != null) {
						pagamento
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[7]);
					}

					DebitoTipo debitoTipoDebito = null;

					// Id do Tipo de Débito do Débito a Cobrar
					if (dadosPagamento[8] != null) {
						debitoTipoDebito = new DebitoTipo();
						debitoTipoDebito.setId((Integer) dadosPagamento[8]);
					}

					// Descrição do Tipo de Débito do Débito a Cobrar
					if (dadosPagamento[9] != null) {
						debitoTipoDebito
								.setDescricao((String) dadosPagamento[9]);
					}

					debitoACobrar.setDebitoTipo(debitoTipoDebito);

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if (dadosPagamento[10] != null) {
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[10]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if (dadosPagamento[11] != null) {
						debitoTipoPagamento
								.setDescricao((String) dadosPagamento[11]);
					}

					pagamento.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if (dadosPagamento[12] != null) {
						pagamento
								.setValorPagamento((BigDecimal) dadosPagamento[12]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[14] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[14]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[15] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[15]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[16] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[16]);
					}

					pagamento
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if (dadosPagamento[17] != null) {
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[17]);
						pagamento.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel do Débito a Cobrar
					if (dadosPagamento[18] != null) {
						Imovel imovelDebito = new Imovel();
						imovelDebito.setId((Integer) dadosPagamento[18]);
						debitoACobrar.setImovel(imovelDebito);
					}

                    //numero de parcela bonus
                    if (dadosPagamento[20] != null){
                        debitoACobrar
                        .setNumeroParcelaBonus((Short) dadosPagamento[20]);
                    }
                    
                    DebitoACobrarGeral debitoACobrarGeral = null;
                    
					if(debitoACobrar != null){
	                    
						debitoACobrarGeral = new DebitoACobrarGeral();
						debitoACobrarGeral.setId(debitoACobrar.getId());
						debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
					}

					pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
                    
					retorno.add(pagamento);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoLocalidade(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, Integer numeroPagina,
            String valorPagamentoInicial, 
            String valorPagamentoFinal)
			throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoLocalidade(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, numeroPagina,
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancario(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal)
			throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoAvisoBancario(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imóvel pesquisarPagamento
	 * 
	 * @author Roberta Costa
	 * @date 12/06/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadador(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial, 
            String valorPagamentoFinal )
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoMovimentoArrecadador(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial, 
                            valorPagamentoFinal);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * obtem colecao com dados diarios da arrecadacao
	 * 
	 * @author Fernanda Paiva
	 * @date 09/06/2006
	 * 
	 * @param anoMesReferencia,
	 *            id
	 * @return Uma Colecao
	 * @throws ControladorException
	 */
	public Collection consultarDadosDiarios(int anoMesReferencia, int id,
			String descricao, int idElo) throws ControladorException {
		try {
			Collection colecaoDadosDiarios = this.repositorioArrecadacao
					.consultarDadosDiarios(anoMesReferencia, id, descricao,
							idElo);

			Collection dadosDiarios = new ArrayList();
			Iterator iteratorColecaoArrecadacaoDadosDiarios = colecaoDadosDiarios
					.iterator();
			while (iteratorColecaoArrecadacaoDadosDiarios.hasNext()) {

				// Obtém os dados do crédito realizado
				Object[] guiaArray = (Object[]) iteratorColecaoArrecadacaoDadosDiarios
						.next();

				ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();
				if (descricao == "VALORESELO"
						|| descricao == "VALORESLOCALIDADE"
						|| descricao == "VALORESGERENCIA"
						|| descricao == "VALORES"
						|| descricao == "VALORESARRECADADOR"
						|| descricao == "VALORESPERFIL"
						|| descricao == "VALORESCATEGORIA"
						|| descricao == "VALORESDOCUMENTO") {
					if ((Date) guiaArray[0] != null) {
						// Data Pagamento
						arrecadacaoDadosDiarios
								.setDataPagamento((Date) guiaArray[0]);
					}
					if ((BigDecimal) guiaArray[1] != null) {
						// Valor Pagamento
						arrecadacaoDadosDiarios
								.setValorPagamentos((BigDecimal) guiaArray[1]);
					}

					if ((Integer) guiaArray[2] != null) {
						// Ano Mês referencia
						arrecadacaoDadosDiarios
								.setAnoMesReferenciaArrecadacao((Integer) guiaArray[2]);
					}
				} else if (descricao == "ARRECADADOR") {
					if ((String) guiaArray[0] != null) {

						// Nome do Cliente Arrecadador
						Arrecadador arrecadador = new Arrecadador();
						arrecadador.setId((Integer) guiaArray[3]);
						Cliente cliente = new Cliente();
						cliente.setNome((String) guiaArray[0]);
						arrecadador.setCliente(cliente);
						arrecadacaoDadosDiarios.setArrecadador(arrecadador);
						arrecadacaoDadosDiarios.setArrecadador(arrecadador);
					}
					if ((BigDecimal) guiaArray[1] != null) {
						// Valor Total
						arrecadacaoDadosDiarios
								.setValorPagamentos((BigDecimal) guiaArray[1]);
					}
					if ((Integer) guiaArray[2] != null) {
						// Ano Mês referencia
						arrecadacaoDadosDiarios
								.setAnoMesReferenciaArrecadacao((Integer) guiaArray[2]);
					}
				} else if (descricao == "VALORESPORDIA") {
					if ((Date) guiaArray[0] != null) {
						// Data Pagamento
						arrecadacaoDadosDiarios
								.setDataPagamento((Date) guiaArray[0]);
					}
					if ((BigDecimal) guiaArray[1] != null) {
						// Valor Pagamento
						arrecadacaoDadosDiarios
								.setValorPagamentos((BigDecimal) guiaArray[1]);
					}

					if ((Integer) guiaArray[2] != null) {
						// Ano Mês referencia
						arrecadacaoDadosDiarios
								.setAnoMesReferenciaArrecadacao((Integer) guiaArray[2]);
					}

				} else {
					if ((Integer) guiaArray[0] != null) {
						// ID da localidade
						Localidade localidade = new Localidade();
						localidade.setId((Integer) guiaArray[0]);
						Localidade localidadeElo = new Localidade();
						localidadeElo.setDescricao((String) guiaArray[3]);
						localidadeElo.setId((Integer) guiaArray[4]);
						localidade.setLocalidade(localidadeElo);
						arrecadacaoDadosDiarios.setLocalidade(localidade);
					}
					if ((BigDecimal) guiaArray[1] != null) {
						// Ano Mês referencia
						arrecadacaoDadosDiarios
								.setValorPagamentos((BigDecimal) guiaArray[1]);
					}
					if ((Integer) guiaArray[2] != null) {
						// ID da localidade
						GerenciaRegional gerenciaRegional = new GerenciaRegional();
						gerenciaRegional.setId((Integer) guiaArray[2]);
						arrecadacaoDadosDiarios
								.setGerenciaRegional(gerenciaRegional);
					}
					if ((Integer) guiaArray[5] != null) {
						// Ano Mês referencia
						arrecadacaoDadosDiarios
								.setAnoMesReferenciaArrecadacao((Integer) guiaArray[5]);
					}
				}
				dadosDiarios.add(arrecadacaoDadosDiarios);
			}
			return dadosDiarios;

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @param avisoBancarioHelper
	 * @return Coleção de DebitoAutomaticoMovimento
	 * @throws ErroRepositorioException
	 */

	public Integer filtrarAvisoBancarioAbertoFechadoCount(
			AvisoBancarioHelper avisoBancarioHelper,
			AvisoBancarioHelper avisoBancarioHelperNovo)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.filtrarAvisoBancarioAbertoFechadoCount(
							avisoBancarioHelper, avisoBancarioHelperNovo);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0319] Filtrar Aviso Bancario
	 * 
	 * @param avisoBancarioHelper
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarAvisoBancarioAbertoFechadoParaPaginacao(
			AvisoBancarioHelper avisoBancarioHelper, Integer numeroPagina)
			throws ControladorException {
		try {
			Collection colecaoAvisosBancario = this.repositorioArrecadacao
					.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			AvisoBancarioHelper avisoBancarioHelperNovo = null;
			Iterator iterator = colecaoAvisosBancario.iterator();

			Collection colecaoAvisosBancarioHelperFinal = new ArrayList();

			while (iterator.hasNext()) {

				Object[] dadosAvisoBancario = (Object[]) iterator.next();
				AvisoBancario avisoBancario = new AvisoBancario();

				avisoBancarioHelperNovo = new AvisoBancarioHelper();

				avisoBancarioHelperNovo.setTipoAviso(avisoBancarioHelper
						.getTipoAviso());

				Arrecadador arrecadador = new Arrecadador();
				arrecadador.setId((Integer) dadosAvisoBancario[0]);
				avisoBancario.setArrecadador(arrecadador);

				avisoBancario.setDataLancamento((Date) dadosAvisoBancario[1]);

				avisoBancario
						.setNumeroSequencial((Short) dadosAvisoBancario[2]);

				avisoBancario
						.setIndicadorCreditoDebito((Short) dadosAvisoBancario[3]);

				avisoBancario.setDataPrevista((Date) dadosAvisoBancario[4]);

				avisoBancario.setDataRealizada((Date) dadosAvisoBancario[5]);

				avisoBancario
						.setValorRealizado((BigDecimal) dadosAvisoBancario[6]);

				avisoBancario.setId((Integer) dadosAvisoBancario[15]);

				avisoBancarioHelperNovo.setAvisoBancario(avisoBancario);

				BigDecimal vlArrecadacaoFinal = new BigDecimal("0.00");
				BigDecimal vlDevolucaoFinal = new BigDecimal("0.00");

				if (dadosAvisoBancario[7] != null) {
					// valor da Arrecadacao Calculado
					vlArrecadacaoFinal = (BigDecimal) dadosAvisoBancario[7];
				}

				if (dadosAvisoBancario[8] != null) {
					// valor da Arrecadacao Informado
					vlArrecadacaoFinal = vlArrecadacaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[8]);
				}

				if (dadosAvisoBancario[9] != null) {
					// valor dos Acertos da Arrecadacao1
					vlArrecadacaoFinal = vlArrecadacaoFinal
							.add((BigDecimal) dadosAvisoBancario[9]);
				}

				if (dadosAvisoBancario[10] != null) {
					// valor dos Acertos da Arrecadacao2
					vlArrecadacaoFinal = vlArrecadacaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[10]);
				}

				if (dadosAvisoBancario[11] != null) {
					// valor da Devolucao Calculado
					vlDevolucaoFinal = (BigDecimal) dadosAvisoBancario[11];
				}

				if (dadosAvisoBancario[12] != null) {
					// valor da Devolucao Informado
					vlDevolucaoFinal = vlDevolucaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[12]);
				}

				if (dadosAvisoBancario[13] != null) {
					// valor dos Acertos da Devolucao1
					vlDevolucaoFinal = vlDevolucaoFinal
							.add((BigDecimal) dadosAvisoBancario[13]);
				}

				if (dadosAvisoBancario[14] != null) {
					// valor dos Acertos da Devolucao2
					vlDevolucaoFinal = vlDevolucaoFinal
							.subtract((BigDecimal) dadosAvisoBancario[14]);
				}

				String situacaoAbertoFechado = ConstantesSistema.ABERTO;
				String situacaoAbertoFechadoNumero = "2";
				if (vlArrecadacaoFinal.compareTo(vlDevolucaoFinal) == 0) {
					situacaoAbertoFechado = ConstantesSistema.FECHADO;
					situacaoAbertoFechadoNumero = "3";
				}

				if (avisoBancarioHelper.getTipoAviso() == null
						|| avisoBancarioHelper.getTipoAviso().equals(
								situacaoAbertoFechadoNumero)) {
					avisoBancarioHelperNovo.setTipoAviso(situacaoAbertoFechado);
					colecaoAvisosBancarioHelperFinal
							.add(avisoBancarioHelperNovo);
				}

			}

			Collection colecao = null;
			if (numeroPagina > 0) {

				if (colecaoAvisosBancarioHelperFinal != null
						&& !colecaoAvisosBancarioHelperFinal.isEmpty()) {

					int posicao = 0;

					colecao = new ArrayList();

					Iterator iteratorColecaoAvisosBancarioHelperFinal = colecaoAvisosBancarioHelperFinal
							.iterator();
					AvisoBancarioHelper avisoBancarioHelper2 = null;
					while (iteratorColecaoAvisosBancarioHelperFinal.hasNext()) {
						avisoBancarioHelper2 = (AvisoBancarioHelper) iteratorColecaoAvisosBancarioHelperFinal
								.next();

						if (posicao >= (numeroPagina * 10)) {
							colecao.add(avisoBancarioHelper2);
						}
						posicao++;
					}
				}
			} else {
				colecao = colecaoAvisosBancarioHelperFinal;
			}

			return colecao;

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoCliente(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, Integer numeroPagina,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoCliente(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					Pagamento pagamento = new Pagamento();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamento.setId((Integer) dadosPagamento[0]);
					}

					// Id do Imóvel
					if (dadosPagamento[1] != null) {
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[1]);
						pagamento.setImovel(imovel);
					}

					// Id do Cliente
					if (dadosPagamento[2] != null) {
						Cliente cliente = new Cliente();
						cliente.setId((Integer) dadosPagamento[2]);
						pagamento.setCliente(cliente);
					}

					Arrecadador arrecadador = null;

					// Código Agente do Arrecadador
					if (dadosPagamento[3] != null) {
						arrecadador = new Arrecadador();
						arrecadador.setCodigoAgente((Short) dadosPagamento[3]);
					}

					AvisoBancario avisoBancario = new AvisoBancario();

					// Data do Lançamento do Aviso Bancário
					if (dadosPagamento[4] != null) {
						avisoBancario
								.setDataLancamento((Date) dadosPagamento[4]);
					}

					// Número Sequencial do Aviso Bancário
					if (dadosPagamento[5] != null) {
						avisoBancario
								.setNumeroSequencial((Short) dadosPagamento[5]);
					}

					avisoBancario.setArrecadador(arrecadador);
					pagamento.setAvisoBancario(avisoBancario);

					DocumentoTipo documentoTipo = null;

					// Id do Tipo de Documento
					if (dadosPagamento[6] != null) {
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[6]);
					}

					// Descrição do Tipo de Documento
					if (dadosPagamento[7] != null) {
						documentoTipo
								.setDescricaoDocumentoTipo((String) dadosPagamento[7]);
					}

					pagamento.setDocumentoTipo(documentoTipo);

					// Valor do Pagamento
					if (dadosPagamento[8] != null) {
						pagamento
								.setValorPagamento((BigDecimal) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) {
						pagamento.setDataPagamento((Date) dadosPagamento[9]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[10] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[11] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[12] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[12]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[13]);
					}

					pagamento
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					retorno.add(pagamento);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoClienteCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection qtdes = null;
		int retorno = 0;

		try {
			qtdes = repositorioArrecadacao.pesquisarPagamentoClienteCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			if (qtdes != null && !qtdes.isEmpty()) {

				Iterator qtdesIterator = qtdes.iterator();

				while (qtdesIterator.hasNext()) {
					Integer qtde = (Integer) qtdesIterator.next();
					retorno = retorno + qtde;
				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoAvisoBancarioParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina,
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarPagamentoAvisoBancarioParaPaginacao(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina,
                            valorPagamentoInicial, 
                            valorPagamentoFinal );

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Vivianne Sousa
	 * @date 21/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoAvisoBancarioCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoAvisoBancarioCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoImovelCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial, 
            String valorPagamentoFinal ) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoImovelCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial, 
                    valorPagamentoFinal );
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Vivianne Sousa
	 * @date 22/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<Pagamento> pesquisarPagamentoImovelParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina, String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoImovelParaPaginacao(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina, 
                            valorPagamentoInicial, 
                            valorPagamentoFinal);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * 
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoImovelRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoImovelRelatorio(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos, 
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * 
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarPagamentoImovelAmbosRelatorio(String idImovel)
			throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoImovelAmbosRelatorio(idImovel);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					// Descrição do Tipo de Documento
					if (dadosPagamento[24] != null) { // 24
						pagamentoRelatorioHelper
								.setDescricaoDocumentoTipo((String) dadosPagamento[24]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[25] != null) { // 25
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAnterior((String) dadosPagamento[25]);
					}
					
					//Valor dos Impostos da Conta
					if (dadosPagamento[26] != null) { // 26
						pagamentoRelatorioHelper
								.setValorImpostos((BigDecimal) dadosPagamento[26]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);
				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * 
	 * Este caso de uso cria um sql que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoClienteRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoClienteRelatorio(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor do Documento
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[12]);
					}

					// Valor do Pagamento
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[14]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[15]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[16]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * 
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoAvisoBancarioRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoAvisoBancarioRelatorio(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * 
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */

	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoMovimentoArrecadadorRelatorio(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * 
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/2006
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoLocalidadeRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoLocalidadeRelatorio(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					// Valor dos Impostos da Conta
					if (dadosPagamento[24] != null) { // 24
						pagamentoRelatorioHelper
								.setValorImpostos((BigDecimal) dadosPagamento[24]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoMovimentoArrecadadorCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoMovimentoArrecadadorCount(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial, 
                            valorPagamentoFinal);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Corrêa
	 * @date 29/08/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoLocalidadeCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoLocalidadeCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	public Integer verificarExistenciaGuiaDevolucao(Integer idGuiaDevolucao)
			throws ControladorException {

		// Retorna o cliente encontrado ou vazio se não existir
		try {
			return repositorioArrecadacao
					.verificarExistenciaGuiaDevolucao(idGuiaDevolucao);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Pesquisa os avisos bancários para o relatório através das opções
	 * selecionadas no Filtrar Aviso Bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 04/09/06
	 * 
	 * @return Collection<AvisoBancarioRelatorioHelper>
	 * @throws ControladorException
	 */
	public Collection pesquisarAvisoBancarioRelatorio(
			AvisoBancarioHelper avisoBancarioHelper)
			throws ControladorException {

		try {
			// Collection colecaoAvisosBancario =
			// this.repositorioArrecadacao.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			Collection colecaoAvisosBancario = this
					.filtrarAvisoBancarioAbertoFechado(avisoBancarioHelper);

			AvisoBancario objetoAvisoBancario = null;
			AvisoBancarioHelper avisoBancarioHelperNovo = null;
			Iterator iterator = colecaoAvisosBancario.iterator();

			Collection colecaoAvisosBancarioFinal = new ArrayList();
			colecaoAvisosBancarioFinal.removeAll(colecaoAvisosBancarioFinal);

			Collection colecaoAvisoBancarioRelatorioHelper = new ArrayList();

			while (iterator.hasNext()) {
				objetoAvisoBancario = ((AvisoBancarioHelper) iterator.next())
						.getAvisoBancario();
				avisoBancarioHelperNovo = new AvisoBancarioHelper();

				avisoBancarioHelperNovo.setIdAvisoBancario(avisoBancarioHelper
						.getIdAvisoBancario());
				avisoBancarioHelperNovo.setAvisoBancario(objetoAvisoBancario);
				avisoBancarioHelperNovo.setTipoAviso(avisoBancarioHelper
						.getTipoAviso());

				avisoBancarioHelperNovo
						.setCodigoAgenteArrecadador(avisoBancarioHelper
								.getCodigoAgenteArrecadador());
				avisoBancarioHelperNovo
						.setDataLancamentoInicial(avisoBancarioHelper
								.getDataLancamentoInicial());
				avisoBancarioHelperNovo
						.setDataLancamentoFinal(avisoBancarioHelper
								.getDataLancamentoFinal());
				avisoBancarioHelperNovo
						.setIndicadorCreditoDebito(avisoBancarioHelper
								.getIndicadorCreditoDebito());
				avisoBancarioHelperNovo.setIdContaBancaria(avisoBancarioHelper
						.getIdContaBancaria());
				avisoBancarioHelperNovo
						.setDataPrevistaInicial(avisoBancarioHelper
								.getDataPrevistaInicial());
				avisoBancarioHelperNovo
						.setDataPrevistaFinal(avisoBancarioHelper
								.getDataPrevistaFinal());
				avisoBancarioHelperNovo
						.setAnoMesReferenciaArrecadacaoInicial(avisoBancarioHelper
								.getAnoMesReferenciaArrecadacaoInicial());
				avisoBancarioHelperNovo
						.setAnoMesReferenciaArrecadacaoFinal(avisoBancarioHelper
								.getAnoMesReferenciaArrecadacaoFinal());
				avisoBancarioHelperNovo
						.setDataRealizadaInicial(avisoBancarioHelper
								.getDataRealizadaInicial());
				avisoBancarioHelperNovo
						.setDataRealizadaFinal(avisoBancarioHelper
								.getDataRealizadaFinal());
				avisoBancarioHelperNovo
						.setValorRealizadoInicial(avisoBancarioHelper
								.getValorRealizadoInicial());
				avisoBancarioHelperNovo
						.setValorRealizadoFinal(avisoBancarioHelper
								.getValorRealizadoFinal());
				avisoBancarioHelperNovo
						.setValorPrevistoInicial(avisoBancarioHelper
								.getValorPrevistoInicial());
				avisoBancarioHelperNovo
						.setValorPrevistoFinal(avisoBancarioHelper
								.getValorPrevistoFinal());
				avisoBancarioHelperNovo
						.setIdMovimentoArrecadador(avisoBancarioHelper
								.getIdMovimentoArrecadador());
				if (avisoBancarioHelperNovo != null
						&& !avisoBancarioHelperNovo.equals("")) {
					Collection colecaoDadosAvisosBancarios = this.repositorioArrecadacao
							.pesquisarAvisoBancarioRelatorio(avisoBancarioHelperNovo);

					Iterator colecaoDadosAvisosBancariosIterator = colecaoDadosAvisosBancarios
							.iterator();
					while (colecaoDadosAvisosBancariosIterator.hasNext()) {

						AvisoBancarioRelatorioHelper avisoBancarioRelatorioHelper = new AvisoBancarioRelatorioHelper();

						// Obtém os dados do crédito realizado
						Object[] dadosArray = (Object[]) colecaoDadosAvisosBancariosIterator
								.next();

						// Id do Aviso Bancário
						if (dadosArray[0] != null) {
							avisoBancarioRelatorioHelper
									.setIdAvisoBancario((Integer) dadosArray[0]);
						}

						// Nome Arrecadador
						if (dadosArray[1] != null) {
							avisoBancarioRelatorioHelper
									.setNomeArrecadador((String) dadosArray[1]);
						}

						// Data Lançamento
						if (dadosArray[2] != null) {
							avisoBancarioRelatorioHelper
									.setDataLancamento((Date) dadosArray[2]);
						}

						// Sequencial
						if (dadosArray[3] != null) {
							avisoBancarioRelatorioHelper
									.setSequencial((Short) dadosArray[3]);
						}

						// Indicador Crédito/Débito
						if (dadosArray[4] != null) {
							avisoBancarioRelatorioHelper
									.setTipo((Short) dadosArray[4]);
						}

						// Número Documento
						if (dadosArray[5] != null) {
							avisoBancarioRelatorioHelper
									.setNumeroDocumento((Integer) dadosArray[5]);
						}

						// Banco
						if (dadosArray[6] != null) {
							avisoBancarioRelatorioHelper
									.setBanco((String) dadosArray[6]);
						}

						// Agência
						if (dadosArray[7] != null) {
							avisoBancarioRelatorioHelper
									.setAgencia((String) dadosArray[7]);
						}

						// Número Conta
						if (dadosArray[8] != null) {
							avisoBancarioRelatorioHelper
									.setNumeroConta((String) dadosArray[8]);
						}

						// Data Realização
						if (dadosArray[9] != null) {
							avisoBancarioRelatorioHelper
									.setDataRealizacao((Date) dadosArray[9]);
						}

						// Total Arrecadação
						if (dadosArray[10] != null) {
							avisoBancarioRelatorioHelper
									.setTotalArrecadacao((BigDecimal) dadosArray[10]);
						}

						// Total Devolução
						if (dadosArray[11] != null) {
							avisoBancarioRelatorioHelper
									.setTotalDevolucao((BigDecimal) dadosArray[11]);
						}

						// Valor Aviso
						if (dadosArray[12] != null) {
							avisoBancarioRelatorioHelper
									.setValorAviso((BigDecimal) dadosArray[12]);
						}

						colecaoAvisoBancarioRelatorioHelper
								.add(avisoBancarioRelatorioHelper);
					}
				}
			}
			return colecaoAvisoBancarioRelatorioHelper;
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os avisos deduções de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * 
	 * @return Collection<DeducoesRelatorioHelper>
	 * @throws ControladorException
	 */

	public Collection pesquisarAvisoDeducoesAvisoBancarioRelatorio(
			Integer idAvisoBancario) throws ControladorException {

		try {
			Collection colecaoDadosDeducoes = this.repositorioArrecadacao
					.pesquisarAvisoDeducoesAvisoBancarioRelatorio(idAvisoBancario);

			Collection colecaoDeducoesRelatorioHelper = new ArrayList();
			Iterator colecaoDadosDeducoesIterator = colecaoDadosDeducoes
					.iterator();
			while (colecaoDadosDeducoesIterator.hasNext()) {

				DeducoesRelatorioHelper deducoesRelatorioHelper = new DeducoesRelatorioHelper();

				// Obtém os dados do crédito realizado
				Object[] dadosArray = (Object[]) colecaoDadosDeducoesIterator
						.next();

				// Tipo
				if (dadosArray[0] != null) {
					deducoesRelatorioHelper.setTipo((String) dadosArray[0]);
				}

				// Valor Dedução
				if (dadosArray[1] != null) {
					deducoesRelatorioHelper
							.setValorDeducao((BigDecimal) dadosArray[1]);
				}

				colecaoDeducoesRelatorioHelper.add(deducoesRelatorioHelper);
			}

			return colecaoDeducoesRelatorioHelper;

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os avisos acertos de um aviso bancário para o relatório através
	 * do id do aviso bancário
	 * 
	 * @author Rafael Corrêa
	 * @date 05/09/06
	 * 
	 * @return Collection<AcertosRelatorioHelper>
	 * @throws ControladorException
	 */

	public Collection pesquisarAvisoAcertosAvisoBancarioRelatorio(
			Integer idAvisoBancario) throws ControladorException {

		try {
			Collection colecaoDadosAcertos = this.repositorioArrecadacao
					.pesquisarAvisoAcertosAvisoBancarioRelatorio(idAvisoBancario);

			Collection colecaoAcertosRelatorioHelper = new ArrayList();
			Iterator colecaoDadosAcertosIterator = colecaoDadosAcertos
					.iterator();
			while (colecaoDadosAcertosIterator.hasNext()) {

				AcertosRelatorioHelper acertosRelatorioHelper = new AcertosRelatorioHelper();

				// Obtém os dados do crédito realizado
				Object[] dadosArray = (Object[]) colecaoDadosAcertosIterator
						.next();

				// Banco
				if (dadosArray[0] != null) {
					acertosRelatorioHelper.setBanco((String) dadosArray[0]);
				}

				// Agência
				if (dadosArray[1] != null) {
					acertosRelatorioHelper.setAgencia((Integer) dadosArray[1]);
				}

				// Número Conta
				if (dadosArray[2] != null) {
					acertosRelatorioHelper
							.setNumeroConta((String) dadosArray[2]);
				}

				// Indicador Crédito/Débito
				if (dadosArray[3] != null) {
					acertosRelatorioHelper.setTipo(((Integer) dadosArray[3])
							.shortValue());
				}

				// Data Acerto
				if (dadosArray[4] != null) {
					acertosRelatorioHelper.setDataAcerto((Date) dadosArray[4]);
				}

				// Valor Acerto
				if (dadosArray[5] != null) {
					acertosRelatorioHelper
							.setValorAcerto((BigDecimal) dadosArray[5]);
				}

				colecaoAcertosRelatorioHelper.add(acertosRelatorioHelper);
			}

			return colecaoAcertosRelatorioHelper;

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * Pesquisa dos dados diários da arrecadação
	 * 
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * 
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacao(
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String idLocalidade, String idGerenciaRegional,
			String idArrecadador, String idElo, String[] idsImovelPerfil,
			String[] idsLigacaoAgua, String[] idsLigacaoEsgoto,
			String[] idsDocumentosTipos, String[] idsCategoria,
			String[] idsEsferaPoder) throws ControladorException {

		Collection colecaoDadosDiarios = new ArrayList();
		Collection colecaoDadosDiariosArrecadacao = null;
		Collection colecaoDadosDiariosDevolucao   = null;

		try {
			colecaoDadosDiariosArrecadacao = repositorioArrecadacao
					.filtrarDadosDiariosArrecadacao(periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, idLocalidade,
							idGerenciaRegional, idArrecadador, idElo,
							idsImovelPerfil, idsLigacaoAgua, idsLigacaoEsgoto,
							idsDocumentosTipos, idsCategoria, idsEsferaPoder);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		if (colecaoDadosDiariosArrecadacao != null && !colecaoDadosDiariosArrecadacao.isEmpty()) {

			Iterator colecaoDadosDiariosIterator = colecaoDadosDiariosArrecadacao
					.iterator();

			ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;

			while (colecaoDadosDiariosIterator.hasNext()) {

				arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();

				// Obtém os dados
				Object[] dadosArray = (Object[]) colecaoDadosDiariosIterator
						.next();

				// Ano Mês
				if (dadosArray[0] != null) {
					arrecadacaoDadosDiarios
							.setAnoMesReferenciaArrecadacao((Integer) dadosArray[0]);
				}

				// Data Pagamento
				if (dadosArray[1] != null) {
					arrecadacaoDadosDiarios
							.setDataPagamento((java.util.Date) dadosArray[1]);
				}

				// Quantidade Pagmento
				if (dadosArray[2] != null) {
					arrecadacaoDadosDiarios
							.setQuantidadePagamentos((Integer) dadosArray[2]);
				}

				// Valor Pagamento
				if (dadosArray[3] != null) {
					arrecadacaoDadosDiarios
							.setValorPagamentos((BigDecimal) dadosArray[3]);
				}
				//Quantidade documentos
				if (dadosArray[4] != null) {
					arrecadacaoDadosDiarios
							.setQuantidadeDocumentos((Integer) dadosArray[4]);
				}
				// Arrecadador
				if (dadosArray[5] != null) {
					Arrecadador arrecadador = new Arrecadador();
					arrecadador.setId((Integer) dadosArray[5]);

					// if(dadosArray[15] != null){
					// Cliente cliente = new Cliente();
					// cliente.setNome((String)dadosArray[15]);
					// arrecadador.setCliente(cliente);
					// }

					arrecadacaoDadosDiarios.setArrecadador(arrecadador);
				}

				// Documento Tipo
				if (dadosArray[6] != null) {
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId((Integer) dadosArray[6]);

					// / if(dadosArray[13] != null){
					// documentoTipo.setDescricaoDocumentoTipo((String)dadosArray[13]);
					// }

					arrecadacaoDadosDiarios.setDocumentoTipo(documentoTipo);
				}

				// ImovelPerfil
				if (dadosArray[7] != null) {
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					imovelPerfil.setId((Integer) dadosArray[7]);

					// if (dadosArray[16] != null) {
					// imovelPerfil.setDescricao((String)dadosArray[16]);
					// }

					arrecadacaoDadosDiarios.setImovelPerfil(imovelPerfil);
				}

				// Gerencia Regional
				if (dadosArray[8] != null) {
					GerenciaRegional gerenciaRegional = new GerenciaRegional();
					gerenciaRegional.setId((Integer) dadosArray[8]);
					// if (dadosArray[11] != null) {
					// / gerenciaRegional.setNome((String) dadosArray[11]);
					// }
					// if (dadosArray[12] != null) {
					// gerenciaRegional.setNomeAbreviado((String)
					// dadosArray[12]);
					// }

					arrecadacaoDadosDiarios
							.setGerenciaRegional(gerenciaRegional);
				}

				// Localidade
				if (dadosArray[9] != null) {
					Localidade localidade = new Localidade();
					localidade.setId((Integer) dadosArray[9]);

					// if (dadosArray[10] != null) {
					// localidade.setDescricao((String)dadosArray[10]);
					// }

					Localidade elo = null;
					// if (dadosArray[11] != null) {
					// elo = new Localidade();
					// elo.setDescricao((String)dadosArray[11]);
					// }
					if (dadosArray[11] != null) {
						if (elo == null) {
							elo = new Localidade();
						}
						elo.setId((Integer) dadosArray[11]);
					}

					localidade.setLocalidade(elo);

					arrecadacaoDadosDiarios.setLocalidade(localidade);
				}

				// Categoria
				if (dadosArray[10] != null) {
					Categoria categoria = new Categoria();
					categoria.setId((Integer) dadosArray[10]);

					// if (dadosArray[14] != null) {
					// categoria.setDescricao((String)dadosArray[14]);
					// }

					arrecadacaoDadosDiarios.setCategoria(categoria);
				}

				// Unidade Negocio
				if (dadosArray[12] != null) {
					UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId((Integer) dadosArray[12]);

					// if (dadosArray[14] != null) {
					// categoria.setDescricao((String)dadosArray[14]);
					// }

					arrecadacaoDadosDiarios.setUnidadeNegocio(unidadeNegocio);
				}

				// Arrecadador Forma
				
				if (dadosArray[13] != null) { 
					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				 	arrecadacaoForma.setId((Integer)dadosArray[13]);
				  
				 	arrecadacaoDadosDiarios.setArrecadacaoForma(arrecadacaoForma); 
				}

				// Documento Tipo Agregador
				DocumentoTipo documentoTipoAgregador = new DocumentoTipo();
				if (dadosArray[14] != null) { 					
				 	documentoTipoAgregador.setId((Integer)dadosArray[14]);
				} else {
					documentoTipoAgregador.setId(0);				  
				}
				arrecadacaoDadosDiarios.setDocumentoTipoAgregador(documentoTipoAgregador);
				
				ArrecadacaoDadosDiariosValoresDiariosHelper helper =
					new ArrecadacaoDadosDiariosValoresDiariosHelper();
				helper.setArrecadacaoDadosDiarios(arrecadacaoDadosDiarios);
				colecaoDadosDiarios.add(helper);
			}
		}
		
		try {
			colecaoDadosDiariosDevolucao = repositorioArrecadacao
					.filtrarDevolucaoDadosDiarios(periodoArrecadacaoInicial,
							periodoArrecadacaoFinal, idLocalidade,
							idGerenciaRegional, idArrecadador, idElo,
							idsImovelPerfil, idsLigacaoAgua, idsLigacaoEsgoto,
							idsDocumentosTipos, idsCategoria, idsEsferaPoder);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		
		if (colecaoDadosDiariosDevolucao != null && !colecaoDadosDiariosDevolucao.isEmpty()) {

			Iterator colecaoDadosDiariosIterator = colecaoDadosDiariosDevolucao
					.iterator();

			DevolucaoDadosDiarios devolucaoDadosDiarios = null;

			while (colecaoDadosDiariosIterator.hasNext()) {

				devolucaoDadosDiarios = new DevolucaoDadosDiarios();

				// Obtém os dados
				Object[] dadosArray = (Object[]) colecaoDadosDiariosIterator
						.next();

				// Ano Mês
				if (dadosArray[0] != null) {
					devolucaoDadosDiarios
							.setAnoMesReferencia((Integer) dadosArray[0]);
				}

				// Data devolucao
				if (dadosArray[1] != null) {
					devolucaoDadosDiarios
							.setDataDevolucao((java.util.Date) dadosArray[1]);
				}

				// Quantidade devolucoes
				if (dadosArray[2] != null) {
					devolucaoDadosDiarios
							.setQuantidadeDevolucoes((Integer) dadosArray[2]);
				}

				// Valor devolucoes
				if (dadosArray[3] != null) {
					devolucaoDadosDiarios
							.setValorDevolucoes((BigDecimal) dadosArray[3]);
				}
				// Quantidade Documentos
				if (dadosArray[4] != null) {
					devolucaoDadosDiarios
							.setQuantidadeDocumentos((Integer) dadosArray[4]);
				}
				// Arrecadador
				if (dadosArray[5] != null) {
					Arrecadador arrecadador = new Arrecadador();
					arrecadador.setId((Integer) dadosArray[5]);
					devolucaoDadosDiarios.setArrecadador(arrecadador);
				}

				// Documento Tipo
				if (dadosArray[6] != null) {
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setId((Integer) dadosArray[6]);
					devolucaoDadosDiarios.setDocumentoTipo(documentoTipo);
				}

				// ImovelPerfil
				if (dadosArray[7] != null) {
					ImovelPerfil imovelPerfil = new ImovelPerfil();
					imovelPerfil.setId((Integer) dadosArray[7]);
					devolucaoDadosDiarios.setImovelPerfil(imovelPerfil);
				}

				// Gerencia Regional
				if (dadosArray[8] != null) {
					GerenciaRegional gerenciaRegional = new GerenciaRegional();
					gerenciaRegional.setId((Integer) dadosArray[8]);
					devolucaoDadosDiarios
							.setGerenciaRegional(gerenciaRegional);
				}

				// Localidade
				if (dadosArray[9] != null) {
					Localidade localidade = new Localidade();
					localidade.setId((Integer) dadosArray[9]);
					Localidade elo = null;
					if (dadosArray[11] != null) {
						if (elo == null) {
							elo = new Localidade();
						}
						elo.setId((Integer) dadosArray[11]);
					}

					localidade.setLocalidade(elo);

					devolucaoDadosDiarios.setLocalidade(localidade);
				}

				// Categoria
				if (dadosArray[10] != null) {
					Categoria categoria = new Categoria();
					categoria.setId((Integer) dadosArray[10]);

					devolucaoDadosDiarios.setCategoria(categoria);
				}

				// Unidade Negocio
				if (dadosArray[12] != null) {
					UnidadeNegocio unidadeNegocio = new UnidadeNegocio();
					unidadeNegocio.setId((Integer) dadosArray[12]);

					devolucaoDadosDiarios.setUnidadeNegocio(unidadeNegocio);
				}

				// Arrecadador Forma				
				if (dadosArray[13] != null) { 
					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				 	arrecadacaoForma.setId((Integer)dadosArray[13]);				  
				 	devolucaoDadosDiarios.setArrecadacaoForma(arrecadacaoForma); 
				}

				// Tipo de devolucao
				if (dadosArray[14] != null) {
					devolucaoDadosDiarios.setDevolucaoTipo((String) dadosArray[14]);
				}				

				// Documento Tipo Agregador				
				if (dadosArray[15] != null) { 
					DocumentoTipo documentoTipoAgregador = new DocumentoTipo();
				 	documentoTipoAgregador.setId((Integer)dadosArray[15]);
				  
				 	devolucaoDadosDiarios.setDocumentoTipoAgregador(documentoTipoAgregador); 
				}
				
				// Percorrer a colecao de arrecadacoes para acrescentar a devolucao correspondente 
				if (colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()){
					Iterator iterDados = colecaoDadosDiarios.iterator();
					boolean achouGrupo = false;
					while (iterDados.hasNext()) {
						ArrecadacaoDadosDiariosValoresDiariosHelper helper = 
								(ArrecadacaoDadosDiariosValoresDiariosHelper) iterDados.next();
						/*
						@TODO este agrupamento está errado, uma devolucao tá cobrindo a outra
						*/
						if (helper.equalsAgrupamento(devolucaoDadosDiarios)){
							helper.setDevolucaoDadosDiarios(devolucaoDadosDiarios);
							achouGrupo = true;
							break;
						}
					}
					if (!achouGrupo){
						ArrecadacaoDadosDiariosValoresDiariosHelper helper =
							new ArrecadacaoDadosDiariosValoresDiariosHelper();
						helper.setDevolucaoDadosDiarios(devolucaoDadosDiarios);
						colecaoDadosDiarios.add(helper);				
					}					
				}
			}
		}
		
		return colecaoDadosDiarios;

	}

	/**
	 * Pesquisa dos dados diários da arrecadação pela Gerencia
	 * 
	 * [UC0333] Filtrar Dados Diários da Arrecadação
	 * 
	 * @author Rafael Santos
	 * @date 05/09/2006
	 * 
	 * @return
	 */
	public Collection filtrarDadosDiariosArrecadacaoValoresDiarios(
			String idGerenciaRegional) throws ControladorException {

		Collection colecaoValoresDiarios = null;
		try {

			Collection colecaoArrecadacao = repositorioArrecadacao
					.filtrarDadosDiariosArrecadacaoValoresDiarios(idGerenciaRegional);

			ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;
			if (colecaoArrecadacao != null && !colecaoArrecadacao.isEmpty()) {

				Iterator icolecaoColecaoArrecadacao = colecaoArrecadacao
						.iterator();
				colecaoValoresDiarios = new ArrayList();

				// dados diarios
				while (icolecaoColecaoArrecadacao.hasNext()) {

					arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();
					Object[] arrecadacaoArray = (Object[]) icolecaoColecaoArrecadacao
							.next();

					if (arrecadacaoArray[0] != null) {// 0
						// nome gerencia regional
						GerenciaRegional gerenciaRegional = new GerenciaRegional();
						gerenciaRegional
								.setNome(arrecadacaoArray[0].toString());

						arrecadacaoDadosDiarios
								.setGerenciaRegional(gerenciaRegional);
					}
					if (arrecadacaoArray[1] != null) {// 1
						// descricao localidade
						Localidade localidade = new Localidade();

						localidade.setDescricao(arrecadacaoArray[1].toString());
						arrecadacaoDadosDiarios.setLocalidade(localidade);
					}
					// descricao elo
					if (arrecadacaoArray[2] != null) {// 2
						// descricao localidade
						Localidade localidade = new Localidade();
						if (arrecadacaoArray[1] != null) {// 1
							localidade.setDescricao(arrecadacaoArray[1]
									.toString());
						}

						Localidade localidadeElo = new Localidade();
						localidadeElo.setDescricao(arrecadacaoArray[2]
								.toString());

						localidade.setLocalidade(localidadeElo);

						arrecadacaoDadosDiarios.setLocalidade(localidade);
					}
					colecaoValoresDiarios.add(arrecadacaoDadosDiarios);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return colecaoValoresDiarios;
	}

	
	/**
	 * [UC0333] Consultar Dados Diários da Arrecadação
	 * 
	 * Método para filtrar os dados diários para qualquer aba da funcionalidade
	 * 
	 * @author Francisco do Nascimento
	 * @date 12/11/2008
	 *
	 * @param filtro
	 * @return Um TreeMap contendo colecoes de dados diarios por ano mes 
	 * @throws ControladorException 
	 */
	public Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> 
		filtrarDadosDiariosArrecadacao(int anoMesInicial, int anoMesFinal, 
		FiltroConsultarDadosDiariosArrecadacao filtro) throws ControladorException{
		
		Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> mapAnoMes = new TreeMap();
		try {
			
			if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")){
				anoMesInicial = Integer.parseInt(filtro.getAnoMesArrecadacao());
				anoMesFinal = anoMesInicial;
			}
			
			filtro = filtro.clone();

			for (int anoMes = anoMesInicial; anoMes <= anoMesFinal; anoMes++){
				
				filtro.setAnoMesArrecadacao(anoMes+"");
				Collection colecaoDadosDiarios = repositorioArrecadacao
					.filtrarDadosDiariosArrecadacao(filtro);
				
				BigDecimal valorTotal = new BigDecimal(0.0);
				BigDecimal percentualTotal = new BigDecimal(0.0);
				
				Collection<FiltrarDadosDiariosArrecadacaoHelper> colecaoDadosDiariosHelpers = new ArrayList<FiltrarDadosDiariosArrecadacaoHelper>();

				if(colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()){
					for (Iterator iter = colecaoDadosDiarios.iterator(); iter
							.hasNext();) {
						Object[] dadosConsulta = (Object[]) iter.next();
						
						FiltrarDadosDiariosArrecadacaoHelper helper = new FiltrarDadosDiariosArrecadacaoHelper();
						helper.setValorAgrupado(dadosConsulta[0] + "");
						
						helper.setItemAgrupado(pesquisarItemAgrupadoFiltrarDadosDiariosArrecadacao(
								dadosConsulta[0], filtro.getAgrupamento()));
						
						helper.setQuantidadeDocumentos((Integer) dadosConsulta[1]);
						helper.setQuantidadePagamentos((Integer) dadosConsulta[2]);
						helper.setValorDebitos((BigDecimal) dadosConsulta[3]);
						helper.setValorDescontos((BigDecimal) dadosConsulta[4]);
						helper.setValorArrecadacao(helper.getValorDebitos()
							.subtract(helper.getValorDescontos()));
						helper.setValorDevolucoes((BigDecimal) dadosConsulta[5]);
						helper.setValorArrecadacaoLiquida(helper.getValorDebitos()
							.subtract(helper.getValorDescontos()).subtract(helper.getValorDevolucoes()));
						
						valorTotal = valorTotal.add(helper.getValorArrecadacaoLiquida());
						
						/**
						 * Relatório Analitico dos valores diários da arrecadação
						 * 
						 * @author Adriana Muniz
						 * data: 05/09/2012
						 * 
						 * Atende o relatório analitico da consuta de dados diarios
						 * 
						 * Verifica se o agrupamento é por data e se é relatorio analitico
						 */
						if(filtro.getAgrupamento().equals(GROUP_BY.DATA) && filtro.isRelatorioValoresDiariosAnalitico()) {
							Collection<FormasArrecadacaoDadosDiariosHelper> colecaoFormasDeArrecadacaoPorDia = 
									this.obterFormasDeArrecadacaoPorDia(helper.getItemAgrupado(), filtro);
							helper.setColecaoFormasArrecadacao(colecaoFormasDeArrecadacaoPorDia);
						}
						
												
						colecaoDadosDiariosHelpers.add(helper);
					}
					
					// Calculando os percentuais
					Iterator iter = colecaoDadosDiariosHelpers.iterator();
					while (iter.hasNext()) {
						FiltrarDadosDiariosArrecadacaoHelper helper = 
							(FiltrarDadosDiariosArrecadacaoHelper) iter.next();
						
						BigDecimal big100 = new BigDecimal("100.00");
						
						BigDecimal percentual = helper.getValorArrecadacaoLiquida()
							.multiply(big100).divide(valorTotal,2,BigDecimal.ROUND_HALF_UP);
						if (percentual.add(percentualTotal)
							.compareTo(big100) > 0){
							percentual = big100.subtract(percentualTotal);
						}
						helper.setPercentual(percentual);
						
					}
					
					mapAnoMes.put(anoMes, colecaoDadosDiariosHelpers);
				}
				
			}
			

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return mapAnoMes;
		
	}
	
	private Object pesquisarItemAgrupadoFiltrarDadosDiariosArrecadacao(Object idObjeto, 
		GROUP_BY agrupamento) throws ControladorException{
		
		Object itemAgrupado = null;
		
		try {
			switch (agrupamento) {
			case GERENCIA_REGIONAL:
				//pesquisar na base a gerencia Regional
				FiltroGerenciaRegional filtroGerenciaRegional = new FiltroGerenciaRegional ();
				filtroGerenciaRegional.adicionarParametro(new ParametroSimples(FiltroGerenciaRegional.ID,
						idObjeto));
				
				Collection colecaoGerenciaRegional = repositorioUtil.pesquisar(
						filtroGerenciaRegional,
						GerenciaRegional.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoGerenciaRegional);
				break;

			case UNIDADE_NEGOCIO:
				//pesquisar na base a unidade negocio
				FiltroUnidadeNegocio filtroUnidadeNegocio = new FiltroUnidadeNegocio();
				
				filtroUnidadeNegocio.adicionarParametro(new ParametroSimples(FiltroUnidadeNegocio.ID,
						idObjeto));
				
				Collection colecaoUnidadeNegocio = repositorioUtil.pesquisar(filtroUnidadeNegocio,
						UnidadeNegocio.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoUnidadeNegocio);				
				break;
				
			case ELO:
				// pesquisar na base a localidade
				FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples("localidade.id",
					idObjeto));
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				
				Collection colecaoLocalidade = repositorioUtil.pesquisar(filtroLocalidade,
						Localidade.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoLocalidade);				
				break;
			case LOCALIDADE:
				// pesquisar na base a localidade
				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples("id",
					idObjeto));
				
				colecaoLocalidade = repositorioUtil.pesquisar(filtroLocalidade,
						Localidade.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoLocalidade);				
				break;
				
			case DATA:
			case ANO_MES:				
				itemAgrupado = idObjeto;
				break;
			case ARRECADADOR:
				//pesquisar na base o arrecadador
				FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
				filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.ID,
						idObjeto));
				filtroArrecadador.adicionarCaminhoParaCarregamentoEntidade("cliente");
				
				Collection colecaoArrecadador = repositorioUtil.pesquisar(filtroArrecadador,
						Arrecadador.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoArrecadador);				
				break;
			case FORMA_ARRECADACAO:
				if (idObjeto != null){
					//pesquisar na base o arrecadacao forma
					FiltroArrecadacaoForma filtroArrecadacaoForma = new FiltroArrecadacaoForma();
					filtroArrecadacaoForma.adicionarParametro(new ParametroSimples(FiltroArrecadacaoForma.CODIGO,
							idObjeto));
					
					Collection colecaoArrecadacaoForma = repositorioUtil.pesquisar(filtroArrecadacaoForma,
							ArrecadacaoForma.class.getName());
					
					itemAgrupado = Util.retonarObjetoDeColecao(colecaoArrecadacaoForma);					
				}
				
				if(itemAgrupado == null){
					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(0);
					arrecadacaoForma.setDescricao("Sem forma de arrecadação");
					itemAgrupado = arrecadacaoForma;
				}				
								
				break;
			case CATEGORIA:
				//pesquisar na base a Categoria
				FiltroCategoria filtroCategoria = new FiltroCategoria();
				filtroCategoria.adicionarParametro(new ParametroSimples(FiltroCategoria.CODIGO,
						idObjeto));
				
				Collection colecaoCategorias = repositorioUtil.pesquisar(filtroCategoria,
						Categoria.class.getName());
				
				itemAgrupado =  Util.retonarObjetoDeColecao(colecaoCategorias);				
				break;
			case PERFIL:
				//pesquisar na base o Imovel Perfil
				FiltroImovelPerfil filtroImovelPerfil = new FiltroImovelPerfil();
				filtroImovelPerfil.adicionarParametro(new ParametroSimples(FiltroImovelPerfil.ID,
						idObjeto));
				
				Collection colecaoImovelPerfil = repositorioUtil.pesquisar(filtroImovelPerfil,
						ImovelPerfil.class.getName());

				itemAgrupado = Util.retonarObjetoDeColecao(colecaoImovelPerfil);
				break;
			case TIPO_DOCUMENTO:
			case TIPO_DOCUMENTO_AGREGADOR:
				
				if (idObjeto != null) {
					//pesquisar na base o Documento Tipo
					FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
					filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID,
							idObjeto));
					
					Collection colecaoDocumentoTipo = repositorioUtil.pesquisar(filtroDocumentoTipo,
							DocumentoTipo.class.getName());
					
					itemAgrupado = Util.retonarObjetoDeColecao(colecaoDocumentoTipo);
				}
				
				if (itemAgrupado == null){
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setDescricaoDocumentoTipo("Sem tipo de documento");
					documentoTipo.setId(0);
					itemAgrupado = documentoTipo;
				}
				break;
			default:
				break;
			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return itemAgrupado;
		

	}
	
	/**
	 * 
	 * [UC0333] Consultar Dados Diários da Arrecadação
	 *
	 * Verificar se existe dados diarios da arrecadacao de acordo com o filtro 
	 * passado
	 *
	 * @author Francisco do Nascimento
	 * @date 18/11/2008
	 *
	 * @param filtro
	 * @return boolean de existencia dos dados
	 * @throws ControladorException
	 */
	public boolean verificarExistenciaDadosDiariosArrecadacao(int anoMesInicial, int anoMesFinal,
		FiltroConsultarDadosDiariosArrecadacao filtro) throws ControladorException{
		
		boolean retorno = false;
		try {
			if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")){
				anoMesInicial = Integer.parseInt(filtro.getAnoMesArrecadacao());
				anoMesFinal = anoMesInicial;
			}
			
			filtro = filtro.clone();

			for (int anoMes = anoMesInicial; anoMes <= anoMesFinal; anoMes++){
				
				filtro.setAnoMesArrecadacao(anoMes+"");

				retorno = repositorioArrecadacao
					.verificarExistenciaDadosDiariosArrecadacao(filtro);
				
				if (retorno) {
					break;
				}
			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}		
		return retorno;
	}
	
	/**
	 * Este caso de uso retorna uma colecao do movimento dos arrecadadores
	 * 
	 * [UC0263] - Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Fernanda Paiva
	 * @date 12/09/2006
	 * 
	 * @param filtroArrecadadorMovimento
	 * @param numero
	 *            de páginas para paginação
	 * @return Uma coleçao com os movimentos selecionados
	 * @throws ControladorException
	 */
	public Collection<ArrecadadorMovimento> retornarColecaoMovimentoArrecadadores(
			FiltroArrecadadorMovimento filtro, Integer numeroPagina,
			String movimentoOcorrencia, String movimentoAceito,
			String movimentoAbertoFechado) throws ControladorException {

		Collection<ArrecadadorMovimento> retorno = new ArrayList();
		Collection<ArrecadadorMovimento> colecaoMovimentoArrecadadoresTotal = null;

		/*
		 * Coleção com os movimentos abertos e fechados
		 */
		try {

			colecaoMovimentoArrecadadoresTotal = repositorioArrecadacao
					.retornarColecaoMovimentoArrecadadores(filtro, numeroPagina);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		/*
		 * Movimento aberto / fechado
		 * 
		 * Caso seja selecionado "ABERTOS", selecionar os movimentos com valor
		 * total diferente do valor da soma das arrecadações dos avisos
		 * bancários relacionados (ARMV_VLTOTALMOVIMENTO seja diferente da soma
		 * dos AVBC_VLARRECADACAO da tabela AVISO_BANCARIO com ARMV_ID = ARMV_ID
		 * da tabela ARRECADADOR_MOVIMENTO), caso seja selecionado "FECHADOS",
		 * selecionar os movimentos com valor total igual ao valor da soma das
		 * arrecadações dos avisos bancários relacionados (ARMV_VLTOTALMOVIMENTO
		 * seja igual da soma dos AVBC_VLARRECADACAO da tabela AVISO_BANCARIO
		 * com ARMV_ID = ARMV_ID da tabela ARRECADADOR_MOVIMENTO)
		 */
		if (movimentoAbertoFechado != null
				&& !movimentoAbertoFechado.equalsIgnoreCase("")
				&& !movimentoAbertoFechado.equalsIgnoreCase(""
						+ ConstantesSistema.NUMERO_NAO_INFORMADO)) {

			Iterator iteratorMovimentoArrecadadoresTotal = colecaoMovimentoArrecadadoresTotal
					.iterator();
			ArrecadadorMovimento arrecadadorMovimentoObjeto = null;
			BigDecimal valorTotalArrecadacaoAvisoBancario = null;

			while (iteratorMovimentoArrecadadoresTotal.hasNext()) {

				arrecadadorMovimentoObjeto = (ArrecadadorMovimento) iteratorMovimentoArrecadadoresTotal
						.next();
				valorTotalArrecadacaoAvisoBancario = null;

				/*
				 * Obtendo o valor total (AVBC_VLARRECADACAO) na tabela
				 * AVISO_BANCARIO para um determinado ARRECADADOR_MOVIMENTO
				 */
				try {

					valorTotalArrecadacaoAvisoBancario = repositorioArrecadacao
							.obterTotalArrecadacaoAvisoBancarioPorMovimentoArrecadadores(arrecadadorMovimentoObjeto);

				} catch (ErroRepositorioException ex) {
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				/*
				 * Selecionar os movimentos com valor total diferente do valor
				 * da soma das arrecadações dos avisos bancários relacionados
				 */
				if (movimentoAbertoFechado.equalsIgnoreCase(""
						+ ConstantesSistema.MOVIMENTO_ABERTO)) {

					if ((valorTotalArrecadacaoAvisoBancario == null || arrecadadorMovimentoObjeto
							.getValorTotalMovimento() == null)) {

						retorno.add(arrecadadorMovimentoObjeto);
						// } else if (!arrecadadorMovimentoObjeto
						// .getValorTotalMovimento().equals(
						// valorTotalArrecadacaoAvisoBancario)) {
						//
						// retorno.add(arrecadadorMovimentoObjeto);
						// }

					} else if (arrecadadorMovimentoObjeto
							.getValorTotalMovimento().compareTo(
									valorTotalArrecadacaoAvisoBancario) != 0) {
						retorno.add(arrecadadorMovimentoObjeto);
					}

				}
				/*
				 * Selecionar os movimentos com valor total igual ao valor da
				 * soma das arrecadações dos avisos bancários relacionados
				 */
				// else if (movimentoAbertoFechado.equalsIgnoreCase(""
				// + ConstantesSistema.MOVIMENTO_FECHADO)
				// && (valorTotalArrecadacaoAvisoBancario != null &&
				// arrecadadorMovimentoObjeto
				// .getValorTotalMovimento() != null)
				// && (arrecadadorMovimentoObjeto.getValorTotalMovimento()
				// .equals(valorTotalArrecadacaoAvisoBancario))) {
				//
				// retorno.add(arrecadadorMovimentoObjeto);
				// }
				else if (movimentoAbertoFechado.equalsIgnoreCase(""
						+ ConstantesSistema.MOVIMENTO_FECHADO)
						&& (valorTotalArrecadacaoAvisoBancario != null && arrecadadorMovimentoObjeto
								.getValorTotalMovimento() != null)
						&& (arrecadadorMovimentoObjeto.getValorTotalMovimento()
								.compareTo(valorTotalArrecadacaoAvisoBancario) == 0)) {

					retorno.add(arrecadadorMovimentoObjeto);
				}
			}

		} else {

			retorno.addAll(colecaoMovimentoArrecadadoresTotal);
		}

		// [FS0005] - Nenhum registro encontrado
		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}
		return retorno;
	}

	/**
	 * Pesquisa os dados da Guia de Pagamento necessários para o relatório
	 * através do id da Guia de Pagamento
	 * 
	 * @author Vivianne Sousa, Mariana Victor
	 * @date 03/10/06, 02/03/2011
	 * 
	 * @return Collection<GuiaPagamentoRelatorioHelper>
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */

	public Collection<GuiaPagamentoRelatorioHelper> pesquisarGuiaPagamentoRelatorio(
			String[] ids) throws ControladorException {

		Collection<GuiaPagamentoRelatorioHelper> colecaoGuiaPagamentoRelatorioHelper = new ArrayList();

		if (ids != null && ids.length != 0) {
			for (int i = 0; i < ids.length; i++) {

				int idGuiaPagamento = Integer.parseInt(ids[i]);
				GuiaPagamentoRelatorioHelper guiaPagamentoRelatorioHelper = new GuiaPagamentoRelatorioHelper();

				try {
					guiaPagamentoRelatorioHelper = repositorioArrecadacao
							.pesquisarGuiaPagamentoRelatorio(idGuiaPagamento);
				} catch (ErroRepositorioException ex) {
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				Integer idCliente = null;
				Integer idImovel = null;
				String matricula = "";
				String nomeCliente = "";
				String inscricao = "";
				String cpfCliente = "";
				String cnpjCliente = "";
				String sacadoParte01 = "";
				String sacadoParte02 = "";

				// Pesquisar Cliente
				// recupera cliente atraves de ClienteGuiaPagamento
				// se vier null
				// recupera atraves de Imovel.imovelCliente

				Object[] dadosCliente = null;

				try {
					dadosCliente = repositorioArrecadacao
							.pesquisarClienteDeGuiaPagamento(idGuiaPagamento);
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}

				if (dadosCliente == null) {
					try {
						dadosCliente = repositorioArrecadacao
								.pesquisarImovelDeClienteGuiaPagamento(idGuiaPagamento);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}

				}

				if (dadosCliente == null) {
					try {
						dadosCliente = repositorioArrecadacao
								.pesquisarClienteDeClienteImovel(idGuiaPagamento);
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}

				}

				if (dadosCliente != null) {
					if (dadosCliente[0] != null) {
						idCliente = (Integer) dadosCliente[0];
					}
					if (dadosCliente[1] != null) {
						nomeCliente = (String) dadosCliente[1];
					}
					if ( dadosCliente[2] != null ) {
						cpfCliente = (String) dadosCliente[2];
					}
					if ( dadosCliente[3] != null ) {
						cnpjCliente = (String) dadosCliente[3];
					}
				}

				if (guiaPagamentoRelatorioHelper.getIdImovel() == null) {
					// código do cliente
					matricula = "" + idCliente;
					
					// Inscrição do imóvel
					// caso imov_id = null, imprimir código da localidade
					// (loca_id)
					inscricao = ""
							+ guiaPagamentoRelatorioHelper.getIdLocalidade();

					// recupera endereço de correspondencia do cliente
					// [UC0085]Obter Endereco
					String enderecoClienteResponsavel = "";
					enderecoClienteResponsavel = this.getControladorEndereco()
							.pesquisarEnderecoClienteAbreviado(idCliente);
					guiaPagamentoRelatorioHelper
							.setEnderecoClienteResponsavel(enderecoClienteResponsavel);

					sacadoParte01 = nomeCliente;
					sacadoParte02 = "     Cód.Responsável: ";
					
				} else {
					idImovel = guiaPagamentoRelatorioHelper.getIdImovel();
					// matrícula do imóvel
					matricula = "" + idImovel;
					
					// try {
					// nomeCliente = repositorioArrecadacao
					// .pesquisarNomeClienteGuiaPagamentoRelatorio(idGuiaPagamento);
					// } catch (ErroRepositorioException e) {
					// e.printStackTrace();
					// }

					// Inscrição do imóvel
					inscricao = getControladorImovel()
							.pesquisarInscricaoImovel(idImovel);

					// recupera endereco do imóvel
					String enderecoImovel = "";
					try {
						enderecoImovel = this.getControladorEndereco()
								.pesquisarEnderecoFormatado(idImovel);
					} catch (ControladorException e1) {
						e1.printStackTrace();
					}
					guiaPagamentoRelatorioHelper
							.setEnderecoImovel(enderecoImovel);
					
					if (guiaPagamentoRelatorioHelper.getNomeImovel() != null
							&& !guiaPagamentoRelatorioHelper.equals("")) {
						sacadoParte01 = guiaPagamentoRelatorioHelper.getNomeImovel();
					} else {
						sacadoParte01 = nomeCliente;
					}
					sacadoParte02 = "     Matricula: ";
					
				}

				guiaPagamentoRelatorioHelper.setIdCliente(idCliente);
				guiaPagamentoRelatorioHelper.setIdImovel(idImovel);
				guiaPagamentoRelatorioHelper.setMatricula(matricula);
				guiaPagamentoRelatorioHelper.setNomeCliente(nomeCliente);
				guiaPagamentoRelatorioHelper.setInscricao(inscricao);
				guiaPagamentoRelatorioHelper.setIdGuiaPagamento(""
						+ idGuiaPagamento);
				guiaPagamentoRelatorioHelper.setCpfCliente(cpfCliente);
				guiaPagamentoRelatorioHelper.setCnpjCliente(cnpjCliente);
				guiaPagamentoRelatorioHelper.setSacadoParte01(sacadoParte01);
				guiaPagamentoRelatorioHelper.setSacadoParte02(sacadoParte02);
				
				String representacaoNumericaCodBarra = "";
				String anoEmissaoGuia = ""
						+ Util.getAno(guiaPagamentoRelatorioHelper
								.getDataEmissao());

				// caso imov_id da guia de pagamento esteja preenchido,
				// atribuir o valor 1 , caso contrário atribuir o valor 9
				Integer tipoPagamento = 1;
				if (guiaPagamentoRelatorioHelper.getIdImovel() == null
						|| guiaPagamentoRelatorioHelper.getIdImovel()
								.equals("")) {
					tipoPagamento = 9;
				}

				Fachada fachada = Fachada.getInstancia();
				SistemaParametro sistemaParametro = fachada.pesquisarParametrosDoSistema();
				
				String representacaoNumericaCodBarraSemDigito = "";
				String representacaoNumericaCodBarraFormatada = "";
				
				if( guiaPagamentoRelatorioHelper.getValorDebito()!= null && getSistemaParametro().getValorGuiaFichaComp() != null
						&& !getSistemaParametro().getValorGuiaFichaComp().equals(new BigDecimal("0.00"))
						&& guiaPagamentoRelatorioHelper.getValorDebito().compareTo(getSistemaParametro().getValorGuiaFichaComp()) >= 0
						&& guiaPagamentoRelatorioHelper.getIdTipoDebito().equals(DebitoTipo.ENTRADA_PARCELAMENTO)){
					// [UC0716  Obter Representação Numérica do Código de Barras da Ficha de Compensação]
					
					StringBuilder nossoNumero = fachada.obterNossoNumeroFichaCompensacao(
							DocumentoTipo.GUIA_PAGAMENTO.toString(),guiaPagamentoRelatorioHelper.getIdGuiaPagamento().toString()) ;
					String nossoNumeroSemDV = nossoNumero.toString().substring(0,17);
					
					guiaPagamentoRelatorioHelper.setNossoNumero(nossoNumero.toString());
					
//					Date dataVencimentoMais75 = Util.adicionarNumeroDiasDeUmaData(new Date(),75);
					String fatorVencimento = fachada.obterFatorVencimento(guiaPagamentoRelatorioHelper.getDataVencimento());
					
					representacaoNumericaCodBarraSemDigito = fachada.
						obterEspecificacaoCodigoBarraFichaCompensacao(
					    ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO, 
					    ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO, 
					    guiaPagamentoRelatorioHelper.getValorDebito(), nossoNumeroSemDV.toString(),
						ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO, fatorVencimento);
					                                
					representacaoNumericaCodBarraFormatada = 
					fachada.obterRepresentacaoNumericaCodigoBarraFichaCompensacao(representacaoNumericaCodBarraSemDigito);

					guiaPagamentoRelatorioHelper.setSubRelatorio("relatorioEmitirGuiaPagamentoFichaCompensacao.jasper");
				} else {
					// [UC0229] - Obter Representação Numérica do Código de
					// Barras
					representacaoNumericaCodBarra = obterRepresentacaoNumericaCodigoBarra(
							tipoPagamento, // tipo
							// de
							// pagamento
							guiaPagamentoRelatorioHelper.getValorDebito(), // valor
							// do
							// código de
							// barras
							guiaPagamentoRelatorioHelper.getIdLocalidade(), // código
							// da
							// localidade
							guiaPagamentoRelatorioHelper.getIdImovel() == null ? null
									: guiaPagamentoRelatorioHelper.getIdImovel(), // matrícula
							// do imóvel
							null, // mês e ano de referência
							null, // digito verificador da referência
							guiaPagamentoRelatorioHelper.getIdTipoDebito(), // código
							// do
							// tipo do
							// débito
							anoEmissaoGuia, // ano da emissão da guia
							null, // sequencial do documento de
							// cobrança
							null, // código do tipo de documento
							guiaPagamentoRelatorioHelper.getIdCliente() == null ? null
									: guiaPagamentoRelatorioHelper.getIdCliente(), // código
							// do
							// cliente
							null,
							guiaPagamentoRelatorioHelper.getIdGuiaPagamento()); // sequencial da fatura do cliente
	
					// Formata a representação númerica do código de barras
					representacaoNumericaCodBarraFormatada = representacaoNumericaCodBarra
							.substring(0, 11)
							+ "-"
							+ representacaoNumericaCodBarra.substring(11, 12)
							+ " "
							+ representacaoNumericaCodBarra.substring(12, 23)
							+ "-"
							+ representacaoNumericaCodBarra.substring(23, 24)
							+ " "
							+ representacaoNumericaCodBarra.substring(24, 35)
							+ "-"
							+ representacaoNumericaCodBarra.substring(35, 36)
							+ " "
							+ representacaoNumericaCodBarra.substring(36, 47)
							+ "-" + representacaoNumericaCodBarra.substring(47, 48);
					
					representacaoNumericaCodBarraSemDigito = representacaoNumericaCodBarra
						.substring(0, 11)
						+ representacaoNumericaCodBarra.substring(12, 23)
						+ representacaoNumericaCodBarra.substring(24, 35)
						+ representacaoNumericaCodBarra.substring(36, 47);

					guiaPagamentoRelatorioHelper.setSubRelatorio("relatorioEmitirGuiaPagamentoEmissaoPadrao.jasper");
				}
				
				guiaPagamentoRelatorioHelper
						.setRepresentacaoNumericaCodBarraFormatada(representacaoNumericaCodBarraFormatada);

				guiaPagamentoRelatorioHelper
						.setRepresentacaoNumericaCodBarraSemDigito(representacaoNumericaCodBarraSemDigito);

				colecaoGuiaPagamentoRelatorioHelper
						.add(guiaPagamentoRelatorioHelper);
			}
		}

		return colecaoGuiaPagamentoRelatorioHelper;
	}

	/**
	 * Pesquisa os dados da Guia de Devolução necessários para o relatório
	 * através do id da Guia de Devolução
	 * 
	 * @author Ana Maria
	 * @date 05/10/06
	 * 
	 * @return Collection<GuiaDevolucaoRelatorioHelper>
	 * @throws ControladorException
	 * @throws ErroRepositorioException
	 */

	public Collection<GuiaDevolucaoRelatorioHelper> pesquisarGuiaDevolucaoRelatorio(
			String[] ids) throws ControladorException {

		Collection<GuiaDevolucaoRelatorioHelper> colecaoGuiaDevolucaoRelatorioHelper = new ArrayList();

		if (ids != null && ids.length != 0) {
			for (int i = 0; i < ids.length; i++) {

				int idGuiaDevolucao = Integer.parseInt(ids[i]);
				GuiaDevolucaoRelatorioHelper guiaDevolucaoRelatorioHelper = new GuiaDevolucaoRelatorioHelper();

				try {
					guiaDevolucaoRelatorioHelper = repositorioArrecadacao
							.pesquisarGuiaDevolucaoRelatorio(idGuiaDevolucao);
				} catch (ErroRepositorioException ex) {
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				String valorExtenco = Util
						.valorExtenso(guiaDevolucaoRelatorioHelper
								.getValorDevolucao());
				if (valorExtenco != null && !valorExtenco.equals("")) {
					guiaDevolucaoRelatorioHelper.setValorExtenso(valorExtenco);
				}

				if (guiaDevolucaoRelatorioHelper.getIdMatriculaImovel() != null) {
					// Imóvel

					// recupera endereco do imóvel
					String enderecoImovel = "";
					try {
						enderecoImovel = this.getControladorEndereco()
								.pesquisarEnderecoFormatado(
										guiaDevolucaoRelatorioHelper
												.getIdMatriculaImovel());
					} catch (ControladorException e1) {
						e1.printStackTrace();
					}
					guiaDevolucaoRelatorioHelper.setEndereco(enderecoImovel);

					// Pesquisa para recuperar o cpf/cnpj e o rg do Cliente
					Object[] dadosClienteImovel = null;

					try {

						dadosClienteImovel = repositorioArrecadacao
								.pesquisarClienteImovel(guiaDevolucaoRelatorioHelper
										.getIdMatriculaImovel());

					} catch (ErroRepositorioException ex) {
						ex.printStackTrace();
						throw new ControladorException("erro.sistema", ex);
					}
					if (dadosClienteImovel != null) {
						if (dadosClienteImovel[0] != null) {
							guiaDevolucaoRelatorioHelper.setNomeCliente(""
									+ dadosClienteImovel[0]);
						}
						if (dadosClienteImovel[1] != null) {
							guiaDevolucaoRelatorioHelper.setCpfCliente(""
									+ dadosClienteImovel[1]);
						}
						if (dadosClienteImovel[2] != null) {
							guiaDevolucaoRelatorioHelper.setCnpjCliente(""
									+ dadosClienteImovel[2]);
						}
						if (dadosClienteImovel[3] != null) {
							guiaDevolucaoRelatorioHelper
									.setIdentidadeCliente(""
											+ dadosClienteImovel[3]);
						}
						if (dadosClienteImovel[4] != null) {
							guiaDevolucaoRelatorioHelper.setOrgaoExpedidor(""
									+ dadosClienteImovel[4]);
						}
						if (dadosClienteImovel[5] != null) {
							guiaDevolucaoRelatorioHelper.setUnidadeFederacao(""
									+ dadosClienteImovel[5]);
						}
					}
				} else {
					// Cliente

					String enderecoClienteResponsavel = this
							.getControladorEndereco()
							.pesquisarEnderecoClienteAbreviado(
									guiaDevolucaoRelatorioHelper.getIdCliente());
					guiaDevolucaoRelatorioHelper
							.setEndereco(enderecoClienteResponsavel);
				}

				try {

					Object[] dadosContaAgencia = null;
					dadosContaAgencia = repositorioArrecadacao
							.pesquisarContaAgenciaSistemaParametro();

					// Número da conta corrente para débito
					if (dadosContaAgencia[0] != null) {
						guiaDevolucaoRelatorioHelper
								.setConta((String) dadosContaAgencia[0]);
					}
					// Código da agência para débito
					if (dadosContaAgencia[1] != null) {
						guiaDevolucaoRelatorioHelper
								.setAgencia((Integer) dadosContaAgencia[1]);
					}

				} catch (ErroRepositorioException ex) {
					ex.printStackTrace();
					throw new ControladorException("erro.sistema", ex);
				}

				colecaoGuiaDevolucaoRelatorioHelper
						.add(guiaDevolucaoRelatorioHelper);
			}
		}

		return colecaoGuiaDevolucaoRelatorioHelper;
	}

	// /////////////////////////////////////////////////////////////////
	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para pesquisar os pagamento historicos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos historicos do Imóvel
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovel(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {

		try {
			return repositorioArrecadacao.pesquisarPagamentoHistoricoImovel(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * 
	 * Filtar a quantiade de pagamento historicos do imovel [UC0255] Filtrar
	 * Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoHistoricoImovelCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoImovelCount(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra os pagamento historicos do Imovel para paginação
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoImovelParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoImovelParaPaginacao(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra os Pagamento Historicos do Cliente Conta
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteConta(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoHistoricoClienteConta(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamentoHistorico.setId((Integer) dadosPagamento[0]);
					}

					Conta conta = null;

					// Id da Conta
					if (dadosPagamento[1] != null) {
						conta = new Conta();
						conta.setId((Integer) dadosPagamento[1]);
					}

					// Ano Mês Referência da Conta
					if (dadosPagamento[2] != null) {
						conta
								.setReferencia((Integer) dadosPagamento[2]);
					}

					// Valor da Água da Conta
					if (dadosPagamento[3] != null) {
						conta.setValorAgua((BigDecimal) dadosPagamento[3]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[4] != null) {
						conta.setValorEsgoto((BigDecimal) dadosPagamento[4]);
					}

					// Valor de Débitos
					if (dadosPagamento[5] != null) {
						conta.setDebitos((BigDecimal) dadosPagamento[5]);
					}

					// Valor dos Créditos
					if (dadosPagamento[6] != null) {
						conta.setValorCreditos((BigDecimal) dadosPagamento[6]);
					}
					
					ContaGeral contageral = new ContaGeral();
					contageral.setConta(conta);
					pagamentoHistorico.setContaGeral(contageral);

					// Data do Pagamento
					if (dadosPagamento[7] != null) {
						pagamentoHistorico
								.setDataPagamento((Date) dadosPagamento[7]);
					}

					// Ano Mês do Pagamento
					if (dadosPagamento[8] != null) {
						pagamentoHistorico
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[8]);
					}

					// Valor do Pagamento
					if (dadosPagamento[9] != null) {
						pagamentoHistorico
								.setValorPagamento((BigDecimal) dadosPagamento[9]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[10] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[10]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[11] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[11]);
					}

					pagamentoHistorico
							.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[12] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[12]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[13]);
					}

					pagamentoHistorico
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if (dadosPagamento[14] != null) {
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[14]);
						pagamentoHistorico.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if (dadosPagamento[15] != null) {
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[15]);
						pagamentoHistorico.setImovel(imovel);
					}

					retorno.add(pagamentoHistorico);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Filtrar os pagamentos historicos do Cliente Guia Pagamento
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 06/10/06
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteGuiaPagamento(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoHistoricoClienteGuiaPagamento(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamentoHistorico.setId((Integer) dadosPagamento[0]);
					}

					GuiaPagamento guiaPagamento = null;

					// Id da Guia de Pagamento
					if (dadosPagamento[1] != null) {
						guiaPagamento = new GuiaPagamento();
						guiaPagamento.setId((Integer) dadosPagamento[1]);
					}

					// Id do Cliente
					if (dadosPagamento[2] != null) {
						Cliente cliente = new Cliente();
						cliente.setId((Integer) dadosPagamento[2]);
						pagamentoHistorico.setCliente(cliente);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[3] != null) {
						guiaPagamento
								.setValorDebito((BigDecimal) dadosPagamento[3]);
					}

					// Data do Pagamento
					if (dadosPagamento[4] != null) {
						pagamentoHistorico
								.setDataPagamento((Date) dadosPagamento[4]);
					}

					// Ano Mês do Pagamento
					if (dadosPagamento[5] != null) {
						pagamentoHistorico
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[5]);
					}

					DebitoTipo debitoTipoGuia = null;

					// Id do Tipo de Débito da Guia de Pagamento
					if (dadosPagamento[6] != null) {
						debitoTipoGuia = new DebitoTipo();
						debitoTipoGuia.setId((Integer) dadosPagamento[6]);
					}

					// Descrição do Tipo de Débito da Guia de Pagamento
					if (dadosPagamento[7] != null) {
						debitoTipoGuia.setDescricao((String) dadosPagamento[7]);
					}

					if (guiaPagamento != null) {
						guiaPagamento.setDebitoTipo(debitoTipoGuia);
					}

					pagamentoHistorico.setGuiaPagamento(guiaPagamento);

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if (dadosPagamento[8] != null) {
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[8]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if (dadosPagamento[9] != null) {
						debitoTipoPagamento
								.setDescricao((String) dadosPagamento[9]);
					}

					pagamentoHistorico.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if (dadosPagamento[10] != null) {
						pagamentoHistorico
								.setValorPagamento((BigDecimal) dadosPagamento[10]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[11] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[11]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[12] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[12]);
					}

					pagamentoHistorico
							.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[14] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[14]);
					}

					pagamentoHistorico
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if (dadosPagamento[15] != null) {
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[15]);
						pagamentoHistorico.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel
					if (dadosPagamento[16] != null) {
						Imovel imovel = new Imovel();
						imovel.setId((Integer) dadosPagamento[16]);
						pagamentoHistorico.setImovel(imovel);
					}

					retorno.add(pagamentoHistorico);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;
	}

	/**
	 * Filtra os pagamentos historicos do debito a cobrar
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 12/06/06,06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoClienteDebitoACobrar(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoDadosPagamento = null;

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoHistoricoClienteDebitoACobrar(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Object[] dadosPagamento = null;

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoHistorico pagamentoHistorico = new PagamentoHistorico();

					// Id do Pagamento
					if (dadosPagamento[0] != null) {
						pagamentoHistorico.setId((Integer) dadosPagamento[0]);
					}

					DebitoACobrar debitoACobrar = null;

					// Id do Imóvel do Pagamento
					if (dadosPagamento[1] != null) {
						Imovel imovelPagamento = new Imovel();
						imovelPagamento.setId((Integer) dadosPagamento[1]);
						pagamentoHistorico.setImovel(imovelPagamento);
					}

					// Id do Débito a Cobrar
					if (dadosPagamento[2] != null) {
						debitoACobrar = new DebitoACobrar();
						debitoACobrar.setId((Integer) dadosPagamento[2]);
					}

					// Valor do Débito
					if (dadosPagamento[3] != null) {
						debitoACobrar
								.setValorDebito((BigDecimal) dadosPagamento[3]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[4] != null) {
						debitoACobrar
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[4]);
					}

					// Número de Prestações Débito
					if (dadosPagamento[5] != null) {
						debitoACobrar
								.setNumeroPrestacaoDebito((Short) dadosPagamento[5]);
					}

					// Data do Pagamento
					if (dadosPagamento[6] != null) {
						pagamentoHistorico
								.setDataPagamento((Date) dadosPagamento[6]);
					}

					// Ano Mês do Pagamento
					if (dadosPagamento[7] != null) {
						pagamentoHistorico
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[7]);
					}

					DebitoTipo debitoTipoDebito = null;

					// Id do Tipo de Débito do Débito a Cobrar
					if (dadosPagamento[8] != null) {
						debitoTipoDebito = new DebitoTipo();
						debitoTipoDebito.setId((Integer) dadosPagamento[8]);
					}

					// Descrição do Tipo de Débito do Débito a Cobrar
					if (dadosPagamento[9] != null) {
						debitoTipoDebito
								.setDescricao((String) dadosPagamento[9]);
					}

					debitoACobrar.setDebitoTipo(debitoTipoDebito);

					DebitoTipo debitoTipoPagamento = null;

					// Id do Tipo de Débito do Pagamento
					if (dadosPagamento[10] != null) {
						debitoTipoPagamento = new DebitoTipo();
						debitoTipoPagamento.setId((Integer) dadosPagamento[10]);
					}

					// Descrição do Tipo de Débito do Pagamento
					if (dadosPagamento[11] != null) {
						debitoTipoPagamento
								.setDescricao((String) dadosPagamento[11]);
					}

					pagamentoHistorico.setDebitoTipo(debitoTipoPagamento);

					// Valor do Pagamento
					if (dadosPagamento[12] != null) {
						pagamentoHistorico
								.setValorPagamento((BigDecimal) dadosPagamento[12]);
					}

					PagamentoSituacao pagamentoSituacaoAtual = null;

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[13] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[14] != null) {
						pagamentoSituacaoAtual
								.setDescricaoAbreviada((String) dadosPagamento[14]);
					}

					pagamentoHistorico
							.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					PagamentoSituacao pagamentoSituacaoAnterior = null;

					// Id da Situação Anterior do Pagamento
					if (dadosPagamento[15] != null) {
						pagamentoSituacaoAnterior = new PagamentoSituacao();
						pagamentoSituacaoAnterior
								.setId((Integer) dadosPagamento[15]);
					}

					// Descrição da Situação Anterior do Pagamento
					if (dadosPagamento[16] != null) {
						pagamentoSituacaoAnterior
								.setDescricaoAbreviada((String) dadosPagamento[16]);
					}

					pagamentoHistorico
							.setPagamentoSituacaoAnterior(pagamentoSituacaoAnterior);

					// Id do Tipo de Documento
					if (dadosPagamento[17] != null) {
						DocumentoTipo documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) dadosPagamento[17]);
						pagamentoHistorico.setDocumentoTipo(documentoTipo);
					}

					// Id do Imóvel do Débito a Cobrar
					if (dadosPagamento[18] != null) {
						Imovel imovelDebito = new Imovel();
						imovelDebito.setId((Integer) dadosPagamento[18]);
						debitoACobrar.setImovel(imovelDebito);
					}

                    
					// Número de Parcela bonus
                    if (dadosPagamento[20] != null) {
                        debitoACobrar
                                .setNumeroParcelaBonus((Short) dadosPagamento[20]);
                    }

                    DebitoACobrarGeral debitoACobrarGeral = null;
                    if(debitoACobrar != null){
                    	debitoACobrarGeral = new DebitoACobrarGeral();
                    	debitoACobrarGeral.setId(debitoACobrar.getId());
                    	debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
                    }
					pagamentoHistorico.setDebitoACobrarGeral(debitoACobrarGeral);

					retorno.add(pagamentoHistorico);

				}

			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * Filtrar a quantidade de pagamento historicos do cliente
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rafael Santos
	 * @date 06/10/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoClienteCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoClienteCount(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Filtra os pagamento historicos do cliente
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 21/08/06,06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoCliente(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoHistoricoCliente(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos, numeroPagina);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra a quantiadade dos Pagamento Historicos da Localidade
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoHistoricoLocalidadeCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoLocalidadeCount(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * Filtra os Pagamento Historicos da Localidade
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoLocalidade(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoLocalidade(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Filtra oas pagamento historicos do Aviso Bancario
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancario(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoAvisoBancario(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Filtra a quantidade de pagamento historicos do avio bancario
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoAvisoBancarioCount(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoAvisoBancarioCount(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Filtra os pagamento historicos do aviso bancario para paginação
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoAvisoBancarioParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina) throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoAvisoBancarioParaPaginacao(
							idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * Filtrar pagamentos historicos do movimento arrecador
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Santos
	 * @date 06/10/2006
	 * 
	 * @param FiltroPagamento
	 * @return Collection<Pagamento>
	 * @throws ControladorException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoMovimentoArrecadador(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoHistoricoMovimentoArrecadador(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Faz a pesquisa de devoluçãoHistorico fazendo os carregamentos de
	 * clienteContas, clienteImoveis, clientesGuiaPagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 09/10/2006
	 * 
	 * @param FiltroDevolucaoHistorico
	 * @return Collection<DevolucaoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<DevolucaoHistorico> pesquisarDevolucaoHistorico(
			FiltroDevolucaoHistorico filtroDevolucaoHistorico)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarDevolucaoHistorico(filtroDevolucaoHistorico);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * histórico para o Relatório
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos histórico do tipo Debito a Cobrar do Cliente
	 * 
	 * @author Rafael Corrêa
	 * @date 17/12/06
	 * 
	 * @return Collection<PagamentoHistorico>
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoHistorico> pesquisarPagamentoHistoricoLocalidadeRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoHistoricoLocalidadeRelatorio(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					// Valor dos Impostos da Conta
					if (dadosPagamento[24] != null) { // 24
						pagamentoRelatorioHelper
								.setValorImpostos((BigDecimal) dadosPagamento[24]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Consulta dados da tabela dados diarios arrecadacao
	 * 
	 * @author Rafael Santos
	 * @created 21/10/2006
	 * 
	 * 
	 * @return
	 * @throws ErroRepositorioException
	 */
	public ArrecadacaoDadosDiarios consultarDadosDiarios(
			int idGerenciaRegional, int idLocalidade, int idElo)
			throws ControladorException {

		Collection colecaoDadosDiarios = null;

		ArrecadacaoDadosDiarios arrecadacaoDadosDiarios = null;

		try {
			colecaoDadosDiarios = repositorioArrecadacao.consultarDadosDiarios(
					idGerenciaRegional, idLocalidade, idElo);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()) {

			Object[] dados = (Object[]) colecaoDadosDiarios.iterator().next();

			arrecadacaoDadosDiarios = new ArrecadacaoDadosDiarios();

			// gerencia regional
			if (dados[0] != null) {
				GerenciaRegional gerenciaRegional = new GerenciaRegional();
				gerenciaRegional.setNome((String) dados[0]);
				arrecadacaoDadosDiarios.setGerenciaRegional(gerenciaRegional);
			}

			// localidade
			Localidade localidade = null;

			if (dados[1] != null) {
				localidade = new Localidade();
				localidade.setDescricao((String) dados[1]);
				arrecadacaoDadosDiarios.setLocalidade(localidade);
			}

			// elo
			if (dados[2] != null) {
				if (localidade == null) {
					localidade = new Localidade();
				}
				Localidade elo = new Localidade();
				elo.setDescricao((String) dados[2]);
				localidade.setLocalidade(elo);
				arrecadacaoDadosDiarios.setLocalidade(localidade);
			}

		}

		return arrecadacaoDadosDiarios;
	}

	/**
	 * 
	 * Este método se destina a validar todas as situações e particularidades da
	 * inserir guia de devolução no momento da exibição.
	 * 
	 * [FS0002] Validar registro de atendimento [FS0004] Validar ordem de
	 * servico.
	 * 
	 * @author Rafael Pinto
	 * @date 06/11/2006
	 * 
	 * @param RegistroAtendimento,OrdemServico
	 */
	public void validarExibirInserirGuiaDevolucao(RegistroAtendimento ra,
			OrdemServico ordemServico) throws ControladorException {

		// [FS0002] Validar registro de atendimento
		if (ra != null) {

			Imovel imovel = ra.getImovel();

			// Caso o Registro Atendimento não esteja associado a um imóvel e
			// não esteja associado um cliente
			FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

			filtro
					.adicionarParametro(new ParametroSimples(
							FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
							ra.getId()));

			filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");

			Collection colecaoRegistros = getControladorUtil().pesquisar(
					filtro, RegistroAtendimentoSolicitante.class.getName());

			if (colecaoRegistros != null && !colecaoRegistros.isEmpty()) {

				Iterator itera = colecaoRegistros.iterator();
				while (itera.hasNext()) {
					RegistroAtendimentoSolicitante raSoli = (RegistroAtendimentoSolicitante) itera
							.next();

					if (raSoli.getIndicadorSolicitantePrincipal() == ConstantesSistema.SIM
							.shortValue()) {
						if (raSoli.getCliente() == null && imovel == null) {
							throw new ControladorException(
									"atencao.registro.atendimento.sem.imovel.cliente",
									null, "" + ra.getId());
						}

					}
				}

			} else if (imovel == null) {
				throw new ControladorException(
						"atencao.registro.atendimento.sem.imovel.cliente",
						null, "" + ra.getId());
			}

			// Caso a situação do Registro de Atendimento não seja encerrada
			if (ra.getAtendimentoMotivoEncerramento() != null) {
				throw new ControladorException(
						"atencao.registro_atendimento.esta.encerrado");
			}

			// Caso o tipo de solicitação do registro atendimento
			// não permita a geração de guia de devolução
			if (ra.getSolicitacaoTipoEspecificacao()
					.getIndicadorGeracaoCredito().intValue() == ConstantesSistema.NAO
					.intValue()) {
				throw new ControladorException(
						"atencao.registro_atendimento.nao.permite.guia.devolucao");
			}

			// [FS0007] Validar ordem de servico.
		} else if (ordemServico != null) {

			// Caso a Ordem de Serviço não esteja associada a um Registro de
			// Atendimento
			if (ordemServico.getRegistroAtendimento() == null) {
				throw new ControladorException(
						"atencao.ordem_servico.nao.esta.associado.registro_atendimento");
			}

			RegistroAtendimento registroAtendimento = ordemServico
					.getRegistroAtendimento();

			Imovel imovel = registroAtendimento.getImovel();

			// Caso a Ordem de Serviço esteja associada a um Registro
			// Atendimento,
			// porém o Registro Atendimento não esteja associado a um imóvel e
			// não esteja associado um cliente
			FiltroRegistroAtendimentoSolicitante filtro = new FiltroRegistroAtendimentoSolicitante();

			filtro
					.adicionarParametro(new ParametroSimples(
							FiltroRegistroAtendimentoSolicitante.REGISTRO_ATENDIMENTO_ID,
							registroAtendimento.getId()));

			filtro.adicionarCaminhoParaCarregamentoEntidade("cliente");

			Collection colecaoRegistros = getControladorUtil().pesquisar(
					filtro, RegistroAtendimentoSolicitante.class.getName());

			if (colecaoRegistros != null && !colecaoRegistros.isEmpty()) {

				Iterator itera = colecaoRegistros.iterator();
				while (itera.hasNext()) {
					RegistroAtendimentoSolicitante raSoli = (RegistroAtendimentoSolicitante) itera
							.next();

					if (raSoli.getIndicadorSolicitantePrincipal() == ConstantesSistema.SIM
							.shortValue()) {
						if (raSoli.getCliente() == null && imovel == null) {
							throw new ControladorException(
									"atencao.registro.atendimento.sem.imovel.cliente",
									null, "" + raSoli.getID());
						}

					}
				}

			} else if (imovel == null) {
				throw new ControladorException(
						"atencao.registro.atendimento.sem.imovel.cliente",
						null, "" + registroAtendimento.getId());
			}

		}
	}

	/**
	 * Metodo responsável pela remoção das guias de devolução
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 24/11/2006
	 * 
	 * @param idImovel
	 * @param usuarioLogado
	 * @param ids
	 * @param pacoteNomeObjeto
	 * @param operacaoEfetuada
	 * @param acaoUsuarioHelper
	 * @throws ControladorException
	 */
	public void removerGuiaDevolucao(String idImovel, Usuario usuarioLogado,
			String[] ids, String pacoteNomeObjeto,
			OperacaoEfetuada operacaoEfetuada,
			Collection<UsuarioAcaoUsuarioHelper> acaoUsuarioHelper)
			throws ControladorException {

		Imovel imovel = new Imovel();
		imovel.setId(new Integer(idImovel));

		/**
		 * alterado por pedro alexandre dia 24/11/2006 alteração feita para
		 * acoplar o controle de abrangência de usuário
		 */
		// ------------ CONTROLE DE ABRANGENCIA ----------------
		Abrangencia abrangencia = new Abrangencia(usuarioLogado, imovel);

		if (!getControladorAcesso().verificarAcessoAbrangencia(abrangencia)) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.acesso.negado.abrangencia");
		}
		this.getControladorUtil().remover(ids, pacoteNomeObjeto,
				operacaoEfetuada, acaoUsuarioHelper);
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * 
	 * @throws ControladorException
	 */
	public Integer filtrarMovimentoArrecadadoresCount(String codigoBanco,
			String codigoRemessa, String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ControladorException {
		try {
			return repositorioArrecadacao.filtrarMovimentoArrecadadoresCount(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param numeroPagina
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<ArrecadadorMovimento> filtrarMovimentoArrecadadorParaPaginacao(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, Integer numeroPagina,
			String indicadorAbertoFechado) throws ControladorException {

		Collection<ArrecadadorMovimento> retorno = new ArrayList<ArrecadadorMovimento>();
		Collection colecaoMovimentoArrecadadores = null;

		try {

			colecaoMovimentoArrecadadores = repositorioArrecadacao
					.filtrarMovimentoArrecadadorParaPaginacao(codigoBanco,
							codigoRemessa, descricaoIdentificacaoServico,
							numeroSequencialArquivo, dataGeracaoInicio,
							dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia,
							indicadorAceitacao, numeroPagina,
							indicadorAbertoFechado);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		Iterator iteratorMovimentoArrecadadoresTotal = colecaoMovimentoArrecadadores
				.iterator();

		while (iteratorMovimentoArrecadadoresTotal.hasNext()) {

			ArrecadadorMovimento arrecadadorMovimentoRetorno = new ArrecadadorMovimento();
			Object[] arrecadadorMovimento = (Object[]) iteratorMovimentoArrecadadoresTotal
					.next();

            if (arrecadadorMovimento[0] != null) {// 0
				// codigo do banco
				arrecadadorMovimentoRetorno.setCodigoBanco(new Short(
						arrecadadorMovimento[0].toString()));
			}

			if (arrecadadorMovimento[1] != null) {// 1
				// codigo remessa
				arrecadadorMovimentoRetorno.setCodigoRemessa(new Short(
						arrecadadorMovimento[1].toString()));
			}

			if (arrecadadorMovimento[2] != null) {// 2
				// descrição indentificação do serviço
				arrecadadorMovimentoRetorno
						.setDescricaoIdentificacaoServico(arrecadadorMovimento[2]
								.toString());
			}

			if (arrecadadorMovimento[3] != null) {// 3
				// nsa
				arrecadadorMovimentoRetorno
						.setNumeroSequencialArquivo(new Integer(
								arrecadadorMovimento[3].toString()));
			}

			if (arrecadadorMovimento[4] != null) {// 4
				// id de arrecadadorMovimento
				arrecadadorMovimentoRetorno.setId(new Integer(
						arrecadadorMovimento[4].toString()));
			}

			if (arrecadadorMovimento[5] != null) {// 5
				// data de geração
				arrecadadorMovimentoRetorno
						.setDataGeracao((Date) arrecadadorMovimento[5]);
			}

			if (arrecadadorMovimento[6] != null) {// 6
				// numero Registros Movimento
				arrecadadorMovimentoRetorno
						.setNumeroRegistrosMovimento(new Integer(
								arrecadadorMovimento[6].toString()));
			}

			if (arrecadadorMovimento[7] != null) {// 7
				// valor Total do Movimento
				arrecadadorMovimentoRetorno
						.setValorTotalMovimento(new BigDecimal(
								arrecadadorMovimento[7].toString()));
			}

			if (arrecadadorMovimento[8] != null) {// 8
				// ultima alteração
				arrecadadorMovimentoRetorno
						.setUltimaAlteracao((Date) arrecadadorMovimento[8]);
			}

			if (arrecadadorMovimento[9] != null) {// 9
				// nome banco
				arrecadadorMovimentoRetorno
						.setNomeBanco((String) arrecadadorMovimento[9]);
			}
            
            String situacaoArrecadadorMovimento = this.obterSituacaoArrecadadorMovimento(
                    arrecadadorMovimentoRetorno );
            
            if(indicadorAbertoFechado != null && !indicadorAbertoFechado.equals("")){
            	
            	if(indicadorAbertoFechado.equals(""+ConstantesSistema.MOVIMENTO_FECHADO) && 
            		situacaoArrecadadorMovimento.equals(ConstantesSistema.FECHADO)){
            		
            		retorno.add(arrecadadorMovimentoRetorno);
            		
            	}else if(indicadorAbertoFechado.equals(""+ConstantesSistema.MOVIMENTO_ABERTO) && 
                		situacaoArrecadadorMovimento.equals(ConstantesSistema.ABERTO)){
            		
            		retorno.add(arrecadadorMovimentoRetorno);
            	}
            }else{
            	retorno.add(arrecadadorMovimentoRetorno);
            }
		}

		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;

	}

	/**
	 * Pesquisar os ids das localidades que possuem pagamentos
	 * 
	 * [UC0301] Gerar Dados Diários da Arrecadação
	 * 
	 * @author Pedro Alexandre
	 * @date 04/12/2006
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Integer> pesquisarIdsLocalidadeComPagamentosOuDevolucoes()
			throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarIdsLocalidadeComPagamentosOuDevolucoes();
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Classifica os pagamentos para tipo de documento igual a débito a cobrar.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 29/11/2006, 05/06/2007
	 * 
	 * @param colecaoPagamentosDebitoACobrarPreenchido
	 * @param colecaoPagamentosDebitoACobrarNaoPreenchido
	 * @param anoMesFaturamento
	 * 
	 * @throws ControladorException
	 */
	protected Object[] classificarPagamentosDebitoACobrar(
			Collection colecaoPagamentosDebitoACobrarPreenchido,
			Collection colecaoPagamentosDebitoACobrarNaoPreenchido,
			Integer anoMesFaturamento) throws ControladorException {

		/**
		 * Declaração de variáveis.
		 */
		Object[] retorno = new Object[6];
		Object[] arrayDadosPagamentoDebitoACobrar = null;
		Collection colecaoPagamentosAtualizar = new ArrayList();
		Pagamento pagamento = null;
		Collection colecaoConjuntoPagamentos = new ArrayList();
		Iterator iteratorColecaoConjuntoPagamentos = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Pagamento pagamentoConjunto = null;
		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		DebitoTipo debitoTipoAnterior = null;
		Object[] pagamentoArray = null;
		DocumentoTipo documentoTipo = null;
		Localidade localidade = null;
		Imovel imovel = null;
		PagamentoSituacao pagamentoSituacaoAtual = null;
		Map mapDebitoACobrarProcessar = new HashMap();
		Map<Integer, Collection> mapPagamentoValorNaoConfere = new HashMap();
		Collection colecaoPagamentoClassificado = new ArrayList();
		Collection colecaoPagamentoEmDuplicidade = new ArrayList();
		Collection colecaoPagamentoAtualizarValorExcedente = new ArrayList();
		Collection colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo = new ArrayList();

		/*
		 * ==============================================================================================
		 * Para os pagamentos com tipo de documento (DOPT_ID) com o valor
		 * correspondente a DÉBITO A COBRAR:
		 * ==============================================================================================
		 */
		if ((colecaoPagamentosDebitoACobrarPreenchido != null && !colecaoPagamentosDebitoACobrarPreenchido
				.isEmpty())
				|| (colecaoPagamentosDebitoACobrarNaoPreenchido != null && !colecaoPagamentosDebitoACobrarNaoPreenchido
						.isEmpty())) {

			// Para os pagamentos com débito a cobrar preenchido
			// (DBAC_ID diferente de nulo)
			if (!colecaoPagamentosDebitoACobrarPreenchido.isEmpty()) {

				// Para cada conjunto de pagamentos com mesmo
				// débito a
				// cobrar (DBAC_ID):
				Iterator iteratorcolecaoPagamentosDebitoACobrarPreenchido = colecaoPagamentosDebitoACobrarPreenchido
						.iterator();
				pagamento = null;
				primeiraEntrada = true;
				conjuntoFechado = false;
				DebitoACobrar debitoACobrarAnterior = null;
				DebitoACobrar debitoACobrar = null;
				colecaoConjuntoPagamentos.clear();

				/**
				 * Laço para criar os conjuntos de pagamentos para o mesmo
				 * débito a cobrar.
				 */
				while (iteratorcolecaoPagamentosDebitoACobrarPreenchido
						.hasNext()) {

					pagamentoArray = (Object[]) iteratorcolecaoPagamentosDebitoACobrarPreenchido
							.next();

					if (pagamentoArray[1] != null) {
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) pagamentoArray[1]);
					} else {
						documentoTipo = null;
					}

					if (pagamentoArray[2] != null) {
						localidade = new Localidade();
						localidade.setId((Integer) pagamentoArray[2]);
					} else {
						localidade = null;
					}

					if (pagamentoArray[3] != null) {
						imovel = new Imovel();
						imovel.setId((Integer) pagamentoArray[3]);
					} else {
						imovel = null;
					}

					if (pagamentoArray[4] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) pagamentoArray[4]);
					} else {
						pagamentoSituacaoAtual = null;
					}

					if (pagamentoArray[5] != null) {
						
						Integer id = (Integer) pagamentoArray[5];
						
						BigDecimal valorDebito = null;
						Short numeroPrestacaoDebito = null;
						Short numeroPrestacaoCobradas = null;
						Short numeroParcelaBonus = null;
						
						if (pagamentoArray[6] != null) {
							valorDebito = (BigDecimal) pagamentoArray[6];
						}

						if (pagamentoArray[7] != null) {
							numeroPrestacaoDebito = (Short) pagamentoArray[7];
						}
						
						if (pagamentoArray[8] != null) {
							numeroPrestacaoCobradas = (Short) pagamentoArray[8];
						}
						
						if (pagamentoArray[9] != null) {
							numeroParcelaBonus = (Short) pagamentoArray[9];
						}
						
						debitoACobrar = new DebitoACobrar(
							id,
							valorDebito,
							numeroPrestacaoDebito,
							numeroPrestacaoCobradas,
							numeroParcelaBonus);						
						
					} else {
						debitoACobrar = null;
					}

					pagamento = (Pagamento) pagamentoArray[0];
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setLocalidade(localidade);
					pagamento.setImovel(imovel);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
					
                    DebitoACobrarGeral debitoACobrarGeral = null;
                    
					if(debitoACobrar != null){
	                    
						debitoACobrarGeral = new DebitoACobrarGeral();
						debitoACobrarGeral.setId(debitoACobrar.getId());
						debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
					}
					
					pagamento.setDebitoACobrarGeral(debitoACobrarGeral);

					if (!primeiraEntrada) {

						if (pagamento.getDebitoACobrarGeral().getId().equals(debitoACobrarAnterior.getId())) {
							
							colecaoConjuntoPagamentos.add(pagamento);
						} else {
							conjuntoFechado = true;
						}

					} else {
						primeiraEntrada = false;
						colecaoConjuntoPagamentos.add(pagamento);
					}

					if (conjuntoFechado) {

						// [SF0006] Processar Pagamento de Débito a Cobrar
						arrayDadosPagamentoDebitoACobrar = this
								.processarPagamentoDebitoACobrar(
										debitoACobrarAnterior,
										colecaoConjuntoPagamentos);

						if (arrayDadosPagamentoDebitoACobrar != null) {
							if (arrayDadosPagamentoDebitoACobrar[0] != null) {
								mapDebitoACobrarProcessar
										.putAll((Map) arrayDadosPagamentoDebitoACobrar[0]);
							}

							if (arrayDadosPagamentoDebitoACobrar[1] != null) {
								Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoDebitoACobrar[1];

								if (arrayColecoesPagamentosAtualizar[0] != null) {
									mapPagamentoValorNaoConfere
											.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
								}

								if (arrayColecoesPagamentosAtualizar[1] != null) {
									colecaoPagamentoClassificado
											.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
								}
								if (arrayColecoesPagamentosAtualizar[2] != null) {
									colecaoPagamentoEmDuplicidade
											.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
								}
								if (arrayColecoesPagamentosAtualizar[3] != null) {
									colecaoPagamentoAtualizarValorExcedente
											.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
								}
								if (arrayColecoesPagamentosAtualizar[4] != null) {
									colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
											.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
								}

								arrayDadosPagamentoDebitoACobrar = null;
							}
						}
						colecaoConjuntoPagamentos = new ArrayList();
						colecaoConjuntoPagamentos.add(pagamento);
					}
					

					debitoACobrarAnterior = pagamento.getDebitoACobrarGeral().getDebitoACobrar();	
				}

				/*
				 * Último registro
				 */
				if (!colecaoConjuntoPagamentos.isEmpty()) {

					// [SF0006] Processar Pagamento de Débito a Cobrar
					arrayDadosPagamentoDebitoACobrar = this
							.processarPagamentoDebitoACobrar(
									debitoACobrarAnterior,
									colecaoConjuntoPagamentos);

					if (arrayDadosPagamentoDebitoACobrar != null) {
						if (arrayDadosPagamentoDebitoACobrar[0] != null) {
							mapDebitoACobrarProcessar
									.putAll((Map) arrayDadosPagamentoDebitoACobrar[0]);
						}

						if (arrayDadosPagamentoDebitoACobrar[1] != null) {
							Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoDebitoACobrar[1];

							if (arrayColecoesPagamentosAtualizar[0] != null) {
								mapPagamentoValorNaoConfere
										.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
							}

							if (arrayColecoesPagamentosAtualizar[1] != null) {
								colecaoPagamentoClassificado
										.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
							}
							if (arrayColecoesPagamentosAtualizar[2] != null) {
								colecaoPagamentoEmDuplicidade
										.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
							}
							if (arrayColecoesPagamentosAtualizar[3] != null) {
								colecaoPagamentoAtualizarValorExcedente
										.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
							}
							if (arrayColecoesPagamentosAtualizar[4] != null) {
								colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
										.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
							}

							arrayDadosPagamentoDebitoACobrar = null;
						}
					}
					colecaoConjuntoPagamentos = new ArrayList();
				}

			}

			// Para os pagamentos sem débito a cobrar preenchido
			// (DBAC_ID igual a nulo)
			if (!colecaoPagamentosDebitoACobrarNaoPreenchido.isEmpty()) {

				/*
				 * Para cada conjunto de pagamentos com mesma localidade, mesma
				 * matrícula do imóvel, e mesmo tipo de débito:
				 */
				Iterator iteratorColecaoPagamentosDebitoACobrarNaoPreenchido = colecaoPagamentosDebitoACobrarNaoPreenchido
						.iterator();
				pagamento = null;
				primeiraEntrada = true;
				conjuntoFechado = false;
				DebitoACobrar debitoACobrarConjunto = null;

				colecaoConjuntoPagamentos.clear();

				while (iteratorColecaoPagamentosDebitoACobrarNaoPreenchido
						.hasNext()) {

					pagamentoArray = (Object[]) iteratorColecaoPagamentosDebitoACobrarNaoPreenchido
							.next();


					if (pagamentoArray[1] != null) {
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) pagamentoArray[1]);
					} else {
						documentoTipo = null;
					}

					if (pagamentoArray[2] != null) {
						localidade = new Localidade();
						localidade.setId((Integer) pagamentoArray[2]);
					} else {
						localidade = null;
					}

					if (pagamentoArray[3] != null) {
						imovel = new Imovel();
						imovel.setId((Integer) pagamentoArray[3]);
					} else {
						imovel = null;
					}

					if (pagamentoArray[4] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) pagamentoArray[4]);
					} else {
						pagamentoSituacaoAtual = null;
					}

					pagamento = (Pagamento) pagamentoArray[0];
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setLocalidade(localidade);
					pagamento.setImovel(imovel);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);

					if (!primeiraEntrada) {

						if ((localidadeAnterior == null && pagamento
								.getLocalidade() == null)
								|| (localidadeAnterior != null
										&& pagamento.getLocalidade() != null && localidadeAnterior
										.getId().equals(
												pagamento.getLocalidade()
														.getId()))) {

							if ((imovelAnterior == null && pagamento
									.getImovel() == null)
									|| (imovelAnterior != null
											&& pagamento.getImovel() != null && imovelAnterior
											.getId().equals(
													pagamento.getImovel()
															.getId()))) {

								if ((debitoTipoAnterior == null && pagamento
										.getDebitoTipo() == null)
										|| (debitoTipoAnterior != null
												&& pagamento.getDebitoTipo() != null && debitoTipoAnterior
												.getId()
												.equals(
														pagamento
																.getDebitoTipo()
																.getId()))) {

									colecaoConjuntoPagamentos.add(pagamento);

								} else {
									conjuntoFechado = true;
								}
							} else {
								conjuntoFechado = true;
							}
						} else {
							conjuntoFechado = true;
						}

					} else {
						primeiraEntrada = false;
						colecaoConjuntoPagamentos.add(pagamento);
					}

					if (conjuntoFechado) {

						/*
						 * [SF0005] Selecionar Débito a Cobrar pela Localidade,
						 * Imóvel e Tipo de Débito
						 */
						debitoACobrarConjunto = this
								.selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(
										imovelAnterior, debitoTipoAnterior,
										anoMesFaturamento);

						/*
						 * Caso o débito a cobrar não seja encontrado (retorno
						 * nulo do [SB0005]) e a situação atual (PGST_IDATUAL)
						 * não corresponda a baixar valor excedente (tabela
						 * PAGAMENTO_SITUACAO), atualizar a situação atual dos
						 * pagamentos (PGST_IDATUAL) com valor correspondente a
						 * documento inexistente (tabela PAGAMENTO_SITUACAO) e o
						 * valor excedente (PGMT_VLEXCEDENTE) com o valor do
						 * pagamento
						 */
						if (debitoACobrarConjunto == null) {

							iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos
									.iterator();

							while (iteratorColecaoConjuntoPagamentos.hasNext()) {

								pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
										.next();

								if (pagamentoNullOuDiferenteDeValorABaixar(pagamentoConjunto)) {

									pagamentoConjunto
											.setValorExcedente(pagamentoConjunto
													.getValorPagamento());

									colecaoPagamentosAtualizar
											.add(pagamentoConjunto);
								}
							}
						} else {
							iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos
									.iterator();
							/*
							 * Caso o ano/mês de referência contábil do débito a
							 * cobrar seja maior ou igual ao ano/mês de
							 * referência do faturamento atualizar a situação
							 * atual dos pagamentos com o valor correspondente a
							 * documento inexistente ,o valor excedente com o
							 * valor do pagamento e a identificação do débito a
							 * cobrar no pagamento.
							 */
							if (!(debitoACobrarConjunto
									.getAnoMesReferenciaContabil().compareTo(
											anoMesFaturamento) == -1)) {
								while (iteratorColecaoConjuntoPagamentos
										.hasNext()) {

									pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();
									pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
									
				                    DebitoACobrarGeral debitoACobrarGeral = null;
				                    
									if(debitoACobrarConjunto != null){
					                    
										debitoACobrarGeral = new DebitoACobrarGeral();
										debitoACobrarGeral.setId(debitoACobrarConjunto.getId());
										debitoACobrarGeral.setDebitoACobrar(debitoACobrarConjunto);
									}
									
									pagamentoConjunto.setDebitoACobrarGeral(debitoACobrarGeral);
									
									colecaoPagamentosAtualizar.add(pagamentoConjunto);
								}
							} else {

								// [SF0006] Processar Pagamento de Débito a
								// Cobrar
								arrayDadosPagamentoDebitoACobrar = this
										.processarPagamentoDebitoACobrar(
												debitoACobrarConjunto,
												colecaoConjuntoPagamentos);

								if (arrayDadosPagamentoDebitoACobrar != null) {
									if (arrayDadosPagamentoDebitoACobrar[0] != null) {
										mapDebitoACobrarProcessar
												.putAll((Map) arrayDadosPagamentoDebitoACobrar[0]);
									}

									if (arrayDadosPagamentoDebitoACobrar[1] != null) {
										Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoDebitoACobrar[1];

										if (arrayColecoesPagamentosAtualizar[0] != null) {
											mapPagamentoValorNaoConfere
													.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
										}

										if (arrayColecoesPagamentosAtualizar[1] != null) {
											colecaoPagamentoClassificado
													.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
										}
										if (arrayColecoesPagamentosAtualizar[2] != null) {
											colecaoPagamentoEmDuplicidade
													.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
										}
										if (arrayColecoesPagamentosAtualizar[3] != null) {
											colecaoPagamentoAtualizarValorExcedente
													.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
										}

										if (arrayColecoesPagamentosAtualizar[4] != null) {
											colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
													.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
										}

										arrayDadosPagamentoDebitoACobrar = null;
									}
								}
							}
						}

						colecaoConjuntoPagamentos = new ArrayList();
						colecaoConjuntoPagamentos.add(pagamento);
					}

					localidadeAnterior = pagamento.getLocalidade();
					imovelAnterior = pagamento.getImovel();
					debitoTipoAnterior = pagamento.getDebitoTipo();
				}

				/*
				 * Último registro
				 */
				if (!colecaoConjuntoPagamentos.isEmpty()) {

					/*
					 * [SF0005] Selecionar Débito a Cobrar pela Localidade,
					 * Imóvel e Tipo de Débito
					 */
					debitoACobrarConjunto = this
							.selecionarDebitoACobrarPelaLocalidadeImovelDebitoTipo(
									imovelAnterior, debitoTipoAnterior,
									anoMesFaturamento);

					/*
					 * Caso o débito a cobrar não seja encontrado (retorno nulo
					 * do [SB0005]) e a situação atual (PGST_IDATUAL) não
					 * corresponda a baixar valor excedente (tabela
					 * PAGAMENTO_SITUACAO), atualizar a situação atual dos
					 * pagamentos (PGST_IDATUAL) com valor correspondente a
					 * documento inexistente (tabela PAGAMENTO_SITUACAO) e o
					 * valor excedente (PGMT_VLEXCEDENTE) com o valor do
					 * pagamento
					 */
					if (debitoACobrarConjunto == null) {

						iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos
								.iterator();

						while (iteratorColecaoConjuntoPagamentos.hasNext()) {

							pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
									.next();

							if (pagamentoNullOuDiferenteDeValorABaixar(pagamentoConjunto)) {

								pagamentoConjunto
										.setValorExcedente(pagamentoConjunto
												.getValorPagamento());

								colecaoPagamentosAtualizar
										.add(pagamentoConjunto);
							}
						}
					} else {
						iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos
								.iterator();
						/*
						 * Caso o ano/mês de referência contábil do débito a
						 * cobrar seja maior ou igual ao ano/mês de referência
						 * do faturamento atualizar a situação atual dos
						 * pagamentos com o valor correspondente a documento
						 * inexistente ,o valor excedente com o valor do
						 * pagamento e a identificação do débito a cobrar no
						 * pagamento.
						 */
						if (!(debitoACobrarConjunto
								.getAnoMesReferenciaContabil().compareTo(
										anoMesFaturamento) == -1)) {
							while (iteratorColecaoConjuntoPagamentos.hasNext()) {

								pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos.next();
								pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
								
			                    DebitoACobrarGeral debitoACobrarGeral = null;
			                    
								if(debitoACobrarConjunto != null){
				                    
									debitoACobrarGeral = new DebitoACobrarGeral();
									debitoACobrarGeral.setId(debitoACobrarConjunto.getId());
									debitoACobrarGeral.setDebitoACobrar(debitoACobrarConjunto);
								}
								
								pagamentoConjunto.setDebitoACobrarGeral(debitoACobrarGeral);
								
								colecaoPagamentosAtualizar.add(pagamentoConjunto);
							}
						} else {

							// [SF0006] Processar Pagamento de Débito a Cobrar
							arrayDadosPagamentoDebitoACobrar = this
									.processarPagamentoDebitoACobrar(
											debitoACobrarConjunto,
											colecaoConjuntoPagamentos);

							if (arrayDadosPagamentoDebitoACobrar != null) {
								if (arrayDadosPagamentoDebitoACobrar[0] != null) {
									mapDebitoACobrarProcessar
											.putAll((Map) arrayDadosPagamentoDebitoACobrar[0]);
								}

								if (arrayDadosPagamentoDebitoACobrar[1] != null) {
									Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoDebitoACobrar[1];

									if (arrayColecoesPagamentosAtualizar[0] != null) {
										mapPagamentoValorNaoConfere
												.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
									}

									if (arrayColecoesPagamentosAtualizar[1] != null) {
										colecaoPagamentoClassificado
												.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
									}
									if (arrayColecoesPagamentosAtualizar[2] != null) {
										colecaoPagamentoEmDuplicidade
												.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
									}
									if (arrayColecoesPagamentosAtualizar[3] != null) {
										colecaoPagamentoAtualizarValorExcedente
												.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
									}
									if (arrayColecoesPagamentosAtualizar[4] != null) {
										colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
												.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
									}

									arrayDadosPagamentoDebitoACobrar = null;
								}
							}
						}
					}
					colecaoConjuntoPagamentos = new ArrayList();
				}
			}
		}

		/**
		 * Caso a coleção de pagamentos para atualizar não esteja vazia
		 * atualizar a situação e o valor excedente do pagamento.
		 */
		if (colecaoPagamentosAtualizar != null
				&& !colecaoPagamentosAtualizar.isEmpty()) {
			try {

				repositorioArrecadacao
						.atualizarSituacaoEValorExcedentePagamento(
								colecaoPagamentosAtualizar,
								PagamentoSituacao.DOCUMENTO_INEXISTENTE);
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}
		}

		/**
		 * Retorna o array contendo : 0 - Map de pagamentos para processar com
		 * seu respectivo débito a cobrar. 1 - Map de pagamentos para atualizar
		 * a situação com valor igual a valor não confere. 2 - Coleção de
		 * pagamentos para atualizar a situação com valor igual a pagamento
		 * classificado. 3 - Coleção de pagamentos para atualizar a situação com
		 * valor igual a em duplicidade. 4 - Coleção de pagamentos para
		 * atualizar o valor excedente.
		 */
		retorno[0] = mapDebitoACobrarProcessar;
		retorno[1] = mapPagamentoValorNaoConfere;
		retorno[2] = colecaoPagamentoClassificado;
		retorno[3] = colecaoPagamentoEmDuplicidade;
		retorno[4] = colecaoPagamentoAtualizarValorExcedente;
		retorno[5] = colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo;

		return retorno;

		/*
		 * ==============================================================================================
		 * ==============================================================================================
		 * FIM pagamentos com tipo de documento (DOPT_ID) com valor
		 * correspondente a DÉBITO A COBRAR:
		 * ==============================================================================================
		 */
	}

	/**
	 * Classifica os pagamentos para tipo de documento igual a guia de pagamento
	 * para guia preenchida ou não preenchida.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre, Pedro Alexandre
	 * @date 29/11/2006, 02/10/2007
	 * 
	 * @param colecaoPagamentosGuiaPagamentoPreenchida
	 * @param colecaoPagamentosGuiaPagamentoNaoPreenchida
	 * @param anoMesFaturamento
	 * 
	 * @throws ControladorException
	 */
	protected Object[] classificarPagamentosGuiaPagamento(
			Collection colecaoPagamentosGuiaPagamentoPreenchida,
			Collection colecaoPagamentosGuiaPagamentoNaoPreenchida,
			Integer anoMesFaturamento) throws ControladorException {

		/**
		 * Declaração de variáveis
		 */
		Object[] retorno = new Object[6];
		Object[] arrayDadosPagamentoGuia = null;
		Collection colecaoPagamentosAtualizar = new ArrayList();
        Collection colecaoPagamentosAtualizarDocumentoAContabilizar = new ArrayList();
		Pagamento pagamento = null;
		Collection colecaoConjuntoPagamentos = new ArrayList();
		Iterator iteratorColecaoConjuntoPagamentos = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Pagamento pagamentoConjunto = null;
		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		DebitoTipo debitoTipoAnterior = null;
		DebitoTipo debitoTipo = null;
		Cliente cliente = null;
		Cliente clienteAnterior = null;
		Object[] pagamentoArray = null;
		DocumentoTipo documentoTipo = null;
		Localidade localidade = null;
		Imovel imovel = null;
		PagamentoSituacao pagamentoSituacaoAtual = null;
		Integer idGuiaPagamento = null;
		BigDecimal valorPagamento = null;
		Date dataPagamento = null;
		Integer anoMesReferenciaPagamento = null;
		BigDecimal valorDebitoGuiaPagamento = null;
		Map mapGuiaPagamentoProcessar = new HashMap();
		Map mapPagamentoValorNaoConfere = new HashMap();
		Collection colecaoPagamentoClassificado = new ArrayList();
		Collection colecaoPagamentoEmDuplicidade = new ArrayList();
		Collection colecaoPagamentoAtualizarValorExcedente = new ArrayList();
		Collection colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo = new ArrayList();

		/*
		 * ==============================================================================================
		 * Para os pagamentos com tipo de documento (DOPT_ID) com o valor
		 * correspondente a GUIA DE PAGAMENTO:
		 * ==============================================================================================
		 */
		if ((colecaoPagamentosGuiaPagamentoPreenchida != null && !colecaoPagamentosGuiaPagamentoPreenchida
				.isEmpty())
				|| (colecaoPagamentosGuiaPagamentoNaoPreenchida != null && !colecaoPagamentosGuiaPagamentoNaoPreenchida
						.isEmpty())) {

			// Para os pagamentos com guia de pagamento
			// preenchida
			// (GPAG_ID diferente de nulo)
			if (!colecaoPagamentosGuiaPagamentoPreenchida.isEmpty()) {

				// Para cada conjunto de pagamentos com mesma
				// guia de
				// pagamento (GPAG_ID):
				Iterator iteratorColecaoPagamentosGuiaPagamentoPreenchida = colecaoPagamentosGuiaPagamentoPreenchida
						.iterator();
				pagamento = null;
				primeiraEntrada = true;
				conjuntoFechado = false;
				debitoTipoAnterior = null;
				GuiaPagamento guiaPagamentoAnterior = null;
				GuiaPagamento guiaPagamento = null;
				colecaoConjuntoPagamentos = new ArrayList();

				/**
				 * Laço para criar os pagamentos e classificar por conjuntos.
				 */
				while (iteratorColecaoPagamentosGuiaPagamentoPreenchida
						.hasNext()) {

					pagamentoArray = (Object[]) iteratorColecaoPagamentosGuiaPagamentoPreenchida
							.next();

					if (pagamentoArray[1] != null) {
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) pagamentoArray[1]);
					} else {
						documentoTipo = null;
					}

					if (pagamentoArray[2] != null) {
						localidade = new Localidade();
						localidade.setId((Integer) pagamentoArray[2]);
					} else {
						localidade = null;
					}

					if (pagamentoArray[3] != null) {
						imovel = new Imovel();
						imovel.setId((Integer) pagamentoArray[3]);
					} else {
						imovel = null;
					}

					if (pagamentoArray[4] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) pagamentoArray[4]);
					} else {
						pagamentoSituacaoAtual = null;
					}

					if (pagamentoArray[5] != null) {
						idGuiaPagamento = (Integer) pagamentoArray[5];
						guiaPagamento = new GuiaPagamento();
						guiaPagamento.setId(idGuiaPagamento);
					} else {
						idGuiaPagamento = null;
					}

					if (pagamentoArray[6] != null) {
						valorPagamento = (BigDecimal) pagamentoArray[6];
					} else {
						valorPagamento = null;
					}

					if (pagamentoArray[7] != null) {
						dataPagamento = (Date) pagamentoArray[7];
					} else {
						dataPagamento = null;
					}

					if (pagamentoArray[8] != null) {
						anoMesReferenciaPagamento = (Integer) pagamentoArray[8];
					} else {
						anoMesReferenciaPagamento = null;
					}

					if (pagamentoArray[9] != null) {
						valorDebitoGuiaPagamento = (BigDecimal) pagamentoArray[9];
					} else {
						valorDebitoGuiaPagamento = null;
					}

					pagamento = new Pagamento();
					pagamento.setId((Integer) pagamentoArray[0]);
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setLocalidade(localidade);
					pagamento.setImovel(imovel);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
					guiaPagamento.setValorDebito(valorDebitoGuiaPagamento);
					pagamento.setGuiaPagamento(guiaPagamento);
					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento
							.setAnoMesReferenciaPagamento(anoMesReferenciaPagamento);

					if (!primeiraEntrada) {

						if ((guiaPagamentoAnterior == null && pagamento
								.getGuiaPagamento() == null)
								|| (guiaPagamentoAnterior != null
										&& pagamento.getGuiaPagamento() != null && guiaPagamentoAnterior
										.getId().equals(
												pagamento.getGuiaPagamento()
														.getId()))) {

							if ((localidadeAnterior == null && pagamento
									.getLocalidade() == null)
									|| (localidadeAnterior != null
											&& pagamento.getLocalidade() != null && localidadeAnterior
											.getId().equals(
													pagamento.getLocalidade()
															.getId()))) {

								if ((imovelAnterior == null && pagamento
										.getImovel() == null)
										|| (imovelAnterior != null
												&& pagamento.getImovel() != null && imovelAnterior
												.getId().equals(
														pagamento.getImovel()
																.getId()))) {

									if ((clienteAnterior == null && pagamento
											.getCliente() == null)
											|| (clienteAnterior != null
													&& pagamento.getCliente() != null && clienteAnterior
													.getId()
													.equals(
															pagamento
																	.getCliente()
																	.getId()))) {

										if ((debitoTipoAnterior == null && pagamento
												.getDebitoTipo() == null)
												|| (debitoTipoAnterior != null
														&& pagamento
																.getDebitoTipo() != null && debitoTipoAnterior
														.getId()
														.equals(
																pagamento
																		.getDebitoTipo()
																		.getId()))) {

											colecaoConjuntoPagamentos
													.add(pagamento);
											conjuntoFechado = false;
										} else {
											conjuntoFechado = true;
										}
									} else {
										conjuntoFechado = true;
									}
								} else {
									conjuntoFechado = true;
								}
							} else {
								conjuntoFechado = true;
							}
						} else {
							conjuntoFechado = true;
						}

					} else {
						primeiraEntrada = false;
						colecaoConjuntoPagamentos.add(pagamento);
					}

					/**
					 * Caso o conjunto de pagamentos para um mesmo imóvel esteja
					 * fechado.
					 */
					if (conjuntoFechado) {

						// [SF0004] Processar Pagamento de Guia de Pagamento
						arrayDadosPagamentoGuia = this
								.processarPagamentoGuiaPagamento(
										guiaPagamentoAnterior,
										colecaoConjuntoPagamentos);

						if (arrayDadosPagamentoGuia != null) {
							if (arrayDadosPagamentoGuia[0] != null) {
								mapGuiaPagamentoProcessar
										.putAll((Map) arrayDadosPagamentoGuia[0]);
							}

							if (arrayDadosPagamentoGuia[1] != null) {
								Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoGuia[1];

								if (arrayColecoesPagamentosAtualizar[0] != null) {
									mapPagamentoValorNaoConfere
											.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
								}

								if (arrayColecoesPagamentosAtualizar[1] != null) {
									colecaoPagamentoClassificado
											.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
								}

								if (arrayColecoesPagamentosAtualizar[2] != null) {
									colecaoPagamentoEmDuplicidade
											.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
								}

								if (arrayColecoesPagamentosAtualizar[3] != null) {
									colecaoPagamentoAtualizarValorExcedente
											.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
								}

								if (arrayColecoesPagamentosAtualizar[4] != null) {
									colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
											.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
								}
								arrayDadosPagamentoGuia = null;
							}
						}
						colecaoConjuntoPagamentos = new ArrayList();
						colecaoConjuntoPagamentos.add(pagamento);
					}

					guiaPagamentoAnterior = pagamento.getGuiaPagamento();

					localidadeAnterior = pagamento.getLocalidade();
					imovelAnterior = pagamento.getImovel();
					clienteAnterior = pagamento.getCliente();
					debitoTipoAnterior = pagamento.getDebitoTipo();

				}

				/*
				 * Último registro
				 */
				if (!colecaoConjuntoPagamentos.isEmpty()) {

					// [SF0004] Processar Pagamento de Guia de Pagamento
					arrayDadosPagamentoGuia = this
							.processarPagamentoGuiaPagamento(
									guiaPagamentoAnterior,
									colecaoConjuntoPagamentos);

					if (arrayDadosPagamentoGuia != null) {
						if (arrayDadosPagamentoGuia[0] != null) {
							mapGuiaPagamentoProcessar
									.putAll((Map) arrayDadosPagamentoGuia[0]);
						}

						if (arrayDadosPagamentoGuia[1] != null) {
							Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoGuia[1];

							if (arrayColecoesPagamentosAtualizar[0] != null) {
								mapPagamentoValorNaoConfere
										.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
							}

							if (arrayColecoesPagamentosAtualizar[1] != null) {
								colecaoPagamentoClassificado
										.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
							}

							if (arrayColecoesPagamentosAtualizar[2] != null) {
								colecaoPagamentoEmDuplicidade
										.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
							}

							if (arrayColecoesPagamentosAtualizar[3] != null) {
								colecaoPagamentoAtualizarValorExcedente
										.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
							}

							if (arrayColecoesPagamentosAtualizar[4] != null) {
								colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
										.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
							}
							arrayDadosPagamentoGuia = null;
						}
					}
				}
			}

			// Para os pagamentos sem guia de pagamento
			// preenchida
			// (GPAG_ID igual a nulo)
			if (!colecaoPagamentosGuiaPagamentoNaoPreenchida.isEmpty()) {

				/*
				 * Para cada conjunto de pagamentos com mesma localidade, mesma
				 * matrícula do imóvel, mesmo código de cliente e mesmo tipo de
				 * débito:
				 */
				Iterator iteratorColecaoPagamentosGuiaPagamentoNaoPreenchida = colecaoPagamentosGuiaPagamentoNaoPreenchida
						.iterator();
				pagamento = null;
				primeiraEntrada = true;
				conjuntoFechado = false;
				clienteAnterior = null;
				localidadeAnterior = null;
				debitoTipoAnterior = null;
				imovelAnterior = null;

				GuiaPagamento guiaPagamentoConjunto = null;
				cliente = null;
				debitoTipo = null;
				colecaoConjuntoPagamentos = new ArrayList();

				while (iteratorColecaoPagamentosGuiaPagamentoNaoPreenchida
						.hasNext()) {

					pagamentoArray = (Object[]) iteratorColecaoPagamentosGuiaPagamentoNaoPreenchida
							.next();

					if (pagamentoArray[1] != null) {
						documentoTipo = new DocumentoTipo();
						documentoTipo.setId((Integer) pagamentoArray[1]);
					} else {
						documentoTipo = null;
					}

					if (pagamentoArray[2] != null) {
						localidade = new Localidade();
						localidade.setId((Integer) pagamentoArray[2]);
					} else {
						localidade = null;
					}

					if (pagamentoArray[3] != null) {
						imovel = new Imovel();
						imovel.setId((Integer) pagamentoArray[3]);
					} else {
						imovel = null;
					}

					if (pagamentoArray[4] != null) {
						pagamentoSituacaoAtual = new PagamentoSituacao();
						pagamentoSituacaoAtual
								.setId((Integer) pagamentoArray[4]);
					} else {
						pagamentoSituacaoAtual = null;
					}

					if (pagamentoArray[5] != null) {
						cliente = new Cliente();
						cliente.setId((Integer) pagamentoArray[5]);
					} else {
						cliente = null;
					}

					if (pagamentoArray[6] != null) {
						debitoTipo = new DebitoTipo();
						debitoTipo.setId((Integer) pagamentoArray[6]);
					} else {
						debitoTipo = null;
					}

					if (pagamentoArray[7] != null) {
						valorPagamento = (BigDecimal) pagamentoArray[7];
					} else {
						valorPagamento = null;
					}

					if (pagamentoArray[8] != null) {
						dataPagamento = (Date) pagamentoArray[8];
					} else {
						dataPagamento = null;
					}

					if (pagamentoArray[9] != null) {
						anoMesReferenciaPagamento = (Integer) pagamentoArray[9];
					} else {
						anoMesReferenciaPagamento = null;
					}

					pagamento = new Pagamento();
					pagamento.setId((Integer) pagamentoArray[0]);
					pagamento.setDocumentoTipo(documentoTipo);
					pagamento.setLocalidade(localidade);
					pagamento.setImovel(imovel);
					pagamento.setPagamentoSituacaoAtual(pagamentoSituacaoAtual);
					pagamento.setCliente(cliente);
					pagamento.setDebitoTipo(debitoTipo);
					pagamento.setValorPagamento(valorPagamento);
					pagamento.setDataPagamento(dataPagamento);
					pagamento
							.setAnoMesReferenciaPagamento(anoMesReferenciaPagamento);

					if (!primeiraEntrada) {

						if ((localidadeAnterior == null && pagamento
								.getLocalidade() == null)
								|| (localidadeAnterior != null
										&& pagamento.getLocalidade() != null && localidadeAnterior
										.getId().equals(
												pagamento.getLocalidade()
														.getId()))) {

							if ((imovelAnterior == null && pagamento
									.getImovel() == null)
									|| (imovelAnterior != null
											&& pagamento.getImovel() != null && imovelAnterior
											.getId().equals(
													pagamento.getImovel()
															.getId()))) {

								if ((clienteAnterior == null && pagamento
										.getCliente() == null)
										|| (clienteAnterior != null
												&& pagamento.getCliente() != null && clienteAnterior
												.getId().equals(
														pagamento.getCliente()
																.getId()))) {

									if ((debitoTipoAnterior == null && pagamento
											.getDebitoTipo() == null)
											|| (debitoTipoAnterior != null
													&& pagamento
															.getDebitoTipo() != null && debitoTipoAnterior
													.getId()
													.equals(
															pagamento
																	.getDebitoTipo()
																	.getId()))) {

										colecaoConjuntoPagamentos
												.add(pagamento);
										conjuntoFechado = false;
									} else {
										conjuntoFechado = true;
									}
								} else {
									conjuntoFechado = true;
								}
							} else {
								conjuntoFechado = true;
							}
						} else {
							conjuntoFechado = true;
						}

					} else {
						primeiraEntrada = false;
						colecaoConjuntoPagamentos.add(pagamento);
					}

					if (conjuntoFechado) {

						/*
						 * [SF0003] Selecionar Guia de Pagamento pela
						 * Localidade, Imóvel, Cliente, Tipo de Débito
						 */

						guiaPagamentoConjunto = this
								.selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(
										imovelAnterior, clienteAnterior,
										debitoTipoAnterior, anoMesFaturamento);

						/*
						 * Caso a guia de pagamento não seja encontrada (retorno
						 * nulo do [SB0003]) e a situação atual (PGST_IDATUAL)
						 * não corresponda a baixar valor excedente (tabela
						 * PAGAMENTO_SITUACAO), atualizar a situação atual dos
						 * pagamentos (PGST_IDATUAL) com valor correspondente a
						 * documento inexistente (tabela PAGAMENTO_SITUACAO) e o
						 * valor excedente (PGMT_VLEXCEDENTE) com o valor do
						 * pagamento
						 */

						iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos
								.iterator();

						if (guiaPagamentoConjunto == null) {

							while (iteratorColecaoConjuntoPagamentos.hasNext()) {
								pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
										.next();
								if (pagamentoNullOuDiferenteDeValorABaixar(pagamentoConjunto)) {

									pagamentoConjunto
											.setValorExcedente(pagamentoConjunto
													.getValorPagamento());
									colecaoPagamentosAtualizar
											.add(pagamentoConjunto);
								}
							}
						} else {
							/*
							 * Caso o ano/mês de referência contábil da guia de
							 * pagamento seja maior ou igual ao ano/mês de
							 * referência do faturamento atualizar a situação
							 * atual dos pagamentos com o valor correspondente a
							 * documento inexistente, o valor excedente com o
							 * valor do pagamento e a identificação da guia de
							 * pagamento no pagamento.
							 */
							if (!(guiaPagamentoConjunto
									.getAnoMesReferenciaContabil().compareTo(
											anoMesFaturamento) == -1)) {
								while (iteratorColecaoConjuntoPagamentos
										.hasNext()) {
									pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
											.next();
									pagamentoConjunto
											.setGuiaPagamento(guiaPagamentoConjunto);
									pagamentoConjunto
											.setValorExcedente(pagamentoConjunto
													.getValorPagamento());
									colecaoPagamentosAtualizar
											.add(pagamentoConjunto);
								}
							} else {
								// [SF0004] Processar Pagamento de Guia de
								// Pagamento
								arrayDadosPagamentoGuia = this
										.processarPagamentoGuiaPagamento(
												guiaPagamentoConjunto,
												colecaoConjuntoPagamentos);

								if (arrayDadosPagamentoGuia != null) {
									if (arrayDadosPagamentoGuia[0] != null) {
										mapGuiaPagamentoProcessar
												.putAll((Map) arrayDadosPagamentoGuia[0]);
									}

									if (arrayDadosPagamentoGuia[1] != null) {
										Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoGuia[1];

										if (arrayColecoesPagamentosAtualizar[0] != null) {
											mapPagamentoValorNaoConfere
													.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
										}

										if (arrayColecoesPagamentosAtualizar[1] != null) {
											colecaoPagamentoClassificado
													.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
										}

										if (arrayColecoesPagamentosAtualizar[2] != null) {
											colecaoPagamentoEmDuplicidade
													.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
										}

										if (arrayColecoesPagamentosAtualizar[3] != null) {
											colecaoPagamentoAtualizarValorExcedente
													.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
										}

										if (arrayColecoesPagamentosAtualizar[4] != null) {
											colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
													.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
										}
										arrayDadosPagamentoGuia = null;
									}
								}
							}
						}

						colecaoConjuntoPagamentos = new ArrayList();
						colecaoConjuntoPagamentos.add(pagamento);
					}

					localidadeAnterior = pagamento.getLocalidade();
					imovelAnterior = pagamento.getImovel();
					clienteAnterior = pagamento.getCliente();
					debitoTipoAnterior = pagamento.getDebitoTipo();
				}

				/*
				 * Último registro
				 */
				if (!colecaoConjuntoPagamentos.isEmpty()) {

					/*
					 * [SF0003] Selecionar Guia de Pagamento pela Localidade,
					 * Imóvel, Cliente, Tipo de Débito
					 */
					guiaPagamentoConjunto = this
							.selecionarGuiaPagamentoPelaLocalidadeImovelClienteDebitoTipo(
									imovelAnterior, clienteAnterior,
									debitoTipoAnterior, anoMesFaturamento);

					/*
					 * Caso a guia de pagamento não seja encontrada (retorno
					 * nulo do [SB0003]) e a situação atual (PGST_IDATUAL) não
					 * corresponda a baixar valor excedente (tabela
					 * PAGAMENTO_SITUACAO), atualizar a situação atual dos
					 * pagamentos (PGST_IDATUAL) com valor correspondente a
					 * documento inexistente (tabela PAGAMENTO_SITUACAO) e o
					 * valor excedente (PGMT_VLEXCEDENTE) com o valor do
					 * pagamento
					 */
					iteratorColecaoConjuntoPagamentos = colecaoConjuntoPagamentos
							.iterator();

					if (guiaPagamentoConjunto == null) {

						while (iteratorColecaoConjuntoPagamentos.hasNext()) {
							pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
									.next();

							if (pagamentoNullOuDiferenteDeValorABaixar(pagamentoConjunto)) {

								pagamentoConjunto
										.setValorExcedente(pagamentoConjunto
												.getValorPagamento());
								colecaoPagamentosAtualizar
										.add(pagamentoConjunto);
							}
						}
					} else {

						/*
						 * Caso o ano/mês de referência contábil da guia de
						 * pagamento seja maior ou igual ao ano/mês de
						 * referência do faturamento atualizar a situação atual
						 * dos pagamentos com o valor correspondente a documento
						 * inexistente, o valor excedente com o valor do
						 * pagamento e a identificação da guia de pagamento no
						 * pagamento.
						 */
						if (!(guiaPagamentoConjunto
								.getAnoMesReferenciaContabil().compareTo(
										anoMesFaturamento) == -1)) {
							while (iteratorColecaoConjuntoPagamentos.hasNext()) {
								pagamentoConjunto = (Pagamento) iteratorColecaoConjuntoPagamentos
										.next();
								pagamentoConjunto
										.setGuiaPagamento(guiaPagamentoConjunto);
								pagamentoConjunto
										.setValorExcedente(pagamentoConjunto
												.getValorPagamento());
                                colecaoPagamentosAtualizarDocumentoAContabilizar
                                    .add(pagamentoConjunto);
							}
						} else {
							// [SF0004] Processar Pagamento de Guia de Pagamento
							arrayDadosPagamentoGuia = this
									.processarPagamentoGuiaPagamento(
											guiaPagamentoConjunto,
											colecaoConjuntoPagamentos);

							if (arrayDadosPagamentoGuia != null) {
								if (arrayDadosPagamentoGuia[0] != null) {
									mapGuiaPagamentoProcessar
											.putAll((Map) arrayDadosPagamentoGuia[0]);
								}

								if (arrayDadosPagamentoGuia[1] != null) {
									Object[] arrayColecoesPagamentosAtualizar = (Object[]) arrayDadosPagamentoGuia[1];

									if (arrayColecoesPagamentosAtualizar[0] != null) {
										mapPagamentoValorNaoConfere
												.putAll((Map) arrayColecoesPagamentosAtualizar[0]);
									}

									if (arrayColecoesPagamentosAtualizar[1] != null) {
										colecaoPagamentoClassificado
												.addAll((Collection) arrayColecoesPagamentosAtualizar[1]);
									}

									if (arrayColecoesPagamentosAtualizar[2] != null) {
										colecaoPagamentoEmDuplicidade
												.addAll((Collection) arrayColecoesPagamentosAtualizar[2]);
									}

									if (arrayColecoesPagamentosAtualizar[3] != null) {
										colecaoPagamentoAtualizarValorExcedente
												.addAll((Collection) arrayColecoesPagamentosAtualizar[3]);
									}

									if (arrayColecoesPagamentosAtualizar[4] != null) {
										colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo
												.addAll((Collection) arrayColecoesPagamentosAtualizar[4]);
									}

									arrayDadosPagamentoGuia = null;
								}
							}
						}
					}
					colecaoConjuntoPagamentos = new ArrayList();
				}
			}
		}

		/**
		 * Caso a coleção de pagamentos para atualizar não esteja nula nem
		 * esteja vazia Atualiza a situação e o valor excedente do pagamento.
		 */
		if (colecaoPagamentosAtualizar != null
				&& !colecaoPagamentosAtualizar.isEmpty()) {
			try {
				repositorioArrecadacao
						.atualizarSituacaoEValorExcedentePagamento(
								colecaoPagamentosAtualizar,
								PagamentoSituacao.FATURA_INEXISTENTE);
			} catch (ErroRepositorioException ex) {
				throw new ControladorException("erro.sistema", ex);
			}
		}
        
		// Caso seja necessário atualizar pagamentos com documentos a contabilizar
        // Realiza o update
        if (colecaoPagamentosAtualizarDocumentoAContabilizar != null
                && !colecaoPagamentosAtualizarDocumentoAContabilizar.isEmpty()) {
            try {
                repositorioArrecadacao
                        .atualizarSituacaoEValorExcedentePagamento(
                                colecaoPagamentosAtualizarDocumentoAContabilizar,
                                PagamentoSituacao.PAGAMENTO_CLASSIFICADO);
            } catch (ErroRepositorioException ex) {
                throw new ControladorException("erro.sistema", ex);
            }
        }
        

		/**
		 * Monta o array de retorno com : 0 - Map de pagamentos de guia de
		 * pagamento para processar. 1 - Coleção de pagamentos para atualizar a
		 * situação igual a valor não confere. 2 - Coleção de pagamentos para
		 * atualizar a situação igual a pagamento classificado. 3 - Coleção de
		 * pagamentos para atualizar a situação igual a pagamento em
		 * duplicidade. 4 - Coleção de pagamentos para atualizar o valor
		 * excedente.
		 */
		retorno[0] = mapGuiaPagamentoProcessar;
		retorno[1] = mapPagamentoValorNaoConfere;
		retorno[2] = colecaoPagamentoClassificado;
		retorno[3] = colecaoPagamentoEmDuplicidade;
		retorno[4] = colecaoPagamentoAtualizarValorExcedente;
		retorno[5] = colecaoPagamentoValorNaoConfereIdentificadorDocumentoNulo;

		return retorno;
		/*
		 * ==============================================================================================
		 * ==============================================================================================
		 * FIM pagamentos com tipo de documento (DOPT_ID) com valor
		 * correspondente a GUIA DE PAGAMENTO:
		 * ==============================================================================================
		 */
	}

	/**
	 * Classifica as devoluções em duplicidade ou excesso.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 29/11/2006
	 * 
	 * @param colecaoDevolucoesDuplicidadeExcesso
	 * @throws ControladorException
	 */
	protected void classificarDevolucoesDuplicidadeExcesso(
			Collection colecaoDevolucoesDuplicidadeExcesso)
			throws ControladorException {

		/**
		 * Declaração de variáveis.
		 */
		Devolucao devolucao = null;
		Collection colecaoConjuntoDevolucoes = new ArrayList();
		Iterator iteratorColecaoConjuntoDevolucoes = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Devolucao devolucaoConjunto = null;
		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		Integer anoMesReferenciaDevolucaoAnterior = null;
		String[] idDevolucao = null;
		Object[] devolucaoArray = null;
		Localidade localidade = null;
		Imovel imovel = null;
		GuiaDevolucao guiaDevolucao = null;

		/*
		 * Para as devoluções de contas pagas em duplicidade ou em excesso, ou
		 * seja, aquelas com ano/mês de referência preenchidos
		 * (DEVL_AMREFERENCIADEVOLUCAO com valor diferente de nulo)
		 */
		if (!colecaoDevolucoesDuplicidadeExcesso.isEmpty()) {

			/*
			 * Para cada conjunto de devoluções com mesma localidade, mesma
			 * matrícula do imóvel, e mesmo ano/mês de referência da devolução
			 */
			Iterator iteratorColecaoDevolucoesDuplicidadeExcesso = colecaoDevolucoesDuplicidadeExcesso
					.iterator();

			devolucao = null;
			primeiraEntrada = true;
			conjuntoFechado = false;

			colecaoConjuntoDevolucoes.clear();

			while (iteratorColecaoDevolucoesDuplicidadeExcesso.hasNext()) {

				devolucaoArray = (Object[]) iteratorColecaoDevolucoesDuplicidadeExcesso
						.next();

				if (devolucaoArray[1] != null) {
					localidade = new Localidade();
					localidade.setId((Integer) devolucaoArray[1]);
				} else {
					localidade = null;
				}

				if (devolucaoArray[2] != null) {
					imovel = new Imovel();
					imovel.setId((Integer) devolucaoArray[2]);
				} else {
					imovel = null;
				}

				if (devolucaoArray[3] != null) {
					guiaDevolucao = new GuiaDevolucao();
					guiaDevolucao.setId((Integer) devolucaoArray[3]);
				} else {
					guiaDevolucao = null;
				}

				devolucao = (Devolucao) devolucaoArray[0];
				devolucao.setLocalidade(localidade);
				devolucao.setImovel(imovel);
				devolucao.setGuiaDevolucao(guiaDevolucao);

				if (!primeiraEntrada) {

					if ((localidadeAnterior == null && devolucao
							.getLocalidade() == null)
							|| (localidadeAnterior != null
									&& devolucao.getLocalidade() != null && localidadeAnterior
									.getId().equals(
											devolucao.getLocalidade().getId()))) {

						if ((imovelAnterior == null && devolucao.getImovel() == null)
								|| (imovelAnterior != null
										&& devolucao.getImovel() != null && imovelAnterior
										.getId().equals(
												devolucao.getImovel().getId()))) {

							if ((anoMesReferenciaDevolucaoAnterior == null && devolucao
									.getAnoMesReferenciaDevolucao() == null)
									|| (anoMesReferenciaDevolucaoAnterior != null
											&& devolucao
													.getAnoMesReferenciaDevolucao() != null && anoMesReferenciaDevolucaoAnterior
											.equals(devolucao
													.getAnoMesReferenciaDevolucao()))) {

								colecaoConjuntoDevolucoes.add(devolucao);
								conjuntoFechado = false;

							} else {
								conjuntoFechado = true;
							}
						} else {
							conjuntoFechado = true;
						}
					} else {
						conjuntoFechado = true;
					}

				} else {
					primeiraEntrada = false;
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				if (conjuntoFechado) {

					processarDevolucoesDuplicidadeExcesso(colecaoConjuntoDevolucoes, imovelAnterior, anoMesReferenciaDevolucaoAnterior);

					colecaoConjuntoDevolucoes.clear();
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				localidadeAnterior = devolucao.getLocalidade();
				imovelAnterior = devolucao.getImovel();
				anoMesReferenciaDevolucaoAnterior = devolucao
						.getAnoMesReferenciaDevolucao();
			}

			/*
			 * Último registro
			 */
			if (!colecaoConjuntoDevolucoes.isEmpty()) {
				processarDevolucoesDuplicidadeExcesso(colecaoConjuntoDevolucoes, imovelAnterior, anoMesReferenciaDevolucaoAnterior);
			}
		}
	}

	/**
	 * Clasifica as devoluções cobradas indevidamente.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Pedro Alexandre
	 * @date 29/11/2006
	 * 
	 * @param colecaoDevolucoesCobradasIndevidamente
	 * @throws ControladorException
	 */
	protected void classificarDevolucoesCobradasIndevidamente(
			Collection colecaoDevolucoesCobradasIndevidamente)
			throws ControladorException {

		Devolucao devolucao = null;
		Collection colecaoConjuntoDevolucoes = new ArrayList();
		Iterator iteratorColecaoConjuntoDevolucoes = null;
		boolean conjuntoFechado = false;
		boolean primeiraEntrada = true;
		Devolucao devolucaoConjunto = null;

		Localidade localidadeAnterior = null;
		Imovel imovelAnterior = null;
		DebitoTipo debitoTipoAnterior = null;
		DebitoTipo debitoTipo = null;
		CreditoARealizarGeral creditoARealizarGeral = null;
		Cliente cliente = null;
		Cliente clienteAnterior = null;

		String[] idDevolucao = null;

		Object[] devolucaoArray = null;
		Localidade localidade = null;
		Imovel imovel = null;
		GuiaDevolucao guiaDevolucao = null;

		if (!colecaoDevolucoesCobradasIndevidamente.isEmpty()) {

			Iterator iteratorColecaoDevolucoesCobradasIndevidamente = colecaoDevolucoesCobradasIndevidamente
					.iterator();

			devolucao = null;
			primeiraEntrada = true;
			conjuntoFechado = false;

			colecaoConjuntoDevolucoes.clear();

			while (iteratorColecaoDevolucoesCobradasIndevidamente.hasNext()) {

				devolucaoArray = (Object[]) iteratorColecaoDevolucoesCobradasIndevidamente.next();

				if (devolucaoArray[1] != null) {
					localidade = new Localidade();
					localidade.setId((Integer) devolucaoArray[1]);
				} else {
					localidade = null;
				}

				if (devolucaoArray[2] != null) {
					imovel = new Imovel();
					imovel.setId((Integer) devolucaoArray[2]);
				} else {
					imovel = null;
				}

				if (devolucaoArray[3] != null) {
					guiaDevolucao = new GuiaDevolucao();
					guiaDevolucao.setId((Integer) devolucaoArray[3]);
				} else {
					guiaDevolucao = null;
				}

				if (devolucaoArray[4] != null) {
					cliente = new Cliente();
					cliente.setId((Integer) devolucaoArray[4]);
				} else {
					cliente = null;
				}

				if (devolucaoArray[5] != null) {
					debitoTipo = new DebitoTipo();
					debitoTipo.setId((Integer) devolucaoArray[5]);
				} else {
					debitoTipo = null;
				}

				if (devolucaoArray[6] != null) {
					creditoARealizarGeral = new CreditoARealizarGeral();
					creditoARealizarGeral.setId((Integer) devolucaoArray[6]);
				} else {
					creditoARealizarGeral = null;
				}
				
				
				devolucao = (Devolucao) devolucaoArray[0];
				devolucao.setLocalidade(localidade);
				devolucao.setImovel(imovel);
				devolucao.setCliente(cliente);
				devolucao.setDebitoTipo(debitoTipo);
				devolucao.setCreditoARealizarGeral(creditoARealizarGeral);
				devolucao.setGuiaDevolucao(guiaDevolucao);

				if (!primeiraEntrada) {

					if ((localidadeAnterior == null && devolucao.getLocalidade() == null)
							|| (localidadeAnterior != null && devolucao.getLocalidade() != null 
								&& localidadeAnterior.getId().equals(devolucao.getLocalidade().getId()))) {

						if ((imovelAnterior == null && devolucao.getImovel() == null)
								|| (imovelAnterior != null
								   && devolucao.getImovel() != null 
								   && imovelAnterior.getId().equals(devolucao.getImovel().getId()))) {

							if ((clienteAnterior == null && devolucao.getCliente() == null)
									|| (clienteAnterior != null	&& devolucao.getCliente() != null 
										&& clienteAnterior.getId().equals(devolucao.getCliente().getId()))) {

								if ((debitoTipoAnterior == null && devolucao.getDebitoTipo() == null)
										|| (debitoTipoAnterior != null && devolucao.getDebitoTipo() != null 
											&& debitoTipoAnterior.getId().equals(devolucao.getDebitoTipo().getId()))) {

									colecaoConjuntoDevolucoes.add(devolucao);
									conjuntoFechado = false;
								} else {
									conjuntoFechado = true;
								}
							} else {
								conjuntoFechado = true;
							}
						} else {
							conjuntoFechado = true;
						}
					} else {
						conjuntoFechado = true;
					}

				} else {
					primeiraEntrada = false;
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				if (conjuntoFechado) {

					processarDevolucoesCobradasIndevidamente(colecaoConjuntoDevolucoes, imovelAnterior, debitoTipoAnterior, clienteAnterior);

					colecaoConjuntoDevolucoes.clear();
					colecaoConjuntoDevolucoes.add(devolucao);
				}

				localidadeAnterior = devolucao.getLocalidade();
				imovelAnterior = devolucao.getImovel();
				clienteAnterior = devolucao.getCliente();
				debitoTipoAnterior = devolucao.getDebitoTipo();
			}

			/*
			 * Último registro
			 */
			if (!colecaoConjuntoDevolucoes.isEmpty()) {
				processarDevolucoesCobradasIndevidamente(colecaoConjuntoDevolucoes, imovelAnterior, debitoTipoAnterior, clienteAnterior);
			}
		}
	}

	/**
	 * Classifica a coleção de pagamentos para contas.
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter, Pedro Alexandre, Pedro Alexandre
	 * @date 18/04/2006, 06/12/2006, 15/01/2008
	 * 
	 * @param colecaoPagamentosConta
	 * @param imovel
	 * @param anoMesArrecadacao
	 * @return
	 * @throws ControladorException
	 */
	protected Object[] classificarPagamentosConta(Collection<Pagamento> colecaoPagamentosConta, Imovel imovel, Integer anoMesArrecadacao, 
			Integer anoMesFaturamento, Integer referenciaPagamento)
			throws ControladorException {

		Object[] arrayDadosProcessarPagamentosConta = null;
		
		Collection colecaoPagamentosAtualizacao = new ArrayList();
		Collection colecaoPagamentosDocumentoInexistenteDebitoPrescrito = new ArrayList();
		Collection colecaoPagamentosDocumentoInexistenteContaParcelada = new ArrayList();
		Collection colecaoPagamentosDocumentoInexistenteContaCancelada = new ArrayList();
		Collection colecaoPagamentosDocumentoInexistenteErroProcessamento = new ArrayList();
		Collection colecaoPagamentosProcessar = new ArrayList();
		Collection colecaoPagamentosDuplicidade = new ArrayList();
		Collection colecaoPagamentosAtualizarSituacaoAnterior = new ArrayList();

		/*
		 * ==============================================================================================
		 * Para os pagamentos com tipo de documento (DOPT_ID) com valor
		 * correspondente a CONTA:
		 * ==============================================================================================
		 */
		if (!colecaoPagamentosConta.isEmpty()) {

			/*
			 * Para cada conjunto de pagamentos com mesma localidade, mesma
			 * matrícula do imóvel e mesmo ano/mês de referência do pagamento:
			 */
			Iterator iteratorColecaoPagamentosConta = colecaoPagamentosConta.iterator();
			
			Conta conta = null;
			ContaHistorico contaHistorico = null;	
			
			Object retornoPesquisa = this.selecionarContaPorImovelAnoMesReferencia(imovel,referenciaPagamento, anoMesFaturamento);

			if (retornoPesquisa == null) {			
				while (iteratorColecaoPagamentosConta.hasNext()) {

					Pagamento pagamentoConjunto = (Pagamento) iteratorColecaoPagamentosConta.next();

					if (pagamentoNullOuDiferenteDeValorABaixar(pagamentoConjunto)) {

						pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
						colecaoPagamentosAtualizacao.add(pagamentoConjunto);
					}
				}
			} else {
				if(retornoPesquisa instanceof Conta){
					conta = (Conta) retornoPesquisa;
				}else if (retornoPesquisa instanceof ContaHistorico){
					contaHistorico = (ContaHistorico) retornoPesquisa;
				}
				
				//Caso a conta tenha sido encontrada na tabela ContaHistorico
				if(contaHistorico != null ){
					Integer situacaoConta = contaHistorico.getDebitoCreditoSituacaoAtual().getId();
					
					while (iteratorColecaoPagamentosConta.hasNext()) {

						Pagamento pagamentoConjunto = (Pagamento) iteratorColecaoPagamentosConta.next();
						
						ContaGeral contaGeral = new ContaGeral();
						contaGeral.setId(contaHistorico.getId());
						contaGeral.setContaHistorico(contaHistorico);
						pagamentoConjunto.setContaGeral(contaGeral);

						if (pagamentoNullOuDiferenteDeValorABaixar(pagamentoConjunto)) {

							pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());

							if (situacaoConta.equals(DebitoCreditoSituacao.NORMAL)
									|| situacaoConta.equals(DebitoCreditoSituacao.INCLUIDA)
									|| situacaoConta.equals(DebitoCreditoSituacao.RETIFICADA)){
								
								colecaoPagamentosDuplicidade.add(pagamentoConjunto);
								
							}else if(situacaoConta.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)
									|| situacaoConta.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS)){
								
								colecaoPagamentosDocumentoInexistenteDebitoPrescrito.add(pagamentoConjunto);
								
							}else if(situacaoConta.equals(DebitoCreditoSituacao.CANCELADA)){
								colecaoPagamentosDocumentoInexistenteContaCancelada.add(pagamentoConjunto);
								
							}else if(situacaoConta.equals(DebitoCreditoSituacao.PARCELADA)){
								colecaoPagamentosDocumentoInexistenteContaParcelada.add(pagamentoConjunto);
								
							}else if(situacaoConta.equals(DebitoCreditoSituacao.ERRO_PROCESSAMENTO)){
								colecaoPagamentosDocumentoInexistenteErroProcessamento.add(pagamentoConjunto);
							}
						
						}
					}
				}
				
				//Caso a conta tenha sido encontrada na tabela conta
				if(conta != null){
				
					Integer situacaoConta = conta.getDebitoCreditoSituacaoAtual().getId();
					Boolean processarPagamentoConta = false;
					
					/*
					 * Caso o ano/mês de referência contábil da conta seja maior ou igual ao ano/mês de referência do faturamento atualizar a situação atual 
					 * dos pagamentos com o valor correspondente a documento inexistente, o valor excedente com o valor do pagamento e a identificação 
					 * da conta no pagamento.
					 */
					if (conta.getReferenciaContabil().compareTo(anoMesFaturamento) > -1) {
	
						while (iteratorColecaoPagamentosConta.hasNext()) {
	
							Pagamento pagamentoConjunto = (Pagamento) iteratorColecaoPagamentosConta.next();
							pagamentoConjunto.setValorExcedente(pagamentoConjunto.getValorPagamento());
							
							ContaGeral contaGeral = new ContaGeral();
							contaGeral.setId(conta.getId());
							contaGeral.setConta(conta);
							pagamentoConjunto.setContaGeral(contaGeral);
							
							if (situacaoConta.equals(DebitoCreditoSituacao.NORMAL) || situacaoConta.equals(DebitoCreditoSituacao.INCLUIDA) 
									|| situacaoConta.equals(DebitoCreditoSituacao.RETIFICADA)){
								colecaoPagamentosAtualizarSituacaoAnterior.add(pagamentoConjunto);
								try {
									repositorioArrecadacao.atualizarSituacaoAnteriorAtualEValorExcedentePagamento(colecaoPagamentosAtualizarSituacaoAnterior,
																													PagamentoSituacao.DOCUMENTO_A_CONTABILIZAR);
								} catch (ErroRepositorioException e) {
									Logger.getLogger(ControladorArrecadacao.class).error("Erro ao atualizar situação anterior atual e valor excedente do pagamento.");
								}
								colecaoPagamentosAtualizarSituacaoAnterior.remove(pagamentoConjunto);
								processarPagamentoConta = true;
							}else if(situacaoConta.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO)
									|| situacaoConta.equals(DebitoCreditoSituacao.DEBITO_PRESCRITO_CONTAS_INCLUIDAS)){
								colecaoPagamentosDocumentoInexistenteDebitoPrescrito.add(pagamentoConjunto);
							}else if(situacaoConta.equals(DebitoCreditoSituacao.CANCELADA)){
								colecaoPagamentosDocumentoInexistenteContaCancelada.add(pagamentoConjunto);
							}else if(situacaoConta.equals(DebitoCreditoSituacao.PARCELADA)){
								colecaoPagamentosDocumentoInexistenteContaParcelada.add(pagamentoConjunto);
							}else if(situacaoConta.equals(DebitoCreditoSituacao.ERRO_PROCESSAMENTO)){
								colecaoPagamentosDocumentoInexistenteErroProcessamento.add(pagamentoConjunto);
							}
						}
	
					} 
					
					if(situacaoConta.equals(DebitoCreditoSituacao.NORMAL)
									|| situacaoConta.equals(DebitoCreditoSituacao.INCLUIDA)
									|| situacaoConta.equals(DebitoCreditoSituacao.RETIFICADA)
									|| processarPagamentoConta) {
						// [SF0002] Processar Pagamento de Conta
						
						arrayDadosProcessarPagamentosConta = this.processarPagamentoConta(conta,colecaoPagamentosConta);
						processarPagamentoConta = false;
					}
				}
			}
		}
		
		
		/**
		 * 0 - Coleção de pagamentos para atualizar a situação 
		 * 1 - Map para processar os pagamentos da conta. 
		 * 2 - Array de coleções de pagamentos para atualizar a situação.
		 * 3 - Coleção de pagamentos em duplicidade
		 * 4 - Coleção de pagamentos para atualizar as situações anterior e atual
		 */
		Object[] retorno = new Object[9];

		retorno[0] = colecaoPagamentosAtualizacao;
		retorno[3] = colecaoPagamentosDuplicidade;
		retorno[4] = colecaoPagamentosAtualizarSituacaoAnterior;
		retorno[5] = colecaoPagamentosDocumentoInexistenteDebitoPrescrito;
		retorno[6] = colecaoPagamentosDocumentoInexistenteContaCancelada;
		retorno[7] = colecaoPagamentosDocumentoInexistenteContaParcelada;
		retorno[8] = colecaoPagamentosDocumentoInexistenteErroProcessamento;
		

		/**
		 * Caso os dados de processamento dos pagamentos para conta não esteja
		 * vazio, adiciona o map e o array de coleções no array de retorno.
		 */
		if (arrayDadosProcessarPagamentosConta != null) {
			retorno[1] = arrayDadosProcessarPagamentosConta[0];
			retorno[2] = arrayDadosProcessarPagamentosConta[1];
		} else {
			retorno[1] = null;
			retorno[2] = null;
		}
		return retorno;

	}

	private boolean pagamentoNullOuDiferenteDeValorABaixar(Pagamento pagamentoConjunto) {
		return pagamentoConjunto.getPagamentoSituacaoAtual() == null
				|| (pagamentoConjunto.getPagamentoSituacaoAtual() != null 
					&& !pagamentoConjunto.getPagamentoSituacaoAtual().getId().equals(PagamentoSituacao.VALOR_A_BAIXAR));
	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @return Collection<DeducoesHelper>
	 * @throws ControladorException
	 */

	public Collection<DeducoesHelper> pesquisarDeducoesAvisoBancario(
			Integer idAvisoBancario) throws ControladorException {

		try {
			Collection colecaoDadosDeducoes = this.repositorioArrecadacao
					.pesquisarDeducoesAvisoBancario(idAvisoBancario);

			Collection<DeducoesHelper> colecaoDeducoesHelper = new ArrayList();
			Iterator colecaoDadosDeducoesIterator = colecaoDadosDeducoes
					.iterator();
			while (colecaoDadosDeducoesIterator.hasNext()) {

				DeducoesHelper deducoesHelper = new DeducoesHelper();

				// Obtém os dados do crédito realizado
				Object[] dadosArray = (Object[]) colecaoDadosDeducoesIterator
						.next();

				// Tipo
				if (dadosArray[0] != null) {
					deducoesHelper.setTipo((String) dadosArray[0]);
				}

				// Valor Dedução
				if (dadosArray[1] != null) {
					deducoesHelper.setValorDeducao(Util
							.formatarMoedaReal((BigDecimal) dadosArray[1]));
				}

				colecaoDeducoesHelper.add(deducoesHelper);
			}

			return colecaoDeducoesHelper;

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0268] - Apresentar Análise do Aviso Bancário
	 * 
	 * @author Vivianne Sousa
	 * @date 13/12/2006
	 * 
	 * @return Collection<AcertosAvisoBancarioHelper>
	 * @throws ControladorException
	 */

	public Collection<AcertosAvisoBancarioHelper> pesquisarAcertosAvisoBancario(
			Integer idAvisoBancario, Integer indicadorArrecadacaoDevolucao)
			throws ControladorException {

		try {
			Collection colecaoDadosAcertosAvisoBancario = this.repositorioArrecadacao
					.pesquisarAcertosAvisoBancario(idAvisoBancario,
							indicadorArrecadacaoDevolucao);

			Collection<AcertosAvisoBancarioHelper> colecaoAcertosAvisoBancarioHelper = new ArrayList();
			Iterator colecaoDadosAcertosAvisoBancarioIterator = colecaoDadosAcertosAvisoBancario
					.iterator();
			while (colecaoDadosAcertosAvisoBancarioIterator.hasNext()) {

				AcertosAvisoBancarioHelper AcertosAvisoBancarioHelper = new AcertosAvisoBancarioHelper();

				Object[] dadosArray = (Object[]) colecaoDadosAcertosAvisoBancarioIterator
						.next();

				// id do Banco
				if (dadosArray[0] != null) {
					AcertosAvisoBancarioHelper.setIdbanco(""
							+ dadosArray[0]);
				}
				// código da Agência
				if (dadosArray[1] != null) {
					AcertosAvisoBancarioHelper.setCodigoAgencia(""
							+ dadosArray[1]);
				}
				// numero da Conta
				if (dadosArray[2] != null) {
					AcertosAvisoBancarioHelper
							.setNumeroConta((String) dadosArray[2]);
				}
				// indicadorCreditoDebito
				if (dadosArray[3] != null) {
					Integer indicadorCreditoDebito = (Integer) dadosArray[3];

					if (indicadorCreditoDebito
							.equals(AvisoBancario.INDICADOR_CREDITO.intValue())) {
						AcertosAvisoBancarioHelper
								.setIndicadorCreditoDebito(AvisoBancario.CREDITO);
					} else {
						AcertosAvisoBancarioHelper
								.setIndicadorCreditoDebito(AvisoBancario.DEBITO);
					}
				}
				// data do Acerto
				if (dadosArray[4] != null) {
					AcertosAvisoBancarioHelper.setDataAcerto(Util
							.formatarData((Date) dadosArray[4]));
				}
				// valor do Acerto
				if (dadosArray[5] != null) {
					AcertosAvisoBancarioHelper.setValorAcerto(Util
							.formatarMoedaReal((BigDecimal) dadosArray[5]));
				}

				colecaoAcertosAvisoBancarioHelper
						.add(AcertosAvisoBancarioHelper);
			}

			return colecaoAcertosAvisoBancarioHelper;

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rafael Corrêa
	 * @date 12/12/2006
	 * 
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoLocalidadeAmbosRelatorio(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal)
			throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoLocalidadeAmbosRelatorio(idImovel,
							idCliente, idTipoRelacao, localidadeInicial,
							localidadeFinal, idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor de Água da Conta
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorAgua((BigDecimal) dadosPagamento[12]);
					}

					// Valor de Esgoto da Conta
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorEsgoto((BigDecimal) dadosPagamento[13]);
					}

					// Valor dos Débitos da Conta
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setDebitos((BigDecimal) dadosPagamento[14]);
					}

					// Valor dos Créditos da Conta
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setValorCreditos((BigDecimal) dadosPagamento[15]);
					}

					// Valor do Débito do Débito a Cobrar
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setValorDebito((BigDecimal) dadosPagamento[16]);
					}

					// Número de Prestações do Débito
					if (dadosPagamento[17] != null) { // 17
						pagamentoRelatorioHelper
								.setNumeroPrestacaoDebito((Short) dadosPagamento[17]);
					}

					// Número de Prestações Cobradas
					if (dadosPagamento[18] != null) { // 18
						pagamentoRelatorioHelper
								.setNumeroPrestacaoCobradas((Short) dadosPagamento[18]);
					}

					// Valor da Guia de Pagamento
					if (dadosPagamento[19] != null) { // 19
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[19]);
					}

					// Valor do Pagamento
					if (dadosPagamento[20] != null) { // 20
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[20]);
					}

					// Id da Situação Atual do Pagamento
					if (dadosPagamento[21] != null) { // 21
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[21]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[22] != null) { // 22
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[22]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[23] != null) { // 23
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[23]);
					}

					// Valor dos Impostos da Conta
					if (dadosPagamento[24] != null) { // 24
						pagamentoRelatorioHelper
								.setValorImpostos((BigDecimal) dadosPagamento[24]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}

	/**
	 * Pesquisa o imóvel pelo id fazendo os carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return Imovel
	 * @throws ControladorException
	 */
	public Imovel pesquisarImovelPagamento(Integer idImovel)
			throws ControladorException {

		try {
			return repositorioArrecadacao.pesquisarImovelPagamento(idImovel);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa o cliente pelo id fazendo os carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return Cliente
	 * @throws ErroRepositorioException
	 */
	public Cliente pesquisarClientePagamento(Integer idCliente)
			throws ControladorException {

		try {
			return repositorioArrecadacao.pesquisarClientePagamento(idCliente);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa o endereço de correspondência do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return ClienteEndereco
	 * @throws ControladorException
	 */
	public ClienteEndereco pesquisarClienteEnderecoPagamento(Integer idCliente)
			throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarClienteEnderecoPagamento(idCliente);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa o telefone padrão do cliente pelo seu id fazendo os
	 * carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return ClienteFone
	 * @throws ControladorException
	 */
	public IClienteFone pesquisarClienteFonePagamento(Integer idCliente)
			throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarClienteFonePagamento(idCliente);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os clientes do imóvel pelo seu id do imóvel fazendo os
	 * carregamentos necessários
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * @author Rafael Corrêa
	 * @date 16/12/06
	 * 
	 * @return Collection<ClienteImovel>
	 * @throws ControladorException
	 */
	public Collection<ClienteImovel> pesquisarClientesImoveisPagamento(
			Integer idImovel) throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarClientesImoveisPagamento(idImovel);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Este caso de uso cria um filtro que será usado na pesquisa de pagamentos
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Debito a Cobrar do Cliente
	 * pesquisarPagamentoLocalidade
	 * 
	 * @author Rafael Corrêa
	 * @date 21/12/06
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Collection<Pagamento> pesquisarPagamentoMovimentoArrecadadorParaPaginacao(
			String idImovel, String idCliente, String idTipoRelacao,
			String localidadeInicial, String localidadeFinal,
			String idAvisoBancario, String idArrecadador,
			String periodoArrecadacaoInicial, String periodoArrecadacaoFinal,
			String periodoPagamentoInicio, String periodoPagamentoFim,
			Date dataPagamentoInicial, Date dataPagamentoFinal,
			String[] idsPagamentosSituacoes, String[] idsDebitosTipos,
			String[] idsArrecadacaoForma, String[] idsDocumentosTipos,
			Integer numeroPagina,
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarPagamentoMovimentoArrecadadorParaPaginacao(
							idImovel, idCliente, idTipoRelacao,
							localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
							numeroPagina,
                            valorPagamentoInicial, 
                            valorPagamentoFinal);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 30/11/06
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection filtrarMovimentoArrecadadorParaRelatorio(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ControladorException {

		Collection<ArrecadadorMovimento> retorno = new ArrayList<ArrecadadorMovimento>();
		Collection colecaoMovimentoArrecadadores = null;

		try {

			colecaoMovimentoArrecadadores = repositorioArrecadacao
					.filtrarMovimentoArrecadadorParaRelatorio(codigoBanco,
							codigoRemessa, descricaoIdentificacaoServico,
							numeroSequencialArquivo, dataGeracaoInicio,
							dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia,
							indicadorAceitacao, indicadorAbertoFechado);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		Iterator iteratorMovimentoArrecadadoresTotal = colecaoMovimentoArrecadadores
				.iterator();

		while (iteratorMovimentoArrecadadoresTotal.hasNext()) {

			ArrecadadorMovimento arrecadadorMovimentoRetorno = new ArrecadadorMovimento();
			Object[] arrecadadorMovimento = (Object[]) iteratorMovimentoArrecadadoresTotal
					.next();

			if (arrecadadorMovimento[0] != null) {// 0
				// codigo do banco
				arrecadadorMovimentoRetorno.setCodigoBanco(new Short(
						arrecadadorMovimento[0].toString()));
			}

			if (arrecadadorMovimento[1] != null) {// 1
				// codigo remessa
				arrecadadorMovimentoRetorno.setCodigoRemessa(new Short(
						arrecadadorMovimento[1].toString()));
			}

			if (arrecadadorMovimento[2] != null) {// 2
				// descrição indentificação do serviço
				arrecadadorMovimentoRetorno
						.setDescricaoIdentificacaoServico(arrecadadorMovimento[2]
								.toString());
			}

			if (arrecadadorMovimento[3] != null) {// 3
				// nsa
				arrecadadorMovimentoRetorno
						.setNumeroSequencialArquivo(new Integer(
								arrecadadorMovimento[3].toString()));
			}

			if (arrecadadorMovimento[4] != null) {// 4
				// id de arrecadadorMovimento
				arrecadadorMovimentoRetorno.setId(new Integer(
						arrecadadorMovimento[4].toString()));
			}

			if (arrecadadorMovimento[5] != null) {// 5
				// data de geração
				arrecadadorMovimentoRetorno
						.setDataGeracao((Date) arrecadadorMovimento[5]);
			}

			if (arrecadadorMovimento[6] != null) {// 6
				// numero Registros Movimento
				arrecadadorMovimentoRetorno
						.setNumeroRegistrosMovimento(new Integer(
								arrecadadorMovimento[6].toString()));
			}

			if (arrecadadorMovimento[7] != null) {// 7
				// valor Total do Movimento
				arrecadadorMovimentoRetorno
						.setValorTotalMovimento(new BigDecimal(
								arrecadadorMovimento[7].toString()));
			}

			if (arrecadadorMovimento[8] != null) {// 8
				// ultima alteração
				arrecadadorMovimentoRetorno
						.setUltimaAlteracao((Date) arrecadadorMovimento[8]);
			}

			if (arrecadadorMovimento[9] != null) {// 9
				// nome do Banco
				arrecadadorMovimentoRetorno
						.setNomeBanco(arrecadadorMovimento[9].toString());
			}

			retorno.add(arrecadadorMovimentoRetorno);
		}

		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;

	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores
	 * 
	 * @author Vivianne Sousa
	 * @date 04/01/07
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * 
	 * @throws ControladorException
	 */
	public Integer filtrarMovimentoArrecadadoresRelatorioCount(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.filtrarMovimentoArrecadadoresRelatorioCount(codigoBanco,
							codigoRemessa, descricaoIdentificacaoServico,
							numeroSequencialArquivo, dataGeracaoInicio,
							dataGeracaoFim, ultimaAlteracaoInicio,
							ultimaAlteracaoFim, descricaoOcorrencia,
							indicadorAceitacao, indicadorAbertoFechado);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Transfere para o histórico as guias de pagamentos e os relacionamentos
	 * ligados a ela.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param colecaoGuiasPagamento
	 * @throws ControladorException
	 */
	public void transferirGuiaPagamentoParaHistorico(Collection<GuiaPagamento> colecaoGuiasPagamento)throws ControladorException {

		try {
			GuiaPagamentoHistorico guiaPagamentoHistoricoTemp = null;

			Collection colecaoGuiasPagamentoRemover = new ArrayList();

			if (colecaoGuiasPagamento != null && !colecaoGuiasPagamento.isEmpty()) {

				colecaoGuiasPagamentoRemover.addAll(colecaoGuiasPagamento);
				int cont = 0;
				for (GuiaPagamento guiaPagamento : colecaoGuiasPagamento) {
					cont++;

					Integer idGuiaPagamento = guiaPagamento.getId();

					/** remove a referência da guia de pagamento dos pagamentos */
					this.repositorioArrecadacao.apagarIdGuiaPagamentoPagamentos(idGuiaPagamento);

					guiaPagamentoHistoricoTemp = new GuiaPagamentoHistorico();
					guiaPagamentoHistoricoTemp.setId(idGuiaPagamento);
					guiaPagamentoHistoricoTemp.setAnoMesReferenciaContabil(guiaPagamento.getAnoMesReferenciaContabil());
					guiaPagamentoHistoricoTemp.setCliente(guiaPagamento.getCliente());
					guiaPagamentoHistoricoTemp.setDataEmissao(guiaPagamento.getDataEmissao());
					guiaPagamentoHistoricoTemp.setDataVencimento(guiaPagamento.getDataVencimento());
					guiaPagamentoHistoricoTemp
							.setDebitoCreditoSituacaoByDcstIdanterior(guiaPagamento
									.getDebitoCreditoSituacaoAnterior());
					guiaPagamentoHistoricoTemp
							.setDebitoCreditoSituacaoByDcstIdatual(guiaPagamento
									.getDebitoCreditoSituacaoAtual());
					guiaPagamentoHistoricoTemp.setDebitoTipo(guiaPagamento
							.getDebitoTipo());
					guiaPagamentoHistoricoTemp.setDocumentoTipo(guiaPagamento
							.getDocumentoTipo());
					guiaPagamentoHistoricoTemp
							.setFinanciamentoTipo(guiaPagamento
									.getFinanciamentoTipo());
					guiaPagamentoHistoricoTemp
							.setGuiaPagamentoGeral(guiaPagamento
									.getGuiaPagamentoGeral());
					guiaPagamentoHistoricoTemp.setImovel(guiaPagamento
							.getImovel());
					guiaPagamentoHistoricoTemp.setIndicadorMulta(guiaPagamento
							.getIndicadoCobrancaMulta());
					guiaPagamentoHistoricoTemp
							.setLancamentoItemContabil(guiaPagamento
									.getLancamentoItemContabil());
					guiaPagamentoHistoricoTemp.setLocalidade(guiaPagamento
							.getLocalidade());
					guiaPagamentoHistoricoTemp.setOrdemServico(guiaPagamento
							.getOrdemServico());
					guiaPagamentoHistoricoTemp.setParcelamento(guiaPagamento
							.getParcelamento());
					guiaPagamentoHistoricoTemp
							.setRegistroAtendimento(guiaPagamento
									.getRegistroAtendimento());
					guiaPagamentoHistoricoTemp.setUltimaAlteracao(new Date());
					guiaPagamentoHistoricoTemp.setValorDebito(guiaPagamento
							.getValorDebito());
					guiaPagamentoHistoricoTemp.setObservacao(guiaPagamento
							.getObservacao());
					guiaPagamentoHistoricoTemp.setIndicadorEmitirObservacao(guiaPagamento
							.getIndicadorEmitirObservacao());
					
					guiaPagamentoHistoricoTemp.setNumeroGuiaFatura(guiaPagamento.getNumeroGuiaFatura());

					/** Inserindo a guia no historico */
					getControladorUtil().inserir(guiaPagamentoHistoricoTemp);

					enviarGuiaPagamentoCategoriaParaHistorico(guiaPagamentoHistoricoTemp, idGuiaPagamento);

					enviarClienteGuiaPagamentoParaHistorico(guiaPagamentoHistoricoTemp, idGuiaPagamento);
				}
			}

			getControladorBatch().removerColecaoGuiaPagamentoParaBatch(colecaoGuiasPagamentoRemover);
			colecaoGuiasPagamentoRemover = null;
			colecaoGuiasPagamento = null;

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Para cada guia de pagamento transferida para o histórico atualiza o
	 * indicador de que a guia de pagamento está no histórico.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param colecaoGuiasPagamento
	 * @throws ControladorException
	 */
	public void atualizarIndicadorGuiaPagamentoNoHistorico(
			Collection colecaoGuiasPagamento) throws ControladorException {

		List colecaoTotalGuiasPagamento = (List) colecaoGuiasPagamento;
		int limiteSuperior;
		int limiteInferior;
		int limiteMaximo = colecaoTotalGuiasPagamento.size();
		int quantidadeMaximaPorColecao = 100;

		try {

			for (int i = 0; i < limiteMaximo; i = i + 100) {

				if (limiteMaximo < quantidadeMaximaPorColecao) {
					limiteInferior = 0;
					limiteSuperior = limiteMaximo;
				} else {
					limiteInferior = i;
					limiteSuperior = i + 100;

					if (limiteSuperior > limiteMaximo) {
						limiteSuperior = limiteMaximo;
					}
				}

				List colecaoGuiasPagamentoTemporaria = new ArrayList();
				colecaoGuiasPagamentoTemporaria
						.addAll(colecaoTotalGuiasPagamento.subList(
								limiteInferior, limiteSuperior));

				this.repositorioArrecadacao
						.atualizarIndicadorGuiaPagamentoNoHistorico(colecaoGuiasPagamentoTemporaria);

			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Transfere para o histórico os pagamentos informados.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param colecaoGuiasPagamento
	 * @param anoMesFaturamentoSistemaParametro
	 * @throws ControladorException
	 */
	public void transferirPagamentoParaHistorico(
			Collection<Pagamento> colecaoPagamentos)
			throws ControladorException {

		PagamentoHistorico pagamentoHistoricoTemp = null;

		Collection colecaoPagamentoHistoricoInserir = new ArrayList();
		Collection colecaoPagamentoHistoricoRemover = new ArrayList();

		try {
			if (colecaoPagamentos != null && !colecaoPagamentos.isEmpty()) {

				colecaoPagamentoHistoricoRemover.addAll(colecaoPagamentos);
				int cont = 0;
				for (Pagamento pagamento : colecaoPagamentos) {
					cont++;

					pagamentoHistoricoTemp = new PagamentoHistorico();
					pagamentoHistoricoTemp.setId(pagamento.getId());
					pagamentoHistoricoTemp.setAnoMesReferenciaArrecadacao(pagamento.getAnoMesReferenciaArrecadacao());
					pagamentoHistoricoTemp.setAnoMesReferenciaPagamento(pagamento.getAnoMesReferenciaPagamento());
					pagamentoHistoricoTemp.setArrecadacaoForma(pagamento.getArrecadacaoForma());
					pagamentoHistoricoTemp.setArrecadadorMovimentoItem(pagamento.getArrecadadorMovimentoItem());
					pagamentoHistoricoTemp.setAvisoBancario(pagamento.getAvisoBancario());
					pagamentoHistoricoTemp.setCliente(pagamento.getCliente());
					if (pagamento.getContaGeral() != null && pagamento.getContaGeral().getId() != null) {
						pagamentoHistoricoTemp.setContaGeral(pagamento.getContaGeral());
					}

					pagamentoHistoricoTemp.setDataPagamento(pagamento.getDataPagamento());
					pagamentoHistoricoTemp.setDebitoACobrarGeral(pagamento.getDebitoACobrarGeral());
					pagamentoHistoricoTemp.setDebitoTipo(pagamento.getDebitoTipo());
					pagamentoHistoricoTemp.setDocumentoTipo(pagamento.getDocumentoTipo());
					pagamentoHistoricoTemp.setGuiaPagamento(pagamento.getGuiaPagamento());
					pagamentoHistoricoTemp.setImovel(pagamento.getImovel());
					pagamentoHistoricoTemp.setLocalidade(pagamento.getLocalidade());
					pagamentoHistoricoTemp.setPagamentoSituacaoAnterior(pagamento.getPagamentoSituacaoAnterior());
					pagamentoHistoricoTemp.setPagamentoSituacaoAtual(pagamento.getPagamentoSituacaoAtual());
					pagamentoHistoricoTemp.setUltimaAlteracao(new Date());
					pagamentoHistoricoTemp.setValorPagamento(pagamento.getValorPagamento());
					pagamentoHistoricoTemp.setValorExcedente(pagamento.getValorExcedente());
					
					// Alterado por Sávio Luiz
					// Data:27/05/2008
					pagamentoHistoricoTemp.setIndicadorExpurgado(pagamento.getIndicadorExpurgado());
					
					//Alterado por Anderson Italo
					// Data:21/07/2009
					if (pagamento.getCobrancaDocumento() != null){
						pagamentoHistoricoTemp.setCobrancaDocumentoAgregador(pagamento.getCobrancaDocumento());
					}
					
					if (pagamento.getDocumentoTipoAgregador() != null){
						pagamentoHistoricoTemp.setDocumentoTipoAgregador(pagamento.getDocumentoTipoAgregador());
					}
					
					if (pagamento.getFatura() != null){
						pagamentoHistoricoTemp.setFatura(pagamento.getFatura());
					}
					
					if (pagamento.getDataProcessamento() != null){
						pagamentoHistoricoTemp.setDataHoraProcessamento(pagamento.getDataProcessamento());
					}
					//fim alteracao

					colecaoPagamentoHistoricoInserir.add(pagamentoHistoricoTemp);

				}
			}

			getControladorBatch().inserirColecaoObjetoParaBatch(
					colecaoPagamentoHistoricoInserir);

			getControladorBatch().removerColecaoPagamentoParaBatch(
					colecaoPagamentoHistoricoRemover);

			colecaoPagamentoHistoricoInserir = null;
			colecaoPagamentoHistoricoRemover = null;

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Transfere para o histórico as devoluções informadas.
	 * 
	 * @author Administrador
	 * @date 09/01/2007
	 * 
	 * @param colecaoDevolucoes
	 * @throws ControladorException
	 */
	public void transferirDevolucaoParaHistorico(
			Collection<Devolucao> colecaoDevolucoes)
			throws ControladorException {

		DevolucaoHistorico devolucaoHistoricoTemp = null;

		Collection colecaoDevolucaoHistoricoInserir = new ArrayList();
		Collection colecaoDevolucaoHistoricoRemover = new ArrayList();

		try {

			if (colecaoDevolucoes != null && !colecaoDevolucoes.isEmpty()) {

				colecaoDevolucaoHistoricoRemover.addAll(colecaoDevolucoes);

				int cont = 0;
				for (Devolucao devolucao : colecaoDevolucoes) {
					cont++;

					devolucaoHistoricoTemp = new DevolucaoHistorico();
					devolucaoHistoricoTemp.setId(devolucao.getId());
					devolucaoHistoricoTemp.setAnoMesReferenciaArrecadacao(devolucao.getAnoMesReferenciaArrecadacao());
					devolucaoHistoricoTemp.setAnoMesReferenciaDevolucao(devolucao.getAnoMesReferenciaDevolucao());
					devolucaoHistoricoTemp.setAvisoBancario(devolucao.getAvisoBancario());
					devolucaoHistoricoTemp.setCliente(devolucao.getCliente());
					devolucaoHistoricoTemp.setDataDevolucao(devolucao.getDataDevolucao());
					devolucaoHistoricoTemp.setDebitoTipo(devolucao.getDebitoTipo());
					devolucaoHistoricoTemp.setDevolucaoSituacaoAnterior(devolucao.getDevolucaoSituacaoAnterior());
					devolucaoHistoricoTemp.setDevolucaoSituacaoAtual(devolucao.getDevolucaoSituacaoAtual());
					devolucaoHistoricoTemp.setGuiaDevolucao(devolucao.getGuiaDevolucao());
					devolucaoHistoricoTemp.setImovel(devolucao.getImovel());
					devolucaoHistoricoTemp.setLocalidade(devolucao.getLocalidade());
					devolucaoHistoricoTemp.setUltimaAlteracao(new Date());
					devolucaoHistoricoTemp.setValorDevolucao(devolucao.getValorDevolucao());

					//adicionado por Vivianne Sousa 11/09/2008
					//analista responsavel: Aryed Lins
					devolucaoHistoricoTemp.setCreditoARealizarGeral(devolucao.getCreditoARealizarGeral());
					devolucaoHistoricoTemp.setArrecadadorMovimentoItem(devolucao.getArrecadadorMovimentoItem());
					
					//Alterado por Anderson Italo
					// Data:21/07/2009
					if (devolucao.getCobrancaDocumento() != null){
						devolucaoHistoricoTemp.setCobrancaDocumentoAgregador(devolucao.getCobrancaDocumento());
					}
					
					if (devolucao.getDocumentoTipoAgregador() != null){
						devolucaoHistoricoTemp.setDocumentoTipoAgregador(devolucao.getDocumentoTipoAgregador());
					}
					//fim alteracao

					colecaoDevolucaoHistoricoInserir.add(devolucaoHistoricoTemp);
				}
			}

			getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDevolucaoHistoricoInserir);

			getControladorBatch().removerColecaoDevolucaoParaBatch(colecaoDevolucaoHistoricoRemover);

			colecaoDevolucaoHistoricoInserir = null;
			colecaoDevolucaoHistoricoRemover = null;

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0276] Encerrar Arrecadação do Mês
	 * 
	 * Atualiza o ano/mês de referência da arrecadação.
	 * 
	 * @author Pedro Alexandre
	 * @date 09/01/2007
	 * 
	 * @param anoMesArrecadacaoSistemaParametro
	 * @throws ControladorException
	 */
	public void atualizarAnoMesArrecadacao(
			Integer anoMesArrecadacaoSistemaParametro)
			throws ControladorException {
		try {
			repositorioArrecadacao.atualizarAnoMesArrecadacao(
					anoMesArrecadacaoSistemaParametro, Util
							.somarData(anoMesArrecadacaoSistemaParametro));
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}

	/**
	 * [UC0506] Inserir Arrecadador
	 * 
	 * Inclusão de um novo arrecadador.
	 * 
	 * @author Marcio Roberto
	 * @date 29/01/2007
	 * 
	 * @param String
	 *            idAgente, String idCliente, String inscricaoEstadual, String
	 *            idImovel, Usuario usuarioLogado
	 * @throws ControladorException
	 */
	public Integer inserirArrecadador(String idAgente, String idCliente,
			String inscricaoEstadual, String idImovel, Usuario usuarioLogado)
			throws ControladorException {

		Arrecadador arrecadador = new Arrecadador();

		// ------------ REGISTRAR TRANSAÇÃO ----------------------------
		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ARRECADADOR_INSERIR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ARRECADADOR_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		arrecadador.setOperacaoEfetuada(operacaoEfetuada);
		arrecadador.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		// preenche objeto arrecadador
		// seta o atributo de Agente no objeto arrecadador
		arrecadador.setCodigoAgente(new Short(idAgente));

		// seta o atributo de Cliente no objeto arrecadador
		Cliente cliente = new Cliente();
		cliente.setId(new Integer(idCliente));
		arrecadador.setCliente(cliente);

		// Crio um objeto imovel para setar o id e preencher o atributo imovel
		// de arrecadador.
		if (idImovel != null && !idImovel.equals("")) {
			Imovel imovel = new Imovel();
			imovel.setId(new Integer(idImovel));
			arrecadador.setImovel(imovel);
		}

		// seta o atributo de Inscrição Estadual no objeto arrecadador
		arrecadador.setNumeroInscricaoEstadual(inscricaoEstadual);

		arrecadador.setIndicadorUso((short) 1);

		arrecadador.setUltimaAlteracao(new Date());

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		filtroArrecadador.adicionarParametro(new ParametroSimples(
				FiltroArrecadador.CODIGO_AGENTE, idAgente));

		Collection colecaoArrecadador = getControladorUtil().pesquisar(
				filtroArrecadador, Arrecadador.class.getName());

		Integer idArrecadador = null;
		if (colecaoArrecadador.isEmpty()) {
			// Inserir na base de dados Arrecadador
			idArrecadador = (Integer) getControladorUtil().inserir(arrecadador);
		} else {
			throw new ControladorException("atencao.arrecadador_existente");
		}
		return idArrecadador;
	}

	/**
	 * Permite inserir uma Agência Bancaria
	 * 
	 * [UC0217] Inserir Agência Bancaria
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 * 
	 */
	public Integer inserirAgenciaBancaria(Agencia agencia)
			throws ControladorException {

		FiltroAgencia filtroAgencia = new FiltroAgencia();

		filtroAgencia.adicionarParametro(new ParametroSimples(
				FiltroAgencia.BANCO_ID, agencia.getBanco()));

		filtroAgencia.adicionarParametro(new ParametroSimples(
				FiltroAgencia.CODIGO_AGENCIA, agencia.getCodigoAgencia()));

		filtroAgencia.adicionarParametro(new ParametroSimples(
				FiltroAgencia.NOME_AGENCIA, agencia.getNomeAgencia()));

		Collection colecaoEnderecos = getControladorUtil().pesquisar(
				filtroAgencia, Agencia.class.getName());

		if (colecaoEnderecos != null && !colecaoEnderecos.isEmpty()) {
			throw new ControladorException(
					"atencao.endereco_localidade_nao_informado");
		}

		Integer id = (Integer) getControladorUtil().inserir(agencia);

		return id;

	}

	/**
	 * [UC0298] Manter Agência bancária [] Atualizar Agência Bancária Metodo que
	 * atualiza a Agência Bancária
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * 
	 * 
	 * @throws ControladorException
	 */

	public void atualizarAgenciaBancaria(Agencia agencia)
			throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((agencia.getId() == null || agencia.getId().equals(
				"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (agencia.getCodigoAgencia() == null || agencia
						.getCodigoAgencia().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (agencia.getNomeAgencia() == null || agencia
						.getNomeAgencia().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (agencia.getBanco() == null || agencia.getBanco().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (agencia.getNumeroTelefone() == null || agencia
						.getNumeroTelefone().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Código da Agência foi preenchido

		if (agencia.getCodigoAgencia() == null
				|| agencia.getCodigoAgencia().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Código da Agência");
		}
		// Verifica se o campo Nome da Agência foi preenchido

		if (agencia.getNomeAgencia() == null
				|| agencia.getNomeAgencia().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Nome da Agência");
		}

		// Verifica se o campo Banco foi preenchido
		if (agencia.getBanco() == null
				|| agencia.getBanco().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Banco");
		}

		// Verifica se o campo Telefone foi preenchido
		if (agencia.getNumeroTelefone() == null
				|| agencia.getNumeroTelefone().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Telefone");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroAgencia filtroAgencia = new FiltroAgencia();
		filtroAgencia.adicionarParametro(new ParametroSimples(FiltroAgencia.ID,
				agencia.getId()));

		Collection colecaoAgenciaBase = getControladorUtil().pesquisar(
				filtroAgencia, Agencia.class.getName());

		if (colecaoAgenciaBase == null || colecaoAgenciaBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		Agencia agenciaBase = (Agencia) colecaoAgenciaBase.iterator().next();

		if (agenciaBase.getUltimaAlteracao()
				.after(agencia.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		agencia.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(agencia);

	}

	/**
	 * Permite inserir uma Conta Bancaria
	 * 
	 * [UC0217] Inserir Conta Bancaria
	 * 
	 * @author Thiago Tenório
	 * @date 30/03/2006
	 * 
	 */
	public Integer inserirContaBancaria(ContaBancaria contaBancaria)
			throws ControladorException {

		FiltroContaBancaria filtroContaBancaria = new FiltroContaBancaria();

		filtroContaBancaria.adicionarParametro(new ParametroSimples(
				FiltroContaBancaria.AGENCIA_BANCO_ID, contaBancaria
						.getAgencia().getBanco()));

		filtroContaBancaria.adicionarParametro(new ParametroSimples(
				FiltroContaBancaria.AGENCIA_ID, contaBancaria.getAgencia()));

		filtroContaBancaria.adicionarParametro(new ParametroSimples(
				FiltroContaBancaria.NUMERO_CONTA, contaBancaria
						.getNumeroConta()));

		filtroContaBancaria
				.adicionarCaminhoParaCarregamentoEntidade("agencia.banco");
		// filtroContaBancaria
		// .adicionarCaminhoParaCarregamentoEntidade("agencia");
		//		
		Collection colecaoContaBancaria = getControladorUtil().pesquisar(
				filtroContaBancaria, ContaBancaria.class.getName());

		if (colecaoContaBancaria != null && !colecaoContaBancaria.isEmpty()) {
			throw new ControladorException("atencao.conta_bancaria.existente");
		}

		Integer id = (Integer) getControladorUtil().inserir(contaBancaria);

		return id;

	}

	/**
	 * [UC0298] Manter Agência bancária [] Atualizar Agência Bancária Metodo que
	 * atualiza a Agência Bancária
	 * 
	 * 
	 * @author Thiago Tenório
	 * @date 25/05/2006
	 * 
	 * 
	 * @throws ControladorException
	 */

	public void atualizarContaBancaria(ContaBancaria contaBancaria)
			throws ControladorException {

		// Verifica se todos os campos obrigatorios foram preenchidos

		if ((contaBancaria.getId() == null || contaBancaria.getId().equals(
				"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (contaBancaria.getAgencia().getBanco() == null || contaBancaria
						.getAgencia().getBanco().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (contaBancaria.getAgencia() == null || contaBancaria
						.getAgencia().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))
				&& (contaBancaria.getNumeroConta() == null || contaBancaria
						.getNumeroConta().equals(
								"" + ConstantesSistema.NUMERO_NAO_INFORMADO))) {
			throw new ControladorException(
					"atencao.filtro.nenhum_parametro_informado");

		}

		// Verifica se o campo Banco foi preenchido

		if (contaBancaria.getAgencia().getBanco() == null
				|| contaBancaria.getAgencia().getBanco().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Banco");
		}
		// Verifica se o campo Agencia foi preenchido

		if (contaBancaria.getAgencia() == null
				|| contaBancaria.getAgencia().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Agência");
		}

		// Verifica se o campo Banco foi preenchido
		if (contaBancaria.getNumeroConta() == null
				|| contaBancaria.getNumeroConta().equals(
						"" + ConstantesSistema.NUMERO_NAO_INFORMADO)) {
			throw new ControladorException("atencao.Informe_entidade", null,
					" Numero da Conta");
		}

		// [FS0003] - Atualização realizada por outro usuário
		FiltroContaBancaria filtroContaBancaria = new FiltroContaBancaria();
		filtroContaBancaria.adicionarParametro(new ParametroSimples(
				FiltroContaBancaria.ID, contaBancaria.getId()));

		Collection colecaoContaBancariaBase = getControladorUtil().pesquisar(
				filtroContaBancaria, ContaBancaria.class.getName());

		if (colecaoContaBancariaBase == null
				|| colecaoContaBancariaBase.isEmpty()) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		ContaBancaria contaBancariaBase = (ContaBancaria) colecaoContaBancariaBase
				.iterator().next();

		if (contaBancariaBase.getUltimaAlteracao().after(
				contaBancaria.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		contaBancaria.setUltimaAlteracao(new Date());

		getControladorUtil().atualizar(contaBancaria);

	}

	/**
	 * @author Ana Maria
	 * @date 29/01/2007
	 * 
	 * @param idGuiaPagamento
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */

	public Collection pesquisarGuiaPagemento(Integer idGuiaPagamento)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarGuiaPagamento(idGuiaPagamento);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0508] Filtrar Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 07/02/2007
	 * 
	 * @param Integer
	 * @return boolean
	 */
	public boolean verificarExistenciaAgente(Integer codigoAgente)
			throws ControladorException {

		// [FS0003] - Verificando a existência do Agente
		boolean retorno = true;

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();

		filtroArrecadador.adicionarParametro(new ParametroSimples(
				FiltroArrecadador.CODIGO_AGENTE, codigoAgente));

		Collection colecaoAgente = getControladorUtil().pesquisar(
				filtroArrecadador, Arrecadador.class.getName());

		if (colecaoAgente == null || colecaoAgente.isEmpty()) {
			throw new ControladorException("atencao.agente_inexistente");
		}
		return retorno;

	}

	/**
	 * [UC0507] Manter Arrecadador
	 * 
	 * Remover Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 08/02/2007
	 * 
	 * @pparam id, usuarioLogado
	 * @throws ControladorException
	 */
	public void removerArrecadador(String[] ids, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// [SB0002]
		this.getControladorUtil().remover(ids, Arrecadador.class.getName(),
				null, null);
	}

	/**
	 * [UC507] Manter Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 08/02/2007
	 * 
	 * @pparam
	 * @throws ControladorException
	 */
	public void atualizarArrecadador(Arrecadador arrecadador,
			Usuario usuarioLogado) throws ControladorException {

		arrecadador.setUltimaAlteracao(new Date());

		// [UC0107] - Registrar Transação
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ARRECADADOR_ATUALIZAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ARRECADADOR_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		arrecadador.setOperacaoEfetuada(operacaoEfetuada);

		arrecadador.adicionarUsuario(usuarioLogado,
				UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------
		// [FS0002] - Atualização realizada por outro usuário
		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
		// Seta o filtro para buscar o arrecadador na base
		filtroArrecadador.adicionarParametro(new ParametroSimples(
				FiltroArrecadador.ID, arrecadador.getId()));

		// Procura arrecadador na base
		Collection arrecadadorAtualizadas = getControladorUtil().pesquisar(
				filtroArrecadador, Arrecadador.class.getName());

		Arrecadador arrecadadorNaBase = (Arrecadador) Util
				.retonarObjetoDeColecao(arrecadadorAtualizadas);

		if (arrecadadorNaBase == null) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.registro_remocao_nao_existente");
		}

		// Verificar se o arrecadador já foi atualizado por outro usuário
		// durante esta atualização

		if (arrecadadorNaBase.getUltimaAlteracao().after(
				arrecadador.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		arrecadador.setUltimaAlteracao(new Date());

		// Atualiza o objeto na base
		getControladorUtil().atualizar(arrecadador);
	}

	/**
	 * Atualiza logradouroCep de um ou mais imóveis
	 * 
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroCep(LogradouroCep logradouroCepAntigo,
			LogradouroCep logradouroCepNovo) throws ControladorException {

		try {

			this.repositorioArrecadacao.atualizarLogradouroCep(
					logradouroCepAntigo, logradouroCepNovo);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Atualiza logradouroBairro de um ou mais imóveis
	 * 
	 * [UC0] Atualizar Logradouro
	 * 
	 * @author Raphael Rossiter
	 * @date 22/02/2007
	 * 
	 * @param
	 * @return void
	 */
	public void atualizarLogradouroBairro(
			LogradouroBairro logradouroBairroAntigo,
			LogradouroBairro logradouroBairroNovo) throws ControladorException {

		try {

			this.repositorioArrecadacao.atualizarLogradouroBairro(
					logradouroBairroAntigo, logradouroBairroNovo);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0213] Desfazer Parcelamento Debito - remover guia pagamento referente
	 * ao parcelamento
	 * 
	 * remove a guia de pagamento do Pagamento
	 * 
	 * @author Vivianne Sousa
	 * @date 06/03/2007
	 * 
	 * @param
	 * @return void
	 */
	public void removerGuiaPagamentoPagamento(Integer idPagamento)
			throws ControladorException {

		try {

			this.repositorioArrecadacao
					.removerGuiaPagamentoPagamento(idPagamento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * [UC0113] - Faturar Grupo de Faturamento
	 * 
	 * @author Raphael Rossiter
	 * @date 20/03/2007
	 * 
	 * @param idDebitoACobrar
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarQuantidadePagamentosPorDebitoACobrar(
			Integer idDebitoACobrar) throws ControladorException {

		try {

			return this.repositorioArrecadacao
					.pesquisarQuantidadePagamentosPorDebitoACobrar(idDebitoACobrar);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Pesquisa os movimentos dos arrecadores para a geração do relatório
	 * 
	 * [UCXXXX] Acompanhar Movimento dos Arrecadadores
	 * 
	 * @author Rafael Corrêa
	 * @date 02/04/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection pesquisarMovimentoArrecadadoresRelatorio(
			Integer mesAnoReferencia, Integer idArrecadador,
			Integer idFormaArrecadacao, Date dataPagamentoInicial,
			Date dataPagamentoFinal) throws ControladorException {

		Collection colecaoMovimentoArrecadadoresHelper = new ArrayList();
		Collection colecaoDadosMovimentoArrecadador = null;

		try {
			colecaoDadosMovimentoArrecadador = repositorioArrecadacao
					.pesquisarMovimentoArrecadadoresRelatorio(mesAnoReferencia,
							idArrecadador, idFormaArrecadacao,
							dataPagamentoInicial, dataPagamentoFinal);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}

		if (colecaoDadosMovimentoArrecadador != null
				&& !colecaoDadosMovimentoArrecadador.isEmpty()) {

			Iterator colecaoDadosMovimentoArrecadadorIterator = colecaoDadosMovimentoArrecadador
					.iterator();

			while (colecaoDadosMovimentoArrecadadorIterator.hasNext()) {

				Object[] dadosMoviemntoArrecador = (Object[]) colecaoDadosMovimentoArrecadadorIterator
						.next();

				MovimentoArrecadadoresRelatorioHelper movimentoArrecadadoresRelatorioHelper = new MovimentoArrecadadoresRelatorioHelper();

				if (dadosMoviemntoArrecador[0] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setAnoMesReferencia((Integer) dadosMoviemntoArrecador[0]);
				}

				if (dadosMoviemntoArrecador[1] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setArrecadador((String) dadosMoviemntoArrecador[1]);
				}

				if (dadosMoviemntoArrecador[2] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setDescricaoArrecadacaoForma((String) dadosMoviemntoArrecador[2]);
				}

				if (dadosMoviemntoArrecador[3] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setDataPagamento((Date) dadosMoviemntoArrecador[3]);
				}

				if (dadosMoviemntoArrecador[4] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setValorPagamento((BigDecimal) dadosMoviemntoArrecador[4]);
				}

				if (dadosMoviemntoArrecador[5] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setQtdeDocumentos((Integer) dadosMoviemntoArrecador[5]);
				}

				if (dadosMoviemntoArrecador[6] != null) {
					movimentoArrecadadoresRelatorioHelper
							.setQtdePagamentos((Integer) dadosMoviemntoArrecador[6]);
				}

				colecaoMovimentoArrecadadoresHelper
						.add(movimentoArrecadadoresRelatorioHelper);

			}

		}

		return colecaoMovimentoArrecadadoresHelper;

	}

	/**
	 * Relatório para acompanhar o movimento dos arrecadadores
	 * 
	 * @author Sávio Luiz
	 * @date 02/04/2007
	 * 
	 * @param idDebitoACobrar
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public void gerarResumoAcompanhamentoMovimentoArrecadadores(
			Usuario usuario, String mesAnoReferencia, Arrecadador arrecadador,
			ArrecadacaoForma arrecadacaoForma) throws ControladorException {

		EnvioEmail envioEmail = getControladorCadastro()
				.pesquisarEnvioEmail(
						EnvioEmail.GERAR_RELATORIO_ACOMPANHAMENTO_MOVIMENTO_ARRECADADORES);
		// Parte que gera o relatório e envia por email
		// cria uma instância da classe do relatório
		RelatorioAcompanhamentoMovimentoArrecadadores relatorioAcompanhamentoMovimentoArrecadadores = new RelatorioAcompanhamentoMovimentoArrecadadores(
				usuario);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro(
				"mesAnoReferencia", mesAnoReferencia);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro(
				"arrecadador", arrecadador);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro(
				"arrecadacaoForma", arrecadacaoForma);

		relatorioAcompanhamentoMovimentoArrecadadores.addParametro(
				"tipoFormatoRelatorio", TarefaRelatorio.TIPO_PDF);
		byte[] relatorioGerado = (byte[]) relatorioAcompanhamentoMovimentoArrecadadores
				.executar();

		String emailRemetente = envioEmail.getEmailRemetente();

		String tituloMensagem = envioEmail.getTituloMensagem();

		String corpoMensagem = envioEmail.getCorpoMensagem();
		String emailReceptor = envioEmail.getEmailReceptor();

		FileOutputStream out = null;
		
		try {
			File leitura = new File("gcom.PDF");
			out = new FileOutputStream(leitura
					.getAbsolutePath());
			out.write(relatorioGerado);
			out.flush();

			ServicosEmail.enviarMensagemArquivoAnexado(emailReceptor,
					emailRemetente, tituloMensagem, corpoMensagem, leitura);

			leitura.delete();
		} catch (IOException e) {
			throw new ControladorException("erro.sistema", e);
		} catch (Exception e) {
			throw new ControladorException("erro.sistema", e);
		} finally{
			IoUtil.fecharStream(out);
		}

	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 05/04/2007
	 * 
	 * @param guiaPagamentoHistoricoTemp
	 * @param idGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	protected void enviarGuiaPagamentoCategoriaParaHistorico(
			GuiaPagamentoHistorico guiaPagamentoHistoricoTemp,
			Integer idGuiaPagamento) throws ControladorException {

		Collection colecaoGuiaPagamentoCategoriaHistoricoInserir = new ArrayList();
		Collection colecaoGuiaPagamentoCategoriaRemover = new ArrayList();

		try {
			Collection<GuiaPagamentoCategoria> colecaoGuiaPagamentoCategoria = repositorioArrecadacao
					.pesquisarGuiaPagamentoCategoria(idGuiaPagamento);

			GuiaPagamentoCategoriaHistorico guiaPagamentoCategoriaHistoricoTemp = null;

			if (colecaoGuiaPagamentoCategoria != null
					&& !colecaoGuiaPagamentoCategoria.isEmpty()) {

				colecaoGuiaPagamentoCategoriaRemover
						.addAll(colecaoGuiaPagamentoCategoria);

				for (GuiaPagamentoCategoria guiaPagamentoCategoria : colecaoGuiaPagamentoCategoria) {

					GuiaPagamentoCategoriaHistoricoPK guiaPagamentoCategoriaHistoricoTempPK = new GuiaPagamentoCategoriaHistoricoPK(
							guiaPagamentoCategoria.getCategoria().getId(),
							guiaPagamentoHistoricoTemp.getId());

					guiaPagamentoCategoriaHistoricoTemp = new GuiaPagamentoCategoriaHistorico();
					guiaPagamentoCategoriaHistoricoTemp
							.setComp_id(guiaPagamentoCategoriaHistoricoTempPK);
					guiaPagamentoCategoriaHistoricoTemp
							.setCategoria(guiaPagamentoCategoria.getCategoria());
					guiaPagamentoCategoriaHistoricoTemp
							.setGuiaPagamentoHistorico(guiaPagamentoHistoricoTemp);
					guiaPagamentoCategoriaHistoricoTemp
							.setQuantidadeEconomia(guiaPagamentoCategoria
									.getQuantidadeEconomia());
					guiaPagamentoCategoriaHistoricoTemp
							.setUltimaAlteracao(new Date());
					guiaPagamentoCategoriaHistoricoTemp
							.setValorCategoria(guiaPagamentoCategoria
									.getValorCategoria());

					colecaoGuiaPagamentoCategoriaHistoricoInserir
							.add(guiaPagamentoCategoriaHistoricoTemp);
				}

				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoGuiaPagamentoCategoriaHistoricoInserir);

				getControladorBatch().removerColecaoGuiaPagamentoCategoriaParaBatch(colecaoGuiaPagamentoCategoriaRemover);

				colecaoGuiaPagamentoCategoriaHistoricoInserir = null;
				colecaoGuiaPagamentoCategoriaRemover = null;

			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * <Breve descrição sobre o caso de uso>
	 * 
	 * <Identificador e nome do caso de uso>
	 * 
	 * @author Pedro Alexandre
	 * @date 05/04/2007
	 * 
	 * @param guiaPagamentoHistoricoTemp
	 * @param idGuiaPagamento
	 * @throws ErroRepositorioException
	 */
	protected void enviarClienteGuiaPagamentoParaHistorico(
			GuiaPagamentoHistorico guiaPagamentoHistoricoTemp,
			Integer idGuiaPagamento) throws ControladorException {

		Collection colecaoClienteGuiaPagamentoHistoricoInserir = new ArrayList();
		Collection colecaoClienteGuiaPagamentoRemover = new ArrayList();
		try {
			Collection<ClienteGuiaPagamento> colecaoClienteGuiaPagamento = repositorioArrecadacao
					.pesquisarClienteGuiaPagamento(idGuiaPagamento);

			ClienteGuiaPagamentoHistorico clienteGuiaPagamentoHistoricoTemp = null;

			if (colecaoClienteGuiaPagamento != null
					&& !colecaoClienteGuiaPagamento.isEmpty()) {

				colecaoClienteGuiaPagamentoRemover
						.addAll(colecaoClienteGuiaPagamento);

				for (ClienteGuiaPagamento clienteGuiaPagamento : colecaoClienteGuiaPagamento) {
					clienteGuiaPagamentoHistoricoTemp = new ClienteGuiaPagamentoHistorico();
					clienteGuiaPagamentoHistoricoTemp
							.setId(clienteGuiaPagamento.getId());
					clienteGuiaPagamentoHistoricoTemp
							.setCliente(clienteGuiaPagamento.getCliente());
					clienteGuiaPagamentoHistoricoTemp
							.setClienteRelacaoTipo(clienteGuiaPagamento
									.getClienteRelacaoTipo());
					clienteGuiaPagamentoHistoricoTemp
							.setGuiaPagamentoHistorico(guiaPagamentoHistoricoTemp);
					clienteGuiaPagamentoHistoricoTemp
							.setUltimaAlteracao(new Date());

					colecaoClienteGuiaPagamentoHistoricoInserir
							.add(clienteGuiaPagamentoHistoricoTemp);
				}

				getControladorBatch().inserirColecaoObjetoParaBatch(
						colecaoClienteGuiaPagamentoHistoricoInserir);

				getControladorBatch().removerColecaoClienteGuiaPagamentoParaBatch(colecaoClienteGuiaPagamentoRemover);

				colecaoClienteGuiaPagamentoHistoricoInserir = null;
				colecaoClienteGuiaPagamentoRemover = null;

			}

		} catch (Exception ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	public Collection<Integer> pesquisarIdsSetoresComPagamentosOuDevolucoes()
			throws ControladorException {

		try {
			return repositorioArrecadacao
					.pesquisarIdsSetoresComPagamentosOuDevolucoes();
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}

	}

	public Pagamento pesquisarPagamentoDeConta(Integer idConta) throws ControladorException {

		Pagamento pagamento = null;
		
		if (idConta != null) {
			try {
				pagamento = repositorioArrecadacao.pesquisarPagamentoDeConta(idConta);
			} catch (ErroRepositorioException ex) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", ex);
			}
		}


		return pagamento;
	}

	/**
	 * 
	 * @author Sávio Luiz
	 * @data 28/04/2007
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDoDebitoACobrar(Integer idDebitoACobrar)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarIdPagamentoDoDebitoACobrar(idDebitoACobrar);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * 
	 * @author Sávio Luiz
	 * @data 28/04/2007
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Integer pesquisarIdPagamentoDaGuia(Integer idGuiaPagamento)
			throws ControladorException {
		try {
			return repositorioArrecadacao
					.pesquisarIdPagamentoDaGuia(idGuiaPagamento);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0509] Inserir Contrato Arrecadador
	 * 
	 * Inclusão de um novo Contrato de arrecadador.
	 * 
	 * @author Marcio Roberto
	 * @date 22/03/2007
	 * 
	 * @param
	 * @throws ControladorException
	 */
	public Integer inserirContratoArrecadador(ArrecadadorContrato contrato, 
			Collection<ArrecadadorContratoTarifa> colecaoArrecadadorContratoTarifa, 
			Usuario usuarioLogado) throws ControladorException {

		// // ------------ REGISTRAR TRANSAÇÃO ----------------------------
		// RegistradorOperacao registradorOperacao = new RegistradorOperacao(
		// Operacao.OPERACAO_ARRECADADOR_CONTRATO_INSERIR,
		// new UsuarioAcaoUsuarioHelper(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
		//
		// Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_CONTRATO_INSERIR);
		//
		// OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		// operacaoEfetuada.setOperacao(operacao);

		// arrecadador.setOperacaoEfetuada(operacaoEfetuada);
		// arrecadador.adicionarUsuario(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		// registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO ----------------------------

		contrato.setUltimaAlteracao(new Date());

		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(
				FiltroArrecadadorContrato.NUMEROCONTRATO, contrato
						.getNumeroContrato()));

		Collection colecaoArrecadadorContrato = getControladorUtil().pesquisar(
				filtroArrecadadorContrato, ArrecadadorContrato.class.getName());

		Integer idContrato = null;
		if (colecaoArrecadadorContrato.isEmpty()) {
			// Inserir na base de dados Arrecadador
			idContrato = (Integer) getControladorUtil().inserir(contrato);
		} else {
			throw new ControladorException(
					"atencao.arrecadador_contrato_ja_exixtente");
		}
		
		this.inserirArrecadadorContratoTarifa(contrato, colecaoArrecadadorContratoTarifa);
		
		return idContrato;
	}

	/**
	 * [UC0511] Filtrar Contrato Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 09/04/2007
	 * 
	 * @param Integer
	 * @return boolean
	 */
	public boolean verificarExistenciaArrecadador(Integer codigoArrecadador)
			throws ControladorException {

		// [FS0003] - Verificando a existência do Agente
		boolean retorno = true;

		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();

		filtroArrecadador.adicionarParametro(new ParametroSimples(
				FiltroArrecadador.ID, codigoArrecadador));

		Collection colecaoArrecadador = getControladorUtil().pesquisar(
				filtroArrecadador, Arrecadador.class.getName());

		if (colecaoArrecadador == null || colecaoArrecadador.isEmpty()) {
			throw new ControladorException("atencao.arrecadador_inexistente");
		}
		return retorno;

	}

	/**
	 * [UC0511] Filtrar Contrato Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 09/04/2007
	 * 
	 * @param Integer
	 * @return boolean
	 */
	public boolean verificarExistenciaContrato(String numeroContrato)
			throws ControladorException {

		
		boolean retorno = false;

		try {
			retorno = repositorioArrecadacao.verificarExistenciaContrato(numeroContrato);
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		
		if ( retorno == false ) {
			throw new ControladorException(
					"atencao.contratoArrecadador_inexistente");
		}
		return retorno;

	}

	/**
	 * [UC510] Atualiza Contrato Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 12/04/2007
	 * 
	 * @pparam
	 * @throws ControladorException
	 */
	public void atualizarContratoArrecadador(
			ArrecadadorContrato arrecadadorContrato, Collection<ArrecadadorContratoTarifa> colecaoArrecadadorContratoTarifa,
			Usuario usuarioLogado)
			throws ControladorException {

		arrecadadorContrato.setUltimaAlteracao(new Date());

		// [UC0107] - Registrar Transação
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		/*RegistradorOperacao registradorOperacao = new RegistradorOperacao(
				Operacao.OPERACAO_ARRECADADOR_CONTRATO_ATUALIZAR,
				new UsuarioAcaoUsuarioHelper(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));*/

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_ARRECADADOR_CONTRATO_ATUALIZAR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		// arrecadadorContrato.setOperacaoEfetuada(operacaoEfetuada);

		// arrecadador.adicionarUsuario(usuarioLogado,
		// UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		// registradorOperacao.registrarOperacao(arrecadador);
		// ------------ REGISTRAR TRANSAÇÃO----------------------------

		// [FS0002] - Atualização realizada por outro usuário
		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		// Seta o filtro para buscar o arrecadador na base
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(
				FiltroArrecadadorContrato.ID, arrecadadorContrato.getId()));

		// Procura arrecadador na base
		Collection<ArrecadadorContrato> contratoArrecadadorAtualizados = getControladorUtil()
				.pesquisar(filtroArrecadadorContrato,
						ArrecadadorContrato.class.getName());

		ArrecadadorContrato arrecadadorContratoNaBase = (ArrecadadorContrato) Util
				.retonarObjetoDeColecao(contratoArrecadadorAtualizados);

		if (arrecadadorContratoNaBase == null) {
			sessionContext.setRollbackOnly();
			throw new ControladorException(
					"atencao.registro_remocao_nao_existente");
		}

		// Verificar se o arrecadador já foi atualizado por outro usuário
		// durante esta atualização

		if (arrecadadorContratoNaBase.getUltimaAlteracao().after(
				arrecadadorContrato.getUltimaAlteracao())) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("atencao.atualizacao.timestamp");
		}

		arrecadadorContrato.setUltimaAlteracao(new Date());

		// Atualiza o objeto na base
		getControladorUtil().atualizar(arrecadadorContrato);
		
		//Faz um filtro para recuperar todas os contratos de tarifa na base
		// associadas àquele Arrecadador Contrato e remove todas para em seguida inserir
		// apenas as que o usuario selecionou no Atualizar Arrecadador Contrato
		FiltroArrecadadorContratoTarifa filtroArrecadadorContratoTarifa = new FiltroArrecadadorContratoTarifa();
		filtroArrecadadorContratoTarifa.adicionarParametro(new ParametroSimples(
				FiltroArrecadadorContratoTarifa.ARRECADADOR_CONTRATO_ID, arrecadadorContrato.getId() ) );

		Collection colecaoContratoTarifaBase = getControladorUtil()
				.pesquisar(filtroArrecadadorContratoTarifa,
						ArrecadadorContratoTarifa.class.getName());

		if (colecaoContratoTarifaBase != null
				&& !colecaoContratoTarifaBase.isEmpty()) {

			Iterator colecaoContratoTarifaBaseIterator = colecaoContratoTarifaBase
					.iterator();

			while (colecaoContratoTarifaBaseIterator.hasNext()) {

				ArrecadadorContratoTarifa arrecadadorContratoTarifaBase = (ArrecadadorContratoTarifa) 
						colecaoContratoTarifaBaseIterator.next();

				getControladorUtil().remover(arrecadadorContratoTarifaBase);
			}

		}

		// Insere os contratos de Tarifa selecionadas na base
		if (colecaoArrecadadorContratoTarifa != null
				&& !colecaoArrecadadorContratoTarifa.isEmpty()) {

			Iterator colecaoContratoTarifaIterator = colecaoArrecadadorContratoTarifa
					.iterator();

			while (colecaoContratoTarifaIterator.hasNext()) {

				ArrecadadorContratoTarifa arrecadadorContratoTarifa = (ArrecadadorContratoTarifa)
							colecaoContratoTarifaIterator.next();
				
				ArrecadadorContratoTarifaPK pk = new ArrecadadorContratoTarifaPK(arrecadadorContrato.getId(), 
						arrecadadorContratoTarifa.getArrecadacaoForma().getId());
				
				arrecadadorContratoTarifa.setComp_id(pk);
				
					this.getControladorUtil().inserir(arrecadadorContratoTarifa);
			}
		}

	}

	/**
	 * [UC0510] Remover Contrato Arrecadador
	 * 
	 * Remover Contrato de Arrecadador
	 * 
	 * @author Marcio Roberto
	 * @date 12/04/2007
	 * 
	 * @pparam id, usuarioLogado
	 * @throws ControladorException
	 */
	public void removerContratoArrecadador(String[] ids, Usuario usuarioLogado)
			throws ControladorException {

		// ------------ REGISTRAR TRANSAÇÃO ----------------
		Operacao operacao = new Operacao();
		// operacao.setId(Operacao.OPERACAO_ARRECADADOR_REMOVER);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);

		UsuarioAcaoUsuarioHelper usuarioAcaoUsuarioHelper = new UsuarioAcaoUsuarioHelper(
				usuarioLogado, UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
		Collection<UsuarioAcaoUsuarioHelper> colecaoUsuarios = new ArrayList();
		colecaoUsuarios.add(usuarioAcaoUsuarioHelper);
		// ------------ REGISTRAR TRANSAÇÃO ----------------

		// [SB0002]
		this.getControladorUtil().remover(ids,
				ArrecadadorContrato.class.getName(), null, null);
	}

	/**
	 * Retorna uma coleção de ids de categoria
	 * 
	 * @author Pedro Alexandre
	 * @date 13/06/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Collection<Integer> pesquisarIdsCategoria()
			throws ControladorException {

		try {
			return this.repositorioArrecadacao.pesquisarIdsCategorias();

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	// //////////////////////////////////////////////////////////////////
	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 19/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio(
			int anoMesReferencia) throws ControladorException {

		Collection colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio = new ArrayList();
		Collection retorno = new ArrayList();

		try {
			colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio = repositorioArrecadacao
					.consultarResumoArrecadacaoRelatorioPorEstadoPorUnidadeNegocio(anoMesReferencia);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio
				.iterator();

		// Prepara cada linha do relatório
		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String codigoCentroCusto = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (recebimentoTipo == null) {
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (recebimentoTipo.equals(tempRecebimentoTipo)
					&& tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					switch (((Integer) element[9]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
						arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(String) elementAnterior[4],
						(Short) elementAnterior[5], (Short) elementAnterior[6],
						(Integer) elementAnterior[7],
						(Integer) elementAnterior[8], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, null, null,
						descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				retorno.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[9]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			if (idGerenciaRegionalAnterior != null
					&& !idGerenciaRegionalAnterior.equals("" + element[16])) {
				// quebra por gerencia
				retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
						anoMesReferencia, new Integer(
								idGerenciaRegionalAnterior), retorno);
			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[15];
			idGerenciaRegionalAnterior = "" + element[16];

			descUnidadeNegocioAnterior = "" + element[10];
			idUnidadeNegocioAnterior = "" + element[11];

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio != null
				&& !colecaoResumoArrecadacaoRelatorioEstadoPorUnidadeNegocio
						.isEmpty()) {
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
					arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(String) elementAnterior[4], (Short) elementAnterior[5],
					(Short) elementAnterior[6], (Integer) elementAnterior[7],
					(Integer) elementAnterior[8], false,
					descGerenciaRegionalAnterior, idGerenciaRegionalAnterior,
					descLocalidadeAnterior, idLocalidadeAnterior,
					null, null, 
					descLancamentoTipoSuperior, descUnidadeNegocioAnterior,
					idUnidadeNegocioAnterior,
					codigoCentroCusto);

			retorno.add(resumoArrecadacaoRelatorioHelper);

			retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
					anoMesReferencia, new Integer(idGerenciaRegionalAnterior),
					retorno);
		}

		return retorno;

	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 19/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
			int anoMesReferencia, Integer idGerenciaRegional,
			Collection colecaoResumoArrecadacaoRelatorio)
			throws ControladorException {

		Collection colecaoResumoArrecadacaoRelatorioPorGerenciaRegional = new ArrayList();

		try {
			colecaoResumoArrecadacaoRelatorioPorGerenciaRegional = repositorioArrecadacao
					.consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
							anoMesReferencia, idGerenciaRegional);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iteratorResumoArrecadacaoRelatorioPorGerenciaRegional = colecaoResumoArrecadacaoRelatorioPorGerenciaRegional
				.iterator();

		// Prepara cada linha do relatório
		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String codigoCentroCusto =  null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		Boolean agrupaPorGerencia = true;
		

		while (iteratorResumoArrecadacaoRelatorioPorGerenciaRegional.hasNext()) {
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iteratorResumoArrecadacaoRelatorioPorGerenciaRegional
					.next();

			if (recebimentoTipo == null) {
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (recebimentoTipo.equals(tempRecebimentoTipo)
					&& tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					// se for agrupado por gerencia
					// compara se o registro atual eh da
					// mesma gerencia regional do registro anterior
					if (!agrupaPorGerencia
							|| descGerenciaRegionalAnterior == null
							|| (agrupaPorGerencia && descGerenciaRegionalAnterior
									.equalsIgnoreCase((String) element[10]))) {

						switch (((Integer) element[9]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}
					} else {
						condicaoIgual = false;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
						arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(String) elementAnterior[4],
						(Short) elementAnterior[5], (Short) elementAnterior[6],
						(Integer) elementAnterior[7],
						(Integer) elementAnterior[8], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, null, null,
						descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				colecaoResumoArrecadacaoRelatorio
						.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[9]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descGerenciaRegionalAnterior = "" + element[10];
			idGerenciaRegionalAnterior = "" + element[11];

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoArrecadacaoRelatorio != null
				&& !colecaoResumoArrecadacaoRelatorio.isEmpty()) {
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
					arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(String) elementAnterior[4], (Short) elementAnterior[5],
					(Short) elementAnterior[6], (Integer) elementAnterior[7],
					(Integer) elementAnterior[8], false,
					descGerenciaRegionalAnterior, idGerenciaRegionalAnterior,
					descLocalidadeAnterior, idLocalidadeAnterior, null, null,
					descLancamentoTipoSuperior, descUnidadeNegocioAnterior,
					idUnidadeNegocioAnterior,codigoCentroCusto);

			colecaoResumoArrecadacaoRelatorio
					.add(resumoArrecadacaoRelatorioHelper);
		}

		return colecaoResumoArrecadacaoRelatorio;
	}

	/**
	 * Pesquisar pagamentos pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarPagamentos(
			FiltroPagamento filtroPagamento) throws ControladorException {

		PagamentosDevolucoesHelper pagamentos = null;

		try {

			pagamentos = repositorioArrecadacao
					.filtrarPagamentos(filtroPagamento);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		return pagamentos;
	}

	/**
	 * Pesquisar devoluções pelo aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 11/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public PagamentosDevolucoesHelper filtrarDevolucoes(
			FiltroDevolucao filtroDevolucao) throws ControladorException {

		PagamentosDevolucoesHelper devolucoes = null;

		try {

			devolucoes = repositorioArrecadacao
					.filtrarDevolucoes(filtroDevolucao);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		return devolucoes;
	}

	/**
	 * Pesquisar valores de arrecadação e devolução do aviso bancário
	 * 
	 * @author Ana Maria
	 * @date 14/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public ValoresArrecadacaoDevolucaoAvisoBancarioHelper pesquisarValoresAvisoBancario(
			Integer idAvisoBancario) throws ControladorException {

		ValoresArrecadacaoDevolucaoAvisoBancarioHelper helper = null;

		try {

			helper = repositorioArrecadacao
					.pesquisarValoresAvisoBancario(idAvisoBancario);

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		return helper;
	}

	/**
	 * Atualizar Pagamentos e Aviso Bancário
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void atualizarAvisoBancarioPagamentos(
			Collection<Integer> idsPagamentos,
			String arrecadacaoInformadoDepoisOrigem,
			String arrecadacaoCalculadoDepoisOrigem,
			String arrecadacaoInformadoDepoisDestino,
			String arrecadacaoCalculadoDepoisDestino, Integer idAvisoBancarioO,
			Integer idAvisoBancarioD) throws ControladorException {
		try {
			if (idsPagamentos != null && !idsPagamentos.isEmpty()) {
				repositorioArrecadacao.atualizarAvisoBancarioPagamentos(
						idsPagamentos, idAvisoBancarioD);

				repositorioArrecadacao.atualizarValorArrecadacaoAvisoBancario(
						arrecadacaoInformadoDepoisOrigem,
						arrecadacaoCalculadoDepoisOrigem, idAvisoBancarioO);

				repositorioArrecadacao.atualizarValorArrecadacaoAvisoBancario(
						arrecadacaoInformadoDepoisDestino,
						arrecadacaoCalculadoDepoisDestino, idAvisoBancarioD);
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

	}

	/**
	 * Atualizar Devoluções e Aviso Bancário
	 * 
	 * @author Ana Maria
	 * @date 15/06/2007
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public void atualizarAvisoBancarioDevolucoes(
			Collection<Integer> idsDevolucoes,
			String devolucaoInformadoDepoisOrigem,
			String devolucaoCalculadoDepoisOrigem,
			String devolucaoInformadoDepoisDestino,
			String devolucaoCalculadoDepoisDestino, Integer idAvisoBancarioO,
			Integer idAvisoBancarioD) throws ControladorException {
		try {
			if (idsDevolucoes != null && !idsDevolucoes.isEmpty()) {
				repositorioArrecadacao.atualizarAvisoBancarioDevolucoes(
						idsDevolucoes, idAvisoBancarioD);

				repositorioArrecadacao.atualizarValorDevolucaoAvisoBancario(
						devolucaoInformadoDepoisOrigem,
						devolucaoCalculadoDepoisOrigem, idAvisoBancarioO);

				repositorioArrecadacao.atualizarValorDevolucaoAvisoBancario(
						devolucaoInformadoDepoisDestino,
						devolucaoCalculadoDepoisDestino, idAvisoBancarioD);
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	// //////////////////////////////////////////////////////////////////////////

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return 
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(
			int anoMesReferencia) throws ControladorException {

		Collection colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade = new ArrayList();
		Collection retorno = new ArrayList();
		int contadorGerencia = 0;
		int contadorUnidade = 0;
		
		try {
			colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade = repositorioArrecadacao
					.consultarResumoArrecadacaoRelatorioPorEstadoPorLocalidade(anoMesReferencia);

			if (colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade != null
					&& !colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade
							.isEmpty()) {

				Iterator iterator = colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade
						.iterator();

				// Prepara cada linha do relatório
				String recebimentoTipo = null;
				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String codigoCentroCustoAnterior = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				while (iterator.hasNext()) {
					Object[] element = null;
					String tempRecebimentoTipo = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;
					String codigoCentroCusto = null;
					element = (Object[]) iterator.next();

					if (recebimentoTipo == null) {
						recebimentoTipo = (String) element[1];
						tipoLancamento = (String) element[2];
						itemLancamento = (String) element[3];
						itemContabel = (String) element[4];
					}

					tempRecebimentoTipo = (String) element[1];
					tempTipoLancamento = (String) element[2];
					tempItemLancamento = (String) element[3];
					tempItemContabel = (String) element[4];
                    
					codigoCentroCusto = (String) element[19];

					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if (recebimentoTipo.equals(tempRecebimentoTipo)
							&& tipoLancamento.equals(tempTipoLancamento)
							&& itemLancamento.equals(tempItemLancamento)) {

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if (itemContabel == null
								&& tempItemContabel == null
								|| (itemContabel != null
										&& tempItemContabel != null && itemContabel
										.equals(tempItemContabel))) {

							switch (((Integer) element[9]).intValue()) {
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
							}

						} else {

							condicaoIgual = false;
						}

					} else {

						condicaoIgual = false;

					}

					if (!condicaoIgual) {

						// adiciona uma linha no relátorio
						ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
								arrayValores,
								(String) elementAnterior[1],
								(String) elementAnterior[2],
								(String) elementAnterior[3],
								(String) elementAnterior[4],
								(Short) elementAnterior[5],
								(Short) elementAnterior[6],
								(Integer) elementAnterior[7],
								(Integer) elementAnterior[8], false,
								descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior,
								descLocalidadeAnterior, idLocalidadeAnterior,
								null, null,
								descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior,
								idUnidadeNegocioAnterior,
								codigoCentroCustoAnterior);

						retorno.add(resumoArrecadacaoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch (((Integer) element[9]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}

					}

					if (idUnidadeNegocioAnterior != null
							&& !idUnidadeNegocioAnterior.equals(""
									+ element[18])) {
						// quebra por Unidade Negocio
						retorno = consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
								anoMesReferencia, new Integer(
										idUnidadeNegocioAnterior), retorno);

						contadorUnidade++;
					}

					if (idGerenciaRegionalAnterior != null
							&& !idGerenciaRegionalAnterior.equals(""
									+ element[11])) {
						// quebra por gerencia
						retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
								anoMesReferencia, new Integer(
										idGerenciaRegionalAnterior), retorno);
						contadorGerencia++;
					}

					elementAnterior[1] = element[1]; // descricaoTipoRecebimento
					elementAnterior[2] = element[2]; // descricaoTipoLancamento
					elementAnterior[3] = element[3]; // descricaoItemLancamento
					elementAnterior[4] = element[4]; // descricaoItemContabil
					elementAnterior[5] = element[5]; // indicadorImpressao
					elementAnterior[6] = element[6]; // indicadorTotal
					elementAnterior[7] = element[7]; // lancamentoTipo
					elementAnterior[8] = element[8]; // lancamentoTipoSuperior

					descGerenciaRegionalAnterior = "" + element[10];
					idGerenciaRegionalAnterior = "" + element[11];
					descLocalidadeAnterior = "" + element[12];
					idLocalidadeAnterior = "" + element[13];
					descUnidadeNegocioAnterior = "" + element[17];
					idUnidadeNegocioAnterior = "" + element[18];
					codigoCentroCustoAnterior = codigoCentroCusto;
					recebimentoTipo = tempRecebimentoTipo;
					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;
					

				}

				if (colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade != null
						&& !colecaoResumoArrecadacaoRelatorioEstadoPorLocalidade
								.isEmpty()) {
					// adiciona a ultima linha
					ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
							arrayValores,
							(String) elementAnterior[1],
							(String) elementAnterior[2],
							(String) elementAnterior[3],
							(String) elementAnterior[4],
							(Short) elementAnterior[5],
							(Short) elementAnterior[6],
							(Integer) elementAnterior[7],
							(Integer) elementAnterior[8], false,
							descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior,
							idLocalidadeAnterior, null, null, 
							descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior,
							idUnidadeNegocioAnterior,
							codigoCentroCustoAnterior);

					retorno.add(resumoArrecadacaoRelatorioHelper);

					retorno = consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
							anoMesReferencia, new Integer(
									idUnidadeNegocioAnterior), retorno);

					retorno = consultarResumoArrecadacaoRelatorioPorGerenciaRegional(
							anoMesReferencia, new Integer(
									idGerenciaRegionalAnterior), retorno);

					retorno = consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia, retorno, false);

				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		System.out.println("Contador Unidade de Negócio: " + contadorUnidade);
		System.out.println("Contador Gerência Regional: " + contadorGerencia);
		return retorno;

	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @date 20/04/2011
	 * 
	 * @param anoMesReferencia
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstadoPorMunicipio(int anoMesReferencia) throws ControladorException {

		Collection colecaoResuArrecRelatEstadoPorMuni = new ArrayList();
		Collection retorno = new ArrayList();
		
		try {
			colecaoResuArrecRelatEstadoPorMuni = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorEstadoPorMunicipio(anoMesReferencia);

			if (colecaoResuArrecRelatEstadoPorMuni != null && !colecaoResuArrecRelatEstadoPorMuni.isEmpty()) {

				Iterator iterator = colecaoResuArrecRelatEstadoPorMuni.iterator();

				// Prepara cada linha do relatório
				String recebimentoTipo = null;
				String tipoLancamento = null;
				String itemLancamento = null;
				String itemContabel = null;

				String descGerenciaRegionalAnterior = null;
				String idGerenciaRegionalAnterior = null;
				String descLocalidadeAnterior = null;
				String idLocalidadeAnterior = null;
				String descMunicipioAnterior = null;
				String idMunicipioAnterior = null;
				String codigoCentroCustoAnterior = null;
				String descLancamentoTipoSuperior = "";

				String descUnidadeNegocioAnterior = null;
				String idUnidadeNegocioAnterior = null;

				Object[] elementAnterior = new Object[13];
				BigDecimal[] arrayValores = new BigDecimal[5];

				while (iterator.hasNext()) {
					Object[] element = null;
					String tempRecebimentoTipo = null;
					String tempTipoLancamento = null;
					String tempItemLancamento = null;
					String tempItemContabel = null;
					element = (Object[]) iterator.next();

					if (recebimentoTipo == null) {
						recebimentoTipo = (String) element[1];
						tipoLancamento = (String) element[2];
						itemLancamento = (String) element[3];
						itemContabel = (String) element[4];
					}

					tempRecebimentoTipo = (String) element[1];
					tempTipoLancamento = (String) element[2];
					tempItemLancamento = (String) element[3];
					tempItemContabel = (String) element[4];
                    
					boolean condicaoIgual = true;
					// compara se o registro atual eh do
					// mesmo tipo de Recebimento, mesmo tipo de lançamento
					// e mesmo item de lançamento do registro anterior
					if (recebimentoTipo.equals(tempRecebimentoTipo) && tipoLancamento.equals(tempTipoLancamento) 
							&& itemLancamento.equals(tempItemLancamento)) {

						// se o registro possuir item contabel
						// compara se eh do mesmo item contabel do registro
						// anterior
						if (itemContabel == null && tempItemContabel == null || (itemContabel != null
										&& tempItemContabel != null && itemContabel.equals(tempItemContabel))) {

							switch (((Integer) element[9]).intValue()) {
							case 1:
								arrayValores[0] = (BigDecimal) element[0];
								break;
							case 2:
								arrayValores[1] = (BigDecimal) element[0];
								break;
							case 3:
								arrayValores[2] = (BigDecimal) element[0];
								break;
							case 4:
								arrayValores[4] = (BigDecimal) element[0];
								break;
							}
						} else {
							condicaoIgual = false;
						}
					} else {
						condicaoIgual = false;
					}

					if (!condicaoIgual) {

						// adiciona uma linha no relátorio
						ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
								arrayValores,
								(String) elementAnterior[1],
								(String) elementAnterior[2],
								(String) elementAnterior[3],
								(String) elementAnterior[4],
								(Short) elementAnterior[5],
								(Short) elementAnterior[6],
								(Integer) elementAnterior[7],
								(Integer) elementAnterior[8], false,
								descGerenciaRegionalAnterior,
								idGerenciaRegionalAnterior,
								descLocalidadeAnterior, idLocalidadeAnterior,
								descMunicipioAnterior, idMunicipioAnterior,
								descLancamentoTipoSuperior,
								descUnidadeNegocioAnterior,
								idUnidadeNegocioAnterior,
								codigoCentroCustoAnterior);

						retorno.add(resumoArrecadacaoRelatorioHelper);

						arrayValores = new BigDecimal[5];
						switch (((Integer) element[9]).intValue()) {
						case 1:
							arrayValores[0] = (BigDecimal) element[0];
							break;
						case 2:
							arrayValores[1] = (BigDecimal) element[0];
							break;
						case 3:
							arrayValores[2] = (BigDecimal) element[0];
							break;
						case 4:
							arrayValores[4] = (BigDecimal) element[0];
							break;
						}

					}

					if(idMunicipioAnterior != null && !idMunicipioAnterior.equals(String.valueOf((Integer) element[13]))){
						// quebra por Município Associado a Localidade
						retorno = consultarResumoArrecadacaoRelatorioPorMunicipio(
								anoMesReferencia, new Integer(idMunicipioAnterior), retorno);
					}

					elementAnterior[1] = element[1]; // descricaoTipoRecebimento
					elementAnterior[2] = element[2]; // descricaoTipoLancamento
					elementAnterior[3] = element[3]; // descricaoItemLancamento
					elementAnterior[4] = element[4]; // descricaoItemContabil
					elementAnterior[5] = element[5]; // indicadorImpressao
					elementAnterior[6] = element[6]; // indicadorTotal
					elementAnterior[7] = element[7]; // lancamentoTipo
					elementAnterior[8] = element[8]; // lancamentoTipoSuperior

					descLocalidadeAnterior = (String) element[10];
					idLocalidadeAnterior = String.valueOf((Integer) element[11]);
					descMunicipioAnterior = (String) element[12];
					idMunicipioAnterior = String.valueOf((Integer) element[13]);
					recebimentoTipo = tempRecebimentoTipo;
					tipoLancamento = tempTipoLancamento;
					itemLancamento = tempItemLancamento;
					itemContabel = tempItemContabel;
				}

				if (colecaoResuArrecRelatEstadoPorMuni != null && !colecaoResuArrecRelatEstadoPorMuni.isEmpty()) {
					// adiciona a ultima linha
					ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
							arrayValores,
							(String) elementAnterior[1],
							(String) elementAnterior[2],
							(String) elementAnterior[3],
							(String) elementAnterior[4],
							(Short) elementAnterior[5],
							(Short) elementAnterior[6],
							(Integer) elementAnterior[7],
							(Integer) elementAnterior[8], false,
							descGerenciaRegionalAnterior,
							idGerenciaRegionalAnterior, descLocalidadeAnterior,
							idLocalidadeAnterior, descMunicipioAnterior, idMunicipioAnterior, 
							descLancamentoTipoSuperior,
							descUnidadeNegocioAnterior,
							idUnidadeNegocioAnterior,
							codigoCentroCustoAnterior);

					retorno.add(resumoArrecadacaoRelatorioHelper);

					retorno = consultarResumoArrecadacaoRelatorioPorMunicipio(
							anoMesReferencia, new Integer(idMunicipioAnterior), retorno);
					
					retorno = consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia, retorno, true);
				}
			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return retorno;
	}
	
	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Diogo Peixoto
	 * @date 20/04/2011
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorMunicipio(int anoMesReferencia, Integer idMunicipio, 
			Collection colecaoResumoArrecadacaoRelatorio) throws ControladorException {

		Collection colecaoResuArrecRelPorMunicipio = new ArrayList();
		
		try {
			colecaoResuArrecRelPorMunicipio = repositorioArrecadacao.consultarResumoArrecadacaoRelatorioPorMunicipio(
							anoMesReferencia, idMunicipio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResuArrecRelPorMunicipio.iterator();

		// Prepara cada linha do relatório
		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descMunicipioAnterior = null;
		String idMunicipioAnterior = null;
		String descLancamentoTipoSuperior = "";

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (recebimentoTipo == null) {
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (recebimentoTipo.equals(tempRecebimentoTipo)
					&& tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null && tempItemContabel == null || (itemContabel != null && 
						tempItemContabel != null && itemContabel.equals(tempItemContabel))) {

					switch (((Integer) element[9]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}
				} else {
					condicaoIgual = false;
				}
			} else {
				condicaoIgual = false;
			}

			if (!condicaoIgual) {
				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
						arrayValores, (String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
						(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6],
						(Integer) elementAnterior[7], (Integer) elementAnterior[8], false,
						null, null, null, null, 
						descMunicipioAnterior, idMunicipioAnterior,
						descLancamentoTipoSuperior, null, null, null);

				colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[9]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}
			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descMunicipioAnterior = (String) element[10];
			idMunicipioAnterior = String.valueOf((Integer) element[11]);
			
			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;
		}

		if (colecaoResumoArrecadacaoRelatorio != null && !colecaoResumoArrecadacaoRelatorio.isEmpty()) {
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
					arrayValores, (String) elementAnterior[1], (String) elementAnterior[2], (String) elementAnterior[3],
					(String) elementAnterior[4], (Short) elementAnterior[5], (Short) elementAnterior[6], 
					(Integer) elementAnterior[7], (Integer) elementAnterior[8], false,
					null, null, null, null,
					descMunicipioAnterior, idMunicipioAnterior,
					descLancamentoTipoSuperior, null, null, null);

			colecaoResumoArrecadacaoRelatorio.add(resumoArrecadacaoRelatorioHelper);
		}
		return colecaoResumoArrecadacaoRelatorio;
	}
	
	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
			int anoMesReferencia, Integer idUnidadeNegocio,
			Collection colecaoResumoArrecadacaoRelatorio)
			throws ControladorException {

		Collection colecaoResumoArrecadacaoRelatorioPorUnidadeNegocio = new ArrayList();

		try {
			colecaoResumoArrecadacaoRelatorioPorUnidadeNegocio = repositorioArrecadacao
					.consultarResumoArrecadacaoRelatorioPorUnidadeNegocio(
							anoMesReferencia, idUnidadeNegocio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoArrecadacaoRelatorioPorUnidadeNegocio
				.iterator();

		// Prepara cada linha do relatório

		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;		
		String idLocalidadeAnterior = null;
		String codigoCentroCusto = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (recebimentoTipo == null) {
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (recebimentoTipo.equals(tempRecebimentoTipo)
					&& tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					switch (((Integer) element[9]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
						arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(String) elementAnterior[4],
						(Short) elementAnterior[5], (Short) elementAnterior[6],
						(Integer) elementAnterior[7],
						(Integer) elementAnterior[8], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, descLancamentoTipoSuperior,
						null, null,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,
						codigoCentroCusto);

				colecaoResumoArrecadacaoRelatorio
						.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[9]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			descUnidadeNegocioAnterior = "" + element[10];
			idUnidadeNegocioAnterior = "" + element[11];
			descGerenciaRegionalAnterior = "" + element[15];
			idGerenciaRegionalAnterior = "" + element[16];

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoArrecadacaoRelatorio != null
				&& !colecaoResumoArrecadacaoRelatorio.isEmpty()) {
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
					arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(String) elementAnterior[4], (Short) elementAnterior[5],
					(Short) elementAnterior[6], (Integer) elementAnterior[7],
					(Integer) elementAnterior[8], false,
					descGerenciaRegionalAnterior, idGerenciaRegionalAnterior,
					descLocalidadeAnterior, idLocalidadeAnterior,
					null, null,
					descLancamentoTipoSuperior, descUnidadeNegocioAnterior,
					idUnidadeNegocioAnterior, codigoCentroCusto);

			colecaoResumoArrecadacaoRelatorio
					.add(resumoArrecadacaoRelatorioHelper);
		}

		return colecaoResumoArrecadacaoRelatorio;
	}

	/**
	 * Consulta ResumoArrecadacao para a geração do relatório '[UC0345] Gerar
	 * Relatório de Resumo Arrecadacao' de acordo com a opção de totalização.
	 * 
	 * @author Vivianne Sousa
	 * @date 26/06/2007
	 * 
	 * @param opcaoTotalizacao
	 * @return
	 * @throws ControladorException
	 */
	public Collection consultarResumoArrecadacaoRelatorioPorEstado(
			int anoMesReferencia, Collection colecaoResumoArrecadacaoRelatorio, boolean estadoMunicipio)
			throws ControladorException {

		Collection colecaoResumoArrecadacaoRelatorioPorEstado = new ArrayList();

		try {
			colecaoResumoArrecadacaoRelatorioPorEstado = repositorioArrecadacao
					.consultarResumoArrecadacaoRelatorioPorEstado(anoMesReferencia, estadoMunicipio);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		Iterator iterator = colecaoResumoArrecadacaoRelatorioPorEstado
				.iterator();

		String recebimentoTipo = null;
		String tipoLancamento = null;
		String itemLancamento = null;
		String itemContabel = null;

		String descGerenciaRegionalAnterior = null;
		String idGerenciaRegionalAnterior = null;
		String descLocalidadeAnterior = null;
		String idLocalidadeAnterior = null;
		String codigoCentroCusto = null;
		String descLancamentoTipoSuperior = "";

		String descUnidadeNegocioAnterior = null;
		String idUnidadeNegocioAnterior = null;

		Object[] elementAnterior = new Object[13];
		BigDecimal[] arrayValores = new BigDecimal[5];

		while (iterator.hasNext()) {
			Object[] element = null;
			String tempRecebimentoTipo = null;
			String tempTipoLancamento = null;
			String tempItemLancamento = null;
			String tempItemContabel = null;

			element = (Object[]) iterator.next();

			if (recebimentoTipo == null) {
				recebimentoTipo = (String) element[1];
				tipoLancamento = (String) element[2];
				itemLancamento = (String) element[3];
				itemContabel = (String) element[4];
			}

			tempRecebimentoTipo = (String) element[1];
			tempTipoLancamento = (String) element[2];
			tempItemLancamento = (String) element[3];
			tempItemContabel = (String) element[4];

			boolean condicaoIgual = true;
			// compara se o registro atual eh do
			// mesmo tipo de Recebimento, mesmo tipo de lançamento
			// e mesmo item de lançamento do registro anterior
			if (recebimentoTipo.equals(tempRecebimentoTipo)
					&& tipoLancamento.equals(tempTipoLancamento)
					&& itemLancamento.equals(tempItemLancamento)) {

				// se o registro possuir item contabel
				// compara se eh do mesmo item contabel do registro anterior
				if (itemContabel == null
						&& tempItemContabel == null
						|| (itemContabel != null && tempItemContabel != null && itemContabel
								.equals(tempItemContabel))) {

					switch (((Integer) element[9]).intValue()) {
					case 1:
						arrayValores[0] = (BigDecimal) element[0];
						break;
					case 2:
						arrayValores[1] = (BigDecimal) element[0];
						break;
					case 3:
						arrayValores[2] = (BigDecimal) element[0];
						break;
					case 4:
						arrayValores[4] = (BigDecimal) element[0];
						break;
					}

				} else {

					condicaoIgual = false;
				}

			} else {

				condicaoIgual = false;

			}

			if (!condicaoIgual) {

				// adiciona uma linha no relátorio
				ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
						arrayValores,
						(String) elementAnterior[1],
						(String) elementAnterior[2],
						(String) elementAnterior[3],
						(String) elementAnterior[4],
						(Short) elementAnterior[5], (Short) elementAnterior[6],
						(Integer) elementAnterior[7],
						(Integer) elementAnterior[8], false,
						descGerenciaRegionalAnterior,
						idGerenciaRegionalAnterior, descLocalidadeAnterior,
						idLocalidadeAnterior, null, null, descLancamentoTipoSuperior,
						descUnidadeNegocioAnterior, idUnidadeNegocioAnterior,codigoCentroCusto);

				colecaoResumoArrecadacaoRelatorio
						.add(resumoArrecadacaoRelatorioHelper);

				arrayValores = new BigDecimal[5];
				switch (((Integer) element[9]).intValue()) {
				case 1:
					arrayValores[0] = (BigDecimal) element[0];
					break;
				case 2:
					arrayValores[1] = (BigDecimal) element[0];
					break;
				case 3:
					arrayValores[2] = (BigDecimal) element[0];
					break;
				case 4:
					arrayValores[4] = (BigDecimal) element[0];
					break;
				}

			}

			elementAnterior[1] = element[1]; // descricaoTipoRecebimento
			elementAnterior[2] = element[2]; // descricaoTipoLancamento
			elementAnterior[3] = element[3]; // descricaoItemLancamento
			elementAnterior[4] = element[4]; // descricaoItemContabil
			elementAnterior[5] = element[5]; // indicadorImpressao
			elementAnterior[6] = element[6]; // indicadorTotal
			elementAnterior[7] = element[7]; // lancamentoTipo
			elementAnterior[8] = element[8]; // lancamentoTipoSuperior

			recebimentoTipo = tempRecebimentoTipo;
			tipoLancamento = tempTipoLancamento;
			itemLancamento = tempItemLancamento;
			itemContabel = tempItemContabel;

		}

		if (colecaoResumoArrecadacaoRelatorio != null
				&& !colecaoResumoArrecadacaoRelatorio.isEmpty()) {
			// adiciona a ultima linha
			ResumoArrecadacaoRelatorioHelper resumoArrecadacaoRelatorioHelper = new ResumoArrecadacaoRelatorioHelper(
					arrayValores, (String) elementAnterior[1],
					(String) elementAnterior[2], (String) elementAnterior[3],
					(String) elementAnterior[4], (Short) elementAnterior[5],
					(Short) elementAnterior[6], (Integer) elementAnterior[7],
					(Integer) elementAnterior[8], false,
					descGerenciaRegionalAnterior, idGerenciaRegionalAnterior,
					descLocalidadeAnterior, idLocalidadeAnterior,
					null, null,
					descLancamentoTipoSuperior, descUnidadeNegocioAnterior,
					idUnidadeNegocioAnterior,codigoCentroCusto);

			colecaoResumoArrecadacaoRelatorio
					.add(resumoArrecadacaoRelatorioHelper);
		}

		return colecaoResumoArrecadacaoRelatorio;
	}

	/**
	 * [UC0263] Filtrar Movimento dos Arrecadadores - Relatório
	 * 
	 * @author Ana Maria
	 * @date 13/07/07
	 * 
	 * @param codigoBanco
	 * @param codigoRemessa
	 * @param descricaoIdentificacaoServico
	 * @param numeroSequencialArquivo
	 * @param dataGeracaoInicio
	 * @param dataGeracaoFim
	 * @param ultimaAlteracaoInicio
	 * @param ultimaAlteracaoFim
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacao
	 * @param indicadorAbertoFechado
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> filtrarIdsMovimentoArrecadador(
			String codigoBanco, String codigoRemessa,
			String descricaoIdentificacaoServico,
			String numeroSequencialArquivo, Date dataGeracaoInicio,
			Date dataGeracaoFim, Date ultimaAlteracaoInicio,
			Date ultimaAlteracaoFim, String descricaoOcorrencia,
			String indicadorAceitacao, String indicadorAbertoFechado)
			throws ControladorException {

		Collection<Integer> retorno = new ArrayList<Integer>();

		try {

			retorno = repositorioArrecadacao.filtrarIdsMovimentoArrecadador(
					codigoBanco, codigoRemessa, descricaoIdentificacaoServico,
					numeroSequencialArquivo, dataGeracaoInicio, dataGeracaoFim,
					ultimaAlteracaoInicio, ultimaAlteracaoFim,
					descricaoOcorrencia, indicadorAceitacao,
					indicadorAbertoFechado);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return retorno;

	}

	/**
	 * 
	 * [UC0619] Gerar Relação de Acompanhamento dos Movimentos Arrecadadores por
	 * NSA
	 * 
	 * @author Ana Maria
	 * @date 12/07/2007
	 * 
	 * @param idMovimentoArrecadador
	 * @return
	 */
	public Collection<MovimentoArrecadadoresPorNSAHelper> gerarMovimentoArrecadadoresNSA(
			Collection<Integer> idsArrecadadorMovimento,
			Integer codigoFormaArrecadacao) throws ControladorException {

		Collection<MovimentoArrecadadoresPorNSAHelper> colecaoMovimentoArrecadadoresPorNSAHelper = null;

		try {
			colecaoMovimentoArrecadadoresPorNSAHelper = repositorioArrecadacao
					.gerarMovimentoArrecadadoresNSA(idsArrecadadorMovimento,
							codigoFormaArrecadacao);

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return colecaoMovimentoArrecadadoresPorNSAHelper;
	}

	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0012] - Verifica Pagamento de Debito a Cobrar de Parcelamento 
	 *
	 * @author Vivianne Sousa, Raphael Rossiter
	 * @date 19/07/2007, 12/04/2010
	 *
	 * @param idDebitoACobrar
	 * @param numeroParcelasAntecipadas
	 * @throws ControladorException
	 */
	public void verificaPagamentoDebitoACobrarParcelamento(Integer idDebitoACobrar, Integer numeroParcelasAntecipadas) 
		throws ControladorException {

		Integer idImovel = null;

		try {

			//Pesquisando o imóvel a partir do débito a cobrar
			idImovel = repositorioFaturamento.pesquisarImovelDebitoACobrar(idDebitoACobrar);

			if (idImovel != null && numeroParcelasAntecipadas == null) {
				
				/*
				 * Atualiza DSCT_IDATUAL com o valor correspondente a cancelado(3),
				 * na tabela DEBITO_A_COBRAR com IMOV_ID do debito a cobrar que foi pago,
				 * DCST_IDATUAL com o valor correspondente a normal (0) e FNTP_ID com o valor 
				 * correspondente a juros de parcelamento (8)
				 */
				repositorioFaturamento.atualizarDebitoCreditoSituacaoAtualDoDebitoACobrar(idImovel);
			}

		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * Obtém a representação númerica do código de barras de um pagamento de
	 * acordo com os parâmetros informados
	 * 
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * 
	 * @author Pedro Alexandre,Hugo Amorim,Hugo Amorim
	 * @date 20/04/2006,12/01/2010,10/03/2010
	 * 
	 * @param tipoPagamento
	 * @param valorCodigoBarra
	 * @param idLocalidade
	 * @param matriculaImovel
	 * @param anoMesReferenciaConta
	 * @param digitoVerificadorRefContaModulo10
	 * @param idTipoDebito
	 * @param anoEmissaoGuiaPagamento
	 * @param sequencialDocumentoCobranca
	 * @param idTipoDocumento
	 * @param idCliente
	 * @param seqFaturaClienteResponsavel
	 * @param idGuiaPagamento
	 * @return
	 * @throws ParametroNaoInformadoException
	 */
	public String obterRepresentacaoNumericaCodigoBarra(Integer tipoPagamento,
			BigDecimal valorCodigoBarra, Integer idLocalidade,
			Integer matriculaImovel, String mesAnoReferenciaConta,
			Integer digitoVerificadorRefContaModulo10, Integer idTipoDebito,
			String anoEmissaoGuiaPagamento, String sequencialDocumentoCobranca,
			Integer idTipoDocumento, Integer idCliente,
			Integer seqFaturaClienteResponsavel,String idGuiaPagamento) throws ControladorException {

		// Cria uma instância da fachada
		Fachada fachada = Fachada.getInstancia();
		
		// Obtem parametros do sistema
		SistemaParametro sistemaParametro = fachada.pesquisarParametrosDoSistema();
		
		// [FS0001] Verificar compatibilidade dos campos informados com o tipo
		// de pagamento
		if (tipoPagamento == null) {
			throw new ControladorException(
					"atencao.parametros.incompletos.codigobarra");
		}
		// Caso o tipo de pagamento seja referente a conta
		if (tipoPagamento.intValue() == 3) {

			// Caso o código da localidade ou a matrícula do imóvel ou o
			// mês/ano da referência da conta ou o dígito verificador da
			// referência da conta no módulo 10
			// não forem informados levanta uma exceção para o usuário
			// indicando que os parâmetros para geração do código de barras
			// está incompleto.
			if (idLocalidade == null || matriculaImovel == null
					|| mesAnoReferenciaConta == null
					|| digitoVerificadorRefContaModulo10 == null) {
				throw new ControladorException(
						"atencao.parametros.incompletos.codigobarra");
			}

			// Caso o tipo de pagamento seja referente a guia de pagamento
		} else if (tipoPagamento.intValue() == 4) {

			// Caso o código da localidade ou a matrícula do imóvel ou o
			// tipo de débito ou o ano da emissão da guia de pagamento
			// não forem informados levanta uma exceção para o usuário
			// indicando que os parâmetros para geração do código de barras
			// está incompleto.
			if (idLocalidade == null || matriculaImovel == null
					|| idTipoDebito == null
					|| anoEmissaoGuiaPagamento == null) {
				throw new ControladorException(
						"atencao.parametros.incompletos.codigobarra");
			}

			// Caso a tipo de pagamento seja referente a documento de
			// cobrança
		} else if (tipoPagamento.intValue() == 5) {

			// Caso o código da localidade ou a matrícula do imóvel ou o
			// sequencial do documento de cobrança ou o tipo de documento
			// não forem informados levanta uma exceção para o usuário
			// indicando que os parâmetros para geração do código de barras
			// está incompleto.
			if (idLocalidade == null || matriculaImovel == null
					|| sequencialDocumentoCobranca == null
					|| idTipoDocumento == null) {
				throw new ControladorException(
						"atencao.parametros.incompletos.codigobarra");
			}

			// Caso o tipo de pagamento seja referente a fatura do cliente
			// responsável
		} else if (tipoPagamento.intValue() == 7) {
			// Caso o código do cliente ou o mês/ano da referência da conta
			// ou o sequencial da fatura do cliente responsável
			// não forem informados levanta uma exceção para o usuário
			// indicando que os parâmetros para geração do código de barras
			// está incompleto.
			if (idCliente == null || mesAnoReferenciaConta == null
					|| seqFaturaClienteResponsavel == null) {
				throw new ControladorException(
						"atencao.parametros.incompletos.codigobarra");
			}

			// Caso a tipo de pagamento seja referente a guia de pagamento
		} else if (tipoPagamento.intValue() == 6) {
			// Caso o código da localidade ou id do cliente ou o
			// tipo de débito ou o ano da emissão da guia de pagamento
			// não forem informados levanta uma exceção para o usuário
			// indicando que os parâmetros para geração do código de barras
			// está incompleto.
			if (idLocalidade == null || idCliente == null
					|| idTipoDebito == null
					|| anoEmissaoGuiaPagamento == null) {
				throw new ControladorException(
						"atencao.parametros.incompletos.codigobarra");
			}
		} else if (tipoPagamento.intValue() == 8) {

			// Caso o código do cliente ou o
			// sequencial do documento de cobrança ou o tipo de documento
			// não forem informados levanta uma exceção para o usuário
			// indicando que os parâmetros para geração do código de barras
			// está incompleto.
			if (idCliente == null || sequencialDocumentoCobranca == null
					|| idTipoDocumento == null) {
				throw new ControladorException(
						"atencao.parametros.incompletos.codigobarra");
			}
		}

		// Cria a variável que vai armazenar a representação númerica do código
		// de barras
		String representacaoNumericaCodigoBarra = "";

		// G.05.1 - Identificação do produto
		String identificacaoProduto = "8";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
				+ identificacaoProduto;

		// G.05.2 - Identificação do segmento
		String identificacaoSegmento = "2";
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
				+ identificacaoSegmento;

		// G.05.3 - Identificação dovalor real ou referência

		// MODULO 10
		Short moduloVerificador = ConstantesSistema.MODULO_VERIFICADOR_10;
		String identificacaoValorRealOuReferencia = "6";
		
		if(getSistemaParametro().getNumeroModuloDigitoVerificador()!=null
				&& getSistemaParametro().getNumeroModuloDigitoVerificador().compareTo(ConstantesSistema.MODULO_VERIFICADOR_11)==0){
			// MODULO 11
			moduloVerificador = ConstantesSistema.MODULO_VERIFICADOR_11;
			identificacaoValorRealOuReferencia = "8";
		}
		

		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
				+ identificacaoValorRealOuReferencia;

		// G.05.5 - Valor do código de barras
		String valorCodigoBarraFormatado = Util.adicionarZerosEsquedaNumero(11,
				valorCodigoBarra.setScale(2).toString().replace(".", ""));
		valorCodigoBarraFormatado = valorCodigoBarraFormatado.replace("-", "");
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
				+ valorCodigoBarraFormatado;

		// G.05.6 - Identificação da empresa
		String identificacaoEmpresa = getSistemaParametro()
				.getCodigoEmpresaFebraban().toString();
		identificacaoEmpresa = Util.adicionarZerosEsquedaNumero(4,
				identificacaoEmpresa);
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
				+ identificacaoEmpresa;

		// G.05.7 Identificação do pagamento
		// [SB0001] Obter Identificação do Pagamento
		String identificacaoPagamento = obterIdentificacaoPagamento(
				tipoPagamento, idLocalidade, matriculaImovel,
				mesAnoReferenciaConta, digitoVerificadorRefContaModulo10,
				idTipoDebito, anoEmissaoGuiaPagamento,
				sequencialDocumentoCobranca, idTipoDocumento, idCliente,
				seqFaturaClienteResponsavel,idGuiaPagamento);

		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
				+ identificacaoPagamento + tipoPagamento.toString();

		// G.05.4 - Dígito verificador geral
		// [SB0002] Obter Dígito verificador geral
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra.replace(".", "");
		representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra.replace("-", "");
		String digitoVerificadorGeral = (Util
				.obterDigitoVerificadorGeral(representacaoNumericaCodigoBarra,moduloVerificador))
				.toString();

		// Monta a representaçaõ númerica com todos os campos informados
		representacaoNumericaCodigoBarra = identificacaoProduto
				+ identificacaoSegmento + identificacaoValorRealOuReferencia
				+ digitoVerificadorGeral + valorCodigoBarraFormatado
				+ identificacaoEmpresa + identificacaoPagamento
				+ tipoPagamento.toString();

		// Cria as variáveis que vão armazenar o código de barra separado por
		// campos
		// e seus respectivos dígitos verificadores se existirem
		String codigoBarraCampo1 = null;
		String codigoBarraDigitoVerificadorCampo1 = null;
		String codigoBarraCampo2 = null;
		String codigoBarraDigitoVerificadorCampo2 = null;
		String codigoBarraCampo3 = null;
		String codigoBarraDigitoVerificadorCampo3 = null;
		String codigoBarraCampo4 = null;
		String codigoBarraDigitoVerificadorCampo4 = null;

		// Separa as 44 posições do código de barras em 4 grupos de onze
		// posições
		// e para cada um dos grupos calcula o dígito verificador do módulo 11
		codigoBarraCampo1 = representacaoNumericaCodigoBarra.substring(0, 11);

		codigoBarraDigitoVerificadorCampo1 = (Util
				.obterDigitoVerificador(new Long(codigoBarraCampo1),moduloVerificador))
				.toString();
		codigoBarraCampo2 = representacaoNumericaCodigoBarra.substring(11, 22);

		codigoBarraDigitoVerificadorCampo2 = (Util
				.obterDigitoVerificador(new Long(codigoBarraCampo2),moduloVerificador))
				.toString();
		codigoBarraCampo3 = representacaoNumericaCodigoBarra.substring(22, 33);

		codigoBarraDigitoVerificadorCampo3 = (Util
				.obterDigitoVerificador(new Long(codigoBarraCampo3),moduloVerificador))
				.toString();
		codigoBarraCampo4 = representacaoNumericaCodigoBarra.substring(33, 44);

		codigoBarraDigitoVerificadorCampo4 = (Util
				.obterDigitoVerificador(new Long(codigoBarraCampo4),moduloVerificador))
				.toString();

		// Monta a representação númerica do código de barras com os dígitos
		// verificadores
		representacaoNumericaCodigoBarra = codigoBarraCampo1
				+ codigoBarraDigitoVerificadorCampo1 + codigoBarraCampo2
				+ codigoBarraDigitoVerificadorCampo2 + codigoBarraCampo3
				+ codigoBarraDigitoVerificadorCampo3 + codigoBarraCampo4
				+ codigoBarraDigitoVerificadorCampo4;

		// Retorna a representação númerica do código de barras
		return representacaoNumericaCodigoBarra;
	}

	/**
	 * Obtém a representação númerica do código de barras de um pagamento de
	 * acordo com os parâmetros informados
	 * 
	 * [UC0229] Obter Representação Numérica do Código de Barras
	 * 
	 * Formata a identificação do pagamento de acordo com o tipo de pagamento
	 * informado
	 * 
	 * [SB0001] Obter Identificação do Pagamento
	 * 
	 * @author Pedro Alexandre
	 * @date 20/04/2006
	 * 
	 * @param tipoPagamento
	 * @param idLocalidade
	 * @param matriculaImovel
	 * @param anoMesReferenciaConta
	 * @param digitoVerificadorRefContaModulo10
	 * @param idTipoDebito
	 * @param anoEmissaoGuiaPagamento
	 * @param sequencialDocumentoCobranca
	 * @param idTipoDocumento
	 * @param idCliente
	 * @param seqFaturaClienteResponsavel
	 * @return
	 */
	public String obterIdentificacaoPagamento(Integer tipoPagamento,
			Integer idLocalidade, Integer matriculaImovel,
			String mesAnoReferenciaConta,
			Integer digitoVerificadorRefContaModulo10, Integer idTipoDebito,
			String anoEmissaoGuiaPagamento, String sequencialDocumentoCobranca,
			Integer idTipoDocumento, Integer idCliente,
			Integer seqFaturaClienteResponsavel,String idGuiaPagamento) throws ControladorException {

		// Cria a variável que vai armazenar o identificador do pagamento formatado
		String identificacaoPagamento = "";

		// Caso o tipo de pagamento seja referente a conta
		if (tipoPagamento.intValue() == 3) {
			
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(9, "" + matriculaImovel);
			
			//FIXO
			identificacaoPagamento = identificacaoPagamento + "0";
			
			//Identifica o tamanho da matrícula do imóvel
			identificacaoPagamento = identificacaoPagamento + "1";
			
			identificacaoPagamento = identificacaoPagamento + mesAnoReferenciaConta;
			identificacaoPagamento = identificacaoPagamento + digitoVerificadorRefContaModulo10;
			
			identificacaoPagamento = identificacaoPagamento + "000";
	
		}
		//Caso o tipo de pagamento seja referente a guia de pagamento (Imóvel)
		else if (tipoPagamento.intValue() == 4) {
			
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(9, "" + matriculaImovel);
			
			//FIXO
			identificacaoPagamento = identificacaoPagamento + "0";
			
			//Identifica o tamanho da matrícula do imóvel
			identificacaoPagamento = identificacaoPagamento + "1";
			
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(3, idTipoDebito.toString()));
			identificacaoPagamento = identificacaoPagamento + anoEmissaoGuiaPagamento;
			
			identificacaoPagamento = identificacaoPagamento + "000";
	
		}
		//Caso a tipo de pagamento seja referente a documento de cobrança
		else if (tipoPagamento.intValue() == 5) {
			
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(9, "" + matriculaImovel);
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, sequencialDocumentoCobranca));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(2, idTipoDocumento.toString()));
			
			//Identifica o tamanho da matrícula do imóvel
			identificacaoPagamento = identificacaoPagamento + "1";

			// Caso o tipo de pagamento seja referente a guia de pagamento (Cliente)
		} else if (tipoPagamento.intValue() == 6) {
			
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(3, "" + idLocalidade);
			identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumero(8, "" + idCliente);
			
			identificacaoPagamento = identificacaoPagamento + "000";
			
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(3, idTipoDebito.toString()));
			identificacaoPagamento = identificacaoPagamento + anoEmissaoGuiaPagamento;
			
			identificacaoPagamento = identificacaoPagamento + "000";
			
		}
		//Caso o tipo de pagamento seja referente a fatura do cliente responsável
		else if (tipoPagamento.intValue() == 7) {
			
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, idCliente.toString()));
			
			identificacaoPagamento = identificacaoPagamento + "00";
			
			identificacaoPagamento = identificacaoPagamento + mesAnoReferenciaConta;
			identificacaoPagamento = identificacaoPagamento + digitoVerificadorRefContaModulo10;
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(6, seqFaturaClienteResponsavel.toString()));
			
		}
		//Caso a tipo de pagamento seja referente a documento de cobrança cliente
		else if (tipoPagamento.intValue() == 8) {
			
			identificacaoPagamento = identificacaoPagamento + "000";
			
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(8, idCliente.toString()));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(9, sequencialDocumentoCobranca));
			identificacaoPagamento = identificacaoPagamento + (Util.adicionarZerosEsquedaNumero(2, idTipoDocumento.toString()));
			
			identificacaoPagamento = identificacaoPagamento + "00";
			
		}
		else if(tipoPagamento.intValue() == 1 || tipoPagamento.intValue() == 9){
			
			identificacaoPagamento = Util.adicionarZerosEsquedaNumeroTruncando(3,idLocalidade.toString());
				
			if(tipoPagamento.intValue() == 1){
				
				identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumeroTruncando(9,matriculaImovel.toString());
				
				identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumeroTruncando(9,idGuiaPagamento);
				
				//FIXO
				identificacaoPagamento = identificacaoPagamento + "00";
				
				//Identifica o tamanho da matrícula do imóvel
				identificacaoPagamento = identificacaoPagamento + "1";
			}
			else if(tipoPagamento.intValue() == 9){
				
				identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumeroTruncando(9,idCliente.toString());
				
				identificacaoPagamento = identificacaoPagamento + Util.adicionarZerosEsquedaNumeroTruncando(9,idGuiaPagamento);
				
				//FIXO
				identificacaoPagamento = identificacaoPagamento + "00";
				
				//Identifica o tamanho da matrícula do imóvel
				identificacaoPagamento = identificacaoPagamento + "1";
			}
		}

		// Retorna o identificador do pagamento formatado
		return identificacaoPagamento;
	}

	/**
	 * Processamento Rápido
	 * 
	 * @author Raphael Rossiter
	 * @date 17/08/2007
	 * 
	 * @return Collection<Conta>
	 * @throws ErroRepositorioException
	 */
	public Collection<Conta> pesquisarContaComPagamentoHistorico()
			throws ControladorException {

		try {

			return repositorioArrecadacao.pesquisarContaComPagamentoHistorico();

		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}

	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 * 
	 * O sistema seleciona os itens do movimento do arrecadador com os seguintes
	 * dados: 1 - Código do Registro 2 - Identificação do Imóvel/Cliente 3 -
	 * Ocorrência 4 - Indicador de Aceitação 5 - Descrição do Indicador de
	 * Aceitação
	 * 
	 * [SF0001] Consultar os Itens do Movimento do Arrecadador
	 * 
	 * @author Raphael Rossiter
	 * @data 20/03/2006
	 * 
	 * @param arrecadadorMovimento
	 * @return Collection<ArrecadadorMovimentoItemHelper>
	 */
	public Collection<ArrecadadorMovimentoItemHelper> consultarItensMovimentoArrecadador(
			ArrecadadorMovimento arrecadadorMovimento, Integer idImovel,
			Short indicadorAceitacao, String descricaoOcorrencia,
			String codigoArrecadacaoForma, Short indicadorDiferencaValorMovimentoValorPagamento) throws ControladorException {

		Collection<ArrecadadorMovimentoItemHelper> retorno = new ArrayList();
		Collection<ArrecadadorMovimentoItem> colecaoArrecadadorMovimentoItens = null;
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = null;
		ArrecadadorMovimentoItemHelper arrecadadorMovimentoItemHelper = null;

		/*
		 * Seleciona os itens de um determinado movimento
		 */
		try {

			colecaoArrecadadorMovimentoItens = repositorioArrecadacao
					.consultarItensMovimentoArrecadador(arrecadadorMovimento,
							idImovel, indicadorAceitacao, descricaoOcorrencia,
							codigoArrecadacaoForma);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoArrecadadorMovimentoItens != null
				&& !colecaoArrecadadorMovimentoItens.isEmpty()) {

			Iterator iteratorColecaoArrecadadorMovimentoItens = colecaoArrecadadorMovimentoItens
					.iterator();

			while (iteratorColecaoArrecadadorMovimentoItens.hasNext()) {

				arrecadadorMovimentoItem = (ArrecadadorMovimentoItem) iteratorColecaoArrecadadorMovimentoItens
						.next();

				arrecadadorMovimentoItemHelper = new ArrecadadorMovimentoItemHelper();

				arrecadadorMovimentoItemHelper.setId(arrecadadorMovimentoItem
						.getId());

				if(arrecadadorMovimentoItem.getImovel() != null && 
						arrecadadorMovimentoItem.getImovel().getId() != null){
						
					arrecadadorMovimentoItemHelper.setMatriculaImovel(""+arrecadadorMovimentoItem.getImovel().getId());
				}				
				
				/*
				 * (RGCD_CDREGISTROCODIGO da tabela REGISTRO_CODIGO com RGCD_ID =
				 * RGCD_ID da tabela ARRECADADOR_MOVIMENTO_ITEM)
				 */
				if (arrecadadorMovimentoItem.getRegistroCodigo() != null) {
					arrecadadorMovimentoItemHelper
							.setCodigoRegistro(arrecadadorMovimentoItem
									.getRegistroCodigo().getCodigo());
				}

				/*
				 * Caso o código do registro corresponda a "B", "C", "E" ou "F",
				 * exibir a identificação do cliente na empresa retornada pelo
				 * [UC0262]
				 */
				if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_B)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoB registroHelperCodigoB = (RegistroHelperCodigoB) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoB
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoB(registroHelperCodigoB);
				} else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_C)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoC registroHelperCodigoC = (RegistroHelperCodigoC) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoC
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoC(registroHelperCodigoC);

				} else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_E)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoE registroHelperCodigoE = (RegistroHelperCodigoE) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoE
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoE(registroHelperCodigoE);

				} else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_F)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoF registroHelperCodigoF = (RegistroHelperCodigoF) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);

					arrecadadorMovimentoItemHelper
							.setIdentificacao(registroHelperCodigoF
									.getIdClienteEmpresa());
					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoF(registroHelperCodigoF);

					int tamanho = registroHelperCodigoF.getValorDebito()
							.length();

					String valorDebito = registroHelperCodigoF.getValorDebito()
							.substring(0, (tamanho - 2))
							+ "."
							+ registroHelperCodigoF.getValorDebito().substring(
									(tamanho - 2), tamanho);

					arrecadadorMovimentoItemHelper.setVlMovimento(Util
							.formatarMoedaReal(new BigDecimal(valorDebito)));
				}

				/*
				 * Caso o código do registro corresponda a "G"
				 * 
				 * Distribui os dados do código de barras [UC0264] - Distribuir
				 * Dados co Código de Barras passando o código de barras
				 * retornado pelo [UC0262]- Distribuir Dados do Registro de
				 * Movimento do Arrecadador.
				 * 
				 * Exibir o tipo de pagamento retornado pelo [UC0262] -
				 * Distribuir Dados co Código de Barras
				 */
				else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
						&& arrecadadorMovimentoItemHelper.getCodigoRegistro()
								.equals(RegistroCodigo.CODIGO_G)) {

					// [UC0262] - Distribuir Dados do Registro de Movimento do
					// Arrecadador
					RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this
							.distribuirdadosRegistroMovimentoArrecadador(
									arrecadadorMovimentoItem
											.getConteudoRegistro(), null);
					

					arrecadadorMovimentoItemHelper
							.setRegistroHelperCodigoG(registroHelperCodigoG);

					int tamanho = registroHelperCodigoG.getValorRecebido()
							.length();

					String valorRecebido = registroHelperCodigoG
							.getValorRecebido().substring(0, (tamanho - 2))
							+ "."
							+ registroHelperCodigoG.getValorRecebido()
									.substring((tamanho - 2), tamanho);

					arrecadadorMovimentoItemHelper.setVlMovimento(Util
					.formatarMoedaReal(new BigDecimal(valorRecebido)));

					
					//Colocado por Raphael Rossiter em 08/11/2008
					this.distribuirDadosRegistroMovimentoArrecadadorPorTipoPagamento(registroHelperCodigoG, arrecadadorMovimentoItemHelper);
				}
                
                /*
                 * Caso o código do registro corresponda a "W"
                 */
                else if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
                        && arrecadadorMovimentoItemHelper.getCodigoRegistro()
                                .equals(RegistroCodigo.CODIGO_W)) {

                    if( arrecadadorMovimentoItem.getImovel() != null ){
                        arrecadadorMovimentoItemHelper.setIdentificacao(
                            arrecadadorMovimentoItem.getImovel().getId().toString());
                    }
                    
                    arrecadadorMovimentoItemHelper
                        .setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);
                    
                    
                    
                    
//                    // [UC0262] - Distribuir Dados do Registro de Movimento do Arrecadador
//                    RegistroHelperCodigoG registroHelperCodigoG = (RegistroHelperCodigoG) this
//                            .distribuirdadosRegistroMovimentoArrecadador(
//                                    arrecadadorMovimentoItem
//                                            .getConteudoRegistro(), null);
//
//                    arrecadadorMovimentoItemHelper.setRegistroHelperCodigoG(registroHelperCodigoG);


                    String valorRecebido = arrecadadorMovimentoItem.getConteudoRegistro().substring(93,108);
                    int tamanho = valorRecebido.length();
                    
                    String valorRecebidoComPonto = valorRecebido.substring(0, (tamanho - 2)) + "."
                            + valorRecebido.substring((tamanho - 2), tamanho);

                    arrecadadorMovimentoItemHelper.setVlMovimento(Util.formatarMoedaReal(new BigDecimal(valorRecebidoComPonto)));
                  

                }


				// (AMIT_DSOCORRENCIA)
				if (arrecadadorMovimentoItem.getDescricaoOcorrencia() != null) {
					arrecadadorMovimentoItemHelper
							.setOcorrencia(arrecadadorMovimentoItem
									.getDescricaoOcorrencia());
				}

				if (arrecadadorMovimentoItem.getIndicadorAceitacao() != null
						&& arrecadadorMovimentoItem
								.getIndicadorAceitacao()
								.equals(
										ArrecadadorMovimentoItem.INDICADOR_ACEITO)) {

					arrecadadorMovimentoItemHelper
							.setIndicadorAceitacao(arrecadadorMovimentoItem
									.getIndicadorAceitacao());

					// Colocado a pedido de Rosana em 08/04/2006
					if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
							&& !arrecadadorMovimentoItemHelper
									.getCodigoRegistro().equals(
											RegistroCodigo.CODIGO_C)) {

						arrecadadorMovimentoItemHelper
								.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_ACEITO);
					}

				} else {

					arrecadadorMovimentoItemHelper
							.setIndicadorAceitacao(arrecadadorMovimentoItem
									.getIndicadorAceitacao());

					// Colocado a pedido de Rosana em 08/04/2006
					if (arrecadadorMovimentoItemHelper.getCodigoRegistro() != null
							&& !arrecadadorMovimentoItemHelper
									.getCodigoRegistro().equals(
											RegistroCodigo.CODIGO_C)) {

						arrecadadorMovimentoItemHelper
								.setDescricaoIndicadorAceitacao(ArrecadadorMovimentoItem.DESCRICAO_INDICADOR_NAO_ACEITO);
					}

				}

				BigDecimal valorPagamento = null;
				try {
					valorPagamento = repositorioArrecadacao
							.recuperaValorPagamentoArrecadadorMovimentoItem(arrecadadorMovimentoItem
									.getId());
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}

				arrecadadorMovimentoItemHelper.setVlPagamento(Util
						.formatarMoedaReal(valorPagamento));
				
				// Verificamos se o filtro de relatorio a diferença entre o valor pago e o valor movimentado foi informado
				if ( indicadorDiferencaValorMovimentoValorPagamento != null &&
					 indicadorDiferencaValorMovimentoValorPagamento != 1 &&
					 // Indicador de todos
					 indicadorDiferencaValorMovimentoValorPagamento != 3 ){
					// Sem diferença
					if ( indicadorDiferencaValorMovimentoValorPagamento == 1 ){
						if ( arrecadadorMovimentoItemHelper.getVlPagamento().equals( arrecadadorMovimentoItemHelper.getVlMovimento() ) ){
							retorno.add(arrecadadorMovimentoItemHelper);
						}
					}
					
					// Com diferenca
					if ( indicadorDiferencaValorMovimentoValorPagamento == 2 ){
						if ( !arrecadadorMovimentoItemHelper.getVlPagamento().equals( arrecadadorMovimentoItemHelper.getVlMovimento() ) ){
							retorno.add(arrecadadorMovimentoItemHelper);
						}
					}
				} else {
					retorno.add(arrecadadorMovimentoItemHelper);
				}					
			}
		}

		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.pesquisa.nenhumresultado");
		}

		return retorno;
	}
	
	/**
	 * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
	 *
	 * @author Raphael Rossiter
	 * @date 08/11/2008
	 *
	 * @param registroHelperCodigoG
	 * @param arrecadadorMovimentoItemHelper
	 * @throws ControladorException
	 */
	public void distribuirDadosRegistroMovimentoArrecadadorPorTipoPagamento(RegistroHelperCodigoG registroHelperCodigoG,
			ArrecadadorMovimentoItemHelper arrecadadorMovimentoItemHelper) throws ControladorException {
		
		if (registroHelperCodigoG
				.getRegistroHelperCodigoBarras()
				.getTipoPagamento()
				.equals(
						String
								.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_CONTA))) {

			arrecadadorMovimentoItemHelper
					.setIdentificacao(registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2());

			arrecadadorMovimentoItemHelper
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);

		} else if ((registroHelperCodigoG
				.getRegistroHelperCodigoBarras()
				.getTipoPagamento()
				.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO)))
					||(registroHelperCodigoG
					.getRegistroHelperCodigoBarras()
					.getTipoPagamento()
					.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_COM_IDENTIFICACAO_MATRICULA)))
						||(registroHelperCodigoG
						.getRegistroHelperCodigoBarras()
						.getTipoPagamento()
						.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_COM_IDENTIFICACAO_CLIENTE)))
							||(registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getTipoPagamento()
							.equals(String.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_GUIA_PAGAMENTO_CLIENTE)))){

			arrecadadorMovimentoItemHelper
					.setIdentificacao(registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2());
			arrecadadorMovimentoItemHelper
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_GUIA_PAGAMENTO);
		} else if (registroHelperCodigoG
				.getRegistroHelperCodigoBarras()
				.getTipoPagamento()
				.equals(
						String
								.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_DOCUMENTO_COBRANCA))) {

			arrecadadorMovimentoItemHelper
					.setIdentificacao(registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2());
			arrecadadorMovimentoItemHelper
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
		} else if (registroHelperCodigoG
				.getRegistroHelperCodigoBarras()
				.getTipoPagamento()
				.equals(
						String
								.valueOf(ConstantesSistema.CODIGO_TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL))) {

			arrecadadorMovimentoItemHelper
					.setIdentificacao(registroHelperCodigoG
							.getRegistroHelperCodigoBarras()
							.getRegistroHelperCodigoBarrasTipoPagamento()
							.getIdPagamento2());
			arrecadadorMovimentoItemHelper
					.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);
		}
	}

	/**
	 * Inserir uma coleção de pagamentos informados manualmente
	 * 
	 * @author Raphael Rossiter
	 * @date 26/09/2007
	 * 
	 * @return Collection, Usuario, AvisoBancario
	 * @throws ControladorException
	 */
	public Integer inserirPagamentos(Collection<Pagamento> colecaoPagamento,
			Usuario usuarioLogado, AvisoBancario avisoBancario)
			throws ControladorException {
		try{
			Integer retorno = null;
	
			if (colecaoPagamento != null && !colecaoPagamento.isEmpty()) {
	
				/*
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						Operacao.OPERACAO_PAGAMENTO_INSERIR,
						new UsuarioAcaoUsuarioHelper(usuarioLogado,
								UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
	
				Operacao operacao = new Operacao();
				operacao.setId(Operacao.OPERACAO_PAGAMENTO_INSERIR);
	
				OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
				operacaoEfetuada.setOperacao(operacao);
				// ------------ REGISTRAR TRANSAÇÃO ----------------
				 */
				
				// Cria a variável que vai acumular os valores de pagamentos
				// informados
				BigDecimal valorPagamentoAcumulado = new BigDecimal("0.00");
	
				// Laço para incluir todos os pagamentos informados
				for (Pagamento pagamento : colecaoPagamento) {
	
					// Acumula o valor do pagamento
					valorPagamentoAcumulado = valorPagamentoAcumulado.add(pagamento
							.getValorPagamento());
					
					/*
					 * Colocado por Raphael Rossiter em 16/01/2007
					 * OBJ: Evitar que o campo anoMesReferenciaPagamento seja gravado com valor "0".
					 */
					if (pagamento.getAnoMesReferenciaPagamento() != null &&
						pagamento.getAnoMesReferenciaPagamento().equals(new Integer(ConstantesSistema.ZERO))){
						
						pagamento.setAnoMesReferenciaPagamento(null);
					}
	
					pagamento.setAvisoBancario(avisoBancario);
					pagamento.setUltimaAlteracao(new Date());
					
					Integer idImovelCliente = null;
					if( pagamento.getImovel() != null){
						idImovelCliente = pagamento.getImovel().getId();
					}else{
						idImovelCliente = pagamento.getCliente().getId();
					}
					
					//------------ REGISTRAR TRANSAÇÃO ----------------
					RegistradorOperacao registradorOperacao = new RegistradorOperacao(
						    Operacao.OPERACAO_PAGAMENTO_INSERIR,
						    idImovelCliente,pagamento.getId(),
						    new UsuarioAcaoUsuarioHelper(usuarioLogado,
						    UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));
	
					registradorOperacao.registrarOperacao(pagamento);
	
					//------------ REGISTRAR TRANSAÇÃO ----------------
	/*
					// ------------ REGISTRAR TRANSAÇÃO ----------------
					pagamento.setOperacaoEfetuada(operacaoEfetuada);
					pagamento.adicionarUsuario(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
					registradorOperacao.registrarOperacao(pagamento);
					// ------------ REGISTRAR TRANSAÇÃO ----------------
	*/
						
					// Chama o metódo de inserir pagamento da fachada
					retorno = (Integer) this.getControladorUtil()
							.inserir(pagamento);
					
					// Alterado por Francisco - 26/05/08, por conta do Resumo de Ações de cobrança
					// Analista: Ana Breda
					getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
							CobrancaDebitoSituacao.PAGO);			
					
					//CRC2725 - alterado por Vivianne Sousa - 14/09/2009 analista:Fátima
					//Atualizar os itens de negativação
					//[SB0005] - Inclui Pagamento 1.1.3 - 1.1.4 - 1.2.3 - 1.2.4
					getControladorSpcSerasa().atualizarNegativadorMovimentoRegItemAPartirPagamento(pagamento);
					
				}
	
				// Atualiza o valor do aviso bancário
				avisoBancario.setValorArrecadacaoCalculado(avisoBancario
						.getValorArrecadacaoCalculado()
						.add(valorPagamentoAcumulado));
				avisoBancario.setUltimaAlteracao(new Date());
	
	/*			// ------------ REGISTRAR TRANSAÇÃO ----------------
				avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
				avisoBancario.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(avisoBancario);
				// ------------ REGISTRAR TRANSAÇÃO ----------------
	*/
				this.getControladorUtil().atualizar(avisoBancario);
			} else {
				throw new ControladorException("atencao.documento_naoinformado");
			}
	
			return retorno;
			
		} catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw e;
		}catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}	
	}
	
	
	/**
	 * Inserir uma coleção de pagamentos informados manualmente
	 * 
	 * @author Raphael Rossiter
	 * @date 26/09/2007
	 * 
	 * @return Collection, Usuario, AvisoBancario
	 * @throws ControladorException
	 */
	
	/**
	 * [UC0971] Inserir Pagamentos para Faturas Especiais
	 *  
	 * @author Rafael Pinto
	 * @created 08/01/2010
	 * 
	 * @exception ErroRepositorioException
	 *                Repositorio Exception
	 */	
	private void inserirPagamentosEspeciais(Pagamento pagamento)
			throws ControladorException {
		try{
			
			/*
			 * Colocado por Raphael Rossiter em 16/01/2007
			 * OBJ: Evitar que o campo anoMesReferenciaPagamento seja gravado com valor "0".
			 */
			if (pagamento.getAnoMesReferenciaPagamento() != null &&
				pagamento.getAnoMesReferenciaPagamento().equals(new Integer(ConstantesSistema.ZERO))){
				
				pagamento.setAnoMesReferenciaPagamento(null);
			}

			pagamento.setUltimaAlteracao(new Date());
			
				
			// Chama o metódo de inserir pagamento da fachada
			this.getControladorUtil().inserir(pagamento);
			
			// Alterado por Francisco - 26/05/08, por conta do Resumo de Ações de cobrança
			// Analista: Ana Breda
			getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
					CobrancaDebitoSituacao.PAGO);			
			
		} catch (ControladorException e) {
			sessionContext.setRollbackOnly();
			throw e;
		}catch (Exception e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}	
	}




	
	
	
	/**
	 * Inserir Pagamentos por código de barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/10/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public Integer inserirPagamentosCodigoBarras(
			Collection<Pagamento> colecaoPagamentos,
			Collection<Devolucao> colecaoDevolucoes, Usuario usuarioLogado,
			AvisoBancario avisoBancario) throws ControladorException {

		// INSERINDO PAGAMENTOS
		Integer retorno = this.inserirPagamentos(colecaoPagamentos,
				usuarioLogado, avisoBancario);

		// INSERINDO DEVOLUCOES
		this.inserirDevolucoes(colecaoDevolucoes, usuarioLogado, avisoBancario);

		return retorno;
	}

	/**
	 * Inserir devoluções para os pagamentos efetuados a partir do código de
	 * barras
	 * 
	 * @author Raphael Rossiter
	 * @date 30/10/2007
	 * 
	 * @return
	 * @throws ControladorException
	 */
	public void inserirDevolucoes(Collection<Devolucao> colecaoDevolucoes,
			Usuario usuarioLogado, AvisoBancario avisoBancario)
			throws ControladorException {

		if (colecaoDevolucoes != null && !colecaoDevolucoes.isEmpty()) {

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			RegistradorOperacao registradorOperacao = new RegistradorOperacao(
					Operacao.OPERACAO_DEVOLUCOES_INSERIR,
					new UsuarioAcaoUsuarioHelper(usuarioLogado,
							UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO));

			Operacao operacao = new Operacao();
			operacao.setId(Operacao.OPERACAO_DEVOLUCOES_INSERIR);

			OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
			operacaoEfetuada.setOperacao(operacao);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			Integer idGuiaDevolucao = null;
			
			/*
			 * Cria a variável que vai acumular os valores das devoluções
			 */			 
			BigDecimal valorDevolucaoAcumulado = new BigDecimal("0.00");

			for (Devolucao devolucao : colecaoDevolucoes) {

				// INSERINDO GUIA DEVOLUCAO
				if (devolucao.getGuiaDevolucao() != null) {

					devolucao.getGuiaDevolucao().setUltimaAlteracao(new Date());
					idGuiaDevolucao = (Integer) this.getControladorUtil()
							.inserir(devolucao.getGuiaDevolucao());
					devolucao.getGuiaDevolucao().setId(idGuiaDevolucao);

				}
				
				// Acumula o valor da devolucao
				valorDevolucaoAcumulado = valorDevolucaoAcumulado.add(devolucao.getValorDevolucao());

				devolucao.setAvisoBancario(avisoBancario);
				devolucao.setUltimaAlteracao(new Date());

				// ------------ REGISTRAR TRANSAÇÃO ----------------
				devolucao.setOperacaoEfetuada(operacaoEfetuada);
				devolucao.adicionarUsuario(usuarioLogado,
						UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
				registradorOperacao.registrarOperacao(devolucao);
				// ------------ REGISTRAR TRANSAÇÃO ----------------

				// INSERINDO DEVOLUCAO
				this.getControladorUtil().inserir(devolucao);
			}
			
			// Atualiza o valor da devolução do aviso bancário
			avisoBancario.setValorDevolucaoCalculado(avisoBancario
			.getValorDevolucaoCalculado()
			.add(valorDevolucaoAcumulado));
			avisoBancario.setUltimaAlteracao(new Date());

			// ------------ REGISTRAR TRANSAÇÃO ----------------
			avisoBancario.setOperacaoEfetuada(operacaoEfetuada);
			avisoBancario.adicionarUsuario(usuarioLogado,
					UsuarioAcao.USUARIO_ACAO_EFETUOU_OPERACAO);
			registradorOperacao.registrarOperacao(avisoBancario);
			// ------------ REGISTRAR TRANSAÇÃO ----------------

			this.getControladorUtil().atualizar(avisoBancario);
		}
	}

    /**
     * Obtém a representação númerica do código de barras da Ficha de Compensação
     * 
     * [UC0716] Obter Representação Numérica do Código de Barras da Ficha de Compensação
     * 
     * @author Vivianne Sousa
     * @date 12/11/2007
     * 
     * @param codigoBanco
     * @param codigoMoeda
     * @param valorCodigoBarra
     * @param nossoNumero
     * @param carteira
     * @param fatorVencimento
     * @return
     * @throws ParametroNaoInformadoException
     */
    public String obterRepresentacaoNumericaCodigoBarraFichaCompensacao(String especificacaoCodigoBarra)
                 throws ControladorException {
        
        String representacaoNumericaCodigoBarra = especificacaoCodigoBarra;

        // Cria as variáveis que vão armazenar o código de barra separado por
        // campos e seus respectivos dígitos verificadores se existirem
        String codigoBarraCampo1 = null;
        String codigoBarraDigitoVerificadorCampo1 = null;
        String codigoBarraCampo2 = null;
        String codigoBarraDigitoVerificadorCampo2 = null;
        String codigoBarraCampo3 = null;
        String codigoBarraDigitoVerificadorCampo3 = null;
        String codigoBarraDigitoVerificadorCampo4 = null;
        String codigoBarraCampo5 = null;

        // Separa as 44 posições do código de barras em 5 partes, 
        // sendo 3 primeiros constituidos por DV(módulo 10) e, entre cada campo, 
        // espaço equivalente a uma posição.No quarto campo é indicado, isoladamente, 
        // o DV(módulo 11) do código de barras.
        codigoBarraCampo1 = representacaoNumericaCodigoBarra.substring(0, 4) + representacaoNumericaCodigoBarra.substring(20, 21);
        codigoBarraCampo1 = codigoBarraCampo1 + "." +  representacaoNumericaCodigoBarra.substring(21, 25);
        codigoBarraDigitoVerificadorCampo1 = (Util.obterDigitoVerificadorModulo10(new Long(codigoBarraCampo1.replace(".","")))).toString();
        codigoBarraDigitoVerificadorCampo1 = codigoBarraDigitoVerificadorCampo1 + " ";
        
        codigoBarraCampo2 = representacaoNumericaCodigoBarra.substring(24, 29);
        codigoBarraCampo2 = codigoBarraCampo2 + "." +  representacaoNumericaCodigoBarra.substring(29, 34);
        codigoBarraDigitoVerificadorCampo2 = (Util.obterDigitoVerificadorModulo10(new Long(codigoBarraCampo2.replace(".","")))).toString();
        codigoBarraDigitoVerificadorCampo2 = codigoBarraDigitoVerificadorCampo2 + " ";
        
        codigoBarraCampo3 = representacaoNumericaCodigoBarra.substring(34, 39);
        codigoBarraCampo3 = codigoBarraCampo3 + "." +  representacaoNumericaCodigoBarra.substring(39, 44);
        codigoBarraDigitoVerificadorCampo3 = (Util.obterDigitoVerificadorModulo10(new Long(codigoBarraCampo3.replace(".","")))).toString();
        codigoBarraDigitoVerificadorCampo3 = codigoBarraDigitoVerificadorCampo3 + " ";
        
        codigoBarraDigitoVerificadorCampo4 = representacaoNumericaCodigoBarra.substring(4,5) + " ";
        
        codigoBarraCampo5 = representacaoNumericaCodigoBarra.substring(5, 19);
        
        // Monta a representação númerica do código de barras com os dígitos verificadores
        representacaoNumericaCodigoBarra = codigoBarraCampo1
                + codigoBarraDigitoVerificadorCampo1 
                + codigoBarraCampo2
                + codigoBarraDigitoVerificadorCampo2 
                + codigoBarraCampo3
                + codigoBarraDigitoVerificadorCampo3 
                + codigoBarraDigitoVerificadorCampo4
                + codigoBarraCampo5;
        
        // Retorna a representação númerica do código de barras
        return representacaoNumericaCodigoBarra;
    }

    /**
     * Obtém a representação númerica do código de barras da Ficha de Compensação
     * 
     * [UC0716] Obter Representação Numérica do Código de Barras da Ficha de Compensação
     * 
     * @author Vivianne Sousa
     * @date 12/11/2007
     * 
     * @param codigoBanco
     * @param codigoMoeda
     * @param valorCodigoBarra
     * @param nossoNumero
     * @param carteira
     * @param fatorVencimento
     * @return
     * @throws ParametroNaoInformadoException
     */
    public String obterEspecificacaoCodigoBarraFichaCompensacao( String codigoBanco,
                 String codigoMoeda, BigDecimal valorCodigoBarra, String nossoNumeroSemDV,
                 String carteira, String fatorVencimento)
                 throws ControladorException {
        
        // Cria a variável que vai armazenar a representação númerica do código de barras
        String representacaoNumericaCodigoBarra = "";

        // G.05.1 - Código do Banco
        codigoBanco = Util.adicionarZerosEsquedaNumero(3,codigoBanco);
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + codigoBanco;

        // G.05.2 - Código da Moeda
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + codigoMoeda;
        
        // G.05.4 - Fator de Vencimento
        fatorVencimento = Util.adicionarZerosEsquedaNumero(4,fatorVencimento);
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + fatorVencimento;

        // G.05.5 - Valor do código de barras
        String valorCodigoBarraFormatado = Util.adicionarZerosEsquedaNumero(10,
                valorCodigoBarra.setScale(2).toString().replace(".", ""));
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra
                + valorCodigoBarraFormatado;

        // G.05.6 - Zeros
        String zeros = "";
        zeros = Util.adicionarZerosEsquedaNumero(6,zeros);
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + zeros;

        // G.05.7 Nosso número sem o DV
        nossoNumeroSemDV = Util.adicionarZerosEsquedaNumero(17,nossoNumeroSemDV);
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + nossoNumeroSemDV;

        // G.05.8 Tipo de Carteira
        carteira = Util.adicionarZerosEsquedaNumero(2,carteira);
        representacaoNumericaCodigoBarra = representacaoNumericaCodigoBarra + carteira;
        
        // G.05.3 - Dígito verificador geral
        // [SB0001] Obter Dígito verificador geral
        String digitoVerificadorGeral = (Util.obterDigitoVerificadorModulo11(representacaoNumericaCodigoBarra)).toString();
            //(Util.obterDigitoVerificadorGeral(representacaoNumericaCodigoBarra)).toString();

        if(digitoVerificadorGeral.equalsIgnoreCase("0") ||
                digitoVerificadorGeral.equalsIgnoreCase("10") ||
                digitoVerificadorGeral.equalsIgnoreCase("11")){
            digitoVerificadorGeral = "1";
        }
        
        // Monta a representaçaõ númerica com todos os campos informados
        representacaoNumericaCodigoBarra = codigoBanco + codigoMoeda 
                        + digitoVerificadorGeral +  fatorVencimento 
                        + valorCodigoBarraFormatado + zeros 
                        + nossoNumeroSemDV + carteira;
        

        // Retorna a representação númerica do código de barras
        return representacaoNumericaCodigoBarra;
    }
    
    /**
	 * [UC0626] Gerar Resumo de Metas Acumulado no Mês (CAERN)
	 * 
	 * @author Sávio Luiz
	 * @data 28/11/2007
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection pesquisarPagamentoDeContas(Collection colecaoConta)
			throws ControladorException{
		try {
			return repositorioArrecadacao
					.pesquisarPagamentoDeContas(colecaoConta);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

// ************************************************************************************
    
    /**
     * [UC0721] - Distribuir dados do Registro de Movimento do Arrecadador da Ficha de Compensação
     * Autor: Vivianne Sousa
     * Data: 23/11/2007
     * 
     */
    public Object distribuirdadosRegistroMovimentoArrecadadorFichaCompensacao(
            String linha, String descricaoOcorrencia) throws ControladorException {
        
        Object registroHelperCodigo = null;

        char codigoRegistro = linha.substring(7, 8).charAt(0);

        switch (codigoRegistro) {

        case '0':
            RegistroHelperCodigo0 registroHelperCodigo0 = new RegistroHelperCodigo0();
            
            registroHelperCodigo0.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
            
            registroHelperCodigo0.setLoteServico(linha.substring(3, 7).trim());
            
            registroHelperCodigo0.setCodigoRegistro(linha.substring(7, 8).trim());
            
            registroHelperCodigo0.setUsoExclusivo04(linha.substring(8, 17).trim());
            
            registroHelperCodigo0.setTipoInscricaoEmpresa(linha.substring(17, 18).trim());
            
            registroHelperCodigo0.setNumeroInscricaoEmpresa(linha.substring(18, 32).trim());
            
            registroHelperCodigo0.setCodigoConvenioBanco(linha.substring(32, 52).trim());
            
            registroHelperCodigo0.setAgenciaMantedoraConta(linha.substring(52, 57).trim());
            
            registroHelperCodigo0.setDigitoVerificadorAgencia(linha.substring(57, 58).trim());
            
            registroHelperCodigo0.setNumeroContaCorrente(linha.substring(58, 70).trim());
            
            registroHelperCodigo0.setDigitoVerificadorConta(linha.substring(70, 71).trim());
            
            registroHelperCodigo0.setDigitoVerificadorAgConta(linha.substring(71, 72).trim());
            
            registroHelperCodigo0.setNomeEmpresa(linha.substring(72, 92).trim());
            
            registroHelperCodigo0.setNomeBanco(linha.substring(102, 132).trim());
            
            registroHelperCodigo0.setUsoExclusivo15(linha.substring(132, 142).trim());
            
            registroHelperCodigo0.setCodigoRemessaRetorno(linha.substring(142, 143).trim());
            
            registroHelperCodigo0.setDataGeracaoArquivo(linha.substring(143, 151).trim());
            
            registroHelperCodigo0.setHoraGeracaoArquivo(linha.substring(151, 157).trim());
            
            registroHelperCodigo0.setNumeroSequencialArquivo(linha.substring(157, 163).trim());
            
            registroHelperCodigo0.setNumeroVersaoLayoutArquivo(linha.substring(163, 166).trim());
            
            registroHelperCodigo0.setDensidadeGravacaoArquivo(linha.substring(166, 171).trim());
            
            registroHelperCodigo0.setReservadoBanco(linha.substring(171, 191).trim());
            
            registroHelperCodigo0.setReservadoEmpresa(linha.substring(191, 211).trim());
            
            registroHelperCodigo0.setUsoExclusivo24(linha.substring(211, 222).trim());
            
            registroHelperCodigo0.setCobrancaSemPapel(linha.substring(222, 225).trim());
            
            registroHelperCodigo0.setUsoExclusivoVans(linha.substring(225, 228).trim());
            
            registroHelperCodigo0.setTipoServico(linha.substring(228, 230).trim());
            
            registroHelperCodigo0.setCodigoOcorrencias(linha.substring(230, 240).trim());

            registroHelperCodigo = registroHelperCodigo0;
            break;

        case '1':
            RegistroHelperCodigo1 registroHelperCodigo1 = new RegistroHelperCodigo1();
            
            registroHelperCodigo1.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
            
            registroHelperCodigo1.setLoteServico(linha.substring(3, 7).trim());
            
            registroHelperCodigo1.setCodigoRegistro(linha.substring(7, 8).trim());
            
            registroHelperCodigo1.setTipoOperacao(linha.substring(8, 9).trim());
            
            registroHelperCodigo1.setTipoServico(linha.substring(9, 11).trim());
            
            registroHelperCodigo1.setFormaLancamento(linha.substring(11, 13).trim());
            
            registroHelperCodigo1.setNumeroVersaoLayoutArquivo(linha.substring(13, 16).trim());
            
            registroHelperCodigo1.setUsoExclusivo08(linha.substring(16, 17).trim());
            
            registroHelperCodigo1.setTipoInscricaoEmpresa(linha.substring(17, 18).trim());
            
            registroHelperCodigo1.setNumeroInscricaoEmpresa(linha.substring(18, 33).trim());
            
            registroHelperCodigo1.setCodigoConvenioBanco(linha.substring(33, 53).trim());
            
            registroHelperCodigo1.setAgenciaMantedoraConta(linha.substring(53, 58).trim());
            
            registroHelperCodigo1.setDigitoVerificadorAgencia(linha.substring(58, 59).trim());
            
            registroHelperCodigo1.setNumeroContaCorrente(linha.substring(59, 71).trim());
            
            registroHelperCodigo1.setDigitoVerificadorConta(linha.substring(71, 72).trim());
            
            registroHelperCodigo1.setDigitoVerificadorAgConta(linha.substring(72, 73).trim());
            
            registroHelperCodigo1.setNomeEmpresa(linha.substring(73, 103).trim());
            
            registroHelperCodigo1.setMensagem1(linha.substring(103, 143).trim());
            
            registroHelperCodigo1.setMensagem2(linha.substring(143, 183).trim());
            
            registroHelperCodigo1.setNumeroRemessaRetorno(linha.substring(183, 191).trim());
            
            registroHelperCodigo1.setDataGravacaoRemessaRetorno(linha.substring(191, 199).trim());
            
            registroHelperCodigo1.setDataCredito(linha.substring(199, 207).trim());
            
            registroHelperCodigo1.setUsoExclusivo23(linha.substring(207, 240).trim());
          
            registroHelperCodigo = registroHelperCodigo1;
            break;

        case '3':
            
            String codSegmento = linha.substring(13, 14).trim();
            
            if (codSegmento.equalsIgnoreCase("T")){
                RegistroHelperCodigo3T registroHelperCodigo3T = new RegistroHelperCodigo3T();
                
                registroHelperCodigo3T.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
                
                registroHelperCodigo3T.setLoteServico(linha.substring(3, 7).trim());
                
                registroHelperCodigo3T.setCodigoRegistro(linha.substring(7, 8).trim());
                
                registroHelperCodigo3T.setNumeroSequencialRegLote(linha.substring(8, 13).trim());
                
                registroHelperCodigo3T.setCodSegmentoRegDetalhe(codSegmento);
                
                registroHelperCodigo3T.setUsoExclusivo06(linha.substring(14, 15).trim());
                
                registroHelperCodigo3T.setCodigoMovimento(linha.substring(15, 17).trim());
                
                registroHelperCodigo3T.setAgenciaMantedoraConta(linha.substring(17, 22).trim());
                
                registroHelperCodigo3T.setDigitoVerificadorAgencia(linha.substring(22, 23).trim());
                
                registroHelperCodigo3T.setNumeroContaCorrente(linha.substring(23, 35).trim());
                
                registroHelperCodigo3T.setDigitoVerificadorConta(linha.substring(35, 36).trim());
                
                registroHelperCodigo3T.setDigitoVerificadorAgConta(linha.substring(36, 37).trim());
                
                registroHelperCodigo3T.setNossoNumero(linha.substring(37, 57).trim());
                
                registroHelperCodigo3T.setCodigoCarteira(linha.substring(57, 58).trim());
                
                registroHelperCodigo3T.setNumeroDocCobranca(linha.substring(58, 73).trim());
                
                registroHelperCodigo3T.setDataVencimentoTitulo(linha.substring(73, 81).trim());
                
                registroHelperCodigo3T.setValorNominalTitulo(linha.substring(81, 96).trim());
                
                registroHelperCodigo3T.setNumeroBanco(linha.substring(96, 99).trim());
                
                registroHelperCodigo3T.setAgenciaCobradoraRecebedora(linha.substring(99, 104).trim());
                
                registroHelperCodigo3T.setDigitoVerificadorAgenciaT(linha.substring(104, 105).trim());
                
                registroHelperCodigo3T.setIdentificadorTituloEmpresa(linha.substring(105, 130).trim());
                
                registroHelperCodigo3T.setCodigoMoeda(linha.substring(131, 132).trim());
                
                registroHelperCodigo3T.setTipoInscricao(linha.substring(132, 133).trim());
                
                registroHelperCodigo3T.setNumeroInscricao(linha.substring(133, 148).trim());
                
                registroHelperCodigo3T.setNome(linha.substring(148, 188).trim());
                
                registroHelperCodigo3T.setContratoOperacaoCred(linha.substring(188, 198).trim());
                
                registroHelperCodigo3T.setValorTarifaCustas(linha.substring(198, 213).trim());
                
                registroHelperCodigo3T.setIdentificacao(linha.substring(213, 223).trim());
                
                registroHelperCodigo3T.setUsoExclusivo29(linha.substring(223, 240).trim());
                
                registroHelperCodigo = registroHelperCodigo3T;
                break;
                
            }
				RegistroHelperCodigo3U registroHelperCodigo3U = new RegistroHelperCodigo3U();
                
                registroHelperCodigo3U.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
                
                registroHelperCodigo3U.setLoteServico(linha.substring(3, 7).trim());
                
                registroHelperCodigo3U.setCodigoRegistro(linha.substring(7, 8).trim());
                
                registroHelperCodigo3U.setNumeroSequencialRegLote(linha.substring(8, 13).trim());
                
                registroHelperCodigo3U.setCodSegmentoRegDetalhe(codSegmento);
                
                registroHelperCodigo3U.setUsoExclusivo06(linha.substring(14, 15).trim());
                
                registroHelperCodigo3U.setCodigoMovimento(linha.substring(15, 17).trim());
                
                registroHelperCodigo3U.setJurosMultaEncargos(linha.substring(17, 32).trim());
                
                registroHelperCodigo3U.setValorDescontoConcedido(linha.substring(32, 47).trim());
                
                registroHelperCodigo3U.setValorAbatConcedidoCancelado(linha.substring(47, 62).trim());
                
                registroHelperCodigo3U.setValorIOFRecolhido(linha.substring(62, 77).trim());
                
                registroHelperCodigo3U.setValorPagoSacado(linha.substring(77, 92).trim());
                
                registroHelperCodigo3U.setValorLiquidoASerCreditado(linha.substring(92, 107).trim());
                
                registroHelperCodigo3U.setValorOutrasDespesas(linha.substring(107, 122).trim());
                
                registroHelperCodigo3U.setValorOutrosCreditos(linha.substring(122, 137).trim());
                
                registroHelperCodigo3U.setDataOcorrencia(linha.substring(137, 145).trim());
                
                registroHelperCodigo3U.setDataEfetivacaoCredito(linha.substring(145, 153).trim());
                
                registroHelperCodigo3U.setCodigoOcorrenciaSacado(linha.substring(153, 157).trim());
                
                registroHelperCodigo3U.setDataOcorrenciaSacado(linha.substring(157, 165).trim());
                
                registroHelperCodigo3U.setValorOcorrenciaSacado(linha.substring(165, 180).trim());
                
                registroHelperCodigo3U.setComplOcorrenciaSacado(linha.substring(180, 210).trim());
                
                registroHelperCodigo3U.setCodigoBanco(linha.substring(210, 213).trim());
                
                registroHelperCodigo3U.setNossoNumero(linha.substring(213, 233).trim());
                
                registroHelperCodigo3U.setUsoExclusivo24(linha.substring(233, 240).trim());
                
                registroHelperCodigo = registroHelperCodigo3U;
                break;

        case '5':
            RegistroHelperCodigo5 registroHelperCodigo5 = new RegistroHelperCodigo5();
          
            registroHelperCodigo5.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
            
            registroHelperCodigo5.setLoteServico(linha.substring(3, 7).trim());
            
            registroHelperCodigo5.setCodigoRegistro(linha.substring(7, 8).trim());
            
            registroHelperCodigo5.setUsoExclusivo04(linha.substring(8, 17).trim());
            
            registroHelperCodigo5.setQtdeRegistrosLote(linha.substring(17, 23).trim());
            
            registroHelperCodigo5.setQtdeTITCobranca06(linha.substring(23, 29).trim());
            
            registroHelperCodigo5.setValorTITCarteira07(linha.substring(29, 46).trim());
            
            registroHelperCodigo5.setQtdeTITCobranca08(linha.substring(46, 52).trim());
            
            registroHelperCodigo5.setValorTITCarteira09(linha.substring(52, 69).trim());
            
            registroHelperCodigo5.setQtdeTITCobranca10(linha.substring(69, 75).trim());
            
            registroHelperCodigo5.setValorTITCarteira11(linha.substring(75, 92).trim());
            
            registroHelperCodigo5.setQtdeTITCobranca12(linha.substring(92, 98).trim());
            
            registroHelperCodigo5.setValorTITCarteira13(linha.substring(98, 115).trim());
            
            registroHelperCodigo5.setNumeroAvisoLancamento(linha.substring(115, 123).trim());
            
            registroHelperCodigo5.setUsoExclusivo15(linha.substring(123, 240).trim());
            
            // faz um cast para o object
            registroHelperCodigo = registroHelperCodigo5;
            break;

        case '9':
            RegistroHelperCodigo9 registroHelperCodigo9 = new RegistroHelperCodigo9();
          
            registroHelperCodigo9.setCodigoBancoCompensacao(linha.substring(0, 3).trim());
            
            registroHelperCodigo9.setLoteServico(linha.substring(3, 7).trim());
            
            registroHelperCodigo9.setCodigoRegistro(linha.substring(7, 8).trim());
            
            registroHelperCodigo9.setUsoExclusivo04(linha.substring(8, 17).trim());
            
            registroHelperCodigo9.setQtdeLoteArquivo(linha.substring(17, 23).trim());
            
            registroHelperCodigo9.setQtdeRegistrosArquivo(linha.substring(23, 29).trim());
            
            registroHelperCodigo9.setQtdeContas(linha.substring(29, 35).trim());
            
            registroHelperCodigo9.setUsoExclusivo08(linha.substring(35, 240).trim());
            
            // faz um cast para o object
            registroHelperCodigo = registroHelperCodigo9;
            break;

        }
        return registroHelperCodigo;
    }

    
    /**
     * [UC0724] - Processar Pagamento com Ficha de Compensação
     * 
     * Autor: Vivianne Sousa
     * Data: 26/11/2007
     */
    public PagamentoHelperCodigoBarras processarPagamentosFichaCompensacao(
            SistemaParametro sistemaParametro, Date dataPagamento, 
            BigDecimal valorPagamento, String nossoNumero, Integer idFormaArrecadacao, Usuario usuarioLogado) throws ControladorException {

        PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
     
        String descricaoOcorrencia = "OK";
        String indicadorAceitacaoRegistro = "1";

        Collection colecaoPagamnetos = new ArrayList();
        
        Integer tipoDocumento = new Integer(nossoNumero.substring(7,9));
        Integer idDocumentoEmitido = new Integer(nossoNumero.substring(9,17));
        
        //5.
        FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
        filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID, tipoDocumento));
        Collection colecaoDocumentoTipo = getControladorUtil().pesquisar(filtroDocumentoTipo,DocumentoTipo.class.getName());
        
        //Caso o tipo de documento não esteja na tabela COBRANCA.DOCUMENTO_TIPO
        if (colecaoDocumentoTipo == null || colecaoDocumentoTipo.isEmpty()){
            indicadorAceitacaoRegistro = "2";
            descricaoOcorrencia  = "TIPO DE DOCUMENTO INVÁLIDO";
        }else{
          
            if(tipoDocumento.equals(DocumentoTipo.CONTA)){
                //6.1
                //[SB0001]-Processar Pagamento de Conta
                
                Conta conta = null ;
                ContaHistorico contaHistorico = null ;
                
                conta = this.getControladorFaturamento().pesquisarContaTipoBoleto(idDocumentoEmitido, valorPagamento);
                
                //[FS0001]-Validar Conta
                if(conta == null){
                    
                	contaHistorico = this.getControladorFaturamento().pesquisarContaHistoricoTipoBoleto(idDocumentoEmitido, valorPagamento);
                    
                    if (contaHistorico == null){
                        descricaoOcorrencia = "CONTA INEXISTENTE";
                    }
                }
                
                if(descricaoOcorrencia.equalsIgnoreCase("OK")){
                    //Cria o objeto pagamento para setar os dados
                    Pagamento pagamento = new Pagamento();
                    Integer anoMesPagamento = Util.recuperaAnoMesDaData(dataPagamento);
                    
                    if(conta != null){
                        pagamento.setAnoMesReferenciaPagamento(conta.getReferencia());
                    }else{
                        pagamento.setAnoMesReferenciaPagamento(contaHistorico.getAnoMesReferenciaConta());
                    }
                    
                    /*
                     * Caso o ano mes da data de dedito seja maior que o ano mes de
                     * arrecadação da tabela sistema parametro então seta o ano mes da
                     * data de debito
                     */
                    if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {

                        pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

                    } else {

                        /*
                         * caso contrario seta o o ano mes arrecadação da tabela sistema
                         * parametro
                         */
                        pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
                                .getAnoMesArrecadacao());
                    }

                    pagamento.setValorPagamento(valorPagamento);
                    pagamento.setDataPagamento(dataPagamento);
                    pagamento.setPagamentoSituacaoAtual(null);
                    pagamento.setPagamentoSituacaoAnterior(null);
                    pagamento.setDebitoTipo(null);
                    
                    if(conta != null){
                    	ContaGeral contaGeral = new ContaGeral();
                    	contaGeral.setId(conta.getId());
                    	contaGeral.setConta(conta);
                    	
                        pagamento.setContaGeral(contaGeral);
                        pagamento.setLocalidade(conta.getImovel().getLocalidade());
                        pagamento.setImovel(conta.getImovel());
                    }else{
                        pagamento.setContaGeral(null);
                        pagamento.setLocalidade(contaHistorico.getImovel().getLocalidade());
                        pagamento.setImovel(contaHistorico.getImovel());
                    }
                    
                    pagamento.setGuiaPagamento(null);

                    DocumentoTipo documentoTipo = new DocumentoTipo();
                    documentoTipo.setId(DocumentoTipo.CONTA);
                    pagamento.setDocumentoTipo(documentoTipo);
                    pagamento.setAvisoBancario(null);
                    
                    pagamento.setArrecadadorMovimentoItem(null);

                    ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
                    arrecadacaoForma.setId(idFormaArrecadacao);
                    pagamento.setArrecadacaoForma(arrecadacaoForma);
                    pagamento.setCliente(null);
                    pagamento.setUltimaAlteracao(new Date());

                    pagamento.setFatura(null);
        			pagamento.setCobrancaDocumento(null);
        			
        			DocumentoTipo documentoAgregador = new DocumentoTipo();
        			documentoAgregador.setId(DocumentoTipo.CONTA);
        			pagamento.setDocumentoTipoAgregador(documentoAgregador);	
                    
                    colecaoPagamnetos.add(pagamento);

                }else{
                    indicadorAceitacaoRegistro = "2";
                }

                
            }
            else if (tipoDocumento.equals(DocumentoTipo.EXTRATO_DE_DEBITO) || 
            		tipoDocumento.equals(DocumentoTipo.VISITA_COBRANCA) ||
            		tipoDocumento.equals(DocumentoTipo.ORDEM_CORTE)){
            	
            	//[SB0002]  Processar Pagamento de Extrato de Débitos.
            	CobrancaDocumento cobrancaDocumento = null ;
                
            	try {
            		cobrancaDocumento = repositorioArrecadacao.pesquisarCobrancaDocumentoProcessarFichaCompensacao(idDocumentoEmitido);
                } 
            	catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
            	
            	//[FS0002  Validar documento de cobrança]
            	if (cobrancaDocumento == null){
            		descricaoOcorrencia = "DOCUMENTO INEXISTENTE";
            		indicadorAceitacaoRegistro = "2";
            	}
            	
            	if(descricaoOcorrencia.equalsIgnoreCase("OK")){
            		
            		PagamentoHelperCodigoBarras retorno = new PagamentoHelperCodigoBarras();
            		
            		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();
            		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
            		
            		if (cobrancaDocumento.getImovel() != null){
            			
            			if (cobrancaDocumento.getLocalidade() != null){
            				
            				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(cobrancaDocumento.getLocalidade().getId().toString());
            			}
            			else{
            				
            				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(cobrancaDocumento.getImovel().getLocalidade().getId().toString());
            			}
            			
            			//IMÓVEL
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(cobrancaDocumento.getImovel().getId().toString());
        				
            			//SEQUENCIAL DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(String.valueOf(cobrancaDocumento.getNumeroSequenciaDocumento()));
        				
            			//TIPO DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(cobrancaDocumento.getDocumentoTipo().getId().toString());
            			
        				registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
        				
            			/*
            			 * [UC0259] - Processar Pagamento com Código de Barras
            			 * [SB0003]  Processar Pagamento de Documento de Cobrança - IMÓVEL
            			 */
        				retorno = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo5(registroHelperCodigoBarras, getSistemaParametro(),
            			dataPagamento, Util.recuperaAnoMesDaData(dataPagamento), valorPagamento, idFormaArrecadacao, usuarioLogado);
        				
        				colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
        				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
        				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
            		}
            		else{
            			
            			//CLIENTE
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(cobrancaDocumento.getCliente().getId().toString());
        				
            			//SEQUENCIAL DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(String.valueOf(cobrancaDocumento.getNumeroSequenciaDocumento()));
        				
            			//TIPO DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(cobrancaDocumento.getDocumentoTipo().getId().toString());
            			
        				registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
        				
            			/*
            			 * [UC0259] - Processar Pagamento com Código de Barras
            			 * [SB0003]  Processar Pagamento de Documento de Cobrança - CLIENTE
            			 */
        				retorno = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo8(registroHelperCodigoBarras, getSistemaParametro(),
            			dataPagamento, Util.recuperaAnoMesDaData(dataPagamento), valorPagamento, idFormaArrecadacao);
        				
        				colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
        				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
        				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
            		}
            	}
            } else if(tipoDocumento.equals(DocumentoTipo.EXTRATO_CONTRATO_PARCELAMENTO)){
                //6.1.3. Extrato Contrato Parcelamento 
                // [SB0009] ? Processar Pagamento Extrato Contrato Parcelamento

            	CobrancaDocumentoItem cobrancaDocumentoItem = null ;
                
            	try {
            		cobrancaDocumentoItem = repositorioArrecadacao.pesquisarCobrancaDocumentoItemProcessarFichaCompensacao(idDocumentoEmitido);
                } 
            	catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
            	
            	// [FS0002 ? Validar documento de cobrança]
            	if (cobrancaDocumentoItem == null){
            		descricaoOcorrencia = "DOCUMENTO ITEM INEXISTENTE";
            	}
            	
				if(descricaoOcorrencia.equalsIgnoreCase("OK")){
			            		
            		PagamentoHelperCodigoBarras retorno = new PagamentoHelperCodigoBarras();
            		
            		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();
            		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
            		
        			//CLIENTE
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(cobrancaDocumentoItem.getCobrancaDocumento().getCliente().getId().toString());
    				
        			//SEQUENCIAL DO DOCUMENTO
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(String.valueOf(idDocumentoEmitido));
    				
        			//TIPO DO DOCUMENTO
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(cobrancaDocumentoItem.getCobrancaDocumento().getDocumentoTipo().getId().toString());
        			
    				registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
    				
    				retorno = this.processarPagamentosCodigoBarrasContratoParcelamento(registroHelperCodigoBarras, 
    						getSistemaParametro(), dataPagamento, Util.recuperaAnoMesDaData(dataPagamento), valorPagamento, 
    						ArrecadacaoForma.FICHA_COMPENSACAO, usuarioLogado);
    				
    				colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
    				
    				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
    				
    				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
				}
                
            }
            else if (tipoDocumento.equals(DocumentoTipo.GUIA_PAGAMENTO)){
            	
            	GuiaPagamento guiaPagamento = null;
            	
            	try {
    				
    				guiaPagamento = this.repositorioArrecadacao.pesquisarGuiaPagamentoProcessarFichaCompensacao(idDocumentoEmitido);										

    			} catch (ErroRepositorioException e) {
    				e.printStackTrace();
    				throw new ControladorException("erro.sistema", e);
    			}
    			
    			if (guiaPagamento == null){
            		descricaoOcorrencia = "GUIA PAGAMENTO INEXISTENTE";
            		indicadorAceitacaoRegistro = "2";
            	}
    			
    			if(descricaoOcorrencia.equalsIgnoreCase("OK")){
    				
    				PagamentoHelperCodigoBarras retorno = new PagamentoHelperCodigoBarras();
            		
            		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();
            		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
    				
            		//LOCALIDADE
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamento.getLocalidade().getId().toString());
        			
        			//ID DA GUIA DE PAGAMENTO
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(guiaPagamento.getId().toString());
        			
        			if (guiaPagamento.getImovel() != null){
    					
    					//IMÓVEL
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(String.valueOf(guiaPagamento.getImovel().getId().toString()));
            			
            			//ADICIONANDO AO HELPER
            			registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
            			
            			/*
            			 * [UC0259] - Processar Pagamento com Código de Barras
            			 */
        				retorno = this.processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoMatricula(
        						registroHelperCodigoBarras, getSistemaParametro(), dataPagamento, Util.recuperaAnoMesDaData(dataPagamento), 
        						valorPagamento, idFormaArrecadacao);
        				
    				}
    				else{
    					
    					//CLIENTE
    					registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(String.valueOf(guiaPagamento.getCliente().getId().toString()));
    					
    					//ADICIONANDO AO HELPER
            			registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
            			
            			/*
            			 * [UC0259] - Processar Pagamento com Código de Barras
            			 */
        				retorno = this.processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoCliente(
        						registroHelperCodigoBarras, getSistemaParametro(), dataPagamento, Util.recuperaAnoMesDaData(dataPagamento), 
        						valorPagamento, idFormaArrecadacao);
    				}
        			
        			colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
    				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
    				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
    			}
            }
            else{
                //6.2
                indicadorAceitacaoRegistro = "2";
                descricaoOcorrencia = "FICHA DE COMPENS. COM TIPO DE PAGAMENTO INVÁLIDO";
            }
        }
        
        //Seta os parametros que serão retornados
        pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamnetos);
        pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
        pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
        
        return pagamentoHelperCodigoBarras;
    }
    
    
    public PagamentoHelperCodigoBarras processarPagamentosFichaCompensacaoNovo(
            RegistroFichaCompensacaoTipo7Helper registroTipo7, Integer idFormaArrecadacao, Usuario usuarioLogado) throws ControladorException {

        PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
     
        String descricaoOcorrencia = "OK";
        String indicadorAceitacaoRegistro = "1";

        Collection colecaoPagamnetos = new ArrayList();
        
        FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
        filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID, registroTipo7.getTipoDocumentoInteger()));
        Collection colecaoDocumentoTipo = getControladorUtil().pesquisar(filtroDocumentoTipo,DocumentoTipo.class.getName());
        
        if (colecaoDocumentoTipo == null || colecaoDocumentoTipo.isEmpty()){
            indicadorAceitacaoRegistro = "2";
            descricaoOcorrencia  = "TIPO DE DOCUMENTO INVÁLIDO";
        }else{
          
            if(registroTipo7.getTipoDocumentoInteger().equals(DocumentoTipo.CONTA)){
                IConta conta = null ;
                
                conta = this.getControladorFaturamento().pesquisarContaTipoBoleto(registroTipo7.getIdDocumentoEmitido(), registroTipo7.getValorRecebidoFormatado());
                
                if(conta == null){
                	conta = this.getControladorFaturamento().pesquisarContaHistoricoTipoBoleto(registroTipo7.getIdDocumentoEmitido(), registroTipo7.getValorRecebidoFormatado());
                    
                    if (conta == null){
                        descricaoOcorrencia = "CONTA INEXISTENTE";
                    }
                }
                
                if(descricaoOcorrencia.equalsIgnoreCase("OK")){
                    Pagamento pagamento = new Pagamento();
                    Integer anoMesPagamento = Util.recuperaAnoMesDaData(registroTipo7.getDataLiquidacaoFormatado());
                    
                    pagamento.setAnoMesReferenciaPagamento(conta.getReferencia());
                    
                    if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
                        pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
                    } else {
                        pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
                    }

                    pagamento.setValorPagamento(registroTipo7.getValorRecebidoFormatado());
                    pagamento.setDataPagamento(registroTipo7.getDataLiquidacaoFormatado());
                    pagamento.setPagamentoSituacaoAtual(null);
                    pagamento.setPagamentoSituacaoAnterior(null);
                    pagamento.setDebitoTipo(null);
                    
                    if(conta instanceof Conta){
                    	ContaGeral contaGeral = new ContaGeral();
                    	contaGeral.setId(conta.getId());
                    	contaGeral.setConta(conta);
                    	
                        pagamento.setContaGeral(contaGeral);
                    }
                    
                    pagamento.setLocalidade(conta.getImovel().getLocalidade());
                    pagamento.setImovel(conta.getImovel());
                    
                    pagamento.setGuiaPagamento(null);

                    DocumentoTipo documentoTipo = new DocumentoTipo();
                    documentoTipo.setId(DocumentoTipo.CONTA);
                    pagamento.setDocumentoTipo(documentoTipo);
                    pagamento.setAvisoBancario(null);
                    
                    pagamento.setArrecadadorMovimentoItem(null);

                    ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
                    arrecadacaoForma.setId(idFormaArrecadacao);
                    pagamento.setArrecadacaoForma(arrecadacaoForma);
                    pagamento.setCliente(null);
                    pagamento.setUltimaAlteracao(new Date());

                    pagamento.setFatura(null);
        			pagamento.setCobrancaDocumento(null);
        			
        			DocumentoTipo documentoAgregador = new DocumentoTipo();
        			documentoAgregador.setId(DocumentoTipo.CONTA);
        			pagamento.setDocumentoTipoAgregador(documentoAgregador);	
                    
                    colecaoPagamnetos.add(pagamento);

                }else{
                    indicadorAceitacaoRegistro = "2";
                }
            }
            else if (registroTipo7.getTipoDocumentoInteger().equals(DocumentoTipo.EXTRATO_DE_DEBITO) || 
            		registroTipo7.getTipoDocumentoInteger().equals(DocumentoTipo.VISITA_COBRANCA) ||
            		registroTipo7.getTipoDocumentoInteger().equals(DocumentoTipo.ORDEM_CORTE)){
            	
            	CobrancaDocumento cobrancaDocumento = null ;
                
            	try {
            		cobrancaDocumento = repositorioArrecadacao.pesquisarCobrancaDocumentoProcessarFichaCompensacao(
            																								registroTipo7.getIdDocumentoEmitido());
                } 
            	catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
            	
            	if (cobrancaDocumento == null){
            		descricaoOcorrencia = "DOCUMENTO INEXISTENTE";
            		indicadorAceitacaoRegistro = "2";
            	}
            	
            	if(descricaoOcorrencia.equalsIgnoreCase("OK")){
            		
            		PagamentoHelperCodigoBarras retorno = new PagamentoHelperCodigoBarras();
            		
            		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();
            		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
            		
            		if (cobrancaDocumento.getImovel() != null){
            			if (cobrancaDocumento.getLocalidade() != null){
            				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(cobrancaDocumento.getLocalidade().getId().toString());
            			}
            			else{
            				registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(cobrancaDocumento.getImovel().getLocalidade().getId().toString());
            			}
            			
            			//IMÓVEL
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(cobrancaDocumento.getImovel().getId().toString());
        				
            			//SEQUENCIAL DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(String.valueOf(cobrancaDocumento.getNumeroSequenciaDocumento()));
        				
            			//TIPO DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(cobrancaDocumento.getDocumentoTipo().getId().toString());
            			
        				registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
        				
            			/*
            			 * [UC0259] - Processar Pagamento com Código de Barras
            			 * [SB0003]  Processar Pagamento de Documento de Cobrança - IMÓVEL
            			 */
        				retorno = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo5Novo(registroHelperCodigoBarras, registroTipo7, 
        																										idFormaArrecadacao, usuarioLogado);
        				
        				colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
        				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
        				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
            		}
            		else{
            			
            			//CLIENTE
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(cobrancaDocumento.getCliente().getId().toString());
        				
            			//SEQUENCIAL DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(String.valueOf(cobrancaDocumento.getNumeroSequenciaDocumento()));
        				
            			//TIPO DO DOCUMENTO
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(cobrancaDocumento.getDocumentoTipo().getId().toString());
            			
        				registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
        				
            			/*
            			 * [UC0259] - Processar Pagamento com Código de Barras
            			 * [SB0003]  Processar Pagamento de Documento de Cobrança - CLIENTE
            			 */
        				retorno = this.processarPagamentosCodigoBarrasDocumentoCobrancaTipo8Novo(registroHelperCodigoBarras, registroTipo7, 
        																														idFormaArrecadacao);
        				
        				colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
        				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
        				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
            		}
            	}
            } else if(registroTipo7.getTipoDocumentoInteger().equals(DocumentoTipo.EXTRATO_CONTRATO_PARCELAMENTO)){
                //6.1.3. Extrato Contrato Parcelamento 
                // [SB0009] ? Processar Pagamento Extrato Contrato Parcelamento

            	CobrancaDocumentoItem cobrancaDocumentoItem = null ;
                
            	try {
            		cobrancaDocumentoItem = repositorioArrecadacao.pesquisarCobrancaDocumentoItemProcessarFichaCompensacao(registroTipo7.getIdDocumentoEmitido());
                } 
            	catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
            	
            	// [FS0002 ? Validar documento de cobrança]
            	if (cobrancaDocumentoItem == null){
            		descricaoOcorrencia = "DOCUMENTO ITEM INEXISTENTE";
            	}
            	
				if(descricaoOcorrencia.equalsIgnoreCase("OK")){
			            		
            		PagamentoHelperCodigoBarras retorno = new PagamentoHelperCodigoBarras();
            		
            		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();
            		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
            		
        			//CLIENTE
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(cobrancaDocumentoItem.getCobrancaDocumento().getCliente().getId().toString());
    				
        			//SEQUENCIAL DO DOCUMENTO
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(String.valueOf(registroTipo7.getIdDocumentoEmitido()));
    				
        			//TIPO DO DOCUMENTO
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(cobrancaDocumentoItem.getCobrancaDocumento().getDocumentoTipo().getId().toString());
        			
    				registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
    				
    				retorno = this.processarPagamentosCodigoBarrasContratoParcelamento(registroHelperCodigoBarras, 
    						getSistemaParametro(), registroTipo7.getDataLiquidacaoFormatado(), 
    						Util.recuperaAnoMesDaData(registroTipo7.getDataLiquidacaoFormatado()), registroTipo7.getValorRecebidoFormatado(), 
    						ArrecadacaoForma.FICHA_COMPENSACAO, usuarioLogado);
    				
    				colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
    				
    				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
    				
    				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
				}
                
            }
            else if (registroTipo7.getTipoDocumentoInteger().equals(DocumentoTipo.GUIA_PAGAMENTO)){
            	
            	GuiaPagamento guiaPagamento = null;
            	
            	try {
    				
    				guiaPagamento = this.repositorioArrecadacao.pesquisarGuiaPagamentoProcessarFichaCompensacao(registroTipo7.getIdDocumentoEmitido());										

    			} catch (ErroRepositorioException e) {
    				e.printStackTrace();
    				throw new ControladorException("erro.sistema", e);
    			}
    			
    			if (guiaPagamento == null){
            		descricaoOcorrencia = "GUIA PAGAMENTO INEXISTENTE";
            		indicadorAceitacaoRegistro = "2";
            	}
    			
    			if(descricaoOcorrencia.equalsIgnoreCase("OK")){
    				
    				PagamentoHelperCodigoBarras retorno = new PagamentoHelperCodigoBarras();
            		
            		RegistroHelperCodigoBarras registroHelperCodigoBarras = new RegistroHelperCodigoBarras();

            		RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento = new RegistroHelperCodigoBarrasTipoPagamento();
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(guiaPagamento.getLocalidade().getId().toString());
        			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(guiaPagamento.getId().toString());
        			
        			if (guiaPagamento.getImovel() != null){
    					
            			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(String.valueOf(guiaPagamento.getImovel().getId().toString()));
            			registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
            			
        				retorno = this.processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoMatricula(
        						registroHelperCodigoBarras, getSistemaParametro(), registroTipo7.getDataLiquidacaoFormatado(), 
        						Util.recuperaAnoMesDaData(registroTipo7.getDataLiquidacaoFormatado()), 
        						registroTipo7.getValorRecebidoFormatado(), idFormaArrecadacao);
        				
    				} else {
    					
    					registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(String.valueOf(guiaPagamento.getCliente().getId().toString()));
            			registroHelperCodigoBarras.setRegistroHelperCodigoBarrasTipoPagamento(registroHelperCodigoBarrasTipoPagamento);
            			
        				retorno = this.processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoCliente(
        						registroHelperCodigoBarras, getSistemaParametro(), registroTipo7.getDataLiquidacaoFormatado(), 
        						Util.recuperaAnoMesDaData(registroTipo7.getDataLiquidacaoFormatado()), 
        						registroTipo7.getValorRecebidoFormatado(), idFormaArrecadacao);
    				}
        			
        			colecaoPagamnetos.addAll(retorno.getColecaoPagamentos());
    				descricaoOcorrencia = retorno.getDescricaoOcorrencia();
    				indicadorAceitacaoRegistro = retorno.getIndicadorAceitacaoRegistro();
    			}
            }
            else{
                indicadorAceitacaoRegistro = "2";
                descricaoOcorrencia = "FICHA DE COMPENS. COM TIPO DE PAGAMENTO INVÁLIDO";
            }
        }
        
        pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamnetos);
        pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
        pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
        
        return pagamentoHelperCodigoBarras;
    }

    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores 
     * [SF0013] - Inserir o movimento do arrecadador da Ficha de Compensação
     * Autor: Vivianne Sousa
     * Data: 27/11/2007
     */
    public ArrecadadorMovimento inserirMovimentoArrecadadorFichaCompensacao(
            RegistroHelperCodigo0 registroHelperCodigo0,
            BigDecimal somatorioValorTITCarteira07,
            RegistroHelperCodigo9 registroHelperCodigo9)
            throws ControladorException {

        Integer idMovimento = null;
        ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
        // cria o objeto de arrecadador movimento para a inserção
        arrecadadorMovimento.setCodigoRemessa(new Short(registroHelperCodigo0.getCodigoRemessaRetorno()));
        arrecadadorMovimento.setCodigoConvenio(registroHelperCodigo0.getCodigoConvenioBanco().trim());
        arrecadadorMovimento.setNomeEmpresa(registroHelperCodigo0.getNomeEmpresa().trim());
        arrecadadorMovimento.setCodigoBanco(new Short(registroHelperCodigo0.getCodigoBancoCompensacao().trim()));
        arrecadadorMovimento.setNomeBanco(registroHelperCodigo0.getNomeBanco().trim());
        Date dataGeracao = Util
                .converteStringSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo().trim());
        arrecadadorMovimento.setDataGeracao(dataGeracao);
        arrecadadorMovimento.setNumeroSequencialArquivo(new Integer(registroHelperCodigo0.getNumeroSequencialArquivo().trim()));
        arrecadadorMovimento.setNumeroVersaoLayout(new Integer(registroHelperCodigo0.getNumeroVersaoLayoutArquivo().trim()));
        arrecadadorMovimento.setDescricaoIdentificacaoServico("FICHA DE COMPENSA");
        arrecadadorMovimento.setNumeroRegistrosMovimento(new Integer(registroHelperCodigo9.getQtdeRegistrosArquivo().trim()));
        arrecadadorMovimento.setValorTotalMovimento(somatorioValorTITCarteira07);
        arrecadadorMovimento.setUltimaAlteracao(new Date());

        try {
            idMovimento = (Integer) repositorioUtil.inserir(arrecadadorMovimento);
            arrecadadorMovimento.setId(idMovimento);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema");
        }
        return arrecadadorMovimento;
    }
    
    public ArrecadadorMovimento inserirMovimentoArrecadadorFichaCompensacaoNovo(RegistroFichaCompensacaoHeaderHelper registroHeader, 
    		RegistroFichaCompensacaoTrailerHelper registroTrailer) throws ControladorException {
    	ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
    	arrecadadorMovimento.setCodigoRemessa(Short.valueOf(registroHeader.getTipoOperacao()));
    	arrecadadorMovimento.setCodigoConvenio(registroHeader.getNumeroConvenio());
    	arrecadadorMovimento.setNomeEmpresa(registroHeader.getNomeCedente());
    	arrecadadorMovimento.setCodigoBanco(Short.valueOf(registroHeader.getIdCodigoBanco()));
    	arrecadadorMovimento.setNomeBanco(registroHeader.getNomeBanco());
    	arrecadadorMovimento.setDataGeracao(registroHeader.getDataGravacao());
    	arrecadadorMovimento.setNumeroSequencialArquivo(Integer.valueOf(registroHeader.getSequencialRetorno()));
    	arrecadadorMovimento.setDescricaoIdentificacaoServico("FICHA DE COMPENSACAO");
    	arrecadadorMovimento.setNumeroRegistrosMovimento(registroTrailer.getQuantidadeRegistros());
    	arrecadadorMovimento.setValorTotalMovimento(BigDecimal.ZERO);
    	arrecadadorMovimento.setUltimaAlteracao(new Date());
    	try {
            Integer idMovimento = (Integer) repositorioUtil.inserir(arrecadadorMovimento);
            arrecadadorMovimento.setId(idMovimento);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema");
        }
        return arrecadadorMovimento;
    }
    
    public Integer inserirItemMovimentoArrecadadorFichaCompensacaoNovo(String linhaRegistro, Integer idMovimento, String descricaoOcorrencia,
            int indicadorAceitacaoRegistro, Integer idImovelPagamento)
            throws ControladorException {

        Integer idArrecadadorMovimentoItem = null;

        Integer idRegistroCodigo = RegistroCodigo.FICHA_COMPENSACAO_ID;
        
        ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

        RegistroCodigo registroCodigo = new RegistroCodigo();
        registroCodigo.setId(idRegistroCodigo);
        
        arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);
        ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
        arrecadadorMovimento.setId(idMovimento);
        arrecadadorMovimentoItem.setConteudoRegistro(linhaRegistro);
        arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);
        arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);
        arrecadadorMovimentoItem.setIndicadorAceitacao(new Short("" + indicadorAceitacaoRegistro));
        arrecadadorMovimentoItem.setUltimaAlteracao(new Date());

        if (idImovelPagamento != null) {
            Imovel imovel = new Imovel();
            imovel.setId(idImovelPagamento);
            arrecadadorMovimentoItem.setImovel(imovel);
        }

        try {
            idArrecadadorMovimentoItem = (Integer) repositorioUtil.inserir(arrecadadorMovimentoItem);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema", e);
        }

        return idArrecadadorMovimentoItem;

    }

    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores 
     * [SB0016] - Inserir o item de movimento do arrecadador da Ficha de Compensação
     * Autor: Vivianne Sousa
     * Data: 27/11/2007
     */
    public Integer inserirItemMovimentoArrecadadorFichaCompensacao(String linhaRegistroCodigoT,
            String linhaRegistroCodigoU, Integer idMovimento, String descricaoOcorrencia,
            int indicadorAceitacaoRegistro, Integer idImovelPagamento)
            throws ControladorException {

        Integer idArrecadadorMovimentoItem = null;

        Integer idRegistroCodigo = RegistroCodigo.FICHA_COMPENSACAO_ID;
        
        ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

        RegistroCodigo registroCodigo = new RegistroCodigo();
        registroCodigo.setId(idRegistroCodigo);
        
        StringBuilder conteudoMovimento = new StringBuilder();
        conteudoMovimento.append(linhaRegistroCodigoT.substring(0,13));
        conteudoMovimento.append(linhaRegistroCodigoT.substring(15,57));
        conteudoMovimento.append(linhaRegistroCodigoT.substring(58,96));
        conteudoMovimento.append(linhaRegistroCodigoU.substring(77,92));
        conteudoMovimento.append(linhaRegistroCodigoU.substring(137,153));
        
        arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);
        arrecadadorMovimentoItem.setConteudoRegistro(conteudoMovimento.toString());
        ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
        arrecadadorMovimento.setId(idMovimento);
        arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);
        arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);
        arrecadadorMovimentoItem.setIndicadorAceitacao(new Short("" + indicadorAceitacaoRegistro));
        arrecadadorMovimentoItem.setUltimaAlteracao(new Date());

        if (idImovelPagamento != null) {
            Imovel imovel = new Imovel();
            imovel.setId(idImovelPagamento);
            arrecadadorMovimentoItem.setImovel(imovel);
        }

        try {
            idArrecadadorMovimentoItem = (Integer) repositorioUtil.inserir(arrecadadorMovimentoItem);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema", e);
        }

        return idArrecadadorMovimentoItem;

    }
    
    public AvisoBancario gerarOcorrenciaFichaAvisoBancarioNovo(Integer idMovimento,
            RegistroFichaCompensacaoHeaderHelper registroHeader, Date dataPrevistaCredito, 
            Integer anoMesReferenciaArrecadacao, BigDecimal valorArrecadacaoInf, BigDecimal valorArrecadacaoCalc,
			BigDecimal valorDevolucaoCalc, BigDecimal valorDevolucaoInf, Short numeroSequencialAvisoBancario) throws ControladorException {

		AvisoBancario avisoBancario = new AvisoBancario();

		Integer codigoBancoInteger = Integer.valueOf(registroHeader.getIdCodigoBanco());
		// seta os campos no aviso bancário
		Arrecadador arrecadador = new Arrecadador();
		arrecadador.setId(codigoBancoInteger);
		avisoBancario.setArrecadador(arrecadador);
		avisoBancario.setDataLancamento(registroHeader.getDataGravacaoFormatado());
		avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
		avisoBancario.setDataPrevista(dataPrevistaCredito);
		avisoBancario.setDataRealizada(dataPrevistaCredito);
		avisoBancario.setValorRealizado(valorArrecadacaoInf);
		avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalc);
		avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
		avisoBancario.setValorDevolucaoCalculado(new BigDecimal("0.00"));
		avisoBancario.setValorDevolucaoInformado(new BigDecimal("0.00"));
		avisoBancario.setValorContabilizado(new BigDecimal("0.00"));
		avisoBancario.setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);
		avisoBancario.setNumeroDocumento(0);
		avisoBancario.setUltimaAlteracao(new Date());
		
		avisoBancario.setAnoMesReferenciaArrecadacao(anoMesReferenciaArrecadacao);
		
		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, arrecadador.getId()));
		Collection<ArrecadadorContrato> colecaoArrecadadorContrato = Fachada.getInstancia().pesquisar(filtroArrecadadorContrato,
				ArrecadadorContrato.class.getName());

		ArrecadadorContratoTarifa arrecContratoTarifa = pesquisarArrecadadorContratoTarifa(ArrecadacaoForma.FICHA_COMPENSACAO, colecaoArrecadadorContrato);
		
		ContaBancaria contaBancaria = new ContaBancaria();
		if(arrecContratoTarifa != null)
			contaBancaria.setId(arrecContratoTarifa.getContaBancariaDepositoArrecadacao().getId());
		avisoBancario.setContaBancaria(contaBancaria);
		
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(ArrecadacaoForma.FICHA_COMPENSACAO);
		avisoBancario.setArrecadacaoForma(arrecadacaoForma);

		return avisoBancario;
	}
    
    /**
     * [UC0242] - Registrar Movimento dos Arrecadadores 
     * [SF0015] - Gerar Ocorrência da ficha na coleção de Avisos Bancários 
     * Autor: Vivianne Sousa
     * Data: 27/11/2007
     */
    public AvisoBancario gerarOcorrenciaFichaAvisoBancario(Integer idMovimento,
            RegistroHelperCodigo0 registroHelperCodigo0, Date dataPrevistaCredito, 
            Integer spAnoMesArrecadacao, String codigoBanco,
            BigDecimal valorArrecadacaoInf, BigDecimal valorArrecadacaoCalc,
            BigDecimal valorDevolucaoCalc, BigDecimal valorDevolucaoInf,
            Short numeroSequencialAvisoBancario) throws ControladorException {

        // instância o aviso bancário
        AvisoBancario avisoBancario = new AvisoBancario();

        // seta os campos no aviso bancário
        Arrecadador arrecadador = new Arrecadador();
        arrecadador.setId(new Integer(registroHelperCodigo0.getCodigoBancoCompensacao()));
        avisoBancario.setArrecadador(arrecadador);
        Date dataLancamento = Util
            .converteStringSemBarraParaDate(registroHelperCodigo0.getDataGeracaoArquivo());
        avisoBancario.setDataLancamento(dataLancamento);
        avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
        avisoBancario.setDataPrevista(dataPrevistaCredito);
        avisoBancario.setDataRealizada(dataPrevistaCredito);
        
        avisoBancario.setValorRealizado(valorArrecadacaoInf);
        avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalc);
        avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
        avisoBancario.setValorDevolucaoCalculado(new BigDecimal("0.00"));
        avisoBancario.setValorDevolucaoInformado(new BigDecimal("0.00"));
        avisoBancario.setValorContabilizado(new BigDecimal("0.00"));
        Integer anoMesDataLancamento = Util
                .recuperaAnoMesDaData(dataLancamento);
        if (anoMesDataLancamento > spAnoMesArrecadacao) {
            avisoBancario.setAnoMesReferenciaArrecadacao(anoMesDataLancamento);
        } else {
            avisoBancario.setAnoMesReferenciaArrecadacao(spAnoMesArrecadacao);
        }
        avisoBancario
                .setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);
        avisoBancario.setNumeroDocumento(0);
        avisoBancario.setUltimaAlteracao(new Date());
        Integer codigoBancoInteger = new Integer(codigoBanco);
        Integer idContaBancaria = null;
        try {
            idContaBancaria = repositorioArrecadacao
                    .pesquisarIdDepositoArrecadacao(codigoBancoInteger , null);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema", e);
        }
        ContaBancaria contaBancaria = new ContaBancaria();
        contaBancaria.setId(idContaBancaria);

        avisoBancario.setContaBancaria(contaBancaria);
        ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
        arrecadadorMovimento.setId(idMovimento);
        avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
        
        ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
        arrecadacaoForma.setId(ArrecadacaoForma.FICHA_COMPENSACAO);
        avisoBancario.setArrecadacaoForma(arrecadacaoForma);        

        return avisoBancario;
    }
    
    /**
     * [UC0739] - Informar Situação de Expurgo do Pagamento
     * Autor: Sávio Luiz
     * Data: 02/01/2008
     */
    public Object[] gerarColecaoDadosPagamentoPelaData(String dataPagamento,Integer idCliente,Integer anoMesArrecadacao) throws ControladorException {

		Collection dadosPagamento = null;
		
		Collection dadosPagamentoHistorico = null;
		
		// cria um object com 2 coleções, uma com o indicador de expurgado com 1
		// e outra com o indicador de expurgado 2
		Object[] colecaoDadosPagamento = new Object[2];

		try {
			dadosPagamento = repositorioArrecadacao
					.pesquisarDadosPagamentoExpurgado(dataPagamento,idCliente,anoMesArrecadacao);

			dadosPagamentoHistorico = repositorioArrecadacao
					.pesquisarDadosPagamentoHistoricoExpurgado(dataPagamento,idCliente,anoMesArrecadacao);



		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		
		Collection colecaoExpurgado = new ArrayList();
		
		Collection colecaoNaoExpurgado = new ArrayList();
		
		if(dadosPagamento != null && !dadosPagamento.isEmpty()){
			Iterator ite = dadosPagamento.iterator();
			while(ite.hasNext()){
				Object[] dadoPagamento = (Object[])ite.next();
				
				Pagamento pagamento = new Pagamento();
				pagamento.setId((Integer)dadoPagamento[0]);
				
				if(dadoPagamento[1] != null){
					pagamento.setValorPagamento((BigDecimal)dadoPagamento[1]);
				}
				//seta o indicador de pagamento para sim porque é um pagamento
				pagamento.setIndicadorPagamento(Pagamento.INDICADOR_PAGAMENTO_SIM);
				
				if(dadoPagamento[2] != null){
					pagamento.setIndicadorExpurgado((Short)dadoPagamento[2]);
					if(((Short)dadoPagamento[2]).equals(Pagamento.INDICADOR_EXPURGADO_SIM)){
						colecaoExpurgado.add(pagamento);
					}else{
						colecaoNaoExpurgado.add(pagamento);
					}
				}else{
					pagamento.setIndicadorExpurgado(Pagamento.INDICADOR_EXPURGADO_NAO);
					colecaoNaoExpurgado.add(pagamento);
				}
				
			}
		}
		
		if(dadosPagamentoHistorico != null && !dadosPagamentoHistorico.isEmpty()){
			Iterator ite = dadosPagamentoHistorico.iterator();
			while(ite.hasNext()){
				Object[] dadoPagamento = (Object[])ite.next();
				
				Pagamento pagamento = new Pagamento();
				pagamento.setId((Integer)dadoPagamento[0]);
				
				if(dadoPagamento[1] != null){
					pagamento.setValorPagamento((BigDecimal)dadoPagamento[1]);
				}
				//seta o indicador de pagamento para não porque é um pagamento_historico e não um pagamento
				pagamento.setIndicadorPagamento(Pagamento.INDICADOR_PAGAMENTO_NAO);
				
				if(dadoPagamento[2] != null){
					pagamento.setIndicadorExpurgado((Short)dadoPagamento[2]);
					if(((Short)dadoPagamento[2]).equals(Pagamento.INDICADOR_EXPURGADO_SIM)){
						colecaoExpurgado.add(pagamento);
					}else{
						colecaoNaoExpurgado.add(pagamento);
					}
				}else{
					pagamento.setIndicadorExpurgado(Pagamento.INDICADOR_EXPURGADO_NAO);
					colecaoNaoExpurgado.add(pagamento);
				}
				
			}
		}
		
		if((colecaoExpurgado == null || colecaoExpurgado.isEmpty()) && (colecaoNaoExpurgado == null || colecaoNaoExpurgado.isEmpty())){
			throw new ControladorException("atencao.existencia.pagamento.data_cliente");
		}
		
		
		colecaoDadosPagamento[0] = colecaoExpurgado;
		colecaoDadosPagamento[1] = colecaoNaoExpurgado;

        return colecaoDadosPagamento;
    }
    
    /**
	 * [UC0739] - Informar Situação de Expurgo do Pagamento Autor: Sávio Luiz
	 * Data: 02/01/2008
	 */
	public void atualizarSituacaoExpurgoPagamento(Collection colecaoPagamento)
			throws ControladorException {

		try {
			repositorioArrecadacao.atualizarSituacaoExpurgado(colecaoPagamento);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

	}
	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 10/01/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Collection<RelatorioComparativoFatArrecExpurgoBean> pesquisarDadosComparativosFaturamentoArrecadacaoExpurgo(Integer anoMesReferencia,
			String idGerenciaRegional,String idUnidadeNegocio)
			throws ControladorException{
		try {
			
			SistemaParametro sistemaParametro = getControladorUtil().pesquisarParametrosDoSistema();
			
			if(anoMesReferencia >= getSistemaParametro().getAnoMesArrecadacao()){
				throw new ControladorException("atencao.mes_ano_arrecadacao.maior.mes_ano_escolhido", null,""+Util.formatarAnoMesParaMesAno(getSistemaParametro().getAnoMesArrecadacao()));
			}
			
			List colecaoDadosComparativos = (List)repositorioArrecadacao.pesquisarDadosComparativosFaturamentoArrecadacaoExpurgo(anoMesReferencia,
					idGerenciaRegional,idUnidadeNegocio);
			
			Collection colecaoPagamentos = repositorioArrecadacao.pesquisarPagamentoExpurgado(anoMesReferencia,
					idGerenciaRegional,idUnidadeNegocio);
			
			Map<Integer,BigDecimal> localidadeValorPagamento = this.criarMapPagamentoHistoricoExpurgado(colecaoPagamentos);
			
			
			
			Collection colecaoPagamentosHistorico = repositorioArrecadacao.pesquisarPagamentoHistoricoExpurgado(anoMesReferencia,
					idGerenciaRegional,idUnidadeNegocio);
			
			Map<Integer,BigDecimal> localidadeValorPagamentoHistorico = this.criarMapPagamentoHistoricoExpurgado(colecaoPagamentosHistorico);
			
			
			
			Collection<RelatorioComparativoFatArrecExpurgoBean> colecaoComparativoFatArrecExpurgoBean = 
				this.criarBeanComparativoFatArrecExpurgo(colecaoDadosComparativos,idGerenciaRegional,idUnidadeNegocio,localidadeValorPagamento,
						localidadeValorPagamentoHistorico,anoMesReferencia);
			
			return colecaoComparativoFatArrecExpurgoBean;
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 10/01/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 * @throws ErroRepositorioException 
	 */
	public Collection<RelatorioComparativoFatArrecExpurgoBean> criarBeanComparativoFatArrecExpurgo(List colecaoDadosComparativos,String idGerenciaRegional,String idUnidadeNegocio,
			Map<Integer,BigDecimal> localidadeValorPagamento,Map<Integer,BigDecimal> localidadeValorPagamentoHistorico, Integer anoMesReferencia)
			throws ControladorException, ErroRepositorioException{
		
		Collection<RelatorioComparativoFatArrecExpurgoBean> colecaoComparativoFatArrecExpurgoBean = new ArrayList();
		// se a coleção de parâmetros da analise não for vazia
		if (colecaoDadosComparativos != null && !colecaoDadosComparativos.isEmpty()) {

			// coloca a coleção de parâmetros da analise no iterator
			ListIterator colecaoIterator = colecaoDadosComparativos.listIterator();
			
			String nomeUnidadeNegocioAnterior = "";
			String nomeGerenciaRegionalAnterior = "";
			
			Integer qtdeItemFaturadoUN = 0;
			Integer qtdeItemFaturadoLiquidoUN = 0;
			Integer qtdeItemArrecadacaoUN = 0;
			
			Integer qtdeItemFaturadoGR = 0;
			Integer qtdeItemFaturadoLiquidoGR = 0;
			Integer qtdeItemArrecadacaoGR = 0;
			
			Integer qtdeItemFaturadoESTADO = 0;
			Integer qtdeItemFaturadoLiquidoESTADO = 0;
			Integer qtdeItemArrecadacaoESTADO = 0;
			
			BigDecimal valorItemFaturadoUN = new BigDecimal("0.00");
			BigDecimal valorItemFaturadoLiquidoUN = new BigDecimal("0.00");
			BigDecimal valorItemArrecadacaoUN = new BigDecimal("0.00");
			BigDecimal valorItemFaturadoBrutoUN = new BigDecimal("0.00");
			BigDecimal valorItemCanceladosUN = new BigDecimal("0.00");
			BigDecimal valorPagamentoExpurgadoUN = new BigDecimal("0.00");
			BigDecimal valorArrecadacaoPagamentoUN = new BigDecimal("0.00");
			
			BigDecimal valorItemFaturadoGR = new BigDecimal("0.00");
			BigDecimal valorItemFaturadoLiquidoGR = new BigDecimal("0.00");
			BigDecimal valorItemArrecadacaoGR = new BigDecimal("0.00");
			BigDecimal valorItemFaturadoBrutoGR = new BigDecimal("0.00");
			BigDecimal valorItemCanceladosGR = new BigDecimal("0.00");
			BigDecimal valorPagamentoExpurgadoGR = new BigDecimal("0.00");
			BigDecimal valorArrecadacaoPagamentoGR = new BigDecimal("0.00");
			
			BigDecimal valorItemFaturadoESTADO = new BigDecimal("0.00");
			BigDecimal valorItemFaturadoLiquidoESTADO = new BigDecimal("0.00");
			BigDecimal valorItemArrecadacaoESTADO = new BigDecimal("0.00");
			BigDecimal valorItemFaturadoBrutoESTADO = new BigDecimal("0.00");
			BigDecimal valorItemCanceladosESTADO = new BigDecimal("0.00");
			BigDecimal valorPagamentoExpurgadoESTADO = new BigDecimal("0.00");
			BigDecimal valorArrecadacaoPagamentoESTADO = new BigDecimal("0.00");
			
			String nomeUnidadeNegocioRelatorio = "";
			String nomeGerenciaRegionalRelatorio = "";
			
			
			
			boolean primeiraVez = true;

			// laço para criar a coleção de parâmetros da analise
			while (colecaoIterator.hasNext()) {

				Object[] dadosComparativos = (Object[]) colecaoIterator.next();

				String nomeUnidadeNegocio = "";
				String nomeGerenciaRegional = "";
				String codigoCentroCusto = "";
				String nomeLocalidade = "";
				String valorItemFaturado = "";
				String valorItemFaturadoLiquido = "";
				String qtdeItemFaturado = "";
				BigDecimal valorItemFaturadoBruto = new BigDecimal("0.00");
				BigDecimal valorItemCancelados = new BigDecimal("0.00");
				String qtdeItemArrecadacao = "";
				String qtdeItemFaturadoLiquido = "";
				Integer idLocalidade = null;
				BigDecimal valorPagamento = new BigDecimal("0.00");
				BigDecimal valorPagamentoHistorico = new BigDecimal("0.00");
				BigDecimal valorPagamentoExpurgado = new BigDecimal("0.00");
				BigDecimal valorArrecadacaoPagamento = new BigDecimal("0.00");
				BigDecimal valorItemArrecadacao = new BigDecimal("0.00");
				BigDecimal percentualFaturadoArrecadado = null;
				BigDecimal percentualFaturadoEmContaArrecadado = null;
				if (dadosComparativos != null) {
					// verifica se os valores estão nulos
					// caso estejam então ignora a linha
					if (dadosComparativos[7] == null
							&& dadosComparativos[8] == null 
								&& dadosComparativos[9] == null) {
						continue;
					}
					
					if(primeiraVez){
						// recupera o nome da unidade de negocio inicial
						if (dadosComparativos[1] != null) {
							nomeUnidadeNegocioAnterior = (String) dadosComparativos[1];
							nomeUnidadeNegocioRelatorio = (String) dadosComparativos[1];
								
						}
						// recupera o nome da gerência regional inicial
						if (dadosComparativos[0] != null) {
							nomeGerenciaRegionalAnterior = (String) dadosComparativos[0];
							nomeGerenciaRegionalRelatorio = (String) dadosComparativos[0];
						}
						
						primeiraVez = false;
					}
					

					// recupera o nome da unidade de negocio
					if (dadosComparativos[1] != null) {
						nomeUnidadeNegocio = (String) dadosComparativos[1];
					}
					// recupera o nome da gerência regional
					if (dadosComparativos[0] != null) {
						nomeGerenciaRegional = (String) dadosComparativos[0];
					}
					
					
					//UNIDADE DE NEGÓCIO
					//se a unidade de negocio for diferente da anterior
					if(!nomeUnidadeNegocioAnterior.equals(nomeUnidadeNegocio)){
						//cria uma linha com os acumulativos de unidade de negocio
						
						RelatorioComparativoFatArrecExpurgoBean relatorioComparativoFatArrecExpurgoBean 
										= new RelatorioComparativoFatArrecExpurgoBean(
								"TOT.UNID",
								"","",
								"",valorItemFaturadoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoUN),
							    valorItemFaturadoLiquidoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoLiquidoUN),		
								valorItemArrecadacaoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacaoUN),
								valorItemFaturadoBrutoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoUN),
								valorItemCanceladosUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosUN),
								valorPagamentoExpurgadoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgadoUN),
								valorArrecadacaoPagamentoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamentoUN),
								qtdeItemFaturadoUN.toString(),	
								qtdeItemArrecadacaoUN.toString(), 
								qtdeItemFaturadoLiquidoUN.toString());

						if(valorItemFaturadoLiquidoUN.compareTo(new BigDecimal("0.00")) != 0){
							percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoUN,valorItemFaturadoLiquidoUN)).multiply(new BigDecimal("100.00"));
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
						}else{
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
						}
						
						if(valorItemFaturadoUN.compareTo(new BigDecimal("0.00")) != 0){
							percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoUN,valorItemFaturadoUN)).multiply(new BigDecimal("100.00"));
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
						}else{
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
						}
						
						
						// adiciona no bean a coleção
						colecaoComparativoFatArrecExpurgoBean.add(relatorioComparativoFatArrecExpurgoBean);
						
						
						qtdeItemFaturadoUN = 0;
						qtdeItemFaturadoLiquidoUN = 0;
						qtdeItemArrecadacaoUN = 0;
						
						
						valorItemFaturadoUN = new BigDecimal("0.00");
						valorItemFaturadoLiquidoUN = new BigDecimal("0.00");
						valorItemArrecadacaoUN = new BigDecimal("0.00");
						valorItemFaturadoBrutoUN = new BigDecimal("0.00");
						valorItemCanceladosUN = new BigDecimal("0.00");
						valorPagamentoExpurgadoUN = new BigDecimal("0.00");
						valorArrecadacaoPagamentoUN = new BigDecimal("0.00"); 
						
                        // recupera o nome da unidade de negocio atual e seta
						//para a unidade anterior
						if (dadosComparativos[1] != null) {
							nomeUnidadeNegocioAnterior = (String) dadosComparativos[1];
							nomeUnidadeNegocioRelatorio = (String) dadosComparativos[1];
						}
						

						//GERÊNCIA REGIONAL
						// se a gerência regional for diferente da anterior
						if (!nomeGerenciaRegionalAnterior
								.equals(nomeGerenciaRegional)) {
							// cria uma linha com os acumulativos da gerência regional

							relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
									"",
									"TOT.GER",
									"",
									"",
									valorItemFaturadoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoGR),
									valorItemFaturadoLiquidoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoLiquidoGR),
									valorItemArrecadacaoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacaoGR),
									valorItemFaturadoBrutoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoGR),
									valorItemCanceladosGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosGR),
									valorPagamentoExpurgadoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgadoGR),
									valorArrecadacaoPagamentoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamentoGR),
									qtdeItemFaturadoGR.toString(),	
									qtdeItemArrecadacaoGR.toString(), 
									qtdeItemFaturadoLiquidoGR.toString());

							if(valorItemFaturadoLiquidoGR.compareTo(new BigDecimal("0.00")) != 0){
								percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoGR,valorItemFaturadoLiquidoGR)).multiply(new BigDecimal("100.00"));
								relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
							}else{
								relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
							}		
							
							if(valorItemFaturadoGR.compareTo(new BigDecimal("0.00")) != 0){
								percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoGR,valorItemFaturadoGR)).multiply(new BigDecimal("100.00"));
								relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
							}else{
								relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
							}
							
							// adiciona no bean a coleção
							colecaoComparativoFatArrecExpurgoBean
									.add(relatorioComparativoFatArrecExpurgoBean);
							
							
							qtdeItemFaturadoGR = 0;
							qtdeItemFaturadoLiquidoGR = 0;
							qtdeItemArrecadacaoGR = 0;
							
							valorItemFaturadoGR = new BigDecimal("0.00");
							valorItemFaturadoLiquidoGR = new BigDecimal("0.00");
							valorItemArrecadacaoGR = new BigDecimal("0.00");
							valorItemFaturadoBrutoGR = new BigDecimal("0.00");
							valorItemCanceladosGR = new BigDecimal("0.00");
							valorPagamentoExpurgadoGR = new BigDecimal("0.00");
							valorArrecadacaoPagamentoGR = new BigDecimal("0.00");

							// recupera o nome da gerência regional atual e
							// seta
							// para a gerência regional anterior
							if (dadosComparativos[0] != null) {
								nomeGerenciaRegionalAnterior = (String) dadosComparativos[0];
								nomeGerenciaRegionalRelatorio = (String) dadosComparativos[0];
							}

						}
						
						//retorna para a linha anterior
						colecaoIterator.previous();
						continue;
						
					}
					

					// GERÊNCIA REGIONAL
					// se a gerência regional for diferente da anterior
					if (!nomeGerenciaRegionalAnterior
							.equals(nomeGerenciaRegional)) {
						
						
						RelatorioComparativoFatArrecExpurgoBean relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
								"TOTAL DA UNIDADE",
								"","",
								"",
								valorItemFaturadoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoUN),
								valorItemFaturadoLiquidoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoLiquidoUN),
								valorItemArrecadacaoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacaoUN),
								valorItemFaturadoBrutoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoUN),
								valorItemCanceladosUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosUN),
								valorPagamentoExpurgadoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgadoUN),
								valorArrecadacaoPagamentoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamentoUN),
								qtdeItemFaturadoUN.toString(),	
								qtdeItemArrecadacaoUN.toString(), 
								qtdeItemFaturadoLiquidoUN.toString());

						if(valorItemFaturadoLiquidoUN.compareTo(new BigDecimal("0.00")) != 0){
							percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoUN,valorItemFaturadoLiquidoUN)).multiply(new BigDecimal("100.00"));
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
						}else{
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
						}	
						
						if(valorItemFaturadoUN.compareTo(new BigDecimal("0.00")) != 0){
							percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoUN,valorItemFaturadoUN)).multiply(new BigDecimal("100.00"));
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
						}else{
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
						}
						
						// adiciona no bean a coleção
						colecaoComparativoFatArrecExpurgoBean.add(relatorioComparativoFatArrecExpurgoBean);
						
						qtdeItemFaturadoUN = 0;
						qtdeItemFaturadoLiquidoUN = 0;
						qtdeItemArrecadacaoUN = 0;
						
						valorItemFaturadoUN = new BigDecimal("0.00");
						valorItemFaturadoLiquidoUN = new BigDecimal("0.00");
						valorItemArrecadacaoUN = new BigDecimal("0.00");
						valorItemFaturadoBrutoUN = new BigDecimal("0.00");
						valorItemCanceladosUN = new BigDecimal("0.00");
						valorPagamentoExpurgadoUN = new BigDecimal("0.00");
						valorArrecadacaoPagamentoUN = new BigDecimal("0.00"); 
						
                        // recupera o nome da unidade de negocio atual e seta
						//para a unidade anterior
						if (dadosComparativos[1] != null) {
							nomeUnidadeNegocioAnterior = (String) dadosComparativos[1];
							nomeUnidadeNegocioRelatorio = (String) dadosComparativos[1];
						}
						
						// cria uma linha com os acumulativos da gerência
						// regional
						relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
								"",
								"TOTAL DA GERÊNCIA",
								"",
								"",
								valorItemFaturadoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoGR),
								valorItemFaturadoLiquidoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoLiquidoGR),
								valorItemArrecadacaoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacaoGR),
								valorItemFaturadoBrutoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoGR),
								valorItemCanceladosGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosGR),
								valorPagamentoExpurgadoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgadoGR),
								valorArrecadacaoPagamentoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamentoGR),
								qtdeItemFaturadoGR.toString(),	
								qtdeItemArrecadacaoGR.toString(), 
								qtdeItemFaturadoLiquidoGR.toString());
						
						if(valorItemFaturadoLiquidoGR.compareTo(new BigDecimal("0.00")) != 0){
							percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoGR,valorItemFaturadoLiquidoGR)).multiply(new BigDecimal("100.00"));
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
						}else{
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
						}							
						
						if(valorItemFaturadoGR.compareTo(new BigDecimal("0.00")) != 0){
							percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoGR,valorItemFaturadoGR)).multiply(new BigDecimal("100.00"));
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
						}else{
							relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
						}
						
						// adiciona no bean a coleção
						colecaoComparativoFatArrecExpurgoBean
								.add(relatorioComparativoFatArrecExpurgoBean);
						
						
						qtdeItemFaturadoGR = 0;
						qtdeItemFaturadoLiquidoGR = 0;
						qtdeItemArrecadacaoGR = 0;
						
						valorItemFaturadoGR = new BigDecimal("0.00");
						valorItemFaturadoLiquidoGR = new BigDecimal("0.00");
						valorItemArrecadacaoGR = new BigDecimal("0.00");
						valorItemFaturadoBrutoGR = new BigDecimal("0.00");
						valorItemCanceladosGR = new BigDecimal("0.00");
						valorPagamentoExpurgadoGR = new BigDecimal("0.00");
						valorArrecadacaoPagamentoGR = new BigDecimal("0.00");

						// recupera o nome da gerência regional atual e
						// seta
						// para a gerência regional anterior
						if (dadosComparativos[0] != null) {
							nomeGerenciaRegionalAnterior = (String) dadosComparativos[0];
							nomeGerenciaRegionalRelatorio = (String) dadosComparativos[0];
						}
						
						 
						
						// retorna para a linha anterior
						colecaoIterator.previous();
						continue;

					}
					
					// recupera o codigo do centro de custo que está na localidade
					if (dadosComparativos[2] != null) {
						codigoCentroCusto = (String) dadosComparativos[2];
					}
					// recupera o nome da localidade
					if (dadosComparativos[3] != null) {
						nomeLocalidade = (String) dadosComparativos[3];
					}
					
					//recupera o nome da localidade
					if (dadosComparativos[6] != null) {
						idLocalidade = (Integer) dadosComparativos[6];
					}
					
					
					
					// recupera o valor do item faturado no resumo da fatura
					if (dadosComparativos[7] != null) {
						valorItemFaturado = Util.formatarMoedaReal((BigDecimal) dadosComparativos[7]);
						//acumula os valores dos itens de faturamento
						valorItemFaturadoUN = valorItemFaturadoUN.add((BigDecimal) dadosComparativos[7]);
						valorItemFaturadoGR = valorItemFaturadoGR.add((BigDecimal) dadosComparativos[7]);
						valorItemFaturadoESTADO = valorItemFaturadoESTADO.add((BigDecimal) dadosComparativos[7]);
					}
					// recupera o valor do item arrecadação do resumo da arrecadação
					if (dadosComparativos[8] != null) {
						valorItemArrecadacao = (BigDecimal) dadosComparativos[8];
						//acumula os valores dos itens de arrecadação
						valorItemArrecadacaoUN = valorItemArrecadacaoUN.add((BigDecimal) dadosComparativos[8]);
						valorItemArrecadacaoGR = valorItemArrecadacaoGR.add((BigDecimal) dadosComparativos[8]);
						valorItemArrecadacaoESTADO = valorItemArrecadacaoESTADO.add((BigDecimal) dadosComparativos[8]);
					}
					//recupera o valor do item faturado liquido no resumo da fatura
					if (dadosComparativos[9] != null) {
						valorItemFaturadoLiquido = Util.formatarMoedaReal((BigDecimal) dadosComparativos[9]);
						//acumula os valores dos itens de faturamento
						valorItemFaturadoLiquidoUN = valorItemFaturadoLiquidoUN.add((BigDecimal) dadosComparativos[9]);
						valorItemFaturadoLiquidoGR = valorItemFaturadoLiquidoGR.add((BigDecimal) dadosComparativos[9]);
						valorItemFaturadoLiquidoESTADO = valorItemFaturadoLiquidoESTADO.add((BigDecimal) dadosComparativos[9]);
					}
					//recupera o valor do item faturado bruto no resumo da fatura
					if (dadosComparativos[10] != null) {
						valorItemFaturadoBruto = (BigDecimal) dadosComparativos[10];
						//acumula os valores dos itens de faturamento
						valorItemFaturadoBrutoUN = valorItemFaturadoBrutoUN.add((BigDecimal) dadosComparativos[10]);
						valorItemFaturadoBrutoGR = valorItemFaturadoBrutoGR.add((BigDecimal) dadosComparativos[10]);
						valorItemFaturadoBrutoESTADO = valorItemFaturadoBrutoESTADO.add((BigDecimal) dadosComparativos[10]);
					}
					//recupera o valor do item faturado bruto no resumo da fatura
					if (dadosComparativos[11] != null) {
						valorItemCancelados = (BigDecimal) dadosComparativos[11];
						//acumula os valores dos itens de faturamento
						valorItemCanceladosUN = valorItemCanceladosUN.add((BigDecimal) dadosComparativos[11]);
						valorItemCanceladosGR = valorItemCanceladosGR.add((BigDecimal) dadosComparativos[11]);
						valorItemCanceladosESTADO = valorItemCanceladosESTADO.add((BigDecimal) dadosComparativos[11]);
					}
					
					//Comentado por Romulo Aurelio, correcao do UC. Comentado para geracao da versao.
					
					/*Object[] colecaoQuantidadeFaturado = repositorioArrecadacao.pesquisarQuantidadeContasFaturadas(
							idLocalidade,anoMesReferencia);
					
					if (colecaoQuantidadeFaturado != null
							&& colecaoQuantidadeFaturado.length > 0) {
						if (colecaoQuantidadeFaturado[1] != null) {
							qtdeItemFaturado = ((Integer) colecaoQuantidadeFaturado[1])
									.toString();
							qtdeItemFaturadoUN = qtdeItemFaturadoUN
									+ ((Integer) colecaoQuantidadeFaturado[1]);
							qtdeItemFaturadoGR = qtdeItemFaturadoGR
									+ ((Integer) colecaoQuantidadeFaturado[1]);
							qtdeItemFaturadoESTADO = qtdeItemFaturadoESTADO
									+ ((Integer) colecaoQuantidadeFaturado[1]);
						}
					}else{
						qtdeItemFaturado = "0";
						qtdeItemFaturadoUN = qtdeItemFaturadoUN + 0;
						qtdeItemFaturadoGR = qtdeItemFaturadoGR + 0;
						qtdeItemFaturadoESTADO = qtdeItemFaturadoESTADO + 0;
					}
					
					
					Object[] colecaoQuantidadeArrecadado = repositorioArrecadacao.pesquisarQuantidadeDocumentosPagos(
							idLocalidade,anoMesReferencia);
					//System.out.println("Localidade: " + idLocalidade);
					
					if (colecaoQuantidadeArrecadado != null
							&& colecaoQuantidadeArrecadado.length > 0) {

						if (colecaoQuantidadeArrecadado[1] != null) {
							qtdeItemArrecadacao = ((Integer) colecaoQuantidadeArrecadado[1])
									.toString();
							qtdeItemArrecadacaoUN = qtdeItemArrecadacaoUN
									+ ((Integer) colecaoQuantidadeArrecadado[1]);
							qtdeItemArrecadacaoGR = qtdeItemArrecadacaoGR
									+ ((Integer) colecaoQuantidadeArrecadado[1]);
							qtdeItemArrecadacaoESTADO = qtdeItemArrecadacaoESTADO
									+ ((Integer) colecaoQuantidadeArrecadado[1]);
						}
					}else{
						qtdeItemArrecadacao = "0";
						qtdeItemArrecadacaoUN = qtdeItemArrecadacaoUN + 0;
						qtdeItemArrecadacaoGR = qtdeItemArrecadacaoGR + 0;
						qtdeItemArrecadacaoESTADO = qtdeItemArrecadacaoESTADO + 0;
					}*/
					/*
					// recupera a qtde do item faturado no resumo da fatura
					if (dadosComparativos[10] != null) {
						qtdeItemFaturado = ((Integer) dadosComparativos[10])
								.toString();
						// acumula a quantidade dos itens de faturamento
						qtdeItemFaturadoUN = qtdeItemFaturadoUN
								+ ((Integer) dadosComparativos[10]);
						qtdeItemFaturadoGR = qtdeItemFaturadoGR
								+ ((Integer) dadosComparativos[10]);
						qtdeItemFaturadoESTADO = qtdeItemFaturadoESTADO
								+ ((Integer) dadosComparativos[10]);
					}
					// recupera o quantidade do item arrecadação do resumo da
					// arrecadação
					if (dadosComparativos[11] != null) {
						qtdeItemArrecadacao = ((Integer) dadosComparativos[11])
								.toString();
						// acumula a quantidade dos itens de arrecadação
						qtdeItemArrecadacaoUN = qtdeItemArrecadacaoUN
								+ ((Integer) dadosComparativos[11]);
						qtdeItemArrecadacaoGR = qtdeItemArrecadacaoGR
								+ ((Integer) dadosComparativos[11]);
						qtdeItemArrecadacaoESTADO = qtdeItemArrecadacaoESTADO
								+ ((Integer) dadosComparativos[11]);
					}
					// recupera o quantidade do item arrecadação do resumo da
					// arrecadação
					if (dadosComparativos[12] != null) {
						qtdeItemFaturadoLiquido = ((Integer) dadosComparativos[11])
								.toString();
						// acumula a quantidade dos itens de arrecadação
						qtdeItemFaturadoLiquidoUN = qtdeItemFaturadoLiquidoUN
								+ ((Integer) dadosComparativos[12]);
						qtdeItemFaturadoLiquidoGR = qtdeItemFaturadoLiquidoGR
								+ ((Integer) dadosComparativos[12]);
						qtdeItemFaturadoLiquidoESTADO = qtdeItemFaturadoLiquidoESTADO
								+ ((Integer) dadosComparativos[12]);
					}*/
					
					if(localidadeValorPagamento != null){
						BigDecimal valorPagamentoAux = localidadeValorPagamento.get(idLocalidade);
						if(valorPagamentoAux != null && !valorPagamentoAux.equals("")){
						  valorPagamento = valorPagamentoAux;
						}
					}
					
					if(localidadeValorPagamentoHistorico != null){
						BigDecimal valorPagamentoHistoricoAux = localidadeValorPagamentoHistorico.get(idLocalidade);
						if(valorPagamentoHistoricoAux != null && !valorPagamentoHistoricoAux.equals("")){
						  valorPagamentoHistorico = valorPagamentoHistoricoAux;
						}
					}
						
					
					//adiciona o valor de pagamento expurgado com o valor do pagamento historico expurgado
					valorPagamentoExpurgado = valorPagamento.add(valorPagamentoHistorico);
					// subtrai o valor dos itens de arrecadação com os valores de pagamnetos expurgados
					valorArrecadacaoPagamento = valorItemArrecadacao.subtract(valorPagamentoExpurgado);
					
					// acumula os valores dos pagamentos e pagamentos historicos expurgados
					valorPagamentoExpurgadoUN = valorPagamentoExpurgadoUN.add(valorPagamentoExpurgado);
					valorPagamentoExpurgadoGR = valorPagamentoExpurgadoGR.add(valorPagamentoExpurgado);
					valorPagamentoExpurgadoESTADO = valorPagamentoExpurgadoESTADO.add(valorPagamentoExpurgado);
					
					// acumula os valores de arrecadação menos os pagamentos expurgados
					valorArrecadacaoPagamentoUN = valorArrecadacaoPagamentoUN.add(valorArrecadacaoPagamento);
					valorArrecadacaoPagamentoGR = valorArrecadacaoPagamentoGR.add(valorArrecadacaoPagamento);
					valorArrecadacaoPagamentoESTADO = valorArrecadacaoPagamentoESTADO.add(valorArrecadacaoPagamento);
					
					

				}
                			
				RelatorioComparativoFatArrecExpurgoBean relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
						nomeUnidadeNegocioRelatorio,
						nomeGerenciaRegionalRelatorio,codigoCentroCusto,
						nomeLocalidade,
						valorItemFaturado,
						valorItemFaturadoLiquido,
						valorItemArrecadacao.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacao),
						valorItemFaturadoBruto.compareTo(new BigDecimal("0.00")) == 0 ?"0,00":Util.formatarMoedaReal(valorItemFaturadoBruto),
						valorItemCancelados.compareTo(new BigDecimal("0.00")) == 0 ?"0,00":Util.formatarMoedaReal(valorItemCancelados),								
						valorPagamentoExpurgado.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgado),
						valorArrecadacaoPagamento.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamento),
						qtdeItemFaturado,	
						qtdeItemArrecadacao, 
						qtdeItemFaturadoLiquido);
								
				
				nomeUnidadeNegocioRelatorio = "";
				nomeGerenciaRegionalRelatorio = "";
				
				if(dadosComparativos[9] != null){
					BigDecimal faturadoLiquido = (BigDecimal) dadosComparativos[9];
					
					if( faturadoLiquido.compareTo(new BigDecimal("0.00")) == 1 ){
						percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacao,faturadoLiquido)).multiply(new BigDecimal("100.00"));
						relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
					}else{
						relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("0,0");	
					}
					
					
				}		
				
				if(dadosComparativos[7] != null){
					BigDecimal faturado = (BigDecimal) dadosComparativos[7];
					
					if( faturado.compareTo(new BigDecimal("0.00")) == 1 ){
						percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacao,faturado)).multiply(new BigDecimal("100.00"));
						relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
					}else{
						relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("0,0");	
					}
				}
				
				
				// adiciona no bean a coleção
				colecaoComparativoFatArrecExpurgoBean.add(relatorioComparativoFatArrecExpurgoBean);
			}
			//UNIDADE DE NEGÓCIO
			//cria uma linha com os acumulativos da gerência regional
			RelatorioComparativoFatArrecExpurgoBean relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
					"TOTAL DA UNIDADE",
					"","",
					"",
					valorItemFaturadoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoUN),
					valorItemFaturadoLiquidoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoLiquidoUN),
					valorItemArrecadacaoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacaoUN),
					valorItemFaturadoBrutoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoUN),
					valorItemCanceladosUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosUN),
					valorPagamentoExpurgadoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgadoUN),
					valorArrecadacaoPagamentoUN.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamentoUN),
					qtdeItemFaturadoUN.toString(),	
					qtdeItemArrecadacaoUN.toString(),
					qtdeItemFaturadoLiquidoUN.toString());		
							
			BigDecimal percentualFaturadoArrecadado = null;
			BigDecimal percentualFaturadoEmContaArrecadado = null;
			
			if(valorItemFaturadoLiquidoUN.compareTo(new BigDecimal("0.00")) != 0){
				percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoUN,valorItemFaturadoLiquidoUN)).multiply(new BigDecimal("100.00"));
				relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
			}else{
				relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
			}			
			
			if(valorItemFaturadoUN.compareTo(new BigDecimal("0.00")) != 0){
				percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoUN,valorItemFaturadoUN)).multiply(new BigDecimal("100.00"));
				relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
			}else{
				relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
			}
			
			
			// adiciona no bean a coleção
			colecaoComparativoFatArrecExpurgoBean.add(relatorioComparativoFatArrecExpurgoBean);
			
			if(idUnidadeNegocio == null || idUnidadeNegocio.equals("")){
				
				// GERÊNCIA REGIONAL
				// cria uma linha com os acumulativos da gerência
				// regional
				relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
						"",
						"TOTAL DA GERÊNCIA",
						"",
						"",
						valorItemFaturadoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoGR),
						valorItemFaturadoLiquidoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoLiquidoGR),		
						valorItemArrecadacaoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemArrecadacaoGR),
						valorItemFaturadoBrutoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoGR),
						valorItemCanceladosGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosGR),		
						valorPagamentoExpurgadoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorPagamentoExpurgadoGR),
						valorArrecadacaoPagamentoGR.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorArrecadacaoPagamentoGR),
						qtdeItemFaturadoGR.toString(),	
						qtdeItemArrecadacaoGR.toString(),
						qtdeItemFaturadoLiquidoGR.toString());		
				
				if(valorItemFaturadoLiquidoGR.compareTo(new BigDecimal("0.00")) != 0){
					percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoGR,valorItemFaturadoLiquidoGR)).multiply(new BigDecimal("100.00"));
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
				}else{
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
				}		
				
				if(valorItemFaturadoGR.compareTo(new BigDecimal("0.00")) != 0){
					percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoGR,valorItemFaturadoGR)).multiply(new BigDecimal("100.00"));
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
				}else{
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
				}
				
				
				// adiciona no bean a coleção
				colecaoComparativoFatArrecExpurgoBean
						.add(relatorioComparativoFatArrecExpurgoBean);
			}
			
			if ((idGerenciaRegional == null || idGerenciaRegional.equals(""))
					&& (idUnidadeNegocio == null || idUnidadeNegocio.equals(""))) {
				
				// ESTADO
				// cria uma linha com os acumulativos do estado
				relatorioComparativoFatArrecExpurgoBean = new RelatorioComparativoFatArrecExpurgoBean(
						"",
						"TOTAL DO ESTADO",
						"",
						"",
						valorItemFaturadoESTADO.compareTo(new BigDecimal("0.00")) == 0 ? ""	: Util.formatarMoedaReal(valorItemFaturadoESTADO),
						valorItemFaturadoLiquidoESTADO.compareTo(new BigDecimal("0.00")) == 0 ? ""	: Util.formatarMoedaReal(valorItemFaturadoLiquidoESTADO),
						valorItemArrecadacaoESTADO.compareTo(new BigDecimal("0.00")) == 0 ? "" : Util.formatarMoedaReal(valorItemArrecadacaoESTADO),
						valorItemFaturadoBrutoESTADO.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemFaturadoBrutoESTADO),
						valorItemCanceladosESTADO.compareTo(new BigDecimal("0.00")) == 0 ?"":Util.formatarMoedaReal(valorItemCanceladosESTADO),
						valorPagamentoExpurgadoESTADO.compareTo(new BigDecimal("0.00")) == 0 ? "" : Util.formatarMoedaReal(valorPagamentoExpurgadoESTADO),
						valorArrecadacaoPagamentoESTADO.compareTo(new BigDecimal("0.00")) == 0 ? "" : Util.formatarMoedaReal(valorArrecadacaoPagamentoESTADO),
						qtdeItemFaturadoESTADO.toString(),	
						qtdeItemArrecadacaoESTADO.toString(),
						qtdeItemFaturadoLiquidoESTADO.toString());		
				
				if(valorItemFaturadoLiquidoESTADO.compareTo(new BigDecimal("0.00")) != 0){
					percentualFaturadoArrecadado = (Util.dividirArredondando(valorItemArrecadacaoESTADO,valorItemFaturadoLiquidoESTADO)).multiply(new BigDecimal("100.00"));
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido(Util.formatarMoedaReal(percentualFaturadoArrecadado));
				}else{
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturadoLiquido("");
				}							
				
				if(valorItemFaturadoESTADO.compareTo(new BigDecimal("0.00")) != 0){
					percentualFaturadoEmContaArrecadado = (Util.dividirArredondando(valorItemArrecadacaoESTADO,valorItemFaturadoESTADO)).multiply(new BigDecimal("100.00"));
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta(Util.formatarMoedaReal(percentualFaturadoEmContaArrecadado));
				}else{
					relatorioComparativoFatArrecExpurgoBean.setPercentualArrecadadoFaturamentoEmConta("");
				}
				
				// adiciona no bean a coleção
				colecaoComparativoFatArrecExpurgoBean
						.add(relatorioComparativoFatArrecExpurgoBean);
			}

			
			
		}else{
			throw new ControladorException("atencao.tabela_sem_dados_comparativo");
		}
		return colecaoComparativoFatArrecExpurgoBean;
	}
	
	
	/**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 14/01/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public int pesquisarQuantidadeDadosComparativosFaturamentoArrecadacaoExpurgo(Integer anoMesReferencia,
			String idGerenciaRegional,String idUnidadeNegocio)
			throws ControladorException{
		try {
			List colecaoDadosComparativos = (List)repositorioArrecadacao.pesquisarDadosComparativosFaturamentoArrecadacaoExpurgo(anoMesReferencia,
					idGerenciaRegional,idUnidadeNegocio);
			
			if(colecaoDadosComparativos!= null && !colecaoDadosComparativos.isEmpty()){
				return colecaoDadosComparativos.size();
			}
			return 0;
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

     /**
     * [UC0254] - Efetuar Análise do Movimento dos Arrecadadores
     * Autor: Vivianne Sousa
     * Data: 28/01/2008
     * 
     */
    public RegistroHelperCodigoW distribuirdadosRegistroWMovimentoArrecadador(
            String conteudoMovimento) throws ControladorException {
        
        RegistroHelperCodigoW registroHelperCodigoW = new RegistroHelperCodigoW();
        
        registroHelperCodigoW.setCodigoBancoCompensacao(conteudoMovimento.substring(0, 3).trim());
        
        registroHelperCodigoW.setLoteServico(conteudoMovimento.substring(3, 7).trim());
            
        registroHelperCodigoW.setCodigoRegistro(conteudoMovimento.substring(7, 8).trim());
            
        registroHelperCodigoW.setNumeroSequencialRegLote(conteudoMovimento.substring(8, 13).trim());
            
        registroHelperCodigoW.setCodigoMovimento(conteudoMovimento.substring(13, 15).trim());
            
        registroHelperCodigoW.setAgenciaMantedoraConta(conteudoMovimento.substring(15, 20).trim());
            
        registroHelperCodigoW.setDigitoVerificadorAgencia(conteudoMovimento.substring(20, 21).trim());
            
        registroHelperCodigoW.setNumeroContaCorrente(conteudoMovimento.substring(21, 33).trim());
            
        registroHelperCodigoW.setDigitoVerificadorConta(conteudoMovimento.substring(33, 34).trim());
            
        registroHelperCodigoW.setDigitoVerificadorAgConta(conteudoMovimento.substring(34, 35).trim());
            
        registroHelperCodigoW.setNossoNumero(conteudoMovimento.substring(35, 55).trim());
            
        registroHelperCodigoW.setNumeroDocCobranca(conteudoMovimento.substring(55, 70).trim());
            
        registroHelperCodigoW.setDataVencimentoTitulo(conteudoMovimento.substring(70, 78).trim());
            
        registroHelperCodigoW.setValorNominalTitulo(conteudoMovimento.substring(78, 93).trim());
            
        registroHelperCodigoW.setValorPagoSacado(conteudoMovimento.substring(93, 108).trim());
            
        registroHelperCodigoW.setDataOcorrencia(conteudoMovimento.substring(108, 116).trim());
            
        registroHelperCodigoW.setDataEfetivacaoCredito(conteudoMovimento.substring(116, 124).trim());
            
            
        return registroHelperCodigoW;
    }
	/**
	 * [UCXXX] Pesquisar GuiaDevolucao
	 * 
	 * @author Roberto Barbalho
	 * @data 25/01/2008
	 * 
	 * @param guiaDevolucaoId
	 * @return GuiaDevolucao
	 */
	public GuiaDevolucao pesquisarGuiaDevolucao(Integer guiaDevolucaoId)
			throws ControladorException{
		try {
			return  repositorioArrecadacao.pesquisarGuiaDevolucao(guiaDevolucaoId); 
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
    
    /**
     * [UC0270] Apresentar Análise do Movimento dos Arrecadadores
     * 
     * O sistema captura os dados referentes ao conteúdo do do código de barras
     * 
     * [SB0004] Apresentar Dados do Conteúdo do Código de Barras da Ficha de Compensação
     * 
     * @author Vivianne Sousa
     * @data 29/01/2008
     * 
     * @param registroHelperCodigoW
     * @return DadosConteudoCodigoBarrasHelper
     */
    public DadosConteudoCodigoBarrasHelper apresentarDadosConteudoCodigoBarrasFichaCompensacao(
            RegistroHelperCodigoW registroHelperCodigoW)
            throws ControladorException {

        DadosConteudoCodigoBarrasHelper retorno = new DadosConteudoCodigoBarrasHelper();
        
        BigDecimal valorPagamento = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
        registroHelperCodigoW.getValorPagoSacado());
        
        String nossoNumeroSemDV = registroHelperCodigoW.getNossoNumero().substring(0,17);
        Integer tipoDocumento = new Integer(nossoNumeroSemDV.substring(7,9));
        String idDocumento = nossoNumeroSemDV.substring(9,17);
        
        if(tipoDocumento.equals(DocumentoTipo.CONTA)){
        	
        	Conta conta = getControladorFaturamento().obterImovelLocalidadeConta(new Integer(idDocumento));
            
            if (conta != null){
                //id da Localidade
                retorno.setCodigoLocalidade(conta.getLocalidade().getId().toString());

                //matrícula do imóvel
                retorno.setMatriculaImovel(conta.getImovel().getId().toString());

                //mês e ano de referência da conta
                retorno.setMesAnoReferenciaConta(conta.getReferenciaFormatada());
            }
            else{
                ContaHistorico contaHistorico = getControladorFaturamento().
                    obterImovelLocalidadeContaHistorico(new Integer(idDocumento));
                
                if (contaHistorico != null){
                    //id da Localidade
                    retorno.setCodigoLocalidade(contaHistorico.getLocalidade().getId().toString());

                    //matrícula do imóvel
                    retorno.setMatriculaImovel(contaHistorico.getImovel().getId().toString());

                    //mês e ano de referência da conta
                    retorno.setMesAnoReferenciaConta(contaHistorico.getFormatarAnoMesParaMesAno());
                }
            }
            
            //tipo de pagamento
            retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);
        }
        else if (tipoDocumento.equals(DocumentoTipo.EXTRATO_DE_DEBITO) || 
        		tipoDocumento.equals(DocumentoTipo.VISITA_COBRANCA) ||
        		tipoDocumento.equals(DocumentoTipo.ORDEM_CORTE)){
        	
        	CobrancaDocumento cobrancaDocumento = null ;
            
        	try {
        		cobrancaDocumento = repositorioArrecadacao.pesquisarCobrancaDocumentoProcessarFichaCompensacao(new Integer(idDocumento));
            } 
        	catch (ErroRepositorioException e) {
                throw new ControladorException("erro.sistema", e);
            }
        	
        	if (cobrancaDocumento != null){
        		
        		if (cobrancaDocumento.getImovel() != null){
        			
        			retorno.setMatriculaImovel(cobrancaDocumento.getImovel().getId().toString());
        		}
        		else{
        			
        			retorno.setCodigoCliente(cobrancaDocumento.getCliente().getId().toString());
        		}
        		
        		retorno.setSequencialDocumentoCobranca(cobrancaDocumento.getId().toString());
    			
    			retorno.setCodigoTipoDocumento(tipoDocumento.toString());
        	}
        	
        	//tipo de pagamento
            retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
        }
        
        
        Date dataVencimentoMais15 = Util.adicionarNumeroDiasDeUmaData(new Date(),15);
        String fatorVencimento = getControladorFaturamento().obterFatorVencimento(dataVencimentoMais15);
        
        String especificacaoCodigoBarra = obterEspecificacaoCodigoBarraFichaCompensacao(
                    ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO, 
                    ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO, 
                    valorPagamento, nossoNumeroSemDV.toString(),
                    ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO, fatorVencimento);
        
        String digitoVerificador = especificacaoCodigoBarra.substring(4,5);
        
//        String representacaoNumericaCodigoBarraFichaCompensacao = 
//            obterRepresentacaoNumericaCodigoBarraFichaCompensacao(especificacaoCodigoBarra);
        
        //código do banco
        retorno.setCodigoBanco(ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO);
        
        //código da moeda
        retorno.setCodigoMoeda(ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO);
        
        //dígito verificador geral
        retorno.setDigitoVerificadorGeral(digitoVerificador);
        
        //fator de vencimento
        retorno.setFatorVencimento(fatorVencimento);
        
        //valor do código de barras
        retorno.setValorCodigoBarras(Util.formatarMoedaReal(valorPagamento));
        
        //nosso número
        retorno.setNossoNumero(nossoNumeroSemDV);
        
        //tipo de carteira
        retorno.setTipoCarteira(ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO);
        
        return retorno;

    }
    
    
    /**
     * [UC0242] Registrar Movimento dos Arrecadadores
     * 
     * Atualiza o valor total do movimento (armv_vltotalmovimento) (tabela
     * ARRECADADOR_MOVIMENTO)
     * 
     * @author Vivianne Sousa
     * @date 31/01/2008
     * 
     * @param idArrecadadorMovimento
     * @param valorTotalMovimento
     * @return void
     */
    public void atualizarValorMovimentoArrecadadorMovimento(
            Integer idArrecadadorMovimento, BigDecimal valorTotalMovimento)  throws ControladorException {

        try {
            repositorioArrecadacao.atualizarValorMovimentoArrecadadorMovimento(
                    idArrecadadorMovimento, valorTotalMovimento);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema", e);
        }

    }
    
    /**
     * [UC0737] Atualiza Quantidade de Parcela Paga Consecutiva e Parcela Bônus
     * 
     * @author Vivianne Sousa
     * @data 01/02/2008
     * 
     * @param idConta
     * @return dataPagamento
     */
    public Date pesquisarDataPagamentoDeConta(Integer idConta)
            throws ControladorException{
        
        try {
            return repositorioArrecadacao.pesquisarDataPagamentoDeConta(idConta);
        } catch (ErroRepositorioException e) {
            throw new ControladorException("erro.sistema", e);
        }  
        
    }
    
    /**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 17/02/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Map<Integer,BigDecimal> criarMapPagamentoExpurgado(Collection colecaoPagamento){
		Map<Integer,BigDecimal> localidadeValorPagamento = null;
		if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
			localidadeValorPagamento = new HashMap();
			Iterator ite = colecaoPagamento.iterator();
			while(ite.hasNext()){
				Object[] dadosObjetos = (Object[])ite.next();
				
				if(dadosObjetos != null && dadosObjetos[0] != null && dadosObjetos[1] != null){
				 localidadeValorPagamento.put((Integer)dadosObjetos[0],(BigDecimal)dadosObjetos[1]);	
				}
				
				
			}
		}
		return localidadeValorPagamento;
	}
	
    /**
	 * [UC0744] Gerar Comparativo do Faturamento, Arrecadação e Expurgo
	 * 
	 * @author Sávio Luiz
	 * @data 17/02/2008
	 * 
	 * @param idConta
	 * @return idParcelamento
	 */
	public Map<Integer,BigDecimal> criarMapPagamentoHistoricoExpurgado(Collection colecaoPagamento){
		Map<Integer,BigDecimal> localidadeValorPagamentoHistorico = null;
		if(colecaoPagamento != null && !colecaoPagamento.isEmpty()){
			localidadeValorPagamentoHistorico = new HashMap();
			Iterator ite = colecaoPagamento.iterator();
			while(ite.hasNext()){
				Object[] dadosObjetos = (Object[])ite.next();
				
				if(dadosObjetos != null && dadosObjetos[0] != null && dadosObjetos[1] != null){
					localidadeValorPagamentoHistorico.put((Integer)dadosObjetos[0],(BigDecimal)dadosObjetos[1]);	
				}
				
				
			}
		}
		return localidadeValorPagamentoHistorico;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 * Quando for verificar a existência da conta, pesquisar também  no respectivo histórico no fluxo secundário
	 *  [FS0008 - Verificar existência da conta]
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2008
	 *
	 * @param colecaoConta
	 * @param idLocalidade
	 */
	public ContaGeral verificarLocalidadeContaGuiaDevolucao(Collection colecaoConta, String idLocalidade)
		throws ControladorException {
		
		ContaGeral contaGeral = null;
		
		/*
		 * Caso a conta esteja cadastrada no sistema. Seta todas as informações da conta no form.
		 * Caso contrário: Seta as informações da conta para nulo e indica ao usuário que não existe conta para 
		 * o imóvel informado com a referência indicada. 
		 */
		if (colecaoConta != null && !colecaoConta.isEmpty()) {
			
			contaGeral = new ContaGeral();

			//Recupera a conta do imóvel com a referência informada
			Object objetoConta = colecaoConta.iterator().next();
			Localidade localidadeConta = null;
			Imovel imovelConta = null;
			
			if (objetoConta instanceof Conta) {
				
				Conta conta = (Conta) objetoConta;
				contaGeral.setId(conta.getId());
				contaGeral.setConta(conta);
				localidadeConta = conta.getLocalidade();
				imovelConta = conta.getImovel();
			}
			else{
				
				ContaHistorico contaHistorico = (ContaHistorico) objetoConta;
				contaGeral.setId(contaHistorico.getId());
				contaGeral.setContaHistorico(contaHistorico);
				localidadeConta = contaHistorico.getLocalidade();
				imovelConta = contaHistorico.getImovel();
			}
			
			// [FS0009] - Verificar localidade da conta
			if (!idLocalidade.equals(localidadeConta.getId().toString())) {
				
				throw new ControladorException("atencao.imovel.localidade.diferente.conta.localidade",
				null, localidadeConta.getId().toString(), idLocalidade, imovelConta.getId().toString());
			} 
			
		}
		
		return contaGeral;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2008
	 *
	 * @param imovel
	 * @param anoMesReferencia
	 * @return Collection
	 */
	public Collection pesquisarContaParaGuiaDevolucao(Imovel imovel, Integer anoMesReferencia) 
		throws ControladorException{
		
		//Recupera a conta do imóvel com a referência informada
		FiltroConta filtroConta = new FiltroConta();
		
		//PARÂMETROS IMÓVEL E ANOMESREFERENCIA
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.IMOVEL_ID, imovel.getId()));
		filtroConta.adicionarParametro(new ParametroSimples(FiltroConta.REFERENCIA, anoMesReferencia));
		
		filtroConta.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroConta.adicionarCaminhoParaCarregamentoEntidade("imovel");

		Collection colecaoConta = getControladorUtil().pesquisar(filtroConta,Conta.class.getName());
		
		if (colecaoConta == null || colecaoConta.isEmpty()){
			
			//Recupera a conta do imóvel com a referência informada na tabela de histórico
			FiltroContaHistorico filtroContaHistorico = new FiltroContaHistorico();
			
			//PARÂMETROS IMÓVEL E ANOMESREFERENCIA
			filtroContaHistorico.adicionarParametro(new ParametroSimples(
			FiltroContaHistorico.IMOVEL_ID, imovel.getId()));
			filtroContaHistorico.adicionarParametro(new ParametroSimples(
			FiltroContaHistorico.ANO_MES_REFERENCIA, anoMesReferencia));
			
			filtroContaHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroContaHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			
			colecaoConta = getControladorUtil().pesquisar(filtroContaHistorico,ContaHistorico.class.getName());
		}
		
		if (colecaoConta == null || colecaoConta.isEmpty()){
			
			throw new ControladorException("atencao.pesquisa_inexistente", null, "CONTA");
		}
		
		return colecaoConta;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 * [FS0018] - Verificar valor da devolução
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2008
	 *
	 * @param contaGeral
	 * @return BigDecimal
	 * @throws ControladorException
	 */
	public BigDecimal verificarValorDevolucao(ContaGeral contaGeral, DebitoACobrarGeral debitoACobrarGeral,
			GuiaPagamentoGeral guiaPagamentoGeral) throws ControladorException{
		
		BigDecimal valorLimite = BigDecimal.ZERO;
		
		/*
		 * Faz uma pesquisa em pagamento para somar o valor de todos os pagamentos associados a conta,
		 * depois subtraí-lo do valor total da conta. 
		 */
		
		//PAGAMENTO
		FiltroPagamento filtroPagamento = new FiltroPagamento();
		
		if (contaGeral != null){
			
			if (contaGeral.getConta() != null){
				
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, 
				contaGeral.getConta().getImovel().getId()));
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO, 
				contaGeral.getConta().getReferencia()));
				
			}
			else{
				
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.IMOVEL_ID, 
				contaGeral.getContaHistorico().getImovel().getId()));
				filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ANO_MES_REFERENCIA_PAGAMENTO, 
				contaGeral.getContaHistorico().getAnoMesReferenciaConta()));
			}
			
		}
		
		if (debitoACobrarGeral != null){
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.DEBITO_A_COBRAR, 
			debitoACobrarGeral.getId()));
		}
		
		if (guiaPagamentoGeral != null){
			filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.GUIA_PAGAMENTO_ID,
			guiaPagamentoGeral.getId()));
		}

		Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento,
		Pagamento.class.getName());
		
		if (colecaoPagamento != null && !colecaoPagamento.isEmpty()){
			
			Iterator colecaoPagamentoIterator = colecaoPagamento.iterator();

			while (colecaoPagamentoIterator.hasNext()) {
				
				Pagamento pagamento = (Pagamento) colecaoPagamentoIterator.next();
		
				valorLimite = valorLimite.add(pagamento.getValorPagamento());
			}
		}
		
		
		//PAGAMENTO_HISTORICO
		FiltroPagamentoHistorico filtroPagamentoHistorico = new FiltroPagamentoHistorico();
		
		if (contaGeral != null){
			
			if (contaGeral.getConta() != null){
				
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
				FiltroPagamentoHistorico.IMOVEL_ID, contaGeral.getConta().getImovel().getId()));
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
				FiltroPagamentoHistorico.ANO_MES_REFERENCIA_PAGAMENTO, contaGeral.getConta().getReferencia()));
				
			}
			else{
				
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
				FiltroPagamentoHistorico.IMOVEL_ID, contaGeral.getContaHistorico().getImovel().getId()));
				filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
				FiltroPagamentoHistorico.ANO_MES_REFERENCIA_PAGAMENTO, contaGeral.getContaHistorico()
				.getAnoMesReferenciaConta()));
			}
			
		}
		
		if (debitoACobrarGeral != null){
			filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(
			FiltroPagamentoHistorico.DEBITO_A_COBRAR_ID, debitoACobrarGeral.getId()));
		}
		
		if (guiaPagamentoGeral != null){
			filtroPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroPagamentoHistorico.GUIA_PAGAMENTO_ID,
			guiaPagamentoGeral.getId()));
		}
	
		Collection colecaoPagamentoHistorico = getControladorUtil().pesquisar(filtroPagamentoHistorico,
		PagamentoHistorico.class.getName());
		
		if (colecaoPagamentoHistorico != null && !colecaoPagamentoHistorico.isEmpty()){
			
			Iterator colecaoPagamentoHistoricoIterator = colecaoPagamentoHistorico.iterator();

			while (colecaoPagamentoHistoricoIterator.hasNext()) {
				
				PagamentoHistorico pagamentoHistorico = (PagamentoHistorico) 
				colecaoPagamentoHistoricoIterator.next();
		
				valorLimite = valorLimite.add(pagamentoHistorico.getValorPagamento());
			}
		}
		
		if (valorLimite.compareTo(BigDecimal.ZERO) == 1){
			
			if (contaGeral != null){
			
				if (contaGeral.getConta() != null){
					
					valorLimite = valorLimite.subtract(contaGeral.getConta().getValorTotal());
				}
				else{
					
					valorLimite = valorLimite.subtract(contaGeral.getContaHistorico().getValorTotal());
				}
			}
			
			if (debitoACobrarGeral != null){
				
				if (debitoACobrarGeral.getDebitoACobrar() != null){
					
					valorLimite = valorLimite.subtract(debitoACobrarGeral.getDebitoACobrar().getValorTotal());
				}
				else{
					
					valorLimite = valorLimite.subtract(debitoACobrarGeral.getDebitoACobrarHistorico().getValorTotal());
				}
			}
			
			if (guiaPagamentoGeral != null){
				
				if (guiaPagamentoGeral.getGuiaPagamento() != null){
					
					valorLimite = valorLimite.subtract(guiaPagamentoGeral.getGuiaPagamento().getValorDebito());
				}
				else{
					
					valorLimite = valorLimite.subtract(guiaPagamentoGeral.getGuiaPagamentoHistorico().getValorDebito());
				}
			}
			
			
			//GUIA_DEVOLUCAO
			FiltroGuiaDevolucao filtroGuiaDevolucao = new FiltroGuiaDevolucao();

			if (contaGeral != null){
				
				if (contaGeral.getConta() != null){
					
					filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
					FiltroGuiaDevolucao.IMOVEL_ID, contaGeral.getConta().getImovel().getId()));
					filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
					FiltroGuiaDevolucao.ANO_MES_REFERENCIA_GUIA_DEVOLUCAO, contaGeral.getConta().getReferencia()));
					
				}
				else{
					
					filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
					FiltroGuiaDevolucao.IMOVEL_ID, contaGeral.getContaHistorico().getImovel().getId()));
					filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
					FiltroGuiaDevolucao.ANO_MES_REFERENCIA_GUIA_DEVOLUCAO, contaGeral.getContaHistorico()
					.getAnoMesReferenciaConta()));
				}
				
			}
			
			if (debitoACobrarGeral != null){
				filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
				FiltroGuiaDevolucao.DEBITO_A_COBRAR_ID, debitoACobrarGeral.getId()));
			}
			
			if (guiaPagamentoGeral != null){
				filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
				FiltroGuiaDevolucao.GUIA_PAGAMENTO_ID, guiaPagamentoGeral.getId()));
			}
			
			filtroGuiaDevolucao.adicionarParametro(new ParametroSimples(
			FiltroGuiaDevolucao.DEBITO_CREDITO_SITUACAO_ATUAL_ID, DebitoCreditoSituacao.NORMAL));

			Collection colecaoGuiaDevolucao = getControladorUtil().pesquisar(filtroGuiaDevolucao,
			GuiaDevolucao.class.getName());

			if (colecaoGuiaDevolucao != null && !colecaoGuiaDevolucao.isEmpty()) {

				Iterator colecaoGuiaDevolucaoIterator = colecaoGuiaDevolucao.iterator();

				while (colecaoGuiaDevolucaoIterator.hasNext()) {
					
					GuiaDevolucao guia = (GuiaDevolucao) colecaoGuiaDevolucaoIterator.next();
					
					valorLimite = valorLimite.subtract(guia.getValorDevolucao());
				}
			}
		}
		else{
			
			if (contaGeral != null){
				
				if (contaGeral.getConta() != null){
					
					throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados",
					null, "Conta " + Util.formatarAnoMesParaMesAno(contaGeral.getConta().getReferencia()) + " ");
				}
				throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados",
				null, "Conta " + Util.formatarAnoMesParaMesAno(contaGeral.getContaHistorico().getAnoMesReferenciaConta()) + " ");
				
			}
			
			if (debitoACobrarGeral != null){
				
				throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados",
				null, "Débito a Cobrar " + debitoACobrarGeral.getId().toString() + " ");
				
			}
			
			if (guiaPagamentoGeral != null){
				
				throw new ControladorException("atencao.tipo.documento.sem.pagamentos.associados",
				null, "Guia Pagamento " + guiaPagamentoGeral.getId().toString() + " ");
			}
			
		}
		 
		
		return valorLimite;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2008
	 *
	 * @param imovel
	 * @param idDebitoACobrar
	 * @return Collection
	 */
	public Collection pesquisarDebitoACobrarParaGuiaDevolucao(Imovel imovel, Integer idDebitoACobrar) 
		throws ControladorException{
		
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, imovel.getId()));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
		
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
		
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(
		filtroDebitoACobrar, DebitoACobrar.class.getName());
		
		if (colecaoDebitoACobrar == null || colecaoDebitoACobrar.isEmpty()){
			
			FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
			
			filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
			FiltroDebitoACobrarHistorico.IMOVEL_ID, imovel.getId()));
			filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
			FiltroDebitoACobrarHistorico.ID, idDebitoACobrar));
			
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			
			colecaoDebitoACobrar = getControladorUtil().pesquisar(
			filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());
		}
		
		if (colecaoDebitoACobrar == null || colecaoDebitoACobrar.isEmpty()){
			
			throw new ControladorException("atencao.pesquisa_inexistente", null, "DÉBITO A COBRAR");
		}
		
		return colecaoDebitoACobrar;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 * 
	 * [FS0014] - Verificar imóvel do débito a cobrar
	 * 
	 * [FS0015] - Verificar localidade do débito a cobrar
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2008
	 *
	 * @param idImovel
	 * @param idLocalidade
	 * @param ordemServico
	 * @param debitoACobrar
	 */
	public DebitoACobrarGeral verificarDebitoACobrarParaGuiaDevolucao(Collection colecaoDebitoACobrar, Integer idImovel, 
		Integer idLocalidade, OrdemServico ordemServico) throws ControladorException {
		
		DebitoACobrarGeral debitoACobrarGeral = null;
		
		if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {
			
			debitoACobrarGeral = new DebitoACobrarGeral();

			Object objetoDebito = colecaoDebitoACobrar.iterator().next();
			Localidade localidadeDebito = null;
			Imovel imovelDebito = null;
			DebitoTipo debitoTipo = null;
			
			if (objetoDebito instanceof DebitoACobrar) {
				
				DebitoACobrar debitoACobrar = (DebitoACobrar) objetoDebito;
				debitoACobrarGeral.setId(debitoACobrar.getId());
				debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
				localidadeDebito = debitoACobrar.getLocalidade();
				imovelDebito = debitoACobrar.getImovel();
				debitoTipo = debitoACobrar.getDebitoTipo();
			}
			else{
				
				DebitoACobrarHistorico debitoACobrarHistorico = (DebitoACobrarHistorico) objetoDebito;
				debitoACobrarGeral.setId(debitoACobrarHistorico.getId());
				debitoACobrarGeral.setDebitoACobrarHistorico(debitoACobrarHistorico);
				localidadeDebito = debitoACobrarHistorico.getLocalidade();
				imovelDebito = debitoACobrarHistorico.getImovel();
				debitoTipo = debitoACobrarHistorico.getDebitoTipo();
			}
			
			//[FS0014] - Verificar imóvel do débito a cobrar
			if (!idImovel.equals(imovelDebito.getId())) {
				
				throw new ControladorException("atencao.imovel.debito.a.cobrar.diferente.registro.atendimento.imovel",
				null, imovelDebito.getId().toString(), idImovel.toString());
			} 
				
			// [FS0015] - Verificar localidade do débito a cobrar
			if (!idLocalidade.equals(localidadeDebito.getId())) {
					
				throw new ControladorException("atencao.imovel.localidade.diferente.debito.a.cobrar.localidade",
				null, localidadeDebito.getId().toString(), idLocalidade.toString(), idImovel.toString());
				
			}
			
			if (ordemServico != null &&
				ordemServico.getServicoTipo().getDebitoTipo() != null &&
				!debitoTipo.getId().equals(ordemServico.getServicoTipo().getDebitoTipo().getId())) {
				
				throw new ControladorException("atencao.debito.tipo.debito.a.cobrar.diferente.ordem.servico.debito.tipo",
				null, debitoTipo.getDescricao(),ordemServico.getServicoTipo().getDebitoTipo()
				.getDescricao());
					
			} 	
		}
		
		return debitoACobrarGeral;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 * @author Raphael Rossiter
	 * @date 15/04/2008
	 *
	 * @param idImovel
	 * @param idCliente
	 * @param idGuiaPagamento
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection pesquisarGuiaPagamentoParaGuiaDevolucao(Integer idImovel, Integer idCliente, 
			Integer idGuiaPagamento) throws ControladorException {

		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
		
		/*
		 * Caso o usuário tenha informado o imóvel, seta o código do imóvel no filtro.
		 * Caso contrário, o usuário tenha informado o cliente seta o código do cliente no filtro.
		 * Caso o usuário não tenha informado nem o imóvel nem o cliente levanta uma exceção
		 * para o usuário informando que tem de informar o cliente ou o imóvel
		 */
		if (idImovel != null) {
			
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
			FiltroGuiaPagamento.IMOVEL_ID, idImovel));
		} 
		else if (idCliente != null) {
			
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
			FiltroGuiaPagamento.CLIENTE_ID, idCliente));
		} 
		else {
			throw new ControladorException("atencao.naoinformado", null,
			"Imóvel ou Cliente");
		}
		
		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
		FiltroGuiaPagamento.ID, idGuiaPagamento));
		
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(
		filtroGuiaPagamento, GuiaPagamento.class.getName());
		
		if (colecaoGuiaPagamento == null || colecaoGuiaPagamento.isEmpty()){
			
			FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();
			
			/*
			 * Caso o usuário tenha informado o imóvel, seta o código do imóvel no filtro.
			 * Caso contrário, o usuário tenha informado o cliente seta o código do cliente no filtro.
			 * Caso o usuário não tenha informado nem o imóvel nem o cliente levanta uma exceção
			 * para o usuário informando que tem de informar o cliente ou o imóvel
			 */
			if (idImovel != null) {
				
				filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
				FiltroGuiaPagamentoHistorico.IMOVEL_ID, idImovel));
			} 
			else if (idCliente != null) {
				
				filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
				FiltroGuiaPagamentoHistorico.CLIENTE_ID, idCliente));
			} 
			else {
				throw new ControladorException("atencao.naoinformado", null,
				"Imóvel ou Cliente");
			}
			
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
			FiltroGuiaPagamentoHistorico.ID, idGuiaPagamento));
			
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("cliente");

			colecaoGuiaPagamento = getControladorUtil().pesquisar(
			filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());
		}
		
		if (colecaoGuiaPagamento == null || colecaoGuiaPagamento.isEmpty()){
			
			throw new ControladorException("atencao.pesquisa_inexistente", null, "GUIA DE PAGAMENTO");
		}
		
		return colecaoGuiaPagamento;
	}
	
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 * @author Raphael Rossiter
	 * @date 15/04/2008
	 *
	 * @param colecaoGuiaPagamento
	 * @param registroAtendimento
	 * @param idClienteRegistroAtendimento
	 * @param localidadeImovel
	 * @param ordemServico
	 * @return GuiaPagamentoGeral
	 * @throws ControladorException
	 */
	public GuiaPagamentoGeral verificarGuiaPagamentoParaGuiaDevolucao(Collection colecaoGuiaPagamento,
			RegistroAtendimento registroAtendimento, Integer idClienteRegistroAtendimento,
			Integer idLocalidadeImovel, OrdemServico ordemServico) throws ControladorException{
		
		GuiaPagamentoGeral guiaPagamentoGeral = null;
		
		if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {
			
			guiaPagamentoGeral = new GuiaPagamentoGeral();

			Object objetoGuia = colecaoGuiaPagamento.iterator().next();
			Localidade localidadeGuia = null;
			Imovel imovelGuia = null;
			Cliente clienteGuia = null;
			DebitoTipo debitoTipo = null;
			
			if (objetoGuia instanceof GuiaPagamento) {
				
				GuiaPagamento guiaPagamento = (GuiaPagamento) objetoGuia;
				guiaPagamentoGeral.setId(guiaPagamento.getId());
				guiaPagamentoGeral.setGuiaPagamento(guiaPagamento);
				localidadeGuia = guiaPagamento.getLocalidade();
				imovelGuia = guiaPagamento.getImovel();
				clienteGuia = guiaPagamento.getCliente();
				debitoTipo = guiaPagamento.getDebitoTipo();
			}
			else{
				
				GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) objetoGuia;
				guiaPagamentoGeral.setId(guiaPagamentoHistorico.getId());
				guiaPagamentoGeral.setGuiaPagamentoHistorico(guiaPagamentoHistorico);
				localidadeGuia = guiaPagamentoHistorico.getLocalidade();
				imovelGuia = guiaPagamentoHistorico.getImovel();
				clienteGuia = guiaPagamentoHistorico.getCliente();
				debitoTipo = guiaPagamentoHistorico.getDebitoTipo();
			}
			
			//[FS0011] - Verificar imóvel ou cliente da guia de pagamento
			if (registroAtendimento.getImovel() != null) {
				
				if (imovelGuia == null) {
					
					throw new ControladorException("atencao.guia.pagamento.imovel.inexistente", null);
				} 
				
				if (!registroAtendimento.getImovel().getId().equals(imovelGuia.getId())) {
					
					throw new ControladorException("atencao.imovel.guia.pagamento.diferente.registro.atendimento.imovel",
					null, imovelGuia.getId().toString(), registroAtendimento.getImovel().getId().toString());
				}
				
				if (idLocalidadeImovel == null){
					idLocalidadeImovel = registroAtendimento.getImovel().getLocalidade().getId();
				}
				
				if (!idLocalidadeImovel.equals(localidadeGuia.getId())) {
					
					throw new ControladorException("atencao.imovel.localidade.diferente.guia.pagamento.localidade",
					null, localidadeGuia.getId().toString(), idLocalidadeImovel.toString(),
					registroAtendimento.getImovel().getId().toString());
				}
			}
			
			if (idClienteRegistroAtendimento != null) {
				
				if (clienteGuia == null) {
					
					throw new ControladorException("atencao.guia.pagamento.cliente.inexistente", null);
				}
			
				if (!idClienteRegistroAtendimento.equals(clienteGuia.getId())) {
					
					throw new ControladorException("atencao.cliente.guia.pagamento.diferente.registro.atendimento.cliente",
					null, clienteGuia.getId().toString(), idClienteRegistroAtendimento.toString());
				}
			}
			
			
			if (ordemServico != null &&
				ordemServico.getServicoTipo().getDebitoTipo() != null &&
				!debitoTipo.getId().equals(ordemServico.getServicoTipo().getDebitoTipo().getId())) {
					
				throw new ControladorException("atencao.debito.tipo.guia.pagamento.diferente.ordem.servico.debito.tipo",
				null, debitoTipo.getDescricao(), ordemServico.getServicoTipo().getDebitoTipo().getDescricao());
						
			}
		}
		
		return guiaPagamentoGeral;
	}
	
	
	/**
	 * [UC0352] Emitir Conta
	 * 
	 * pesquisa o nome do banco e código da agencia passando o id do imóvel
	 * 
	 * [SB0017] - Gerar Linhas das contas com Débito Automático
	 * 
	 * @author Sávio Luiz
	 * @date 26/05/2006
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public Object[] pesquisarParmsDebitoAutomatico(Integer idImovel) throws ControladorException{
		
		Object[] parmsDebitoAutomatico = null;
		try {
			
			parmsDebitoAutomatico = repositorioArrecadacao
			.pesquisarParmsDebitoAutomatico(idImovel);
			
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		
		return parmsDebitoAutomatico;
	}
	

	

	
	/**
	 * [UC0823] Atualiza Ligação de Água de Ligado em Análise para Ligado.
	 * 
	 *  Este caso de uso permite atualizar a situação de água de ligado em análise para ligado.
	 * 	Este caso de uso deve ser processado após o encerramento da arrecadação.
	 * 
	 * @author Yara Taciane
	 * @date 04/06/2008
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */
	
	public List pesquisarLocalidadeComImoveisComSituacaoLigadoEmAnalise()
	throws ControladorException{		
		
		 List  retorno = getControladorImovel().pesquisarLocalidadeComImoveisComSituacaoLigadoEmAnalise();
		
		
		return retorno;
		
	}	
	
	
	/**
	 * [UC0823] Atualiza Ligação de Água de Ligado em Análise para Ligado.
	 * 
	 *  Este caso de uso permite atualizar a situação de água de ligado em análise para ligado.
	 * 	Este caso de uso deve ser processado após o encerramento da arrecadação.
	 * 
	 * @author Yara Taciane
	 * @date 04/06/2008
	 * 
	 * @return String
	 * @throws ErroRepositorioException
	 */
	public void atualizarLigacaoAguaLigadoAnaliseParaLigado(Integer idFuncionalidadeIniciada, Integer idLocalidade) throws ControladorException{
		
	
		// -------------------------
		//
		// Registrar o início do processamento da Unidade de
		// Processamento
		// do Batch
		//
		// -------------------------
		int idUnidadeIniciada = 0;
		idUnidadeIniciada = getControladorBatch()
				.iniciarUnidadeProcessamentoBatch(
						idFuncionalidadeIniciada,
						UnidadeProcessamento.LOCALIDADE,idLocalidade);
	
		Collection retorno = getControladorImovel().pesquisarImoveisComSituacaoLigadoEmAnalise(idLocalidade);
			
		  Iterator it = retorno.iterator();
		  while(it.hasNext()){			  
			  Imovel imovel = (Imovel)it.next();		
			  
			  int indicadorDebito = 1;
			  String idImovel = imovel.getId().toString();
			  String periodoReferenciaDebitoInicial = "000101";
			  String periodoReferenciaDebitoFinal = "999912";			  
			  Date periodoVencimentoDebitoInicial = Util.converteStringParaDate("01/01/0001");
			  SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();			  
			  Date periodoVencimentoDebitoFinal = Util.subtrairNumeroDiasDeUmaData(new Date(),getSistemaParametro().getNumeroDiasVencimentoCobranca() );
			  int indicadorPagamento = 2;
			  int indicadorConta = 1;
			  int indicadorDebitoACobrar = 1 ;
			  int indicadorCreditoARealizar = 1;
			  int indicadorNotasPromissorias = 1 ; 
			  int indicadorGuiasPagamento = 1;
			  int indicadorAtualizarDebito = 2;			 
			  
			  ObterDebitoImovelOuClienteHelper  obterDebitoImovelOuClienteHelper = getControladorCobranca().obterDebitoImovelOuCliente(
						indicadorDebito,idImovel, null,
						null,periodoReferenciaDebitoInicial ,
						periodoReferenciaDebitoFinal,
						periodoVencimentoDebitoInicial,
						periodoVencimentoDebitoFinal, indicadorPagamento,
						indicadorConta,indicadorDebitoACobrar,
						indicadorCreditoARealizar,indicadorNotasPromissorias,
						indicadorGuiasPagamento,
						indicadorAtualizarDebito,
						null);
			  
			  
			  	if((obterDebitoImovelOuClienteHelper.getColecaoContasValores()== null || obterDebitoImovelOuClienteHelper.getColecaoContasValores().size() == 0 )&&
			  	    (obterDebitoImovelOuClienteHelper.getColecaoContasValoresImovel()== null || obterDebitoImovelOuClienteHelper.getColecaoContasValoresImovel().size() == 0 )&&
			  		(obterDebitoImovelOuClienteHelper.getColecaoCreditoARealizar()== null || obterDebitoImovelOuClienteHelper.getColecaoCreditoARealizar().size() == 0 )&&
			  		(obterDebitoImovelOuClienteHelper.getColecaoDebitoACobrar()== null || obterDebitoImovelOuClienteHelper.getColecaoDebitoACobrar().size() == 0 )&&
			  		(obterDebitoImovelOuClienteHelper.getColecaoDebitoCreditoParcelamentoHelper()== null || obterDebitoImovelOuClienteHelper.getColecaoDebitoCreditoParcelamentoHelper().size() == 0 )&&
			  		(obterDebitoImovelOuClienteHelper.getColecaoGuiasPagamentoValores()== null || obterDebitoImovelOuClienteHelper.getColecaoGuiasPagamentoValores().size() == 0 )
			  	){		
			  		
			  		this.getControladorImovel().atualizarSituacaoAguaPorImovel(imovel.getId().toString(),LigacaoAguaSituacao.LIGADO.toString());	

			  	}else if ((obterDebitoImovelOuClienteHelper.getColecaoContasValores()!= null && obterDebitoImovelOuClienteHelper.getColecaoContasValores().size() == 1 )||
				  	     (obterDebitoImovelOuClienteHelper.getColecaoContasValoresImovel()!= null && obterDebitoImovelOuClienteHelper.getColecaoContasValoresImovel().size() == 1 )){
			  		
			  		this.getControladorImovel().atualizarSituacaoAguaPorImovel(imovel.getId().toString(),LigacaoAguaSituacao.LIGADO.toString());	
			  	}
			  
			  
		  }
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,idUnidadeIniciada, false);
	}
	
	
	

	/**
	 * Verificar se a entrada de um parcelamento foi paga
	 * @param idImovel
	 * @param dataParcelamento
	 * @return
	 * @throws ControladorException
	 * 
	 * @author Francisco do Nascimento
	 * @date 02/07/2008
	 */
	public boolean verificarExistenciaPagamentoEntradaParcelamento(Integer idImovel,
			Date dataParcelamento)
			throws ControladorException {

		// Cria a variável que vai armazenar o id da guia de pagamento, caso 
		// a entrada tem sido via guia de pagmento
		Integer idGuiaPagamento = null;
		boolean entradaParcelamentoPaga = false;

		// Pesquisar se existe guia de pagamento para este imovel, nesta da data, do tipo
		// de debito ENTRADA DE PARCELAMENTO
		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();

		if (idImovel != null && dataParcelamento != null) {
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.IMOVEL_ID, idImovel));
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.EMISSAO_GUIA_PAGAMENTO, dataParcelamento));
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamento.DEBITO_TIPO_ID, DebitoTipo.ENTRADA_PARCELAMENTO));
		} else {
			return false;
		}

		Collection colecaoGuiaPagamento = getControladorUtil().pesquisar(
				filtroGuiaPagamento, GuiaPagamento.class.getName());

		if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {
			GuiaPagamento guiaPagamento = (GuiaPagamento) Util
					.retonarObjetoDeColecao(colecaoGuiaPagamento);
			idGuiaPagamento = guiaPagamento.getId();
			
			// Caso exista a guia de pagamento, verificar se existe pagamento para esta
			if (idGuiaPagamento != null){
				Collection pagamentos;
				try {
					pagamentos = repositorioFaturamento.obterGuiasPagamentoPagamento(
							idGuiaPagamento);
				} catch (ErroRepositorioException e) {
					sessionContext.setRollbackOnly();
					throw new ControladorException("erro.sistema", e);
				}
				if (pagamentos != null && !pagamentos.isEmpty()){
					entradaParcelamentoPaga = true;
				}			
			}
			
		} else {
			// Caso nao exista , verificar se existe no historico uma guia de pagamento
			// para este imovel, nesta data, do tipo Entrada de parcelamento e
			// que esteja com a situacao NORMAL, caso haja... considerar ENTRADA PAGA!
			FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();

			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamentoHistorico.IMOVEL_ID, idImovel));
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamentoHistorico.EMISSAO_GUIA_PAGAMENTO, dataParcelamento));
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamentoHistorico.DEBITO_TIPO_ID, DebitoTipo.ENTRADA_PARCELAMENTO));
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
					FiltroGuiaPagamentoHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
					DebitoCreditoSituacao.NORMAL));					
			colecaoGuiaPagamento = getControladorUtil().pesquisar(
					filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());
			
			if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {
				entradaParcelamentoPaga = true;	
				GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) Util
					.retonarObjetoDeColecao(colecaoGuiaPagamento);
				idGuiaPagamento = guiaPagamentoHistorico.getId();				
			}
		}
		
		// Pesquisar contas
		if (idGuiaPagamento == null){
			
			try {
				entradaParcelamentoPaga = repositorioCobranca.exitePagamentoContaEntradaParcelamento(idImovel, dataParcelamento);
			} catch (ErroRepositorioException e) {
				sessionContext.setRollbackOnly();
				throw new ControladorException("erro.sistema", e);
			}
			
		}

		return entradaParcelamentoPaga;
	}
	
	
	/**
	 * [UC0826] Gerar Relatório Análise da Arrecação
	 * 
	 * @author Victor Cisneiros
	 * @date 24/07/2008
	 */
    public List<RelatorioAnaliseArrecadacaoBean> pesquisarAnaliseArrecadacao(
    		PesquisarAnaliseArrecadacaoHelper helper) throws ControladorException {
    	try {
    		List<RelatorioAnaliseArrecadacaoBean> retorno = repositorioArrecadacao.pesquisarAnaliseArrecadacao(helper);
    		
    		Fachada fachada = Fachada.getInstancia();
    		
    		if (helper.getPorFormaArrecadacao()) {
    			List<Integer> colecaoIds = new ArrayList<Integer>();
    			Map<Integer, List<RelatorioAnaliseArrecadacaoBean>> hashPorFormaArrecadacao = 
    				new HashMap<Integer, List<RelatorioAnaliseArrecadacaoBean>>();
    			
    			for (RelatorioAnaliseArrecadacaoBean bean : retorno) {
    				colecaoIds.add(bean.getIdFormaArrecadacao());
    				if (!hashPorFormaArrecadacao.containsKey(bean.getIdFormaArrecadacao())) {
    					hashPorFormaArrecadacao.put(
    							bean.getIdFormaArrecadacao(), new ArrayList<RelatorioAnaliseArrecadacaoBean>());
    				}
    				hashPorFormaArrecadacao.get(bean.getIdFormaArrecadacao()).add(bean);
    			}
    			
    			if (!colecaoIds.isEmpty()) {
					FiltroArrecadacaoForma filtro = new FiltroArrecadacaoForma();
					Collection<ArrecadacaoForma> pesquisa = fachada.pesquisar(colecaoIds, filtro, ArrecadacaoForma.class.getName());
					for (ArrecadacaoForma af : pesquisa) {
						for (RelatorioAnaliseArrecadacaoBean bean : hashPorFormaArrecadacao.get(af.getId())) {
							bean.setDescricaoFormaArrecadacao(af.getDescricao());
						}
					}
    			}
    		}
    		
    		if (helper.getPorArrecadador()) {
    			List<Integer> colecaoIds = new ArrayList<Integer>();
    			Map<Integer, List<RelatorioAnaliseArrecadacaoBean>> hashPorArrecadador = 
    				new HashMap<Integer, List<RelatorioAnaliseArrecadacaoBean>>();
    			
    			for (RelatorioAnaliseArrecadacaoBean bean : retorno) {
    				colecaoIds.add(bean.getIdArrecadador());
    				if (!hashPorArrecadador.containsKey(bean.getIdArrecadador())) {
    					hashPorArrecadador.put(
    							bean.getIdArrecadador(), new ArrayList<RelatorioAnaliseArrecadacaoBean>());
    				}
    				hashPorArrecadador.get(bean.getIdArrecadador()).add(bean);
    			}
    			
    			if (!colecaoIds.isEmpty()) {
					FiltroCliente filtro = new FiltroCliente();
					Collection<Cliente> pesquisa = fachada.pesquisar(colecaoIds, filtro, Cliente.class.getName());
					for (Cliente c : pesquisa) {
						for (RelatorioAnaliseArrecadacaoBean bean : hashPorArrecadador.get(c.getId())) {
							bean.setDescricaoArrecadador(c.getNome());
						}
					}
    			}
    		}
    		
    		return retorno;
    	} catch (ErroRepositorioException e) {
    		throw new ControladorException(e.getMessage(), e);
    	}
    }
    
	/**
	 * [UC0827] Gerar Relatório Análise dos Avisos Bancarios
	 * 
	 * @author Victor Cisneiros
	 * @date 30/07/2008
	 */
    public List<RelatorioAnaliseAvisosBancariosBean> pesquisarAnaliseAvisosBancarios(
    		PesquisarAnaliseAvisosBancariosHelper helper) throws ControladorException {
    	try {
    		List<RelatorioAnaliseAvisosBancariosBean> retorno = repositorioArrecadacao.pesquisarAnaliseAvisosBancarios(helper);
    		
    		Fachada fachada = Fachada.getInstancia();
    		
    		if (helper.getPorFormaArrecadacao()) {
    			List<Integer> colecaoIds = new ArrayList<Integer>();
    			Map<Integer, List<RelatorioAnaliseAvisosBancariosBean>> hashPorFormaArrecadacao = 
    				new HashMap<Integer, List<RelatorioAnaliseAvisosBancariosBean>>();
    			
    			for (RelatorioAnaliseAvisosBancariosBean bean : retorno) {
    				colecaoIds.add(bean.getIdFormaArrecadacao());
    				if (!hashPorFormaArrecadacao.containsKey(bean.getIdFormaArrecadacao())) {
    					hashPorFormaArrecadacao.put(
    							bean.getIdFormaArrecadacao(), new ArrayList<RelatorioAnaliseAvisosBancariosBean>());
    				}
    				hashPorFormaArrecadacao.get(bean.getIdFormaArrecadacao()).add(bean);
    			}
    			
    			if (!colecaoIds.isEmpty()) {
					FiltroArrecadacaoForma filtro = new FiltroArrecadacaoForma();
					Collection<ArrecadacaoForma> pesquisa = fachada.pesquisar(colecaoIds, filtro, ArrecadacaoForma.class.getName());
					for (ArrecadacaoForma af : pesquisa) {
						for (RelatorioAnaliseAvisosBancariosBean bean : hashPorFormaArrecadacao.get(af.getId())) {
							bean.setDescricaoFormaArrecadacao(af.getDescricao());
						}
					}
    			}
    		}
    		
    		if (helper.getPorArrecadador()) {
    			List<Integer> colecaoIds = new ArrayList<Integer>();
    			Map<Integer, List<RelatorioAnaliseAvisosBancariosBean>> hashPorArrecadador = 
    				new HashMap<Integer, List<RelatorioAnaliseAvisosBancariosBean>>();
    			
    			for (RelatorioAnaliseAvisosBancariosBean bean : retorno) {
    				colecaoIds.add(bean.getIdArrecadador());
    				if (!hashPorArrecadador.containsKey(bean.getIdArrecadador())) {
    					hashPorArrecadador.put(
    							bean.getIdArrecadador(), new ArrayList<RelatorioAnaliseAvisosBancariosBean>());
    				}
    				hashPorArrecadador.get(bean.getIdArrecadador()).add(bean);
    			}
    			
    			if (!colecaoIds.isEmpty()) {
					FiltroCliente filtro = new FiltroCliente();
					Collection<Cliente> pesquisa = fachada.pesquisar(colecaoIds, filtro, Cliente.class.getName());
					for (Cliente c : pesquisa) {
						for (RelatorioAnaliseAvisosBancariosBean bean : hashPorArrecadador.get(c.getId())) {
							bean.setDescricaoArrecadador(c.getNome());
						}
					}
    			}
    		}
    		
    		return retorno;
    	} catch (ErroRepositorioException e) {
    		throw new ControladorException(e.getMessage(), e);
    	}
    }
    
    /**
     * [UC0829] Gerar Relatório Avisos Bancarios Por Conta Corrente
     * 
     * @author Victor Cisneiros
     * @date 21/08/2008
     */
    public List<RelatorioAvisoBancarioPorContaCorrenteBean> pesquisarAvisoBancarioPorContaCorrente(
    		PesquisarAvisoBancarioPorContaCorrenteHelper helper) throws ControladorException {
    	try {
    		List<RelatorioAvisoBancarioPorContaCorrenteBean> pesquisa = null;
    		
    		/* 
    		 * Pesquisar todos os avisos bancários e acertos de acordo com o helper
    		 * Se um bean é acerto entao seu getIdAviso() é igual a 0
    		 */
    		pesquisa = repositorioArrecadacao.pesquisarAvisoBancarioPorContaCorrente(helper);
    		
    		if (pesquisa.isEmpty()) {
    			return pesquisa;
    		}
    		
    		Set<Integer> avisoPreenchido = new HashSet<Integer>();
    		Map<Integer, RelatorioAvisoBancarioPorContaCorrenteBean> avisos = new LinkedHashMap<Integer, RelatorioAvisoBancarioPorContaCorrenteBean>();
    		Map<Integer, List<RelatorioAvisoBancarioPorContaCorrenteBean>> avisoPagamentos = new HashMap<Integer, List<RelatorioAvisoBancarioPorContaCorrenteBean>>();
    		
    		// Colecao de ids dos Avisos para pesquisar seus pagamentos
    		Collection<Integer> idsAvisos = new ArrayList<Integer>();
    		
    		Collection<Integer> idsAgencias = new ArrayList<Integer>();
    		
    		for (RelatorioAvisoBancarioPorContaCorrenteBean bean : pesquisa) {
    			bean.setAnoMesArrecadacaoInformado(helper.getMesAno()); 
    			bean.setSituacao();
    			
    			idsAgencias.add(bean.getIdAgencia());
    			
    			// se o bean nao for um acerto
    			if (bean.getIdAviso() != null && !bean.getIdAviso().equals(new Integer(0))) {
	    			idsAvisos.add(bean.getIdAviso());
	    			avisos.put(bean.getIdAviso(), bean);
    			}
    		}
    		
    		// Pesquisando os enderecos de cada agencia
    		Map<Integer, String> enderecoAgencia = new HashMap<Integer, String>();
    		
    		FiltroAgencia filtroAgencia = new FiltroAgencia();
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroCep");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroCep.logradouro");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroCep.logradouro.logradouroTipo");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroCep.logradouro.logradouroTitulo");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroCep.cep");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("enderecoReferencia");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroBairro");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroBairro.bairro");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroBairro.bairro.municipio");
    		filtroAgencia.adicionarCaminhoParaCarregamentoEntidade("logradouroBairro.bairro.municipio.unidadeFederacao");
    		
    		Collection<Agencia> agencias = Fachada.getInstancia().pesquisar(idsAgencias, filtroAgencia, Agencia.class.getName());
    		for (Agencia agencia : agencias) {
    			enderecoAgencia.put(agencia.getId(), agencia.getEnderecoFormatado());
    		}
    		
    		List<Object[]> pagamentos = repositorioArrecadacao.pesquisarPagamentosDosAvisos(helper, idsAvisos);
    		
    		for (Object[] linha : pagamentos) {
    			Integer idAviso = (Integer) linha[0];
    			Date dataPagamento = (Date) linha[1];
    			BigDecimal valorPagamentos = (BigDecimal) linha[2];
    			
    			if (!avisoPreenchido.contains(idAviso)) {
    				avisoPreenchido.add(idAviso);
    				RelatorioAvisoBancarioPorContaCorrenteBean aviso = avisos.get(idAviso);
    				aviso.setDataPagamento(dataPagamento);
    				aviso.setValorPagamentos(valorPagamentos);
    			} else {
    				RelatorioAvisoBancarioPorContaCorrenteBean aviso = new RelatorioAvisoBancarioPorContaCorrenteBean();
    				aviso.setIdAviso(idAviso);
    				aviso.setDataPagamento(dataPagamento);
    				aviso.setValorPagamentos(valorPagamentos);
    				
    				if (!avisoPagamentos.containsKey(idAviso)) {
    					List<RelatorioAvisoBancarioPorContaCorrenteBean> listAviso = new ArrayList<RelatorioAvisoBancarioPorContaCorrenteBean>();
    					listAviso.add(aviso);
    					avisoPagamentos.put(idAviso, listAviso);
    				} else {
    					avisoPagamentos.get(idAviso).add(aviso);
    				}
    			}
    		}
    		
    		List<RelatorioAvisoBancarioPorContaCorrenteBean> retorno = new ArrayList<RelatorioAvisoBancarioPorContaCorrenteBean>();
    		
    		for (RelatorioAvisoBancarioPorContaCorrenteBean bean : pesquisa) {
    			
    			if (bean.getIdAgencia() != null) {
    				if (enderecoAgencia.containsKey(bean.getIdAgencia())) {
    					bean.setEnderecoFormatado(enderecoAgencia.get(bean.getIdAgencia()));
    				}
    			}
    			
    			retorno.add(bean);	
    			if (bean.getIdAviso() != null && !bean.getIdAviso().equals(new Integer(0))) {
	    			if (avisoPagamentos.containsKey(bean.getIdAviso())) {
	    				List<RelatorioAvisoBancarioPorContaCorrenteBean> list = avisoPagamentos.get(bean.getIdAviso());
	    				retorno.addAll(list);
	    				
	    				// setar a situacao dos pagamentos igual a situacao dos seus avisos
	    				for (RelatorioAvisoBancarioPorContaCorrenteBean pagamento : list) {
	    					pagamento.setSituacao(bean.getSituacao());
	    					pagamento.setIdBanco(bean.getIdBanco());
	    					pagamento.setIdConta(bean.getIdConta());
	    					pagamento.setAnoMesArrecadacao(bean.getAnoMesArrecadacao());
	    				}
	    			}
    			}
    		}
    		
    		return retorno;
    	} catch (ErroRepositorioException ex) {
    		throw new ControladorException("erro.sistema", ex);
    	}
    }
    
    /**
     * [UC0828] Atualizar Diferença Acumulada no Mês
     * 
     * @author Victor Cisneiros
     * @date 01/09/2008
     */
    public void atualizarDiferencaAcumuladaNoMes(int idFuncionalidadeIniciada, int anoMesArrecadacao) throws ControladorException {
		
    	int idUnidadeIniciada = 0;
    	idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(
    			idFuncionalidadeIniciada, UnidadeProcessamento.FUNCIONALIDADE, 0);
    	
    	try {
    		
    		List<DiferencaAcumulada> diferencas = new ArrayList<DiferencaAcumulada>();
    		
    		int anoMesAnterior = Util.subtraiAteSeisMesesAnoMesReferencia(anoMesArrecadacao, 1);
    		
    		List<Object[]> pesquisa = repositorioArrecadacao.pesquisarDiferencaAcumuladaNoMes(anoMesArrecadacao, anoMesAnterior);
    		
    		for (Object[] linha : pesquisa) {
    			DiferencaAcumulada diferenca = new DiferencaAcumulada();
    			Arrecadador arrecadador = new Arrecadador();
    			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
    			
    			arrecadador.setId((Integer) linha[0]);
    			arrecadacaoForma.setId((Integer) linha[1]);
    			
    			BigDecimal valorDiferencaAcumulada = new BigDecimal("0.0");
    			if (linha[2] != null) valorDiferencaAcumulada = valorDiferencaAcumulada.add((BigDecimal) linha[2]);
    			if (linha[3] != null) valorDiferencaAcumulada = valorDiferencaAcumulada.add((BigDecimal) linha[3]);
    			
    			diferenca.setArrecadador(arrecadador);
    			diferenca.setArrecadacaoForma(arrecadacaoForma);
    			diferenca.setValorDiferencaAcumulada(valorDiferencaAcumulada);
    			diferenca.setAnoMesReferenciaArrecadacao(anoMesArrecadacao);
    			diferenca.setUltimaAlteracao(new Date());
    			
    			diferencas.add(diferenca);
    		}
    		
    		
    		repositorioArrecadacao.removerDiferencasAcumuladasNoMes(anoMesArrecadacao);
    		repositorioUtil.inserirBatch(diferencas);
    		
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null, idUnidadeIniciada, false);
			
		} catch (Exception ex) {

			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex, idUnidadeIniciada, true);
			ex.printStackTrace();
			sessionContext.setRollbackOnly();

			throw new EJBException(ex);
		}
		
    }

	
	/**
	 * <Breve descrição sobre o caso de uso>
	 *
	 * <Identificador e nome do caso de uso>
	 *
	 * @author Vivianne Sousa
	 * @date 20/02/2008
	 *
	 * @param anoMesReferenciaArrecadacao
	 * @param idLocalidade
	 * @throws ErroRepositorioException
	 * @throws ControladorException
	 */
	protected void gerarHistoricoParaEncerrarArrecadacaoCreditoARealizar(
			Integer anoMesReferenciaArrecadacao, Integer idLocalidade)
			throws ErroRepositorioException, ControladorException {
		
		// criar os histórico dos creditos a realizar 
		List creditosARealizar = (List) repositorioArrecadacao
				.pesquisarCreditoaRealizarDeDevolucoesClassificadas(
						anoMesReferenciaArrecadacao, idLocalidade);

		if (creditosARealizar != null && !creditosARealizar.isEmpty()) {
			int limiteSuperiorDebito;
			int limiteInferiorDebito;
			int limiteMaximoDebito = creditosARealizar.size();
			int quantidadeMaximaPorColecaoCredito = 50;

			for (int i = 0; i < limiteMaximoDebito; i = i
					+ quantidadeMaximaPorColecaoCredito) {

				if (limiteMaximoDebito < quantidadeMaximaPorColecaoCredito) {
					limiteInferiorDebito = 0;
					limiteSuperiorDebito = limiteMaximoDebito;
				} else {
					limiteInferiorDebito = i;
					limiteSuperiorDebito = i + quantidadeMaximaPorColecaoCredito;

					if (limiteSuperiorDebito > limiteMaximoDebito) {
						limiteSuperiorDebito = limiteMaximoDebito;
					}
				}

				List colecaoCreditosTemporaria = new ArrayList();
				colecaoCreditosTemporaria.addAll(creditosARealizar.subList(
						limiteInferiorDebito, limiteSuperiorDebito));

				if (colecaoCreditosTemporaria != null && !colecaoCreditosTemporaria.isEmpty()) {
					getControladorFaturamento().transferirCreditoARealizarParaHistorico(colecaoCreditosTemporaria);
					getControladorFaturamento().atualizarIndicadorCreditosARealizarNoHistorico(colecaoCreditosTemporaria);
				}

				colecaoCreditosTemporaria = null;
			}
			creditosARealizar = null;
		}
	}
    
    /**
     * 
     * [UC0818] - Gerar Histórico do Encerramento da Arrecadação
     *
     * Fluxo Principal
     *
     * [FS0001] - Verifica existencia resumo arrecadação   
     *
     * @author bruno
     * @date 24/10/2008
     *
     * @param anoMesReferencia
     * @return
     */
    public boolean verificarExistenciaResumoArrecadacaoParaAnoMes( Integer anoMesReferencia ) throws ControladorException{        
        try {
            // Quantidade de registros
            Integer qtdRegistros = 
                this.repositorioArrecadacao.verificarExistenciaResumoArrecadacaoParaAnoMes( anoMesReferencia );            
            
            return qtdRegistros != null && qtdRegistros > 0;
        } catch (ErroRepositorioException ex) {
            throw new ControladorException( ex.getMessage(), ex );
        }        
    }
    
    /**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Pesquisa o débito a cobrar do imóvel informado pelo usuário
	 * 
	 * [FS0024] - Verificar existência do débito a cobrar
	 * 
	 * @author Rômulo Aurélio 
	 * @date 30/01/2009
	 * 
	 * @param idImovel
	 * @param idDebitoACobrar
	 * @return
	 * @throws ControladorException
	 */
    public DebitoACobrarGeral pesquisarDebitoACobrarGeralDigitado(String idImovel,
			String idDebitoACobrar) throws ControladorException {
    	
    	// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrarGeral debitoACobrarGeralDigitado = null;

		// Cria o filtro de débito a cobrar e seta todos os parâmetros para
		// pesquisar o débito a cobrar do imóvel
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.ID, idDebitoACobrar));
		filtroDebitoACobrar
				.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrar
				.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(
				filtroDebitoACobrar, DebitoACobrar.class.getName());

		// Caso exista o débito a cobrar para o imóvel informado cadastrado no
		// sistema
		// Retorna para o usuário o débito a cobrar retornado pela pesquisa
		// Caso contrário retorna um objeto nulo
		if (colecaoDebitoACobrar == null || colecaoDebitoACobrar.isEmpty()) {
			/*
			 * throw new ControladorException("atencao.pesquisa_inexistente",
			 * null, "Débito a Cobrar");
			 */
			
			// Cria o filtro de débito a cobrar e seta todos os parâmetros para
			// pesquisar o débito a cobrar do imóvel
			FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
			filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
					FiltroDebitoACobrarHistorico.IMOVEL_ID, idImovel));
			filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
					FiltroDebitoACobrarHistorico.ID, idDebitoACobrar));
			filtroDebitoACobrarHistorico
					.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
			filtroDebitoACobrarHistorico
					.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			Collection colecaoDebitoACobrarHistorico = getControladorUtil().pesquisar(
					filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());

			// Caso exista o débito a cobrar para o imóvel informado cadastrado
			// no
			// sistema
			// Retorna para o usuário o débito a cobrar retornado pela pesquisa
			// Caso contrário retorna um objeto nulo
			if (colecaoDebitoACobrarHistorico == null || colecaoDebitoACobrarHistorico.isEmpty()) {
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Débito a Cobrar");
			}
			debitoACobrarGeralDigitado = new DebitoACobrarGeral();
			
			debitoACobrarGeralDigitado.setDebitoACobrarHistorico((DebitoACobrarHistorico) Util
					.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico));
			
		} else {
			debitoACobrarGeralDigitado = new DebitoACobrarGeral();
			
			debitoACobrarGeralDigitado.setDebitoACobrar((DebitoACobrar) Util
					.retonarObjetoDeColecao(colecaoDebitoACobrar));
			
		}

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrarGeralDigitado;
	}

    
    /**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Pesquisa o débito a cobrar do imóvel informado pelo usuário
	 * 
	 * [FS0024] - Verificar existência do débito a cobrar
	 * 
	 * @author Rômulo Aurélio 
	 * @date 30/01/2009
	 * 
	 * @param idImovel
	 * @param idDebitoACobrar
	 * @return
	 * @throws ControladorException
	 */
    
    public void verificarLocalidadeDebitoACobrarGeral(
			DebitoACobrarGeral debitoACobrarGeral, String idLocalidade)
			throws ControladorException {

		// Caso o usuário tenha informado a localidade
		if (idLocalidade != null && !idLocalidade.trim().equalsIgnoreCase("")) {

			if (debitoACobrarGeral.getDebitoACobrar() != null) {

				// Caso a localidade do débito a cobrar seja diferente da
				// localidade
				// informada
				if (!debitoACobrarGeral.getDebitoACobrar().getLocalidade()
						.getId().equals(new Integer(idLocalidade))) {

					// Cria a mensagem que vai ser exibida ao usuário
					// e levanta a exceção
					String mensagem = "A Localidade do Débito a Cobrar "
							+ debitoACobrarGeral.getDebitoACobrar()
									.getLocalidade().getId()
							+ " é diferente da Localidade informada "
							+ idLocalidade;
					throw new ControladorException(
							"atencao.localidade_debito_a_cobrar_diferente",
							null, mensagem);
				}
			} else {
				// Caso a localidade do débito a cobrar seja diferente da
				// localidade
				// informada
				if (!debitoACobrarGeral.getDebitoACobrarHistorico().getLocalidade()
						.getId().equals(new Integer(idLocalidade))) {

					// Cria a mensagem que vai ser exibida ao usuário
					// e levanta a exceção
					String mensagem = "A Localidade do Débito a Cobrar "
							+ debitoACobrarGeral.getDebitoACobrarHistorico()
									.getLocalidade().getId()
							+ " é diferente da Localidade informada "
							+ idLocalidade;
					throw new ControladorException(
							"atencao.localidade_debito_a_cobrar_diferente",
							null, mensagem);
				}
			}
		}
	}
    
    /**
	 * Inseri uma coleção de pagamentos no sistema
	 * 
	 * [UC0265] Inserir Pagamentos
	 * 
	 * Verifica a existência de débito a cobrar com o tipo de débito e o imóvel
	 * informados
	 * 
	 * [FS0016] Verificar existência de débito a cobrar com tipo de débito
	 * informado
	 * 
	 * @author Rômulo Aurélio
	 * @date 30/01/2009
	 * 
	 * @param tipoDebito
	 * @param idImovel
	 * @return
	 * @throws ControladorException
	 */
    public DebitoACobrarGeral verificarExistenciaDebitoACobrarGeralComTipoDebito(
			DebitoTipo tipoDebito, String idImovel, BigDecimal valorInformado) throws ControladorException {

		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		
		DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
		
		// ****Verifica em debito a cobrar***
		
		DebitoACobrar debitoACobrar = null;

		// Cria o filtro de débito a cobrar, e seta os parâmetros para pesquisar
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.DEBITO_TIPO_ID, tipoDebito.getId()));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrar.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
				DebitoCreditoSituacao.NORMAL));

		// Pesquisa o débito a cobrar no sistema
		Collection colecaoDebitoACobrar = getControladorUtil().pesquisar(
				filtroDebitoACobrar, DebitoACobrar.class.getName());
		
		Collection colecaoComValor = new ArrayList();

		// Caso exista débito a cobrar cadastrado com o tipo de débito informado
		if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {

			// Caso exista mais que um débito a cobrar cadastrado para o tipo de
			// débito
			// Monta a mensagem para o usuário e levanta a exceção
			if (colecaoDebitoACobrar.size() > 1) {
				Iterator iteratorColecao = colecaoDebitoACobrar.iterator();
				
				while(iteratorColecao.hasNext()){
					DebitoACobrar debitoACobrarColecao = (DebitoACobrar)iteratorColecao.next(); 
					
					BigDecimal valorFaltaDebito = BigDecimal.ZERO;
				      
					BigDecimal valorDebito = debitoACobrarColecao.getValorDebito();
				    short numeroPrestacaoDebito = debitoACobrarColecao.getNumeroPrestacaoDebito();
				    short numeroPrestacaoCobrada = debitoACobrarColecao.getNumeroPrestacaoCobradas();
				      
				    valorDebito = valorDebito.divide(new BigDecimal(numeroPrestacaoDebito+""));
				      
				    valorFaltaDebito = valorFaltaDebito.add(debitoACobrarColecao.getValorDebito());
				    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
				      
				    valorFaltaDebito = valorFaltaDebito.multiply(new BigDecimal(numeroPrestacaoCobrada+""));
			      
			      
				  if(valorInformado.equals(valorFaltaDebito)){
					
					  colecaoComValor.add(debitoACobrarColecao);
			      }
				}
				
				if(colecaoComValor.size() > 1){
					String mensagem = "Há mais de um Débito a Cobrar com o tipo de débito "
						+ tipoDebito.getDescricao()
						+ " para o Imóvel "
						+ idImovel;
					throw new ControladorException("atencao.descricao_concatenada",
						null, mensagem);
				}
				debitoACobrar = (DebitoACobrar) Util
				.retonarObjetoDeColecao(colecaoComValor);
			} else {
				// Caso só exista apenas um débito a cobrar cadastrado para o
				// tipo de débito
				debitoACobrar = (DebitoACobrar) Util
						.retonarObjetoDeColecao(colecaoDebitoACobrar);
				
				BigDecimal valorFaltaDebito = BigDecimal.ZERO;
			      
				BigDecimal valorDebito = debitoACobrar.getValorDebito();
			    short numeroPrestacaoDebito = debitoACobrar.getNumeroPrestacaoDebito();
			    short numeroPrestacaoCobrada = debitoACobrar.getNumeroPrestacaoCobradas();
			      
			    valorDebito = valorDebito.divide(new BigDecimal(numeroPrestacaoDebito+""));
			      
			    valorFaltaDebito = valorFaltaDebito.add(debitoACobrar.getValorDebito());
			    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
			      
			    valorFaltaDebito = valorFaltaDebito.multiply(new BigDecimal(numeroPrestacaoCobrada+""));
		      
		      
		      if(!valorInformado.equals(valorFaltaDebito)){
		    	  debitoACobrar = null;
		      }
			}
		}
		
		debitoACobrarGeral.setDebitoACobrar(debitoACobrar);
		
		DebitoACobrarHistorico debitoACobrarHistorico = null;

		// Cria o filtro de débito a cobrar, e seta os parâmetros para pesquisar
		FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrarHistorico.DEBITO_TIPO_ID, tipoDebito.getId()));
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrarHistorico.IMOVEL_ID, idImovel));
		filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(
				FiltroDebitoACobrarHistorico.DEBITO_CREDITO_SITUACAO_ATUAL_ID,
				DebitoCreditoSituacao.NORMAL));

		// Pesquisa o débito a cobrar no sistema
		Collection colecaoDebitoACobrarHistorico = getControladorUtil().pesquisar(
				filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());
		
		// Caso exista débito a cobrar historico cadastrado com o tipo de débito informado
		if (colecaoDebitoACobrarHistorico != null && !colecaoDebitoACobrarHistorico.isEmpty()) {

			// Caso exista mais que um débito a cobrar historico cadastrado para o tipo de
			// débito
			// Monta a mensagem para o usuário e levanta a exceção
			if (colecaoDebitoACobrarHistorico.size() > 1) {
				Iterator iteratorColecao = colecaoDebitoACobrarHistorico.iterator();
				
				while(iteratorColecao.hasNext()){
					DebitoACobrarHistorico debitoACobrarHistoricoColecao = (DebitoACobrarHistorico)iteratorColecao.next(); 
					
					BigDecimal valorFaltaDebito = BigDecimal.ZERO;
				      
					BigDecimal valorDebito = debitoACobrarHistoricoColecao.getValorDebito();
				    short numeroPrestacaoDebito = debitoACobrarHistoricoColecao.getPrestacaoDebito();
				    short numeroPrestacaoCobrada = debitoACobrarHistoricoColecao.getPrestacaoCobradas();
				      
				    valorDebito = valorDebito.divide(new BigDecimal(numeroPrestacaoDebito+""));
				      
				    valorFaltaDebito = valorFaltaDebito.add(debitoACobrarHistoricoColecao.getValorDebito());
				    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
				      
				    valorFaltaDebito = valorFaltaDebito.multiply(new BigDecimal(numeroPrestacaoCobrada+""));
			      
			      
				  if(valorInformado.equals(valorFaltaDebito)){
					
					  colecaoComValor.add(debitoACobrarHistoricoColecao);
			      }
				}
				
				if(colecaoComValor.size() > 1){
					String mensagem = "Há mais de um Débito a Cobrar com o tipo de débito "
						+ tipoDebito.getDescricao()
						+ " para o Imóvel "
						+ idImovel;
					throw new ControladorException("atencao.descricao_concatenada",
						null, mensagem);
				}
				debitoACobrar = (DebitoACobrar) Util
				.retonarObjetoDeColecao(colecaoComValor);
			} else {
				// Caso só exista apenas um débito a cobrar cadastrado para o
				// tipo de débito
				debitoACobrarHistorico = (DebitoACobrarHistorico) Util
						.retonarObjetoDeColecao(colecaoDebitoACobrarHistorico);
				
				BigDecimal valorFaltaDebito = BigDecimal.ZERO;
			    
				/*
				BigDecimal valorDebito = debitoACobrarHistorico.getValorDebito();
			    short numeroPrestacaoDebito = debitoACobrarHistorico.getPrestacaoDebito();
			    short numeroPrestacaoCobrada = debitoACobrarHistorico.getPrestacaoCobradas();
			    */
				BigDecimal valorDebito = debitoACobrarHistorico.getValorDebito();
			    short numeroPrestacaoDebito = debitoACobrarHistorico.getPrestacaoDebito();
			    short numeroPrestacaoCobrada = debitoACobrarHistorico.getPrestacaoCobradas();
				
			    valorDebito = valorDebito.divide(new BigDecimal(numeroPrestacaoDebito+""));
			     /* 
			    valorFaltaDebito = valorFaltaDebito.add(debitoACobrarHistorico.getValorDebito());
			    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
			    */
			    valorFaltaDebito = valorFaltaDebito.add(debitoACobrarHistorico.getValorDebito());
			    valorFaltaDebito = valorFaltaDebito.subtract(valorDebito);
			      
			    valorFaltaDebito = valorFaltaDebito.multiply(new BigDecimal(numeroPrestacaoCobrada+""));
		      
		      
		      if(!valorInformado.equals(valorFaltaDebito)){
		    	  debitoACobrarHistorico = null;
		      }
			}
		}

		debitoACobrarGeral.setDebitoACobrarHistorico(debitoACobrarHistorico);
		
		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return debitoACobrarGeral;
	}
    
    /**
	 * Pesquisa os bancos q tem imoveis cadastrados em debito automatico
	 * @return
	 * @throws ErroRepositorioException
	 */
	public Collection<Banco> pesquisarBancoDebitoAutomatico()
		throws ControladorException{
		
		Collection<Banco> retorno = new ArrayList();
		
		try {
			Collection ids = repositorioArrecadacao.pesquisarBancoDebitoAutomatico();
			
			if(ids.isEmpty()){
				throw new ControladorException("atencao.pesquisa_inexistente",
						null, "Banco");
			}
			FiltroBanco filtroBanco = null;
			Collection resultadoBanco = null;
			Integer id = null;
			Banco banco = null;
			
			Iterator it = ids.iterator();
			while(it.hasNext()){
				filtroBanco = new FiltroBanco();
				id = (Integer)it.next();
				filtroBanco.adicionarParametro(new ParametroSimples(FiltroBanco.ID, id));
				resultadoBanco = getControladorUtil().pesquisar(filtroBanco, Banco.class.getName());
				
				banco = (Banco)resultadoBanco.iterator().next();
				
				retorno.add(banco);
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		
		return retorno;
		
	}
	
	/**
	  * [UC0146] Manter Conta
	  * 
	  * FS0028 - Verificar parâmetro consulta e débito automático
	  * @return
	  * @throws ErroRepositorioException
	  */
		public Collection pesquisarImoveisBancoDebitoAutomatico(String[] bancos)
			throws ControladorException{
			
			Collection retorno = null;
			
			try{
				
				retorno = repositorioArrecadacao.pesquisarImoveisBancoDebitoAutomatico(bancos);
				
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
			}
			
			return retorno;
		}
		
		/**
		  * [UC0146] Manter Conta
		  * 
		  * FS0028 - Verificar parâmetro consulta e débito automático
		  * @return
		  * @throws ErroRepositorioException
		  */
			public Integer countImoveisBancoDebitoAutomatico(String[] bancos, 
					Integer anoMesInicial,Integer anoMesFinal, Date dataVencimentoInicial,
					Date dataVencimentoFinal, String indicadorContaPaga, Integer somenteDebitoAutomatico)
				throws ControladorException{
				
				Integer retorno = null;
				
				try{
					
					retorno = repositorioArrecadacao.countImoveisBancoDebitoAutomatico(bancos, 
							anoMesInicial, anoMesFinal, dataVencimentoInicial, dataVencimentoFinal, indicadorContaPaga, somenteDebitoAutomatico);
					
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				
				return retorno;
			}
			
			public Collection selecionarImoveisBancoDebitoAutomatico(String[] bancos, 
					Integer anoMesInicial,Integer anoMesFinal, Date dataVencimentoInicial,
					Date dataVencimentoFinal, String indicadorContaPaga)
				throws ControladorException{
				
				Collection retorno = null;
				
				try{
					
					retorno = repositorioArrecadacao.selecionarImoveisBancoDebitoAutomatico(bancos, 
							anoMesInicial, anoMesFinal, dataVencimentoInicial, dataVencimentoFinal, indicadorContaPaga);
					
				} catch (ErroRepositorioException e) {
					e.printStackTrace();
				}
				
				return retorno;
			}
    
    
    /**
	 * Consultar os dados do movimento arrecadador 
	 * 
	 * dados[0] = NomeBanco
	 * dados[1] = NomeAgencia
	 * 
	 * @author Arthur Carvalho
	 * @date 03/04/2009
	 * 
	 * @param 
	 * @return Collection
	 * @throws ControladorException
	 */
    public Collection<Object[]>  consultarNomeArrecadadorNomeAgencia(
			String idArrecadadorMovimento ) throws ControladorException {
		
    	Collection<Object[]> dados = null;

		try {

			dados = this. repositorioArrecadacao
					.consultarNomeArrecadadorNomeAgencia(idArrecadadorMovimento);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return dados;
	}

    
    /**
	 * Inseri na tabela ARRECADADOR_CONTRATO_TARIFA todos os arrecadadores contratos tarifas 
	 * selecionados pelo usuário para um determinado Arrecadador de contrato.
	 * 
	 * @author Arthur Carvalho
	 * @date 27/05/2009
	 * @return void
	 */
	public void inserirArrecadadorContratoTarifa(ArrecadadorContrato contrato,
			Collection<ArrecadadorContratoTarifa> colecaoArrecadadorContratoTarifa)
			throws ControladorException {

		Operacao operacao = new Operacao();
		operacao.setId(Operacao.OPERACAO_LOGRADOURO_INSERIR);

		OperacaoEfetuada operacaoEfetuada = new OperacaoEfetuada();
		operacaoEfetuada.setOperacao(operacao);
		
		Iterator iteratorColecaoArrecadadorContratoTarifa = colecaoArrecadadorContratoTarifa.iterator();
		ArrecadadorContratoTarifa arrecadadorContratoTarifa = null;

		while (iteratorColecaoArrecadadorContratoTarifa.hasNext()) {
			
			arrecadadorContratoTarifa = (ArrecadadorContratoTarifa) iteratorColecaoArrecadadorContratoTarifa.next();
			
			arrecadadorContratoTarifa.setArrecadadorContrato(contrato);
			
			ArrecadadorContratoTarifaPK pk = new ArrecadadorContratoTarifaPK(contrato.getId(), 
					arrecadadorContratoTarifa.getArrecadacaoForma().getId());
			
			arrecadadorContratoTarifa.setComp_id(pk);

			this.getControladorUtil().inserir(arrecadadorContratoTarifa);
		}
	}

    
    /**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - CONTA
	 *
	 * @author Raphael Rossiter
	 * @date 01/06/2009
	 *
	 * @param numeroFatura
	 * @return Conta
	 * @throws ControladorException
	 */
	public Conta pesquisarExistenciaContaPorNumeroFatura(String numeroFatura) throws ControladorException {
		
		Conta conta = null;
		Object[] contaPorNumeroFatura = null;

		try {

			contaPorNumeroFatura = this. repositorioArrecadacao
			.pesquisarExistenciaContaPorNumeroFatura(numeroFatura);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		if (contaPorNumeroFatura != null){
			
			conta = new Conta();
			
			conta.setId((Integer) contaPorNumeroFatura[0]);
			conta.setReferencia((Integer) contaPorNumeroFatura[1]);
			
			Imovel imovel = new Imovel();
			imovel.setId((Integer) contaPorNumeroFatura[2]);
			conta.setImovel(imovel);
			
			Localidade localidade = new Localidade();
			localidade.setId((Integer) contaPorNumeroFatura[3]);
			conta.setLocalidade(localidade);
		}

		return conta;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - EXTRATO
	 *
	 * @author Raphael Rossiter
	 * @date 02/06/2009
	 *
	 * @param numeroDocumentoFatura
	 * @return CobrancaDocumento
	 * @throws ControladorException
	 */
	public CobrancaDocumento pesquisarParmsCobrancaDocumentoPorNumeroDocumentoFatura(String numeroDocumentoFatura) 
		throws ControladorException {
		
		CobrancaDocumento cobrancaDocumento = null;
		Object[] cobrancaDocumentoPorSequencial = null;

		try {

			cobrancaDocumentoPorSequencial = this. repositorioArrecadacao
			.pesquisarParmsCobrancaDocumentoPorNumeroDocumentoFatura(numeroDocumentoFatura);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		if (cobrancaDocumentoPorSequencial != null){
			
			cobrancaDocumento = new CobrancaDocumento();
			
			cobrancaDocumento.setId((Integer) cobrancaDocumentoPorSequencial[3]);
			cobrancaDocumento.setEmissao((Date) cobrancaDocumentoPorSequencial[2]);
			
			cobrancaDocumento.setValorAcrescimos((BigDecimal) cobrancaDocumentoPorSequencial[0]);
			cobrancaDocumento.setValorDesconto((BigDecimal) cobrancaDocumentoPorSequencial[1]);
			cobrancaDocumento.setValorTaxa((BigDecimal) cobrancaDocumentoPorSequencial[4]);
			
			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId((Integer) cobrancaDocumentoPorSequencial[6]);
			cobrancaDocumento.setDocumentoTipo(documentoTipo);
			
			if (cobrancaDocumentoPorSequencial[5] != null){
				
				Localidade localidade = new Localidade();
				localidade.setId((Integer) cobrancaDocumentoPorSequencial[5]);
				cobrancaDocumento.setLocalidade(localidade);
			}
			
			if (cobrancaDocumentoPorSequencial[7] != null){
				
				Imovel imovel = new Imovel();
				imovel.setId((Integer) cobrancaDocumentoPorSequencial[7]);
				
				Localidade localidadeImovel = new Localidade();
				localidadeImovel.setId((Integer) cobrancaDocumentoPorSequencial[8]);
				imovel.setLocalidade(localidadeImovel);
				
				cobrancaDocumento.setImovel(imovel);
			}
		}

		return cobrancaDocumento;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 *
	 * [SB0014] - Processar Pagamento Legado COSANPA - GUIA DE PAGAMENTO
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2009
	 *
	 * @param numeroGuiaFatura
	 * @return GuiaPagamento
	 * @throws ControladorException
	 */
	public GuiaPagamento pesquisarExistenciaGuiaPagamentoPorNumeroGuiaFatura(String numeroGuiaFatura) 
		throws ControladorException {
		
		GuiaPagamento guiaPagamento = null;
		Object[] guiaPagamentoPorNumeroGuiaFatura = null;

		try {

			guiaPagamentoPorNumeroGuiaFatura = this. repositorioArrecadacao
			.pesquisarExistenciaGuiaPagamentoPorNumeroGuiaFatura(numeroGuiaFatura);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		if (guiaPagamentoPorNumeroGuiaFatura != null){
			
			guiaPagamento = new GuiaPagamento();
			
			guiaPagamento.setId((Integer) guiaPagamentoPorNumeroGuiaFatura[0]);
			
			Imovel imovel = new Imovel();
			imovel.setId((Integer) guiaPagamentoPorNumeroGuiaFatura[1]);
			guiaPagamento.setImovel(imovel);
			
			Localidade localidade = new Localidade();
			localidade.setId((Integer) guiaPagamentoPorNumeroGuiaFatura[2]);
			guiaPagamento.setLocalidade(localidade);
			
			DebitoTipo debitoTipo = new DebitoTipo();
			debitoTipo.setId((Integer) guiaPagamentoPorNumeroGuiaFatura[3]);
			guiaPagamento.setDebitoTipo(debitoTipo);
		}

		return guiaPagamento;
	}
	
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * 
	 * [SB0008] - Distribuir Pagamento Legado COSANPA LEGADO FATURA
	 * 
	 * @author Raphael Rossiter
	 * @created 27/07/2009
	 * 
	 * @param numeroFatura
	 * @return Fatura
	 * @throws ErroRepositorioException
	 */
	public Fatura pesquisarFaturaPorNumeroFatura(String numeroFatura) throws ControladorException {
		
		Fatura fatura = null;
		Integer faturaPorNumeroFatura = null;

		try {

			faturaPorNumeroFatura = this. repositorioArrecadacao
			.pesquisarFaturaPorNumeroFatura(numeroFatura);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		if (faturaPorNumeroFatura != null){
			
			fatura = new Fatura();
			
			fatura.setId((Integer) faturaPorNumeroFatura);
			fatura.setNumeroFatura(numeroFatura);
			
		}

		return fatura;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0016] - Processar Pagamento Antecipado de Conta
	 * 
	 * @autor: Raphael Rossiter 
	 * @data: 02/05/2007
	 */
	protected ProcessarPagamentoParcialContaHelper processarPagamentoParcialConta(Conta conta, 
			BigDecimal valorGuiaPagamento) throws ControladorException {
		
		ProcessarPagamentoParcialContaHelper helper = new ProcessarPagamentoParcialContaHelper();
		
		//Conta que será retificada
		helper.setConta(conta);
		
		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
		Collection colecaoCategoriaOUSubcategoria = null;
		
		if (getSistemaParametro().getIndicadorTarifaCategoria().equals(SistemaParametro.INDICADOR_TARIFA_SUBCATEGORIA)){
    		
			// [UC0108] - Quantidade de economias por categoria
			colecaoCategoriaOUSubcategoria = this.getControladorImovel()
			.obterQuantidadeEconomiasContaCategoriaPorSubcategoria(conta);
    	}
    	else{
    		
    		// [UC0108] - Quantidade de economias por categoria
    		colecaoCategoriaOUSubcategoria = this.getControladorImovel()
    		.obterQuantidadeEconomiasContaCategoria(conta);
    	}
		
		helper.setColecaoCategoriaOUSubcategoria(colecaoCategoriaOUSubcategoria);
		
		//Motivo da retificação (CMRT_IDANTECIPADO da tabela SISTEMA_PARAMETRO);
		helper.setContaMotivoRetificacao(getSistemaParametro().getContaMotivoRetificacaoPagamentoAntecipado());
		
		//DÉBITOS
		Collection colecaoDebitoCobrado = this.getControladorFaturamento().obterDebitosCobradosConta(conta);
		helper.setColecaoDebitoCobrado(colecaoDebitoCobrado);
		
		//CRÉDITOS
		Collection colecaoCreditoRealizado = this.getControladorFaturamento().obterCreditosRealizadosConta(conta);

		/*
		 * Gerando um crédito realizado de acordo com as especificações abaixo:
		 */
		CreditoRealizado creditoRealizado = new CreditoRealizado();
		
		//1. Tipo do Crédito (DBTP_ID da tabela DEBITO_TIPO com valor associado a Pagamento Antecipado;
		CreditoTipo creditoTipo = new CreditoTipo();
		creditoTipo.setId(CreditoTipo.PAGAMENTO_PARCIAL);
		
		creditoRealizado.setCreditoTipo(creditoTipo);
		
		/*
		 * 2. Mês e ano de referência do crédito (CNTA_AMREFERENCIACONTA  da tabela CONTA com CNTA_ID = 
		 * CNTA_ID da conta selecionada);
		 */
		creditoRealizado.setAnoMesReferenciaCredito(conta.getReferencia());
		
		/*
		 * 3. Mês e ano de referência da cobrança (Mês/Ano de referencia da arrecadação 
		 * (PARM_AMREFERENCIAARRECADACAO  da tabela SISTEMA_PARAMETRO));
		 */
		creditoRealizado.setAnoMesCobrancaCredito(getSistemaParametro().getAnoMesArrecadacao());
		
		//4. Valor do crédito realizado (Valor da guia de pagamento (GPAG_VLDEBITO da tabela GUIA_PAGAMENTO);
		creditoRealizado.setValorCredito(valorGuiaPagamento);
		
		//5. Número total de prestações do crédito realizado (1(um));
		creditoRealizado.setNumeroPrestacaoCredito(new Short("1"));
		
		//6. Número da prestação do crédito realizado (1(um));
		creditoRealizado.setNumeroPrestacao(new Short("1"));
		
		/*
		 * 7. Origem do crédito realizado (CROR_ID  da tabela CREDITO_ORIGEM com valor igual a 
		 * DESCONTOS CONCEDIDOS);
		 */
		CreditoOrigem creditoOrigem = new CreditoOrigem();
		creditoOrigem.setId(CreditoOrigem.DESCONTOS_CONCEDIDOS_NO_PARCELAMENTO);
		
		creditoRealizado.setCreditoOrigem(creditoOrigem);
		
		//ACRESCENTANDO UM CRÉDITO REALIZADO NA CONTA COM O VALOR DA GUIA DE PAGAMENTO
		colecaoCreditoRealizado.add(creditoRealizado);
		helper.setColecaoCreditoRealizado(colecaoCreditoRealizado);
		
		
		Integer consumoAgua = 0;
		if (conta.getConsumoAgua() != null){
			consumoAgua = conta.getConsumoAgua();
		}
		
		Integer volumeEsgoto = 0;
		if (conta.getConsumoEsgoto() != null){
			volumeEsgoto = conta.getConsumoEsgoto();
		}
		//[UC0120] - Calcular Valores de Água e/ou Esgoto
		Collection<CalcularValoresAguaEsgotoHelper> valoresConta = this.getControladorFaturamento()
		.calcularValoresConta(Util.formatarAnoMesParaMesAno(conta.getReferencia()), 
		conta.getImovel().getId().toString(),conta.getLigacaoAguaSituacao().getId(), 
		conta.getLigacaoEsgotoSituacao().getId(),colecaoCategoriaOUSubcategoria, consumoAgua.toString(), 
		volumeEsgoto.toString(),conta.getPercentualEsgoto().toString(),conta.getConsumoTarifa().getId(), 
		Usuario.USUARIO_BATCH);
		
		helper.setValoresConta(valoresConta);
		
		
		return helper;
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * 
	 * [SB0008] - Distribuir Pagamento Legado COSANPA LEGADO FATURA
	 * 
	 * @author Raphael Rossiter
	 * @created 27/07/2009
	 * 
	 * @param numeroFatura
	 * @return Fatura
	 * @throws ErroRepositorioException
	 */
	public Fatura pesquisarFaturaPorNumeroFaturaObjetoCompleto(String numeroFatura) throws ControladorException {
		
		Fatura fatura = null;

		try {

			fatura = this.repositorioArrecadacao
			.pesquisarFaturaPorNumeroFaturaObjetpCompleto(numeroFatura);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		return fatura;
	}
	
	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Imovel pesquisarPagamentoImovelParaPaginacao
	 * 
	 * @author Arthur Carvalho
	 * @date 16/12/09
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */

	public Integer pesquisarPagamentoCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial, 
            String valorPagamentoFinal ) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial, 
                    valorPagamentoFinal );
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	
	/**
	 * 
	 * [UC0259] Processar Pagamento com Codigo Barras
	 * 
	 * @author Arthur Carvalho
	 * @since 29/12/2009
	 *
	 */
	protected Integer inserirGuiaPagamentoReferenteDebitoTipoDoacao(Integer idImovel, DebitoTipo debitoTipo, 
			Date dataPagamento, BigDecimal valorPagamento)
			throws ControladorException {

		Integer idGuiaPagamentoRetorno = null;
		
		//Inclui a guia de pagamento na tabela guia_pagamento
		GuiaPagamento guiaPagamento = new GuiaPagamento();

		//IMOVEL
		Imovel imovel = new Imovel();
		imovel.setId(idImovel);

		guiaPagamento.setImovel(imovel);
		
		//DATA DO PAGAMENTO	 
		guiaPagamento.setDataVencimento(dataPagamento);
		
		//VALOR DO DEBITO
		guiaPagamento.setValorDebito(valorPagamento);
		
		idGuiaPagamentoRetorno = 
			this.getControladorFaturamento().inserirGuiaPagamentoCodigoBarras(guiaPagamento,debitoTipo.getId());
		
		
		//Verifica se o imovel ja é cadastrado na tabela imovel doação
		FiltroImovelDoacao filtroImovelDoacao = new FiltroImovelDoacao();
		filtroImovelDoacao.adicionarParametro( 
			new ParametroSimples (FiltroImovelDoacao.ID_IMOVEL, idImovel));
		filtroImovelDoacao.adicionarParametro( 
			new ParametroNulo (FiltroImovelDoacao.DATA_CANCELAMENTO));
		
		Collection colecaoImovelDoacao = 
			getControladorUtil().pesquisar(filtroImovelDoacao,ImovelDoacao.class.getName());
		
		if ( colecaoImovelDoacao == null || colecaoImovelDoacao.isEmpty() ) {
			//Incluir o imovel doação
			ImovelDoacao imovelDoacao = new ImovelDoacao();
			imovelDoacao.setImovel(imovel);
			
			//Entidade Beneficente
			FiltroEntidadeBeneficente filtroEntidadeBeneficente = new FiltroEntidadeBeneficente();
			filtroEntidadeBeneficente.adicionarParametro( new ParametroSimples ( 
					FiltroEntidadeBeneficente.ID_DEBITO_TIPO, debitoTipo.getId()));

			Collection colecaoEntidade = getControladorUtil().pesquisar(filtroEntidadeBeneficente, 
					EntidadeBeneficente.class.getName());
			EntidadeBeneficente entidade = (EntidadeBeneficente) Util.retonarObjetoDeColecao(colecaoEntidade);
			imovelDoacao.setEntidadeBeneficente(entidade);
			
			//Valor do pagamento
			imovelDoacao.setValorDoacao(valorPagamento);
			
			//Data do pagamento
			imovelDoacao.setDataAdesao(dataPagamento);
			
			//Data do cancelamento
			imovelDoacao.setDataCancelamento(null);
			
			//Usuario Adesao
			imovelDoacao.setUsuarioAdesao(Usuario.USUARIO_BATCH);
			
			//Usuario Cancelamento
			imovelDoacao.setUsuarioCancelamento(null);
			
			//timestamp
			imovelDoacao.setUltimaAlteracao(new Date());
			
			
			getControladorUtil().inserir(imovelDoacao);
			
		}
			
		
		return idGuiaPagamentoRetorno;
	}
	
	/**
	 * [UC0971] Inserir Pagamentos para Faturas Especiais
	 * [SB0001] Processar fatura com codigo de barras
	 * 
	 * @author 	Vivianne Sousa
	 * @created	22/12/2009
	 *
	 * @param codigoBarras
	 * @param sistemaParametro
	 * @return PagamentoHelperCodigoBarras
	 * @throws ControladorException
	 */
	public PagamentoHelperCodigoBarras processarFaturaComCodigoBarras(
			String codigoBarras, SistemaParametro sistemaParametro) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";
		boolean setaRetorno = true;
		
		/*
		 * Recupera o objeto registroHelperCodigoBarras passando a string do código de barras.
		 */
		RegistroHelperCodigoBarras registroHelperCodigoBarras = distribuirDadosCodigoBarras(codigoBarras);

		Short identificadorEmpresaCodigoBarras = new Short(registroHelperCodigoBarras.getIdEmpresa());

		/*
		 * Caso o identificador da empresa no txt não seja igual ao código da
		 * empresa no sistemas parametro.
		 */
		if (!identificadorEmpresaCodigoBarras.equals(getSistemaParametro().getCodigoEmpresaFebraban())) {

			// Atribui o valor 2(NÃO) ao indicador aceitação registro
			indicadorAceitacaoRegistro = "2";

			descricaoOcorrencia = "CÓDIGO DE BARRAS NÃO PERTENCE A "+ getSistemaParametro().getNomeEmpresa();

		} 
		else {
			
			int tipoPagamento = Integer.parseInt(registroHelperCodigoBarras.getTipoPagamento());
			
			//FATURA DO CLIENTE RESPONSÁVEL
			if(tipoPagamento == 7){
				
				pagamentoHelperCodigoBarras = this.processarFaturaDoClienteResponsavel(
					descricaoOcorrencia,indicadorAceitacaoRegistro,registroHelperCodigoBarras);
				
				setaRetorno = false;
			}else{
				
				indicadorAceitacaoRegistro = "2";
				descricaoOcorrencia = "CÓDIGO DE BARRAS COM TIPO DE PAGAMENTO INVÁLIDO";
				
			}

		}
		
		if(setaRetorno){
			// Seta os parametros que serão retornados
			pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
			pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		}

		return pagamentoHelperCodigoBarras;
	}
	
	/**
 * [UC0971] Inserir Pagamentos para Faturas Especiais
	 * [SB0002] Processar fatura do cliente responsavel
	 * 
	 * @author 	Vivianne Sousa
	 * @created	22/12/2009
	 */
	protected PagamentoHelperCodigoBarras processarFaturaDoClienteResponsavel(
			String descricaoOcorrencia,String indicadorAceitacaoRegistro,
			RegistroHelperCodigoBarras registroHelperCodigoBarras) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();
		
		int anoMes = 0;

		boolean anoMesReferencia = false;

		// valida a matricula do imóvel
		boolean idClienteInvalido = Util.validarValorNaoNumerico(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());
		Integer idClienteNaBase = null;

		if (idClienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		} else {
			// verifica se existe o id do cliente na base
			Integer idCliente = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idClienteNaBase = repositorioCliente
						.verificarExistenciaCliente(new Integer(idCliente));
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			if (idClienteNaBase == null) {
				descricaoOcorrencia = "CLIENTE RESPONSÁVEL NÂO CADASTRADO";
			}
		}

		// valida o namo mes de referencia da conta
		anoMes = Util.formatarMesAnoParaAnoMes(Integer.parseInt(registroHelperCodigoBarras
				.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4()));
		anoMesReferencia = Util.validarAnoMesSemBarra("" + anoMes);
		if (anoMesReferencia) {
			descricaoOcorrencia = "ANO/MÊS DE REFERÊNCIA DA CONTA INVÁLIDO";
		}
		
		if (descricaoOcorrencia.equals("OK")) {
			
			// inicializa a coleção de fatura item
			Collection fatura = null;

			Integer numeroSequencial = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento6());
			
			BigDecimal valorPagamento = Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
					registroHelperCodigoBarras.getValorPagamento());

			try {
				fatura = repositorioFaturamento.pesquisarFatura(
						idClienteNaBase, anoMes, numeroSequencial,valorPagamento);
			} catch (ErroRepositorioException e) {
				throw new ControladorException("erro.sistema", e);
			}

			// verifica se a coleção é diferente de nula
			if (fatura == null || fatura.isEmpty()) {
				
				descricaoOcorrencia = "FATURA DO CLIENTE RESPONSÁVEL INEXISTENTE";
				indicadorAceitacaoRegistro = "2";
			}
			
		} else {
			// atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);

		return pagamentoHelperCodigoBarras;
	}
	
	
	/**
	 * [UC0971] Inserir Pagamentos para Faturas Especiais
	 * 
	 * @author 	Vivianne Sousa
	 * @created	22/12/2009
	 */
	public void inserirPagamentosFaturasEspeciais(Integer idFuncionalidadeIniciada,Map parametros)
			throws ControladorException {
		
		int idUnidadeIniciada = 0;
		final int quantidadeRegistros = 10000;
		int numeroIndice = 0;
		BigDecimal valorPagamentoAcumulado = new BigDecimal("0.00");

		try{
			
			idUnidadeIniciada = 
				getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,UnidadeProcessamento.FUNCIONALIDADE,0);
			
			Collection<InserirPagamentoViaCanetaHelper> colecaoInserirPagamentoViaCanetaHelper = 
				(Collection<InserirPagamentoViaCanetaHelper>)parametros.get("colecaoInserirPagamentoViaCanetaHelper");
			
			//Usuario usuarioLogado = (Usuario)parametros.get("usuarioLogado");
			AvisoBancario avisoBancario = (AvisoBancario)parametros.get("avisoBancario");
			Integer idFormaArrecadacao = (Integer)parametros.get("idFormaArrecadacao");
			Date dataPagamento = (Date)parametros.get("dataPagamento");			
			
						
			SistemaParametro sistemaParametro = 
				this.getControladorUtil().pesquisarParametrosDoSistema();
			
			if(colecaoInserirPagamentoViaCanetaHelper != null && !colecaoInserirPagamentoViaCanetaHelper.isEmpty()){
				
				Iterator iterHelper = colecaoInserirPagamentoViaCanetaHelper.iterator();
				
				while (iterHelper.hasNext()) {
					
					numeroIndice = 0;
					boolean flagTerminou = false;
					
					InserirPagamentoViaCanetaHelper helper = (InserirPagamentoViaCanetaHelper) iterHelper.next();
					RegistroHelperCodigoBarras registroHelperCodigoBarras = helper.getRegistroHelperCodigoBarras();
					
					Integer idCliente = 
						new Integer(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento2());

					int anoMes = 
						Util.formatarMesAnoParaAnoMes(Integer.parseInt(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento4()));
					
					Integer numeroSequencial = 
						new Integer(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento6());
					
					BigDecimal valorPagamento = 
						Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
							registroHelperCodigoBarras.getValorPagamento());
					
					while(!flagTerminou){
						
						Collection faturaItens = 
							repositorioFaturamento.pesquisarFaturaItem(
								idCliente, 
								anoMes, 
								numeroSequencial,
								valorPagamento,
								numeroIndice,
								quantidadeRegistros);

						// verifica se a coleção é diferente de nula
						if (faturaItens != null && !faturaItens.isEmpty()) {
							
							if (faturaItens.size() < quantidadeRegistros) {
								flagTerminou = true;
							}
							
							Iterator faturaItensIterator = faturaItens.iterator();
							
							while (faturaItensIterator.hasNext()) {
								
								Object[] faturaItem = (Object[]) faturaItensIterator.next();
								// inicializa as variaveis que veio da pesquisa
								Integer idContaPesquisa = null;
								Integer idImovelPesquisa = null;
								Integer idLocalidadePesquisa = null;
								BigDecimal valorConta = null;
								Integer idFatura = null;
								
								// verifica o valor da conta
								if (faturaItem[0] != null) {
									valorConta = (BigDecimal) faturaItem[0];
								}
								// verifica o id da conta
								if (faturaItem[1] != null) {
									idContaPesquisa = (Integer) faturaItem[1];
								}
								// verifica o id da localidade
								if (faturaItem[2] != null) {
									idLocalidadePesquisa = (Integer) faturaItem[2];
								}
								// verifica o id do imovel
								if (faturaItem[3] != null) {
									idImovelPesquisa = (Integer) faturaItem[3];
								}
								// verifica o id da localidade de Conta Histórico
								if (faturaItem[4] != null) {
									idLocalidadePesquisa = (Integer) faturaItem[4];
								}
								
								// verifica o id do imovel de Conta Histórico
								if (faturaItem[5] != null) {
									idImovelPesquisa = (Integer) faturaItem[5];
								}
								// verifica o id da fatura
								if (faturaItem[6] != null) {
									idFatura = (Integer) faturaItem[6];
								}

								// cria o objeto pagamento para setar os dados
								Pagamento pagamento = new Pagamento();
								pagamento.setAnoMesReferenciaPagamento(anoMes);
								// caso o ano mes da data de pagamento seja maior que o ano mes de arrecadação da
								// tabela sistema parametro então seta o ano mes da data de pagamento
								Integer anoMesPagamento = Util.recuperaAnoMesDaData(dataPagamento);
								if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {
									pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);
								} else {
									// caso contrario seta o o ano mes
									// arrecadação da tabela sistema parametro
									pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
								}
								pagamento.setValorPagamento(valorConta);
								pagamento.setDataPagamento(dataPagamento);
								pagamento.setPagamentoSituacaoAtual(null);
								pagamento.setPagamentoSituacaoAnterior(null);
								pagamento.setDebitoTipo(null);
								// verifica se o id da conta é diferente de nulo
								if (idContaPesquisa != null) {
									Conta conta = new Conta();
									conta.setId(idContaPesquisa);
									
									ContaGeral contaGeral = new ContaGeral();
									contaGeral.setConta(conta);
									pagamento.setContaGeral(contaGeral);
								} else {
									pagamento.setContaGeral(null);
								}
								pagamento.setGuiaPagamento(null);

								pagamento.setDebitoACobrarGeral(null);

								if (idLocalidadePesquisa != null) {
									Localidade localidade = new Localidade();
									localidade.setId(idLocalidadePesquisa);
									pagamento.setLocalidade(localidade);
								} else {
									pagamento.setLocalidade(null);
								}
								DocumentoTipo documentoTipo = new DocumentoTipo();
								documentoTipo.setId(DocumentoTipo.CONTA);
								documentoTipo.setDescricaoDocumentoTipo(ConstantesSistema.TIPO_PAGAMENTO_FATURA_CLIENTE_RESPONSAVEL);
								pagamento.setDocumentoTipo(documentoTipo);

								// seta o id do aviso bancario
								pagamento.setAvisoBancario(avisoBancario);

								// seta o imovel
								if (idImovelPesquisa != null) {
									Imovel imovel = new Imovel();
									imovel.setId(idImovelPesquisa);
									pagamento.setImovel(imovel);
								} else {
									pagamento.setImovel(null);
								}

								pagamento.setArrecadadorMovimentoItem(null);

								ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
								arrecadacaoForma.setId(idFormaArrecadacao);
								pagamento.setArrecadacaoForma(arrecadacaoForma);
								pagamento.setCliente(null);
								pagamento.setUltimaAlteracao(new Date());

								Fatura fatura = new Fatura();
								fatura.setId(idFatura);
								pagamento.setFatura(fatura);
								
								pagamento.setCobrancaDocumento(null);
								
								DocumentoTipo documentoAgregador = new DocumentoTipo();
								documentoAgregador.setId(DocumentoTipo.FATURA_CLIENTE);
								pagamento.setDocumentoTipoAgregador(documentoAgregador);
								
								pagamento.setDataProcessamento(new Date());
								pagamento.setAvisoBancario(avisoBancario);
								
								// Acumula o valor do pagamento
								valorPagamentoAcumulado = 
									valorPagamentoAcumulado.add(pagamento.getValorPagamento());
								
								this.inserirPagamentosEspeciais(pagamento);
							}//
							
							faturaItens.clear();
							faturaItens = null;
							
						}else{//fim do (faturaItens != null && !faturaItens.isEmpty())
							flagTerminou = true;
						}
						
						numeroIndice = numeroIndice + quantidadeRegistros;
					}//fim do while !flagTerminou
				}
			}
				
			
			// Atualiza o valor do aviso bancário
			avisoBancario.setValorArrecadacaoCalculado(
				avisoBancario.getValorArrecadacaoCalculado().add(valorPagamentoAcumulado));
			
			avisoBancario.setUltimaAlteracao(new Date());

			this.getControladorUtil().atualizar(avisoBancario);
			
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,idUnidadeIniciada, false);
		        
        } catch (Exception ex) {
        	sessionContext.setRollbackOnly();
            ex.printStackTrace();
            getControladorBatch().encerrarUnidadeProcessamentoBatch(ex,idUnidadeIniciada, true);
            throw new EJBException(ex);
		} 
	}
	
	/**
	 * [UC0264] - Distribuir Dados do Código de Barras
	 * [SB0010] - Distribuir Pagamento de Guia de Pagamento com Identificação
	 * @author Hugo Amorim
	 * @date 11/01/2010
	 *
	 * @param registroHelperCodigoBarrasTipoPagamento
	 * @param idPagamento
	 * @return RegistroHelperCodigoBarrasTipoPagamento
	 */
	public RegistroHelperCodigoBarrasTipoPagamento distribuirDadosCodigoBarrasPorTipoPagamento_GUIA_PAGAMENTO_COM_IDENTIFICACAO(
			RegistroHelperCodigoBarrasTipoPagamento registroHelperCodigoBarrasTipoPagamento, String idPagamento) {
		
		// Seta o código da localidade
		registroHelperCodigoBarrasTipoPagamento.setIdPagamento1(idPagamento.substring(0, 3).trim());
		
		/*
		 * Identifica se a matrícula ou o id do cliente foram formatados com 8 ou 9 dígitos
		 * 0 = 8 dígitos
		 * 1 = 9 dígitos
		 */
		String indicadorTamanhoIdentificacao = idPagamento.substring(23, 24).trim();
		
		if (indicadorTamanhoIdentificacao.equals(ConstantesSistema.OITO_DIGITOS)){
			
			//Seta o id do cliente caso tipo do pagamento seja 9
			// Seta a matricula do imovel caso tipo do pagamento seja 1
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 11).trim());
			
			//Seta Identificador da guia de pagamento
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(11, 20).trim());
			
			// Não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(20, 24).trim());
		}
		else{
			
			//Seta o id do cliente caso tipo do pagamento seja 9
			// Seta a matricula do imovel caso tipo do pagamento seja 1
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento2(idPagamento.substring(3, 12).trim());
			
			//Seta Identificador da guia de pagamento
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento3(idPagamento.substring(12, 21).trim());
			
			// Não está sendo utilizado
			registroHelperCodigoBarrasTipoPagamento.setIdPagamento4(idPagamento.substring(21, 24).trim());
		}
		
		
		return registroHelperCodigoBarrasTipoPagamento;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0017] -  Processar Pagamento de Guia de Pagamento com Identificação Matrícula
	 * 
	 * @autor: Hugo Amorim
	 * @data: 11/01/2010
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoMatricula(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();
		Collection colecaoPagamentoParcial = new ArrayList();
		
		
		boolean idLocalidadeInvalida = false;
		boolean matriculaImovelInvalida = false;

		Integer idImovelNaBase = null;
		Integer matriculaImovel = null;
		Integer idLocalidade = null;

		idLocalidadeInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}else{
			idLocalidade = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento1());
		}
		
		
		
		matriculaImovelInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if (matriculaImovelInvalida) {
			descricaoOcorrencia = "MÁTRICULA DO IMÓVEL INVÁLIDA";
		} else {

			// Verifica se existe a matricula do imóvel na base
			matriculaImovel = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());

			try {
				idImovelNaBase = repositorioImovel
						.recuperarMatriculaImovel(new Integer(matriculaImovel));
			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if (idImovelNaBase == null) {
				descricaoOcorrencia = "MATRÍCULA DO IMÓVEL NÃO CADASTRADA";
			}
		}


		if (descricaoOcorrencia.equals("OK")) {


			Integer idGuiaPagamento =  null;
			GuiaPagamento guiaPagamento = null;

			try {
				
				idGuiaPagamento = this.repositorioArrecadacao
					.pesquisarExistenciaGuiaPagamento(new Integer(registroHelperCodigoBarras
							.getRegistroHelperCodigoBarrasTipoPagamento()
								.getIdPagamento3()));										

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if (idGuiaPagamento == null) {
				descricaoOcorrencia = "GUIA PAGAMENTO INEXISTENTE";
			}else{
				
				FiltroGuiaPagamento filtroGuia = new FiltroGuiaPagamento();
				
				filtroGuia.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));
				
				filtroGuia.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.DEBITO_TIPO);
				
				Collection<GuiaPagamento> colecaoGuias = 
					this.getControladorUtil().pesquisar(filtroGuia, GuiaPagamento.class.getName());
				
				guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuias); 
			}

			
			
			/*
             * Alterado por Hugo Amorim/Rômulo Aurélio/Raphael Rossiter em 02/02/2010 - 
             * OBJ: Gerar os pagamentos associados com a localidade da guia de pagamento e NÃO com
             * a localidade do imóvel.
             */
            if (idGuiaPagamento != null) {

				try {
					idLocalidade = repositorioLocalidade
							.pesquisarIdLocalidadePorGuiaPagamento(idGuiaPagamento);

				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}

			} else {

				try {
					idLocalidade = repositorioLocalidade
							.pesquisarIdLocalidade(idImovelNaBase);

				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}
			}
			
			// Cria o objeto pagamento para setar os dados
			Pagamento pagamento = new Pagamento();
			pagamento.setAnoMesReferenciaPagamento(null);

			/*
			 * Caso o ano mes da data de dedito seja maior que o ano mes de
			 * arrecadação da tabela sistema parametro então seta o ano mes da
			 * data de debito
			 */
			if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {

				pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

			} else {

				/*
				 * caso contrario seta o o ano mes arrecadação da tabela sistema
				 * parametro
				 */
				pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro()
						.getAnoMesArrecadacao());
			}

			pagamento.setValorPagamento(valorPagamento);
			pagamento.setDataPagamento(dataPagamento);
			pagamento.setPagamentoSituacaoAtual(null);
			pagamento.setPagamentoSituacaoAnterior(null);
			
			DebitoTipo debitoTipo = null;
			DocumentoTipo documentoTipo = new DocumentoTipo();
			if(guiaPagamento!=null){
				debitoTipo = guiaPagamento.getDebitoTipo();
				pagamento.setDebitoTipo(debitoTipo);
				pagamento.setGuiaPagamento(guiaPagamento);
			}else{
				FiltroDebitoTipo  filtroDebitoTipo = new FiltroDebitoTipo();
				filtroDebitoTipo.adicionarParametro(new ParametroSimples(
						FiltroDebitoTipo.CODIGO_CONSTANTE, DebitoTipo.GUIA_DE_PAGAMENTO_NAO_ENCONTRADA));
				
				Collection<DebitoTipo> colecaoDebitos = 
					this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());
				
				debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitos); 
				
				pagamento.setDebitoTipo(debitoTipo);
				pagamento.setGuiaPagamento(null);
			}
			pagamento.setContaGeral(null);

			Localidade localidade = new Localidade();
			localidade.setId(idLocalidade);
			pagamento.setLocalidade(localidade);

			// Alterado por Rômulo Aurélio Data: 15/07/2010, Analista Rosana/Aryed
			// quando o tipo de debito for Entrada de Guia é pra inserir 
			// o tipo de documento como guia de Parcelamento
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
			
			pagamento.setDocumentoTipo(documentoTipo);

			pagamento.setAvisoBancario(null);

			if (idImovelNaBase != null) {
				Imovel imovel = new Imovel();
				imovel.setId(idImovelNaBase);
				pagamento.setImovel(imovel);
			} else {
				pagamento.setImovel(null);
			}

			pagamento.setArrecadadorMovimentoItem(null);

			ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
			arrecadacaoForma.setId(idFormaArrecadacao);
			pagamento.setArrecadacaoForma(arrecadacaoForma);
			pagamento.setCliente(null);
			pagamento.setUltimaAlteracao(new Date());
			pagamento.setFatura(null);
			pagamento.setCobrancaDocumento(null);
		
			DocumentoTipo documentoAgregador = new DocumentoTipo();
			documentoAgregador.setId(DocumentoTipo.GUIA_PAGAMENTO);
			pagamento.setDocumentoTipoAgregador(documentoAgregador);
			
			pagamento.setDataProcessamento(new Date());
			
			colecaoPagamentos.add(pagamento);
			
			/*
			 * Caso o pagamento tenha sido incluído para uma guia existente e que tenha uma conta 
			 * associada (CNTA_ID da tabela GUIA_PAGAMENTO_ITEM com valor diferente de nulo)
			 */
			if (idGuiaPagamento != null){
				
				Conta contaPagamentoParcial = null;
				
				try {
					
					contaPagamentoParcial = repositorioArrecadacao
                    .pesquisarContaParaPagamentoParcial(idGuiaPagamento);

                } catch (ErroRepositorioException e) {
                    throw new ControladorException("erro.sistema", e);
                }
                
                if (contaPagamentoParcial != null){
                	
                	//[SB0016] Processar Pagamento Parcial de Conta
                	ProcessarPagamentoParcialContaHelper helper = 
                		this.processarPagamentoParcialConta(contaPagamentoParcial, valorPagamento);
                	
                	colecaoPagamentoParcial.add(helper);
                }
			}
		} else {

			// Atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		pagamentoHelperCodigoBarras.setColecaoProcessarPagamentoParcialContaHelper(colecaoPagamentoParcial);

		return pagamentoHelperCodigoBarras;
	}
	
	/**
	 * [UC0259] - Processar Pagamento com Código de Barras
	 * 
	 * [SB0018] -  Processar Pagamento de Guia de Pagamento com Identificação Cliente
	 * 
	 * @autor: Hugo Amorim
	 * @data: 11/01/2010
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCodigoBarrasGuiaPagamentoComIdentificacaoCliente(
			RegistroHelperCodigoBarras registroHelperCodigoBarras,
			SistemaParametro sistemaParametro, Date dataPagamento,
			Integer anoMesPagamento, BigDecimal valorPagamento,
			Integer idFormaArrecadacao) throws ControladorException {

		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		String indicadorAceitacaoRegistro = "1";

		Collection colecaoPagamentos = new ArrayList();
		Collection colecaoPagamentoParcial = new ArrayList();		
		
		boolean idLocalidadeInvalida = false;
		boolean clienteInvalido = false;

		Integer idLocalidade = null;
		Integer idCliente = null;
		
		/**
		 * Guia de pagamento não vinha sendo preenchida no momento do processamento
		 * do pagamento
		 * 
		 * @author Wellington Rocha
		 * @date 28/11/2012*/
		Integer idGuiaPagamento =  null;
		GuiaPagamento guiaPagamento = null;
		Cliente cliente = null;
		DebitoTipo debitoTipo = null;
		
		
		idLocalidadeInvalida = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento1());

		if (idLocalidadeInvalida) {
			descricaoOcorrencia = "CÓDIGO DA LOCALIDADE NÃO NUMÉRICA";
		}
		else{
			idLocalidade = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento1());
		}
			
		clienteInvalido = Util
				.validarValorNaoNumerico(registroHelperCodigoBarras
						.getRegistroHelperCodigoBarrasTipoPagamento()
						.getIdPagamento2());

		if (clienteInvalido) {
			descricaoOcorrencia = "CÓDIGO DO CLIENTE NÃO NUMÉRICO";
		}
		else{
			idCliente = new Integer(registroHelperCodigoBarras
					.getRegistroHelperCodigoBarrasTipoPagamento()
					.getIdPagamento2());
		}

		if (descricaoOcorrencia.equals("OK")) {
		   
			try {
				
				idGuiaPagamento = this.repositorioArrecadacao.pesquisarExistenciaGuiaPagamento(new Integer(registroHelperCodigoBarras
				.getRegistroHelperCodigoBarrasTipoPagamento().getIdPagamento3()));										

			} catch (ErroRepositorioException e) {
				e.printStackTrace();
				throw new ControladorException("erro.sistema", e);
			}

			if (idGuiaPagamento == null) {
				
				descricaoOcorrencia = "GUIA PAGAMENTO INEXISTENTE";
				
				//CARREGANDO O CLIENTE QUE ESTA VINDO NO CÓDIGO DE BARRAS
				FiltroCliente filtroCliente = new FiltroCliente();
				
				filtroCliente.adicionarParametro(new ParametroSimples(FiltroCliente.ID, idCliente));
				
				Collection<Cliente> colecaoClientes = this.getControladorUtil().pesquisar(filtroCliente, Cliente.class.getName());
				
				if (colecaoClientes == null || colecaoClientes.isEmpty()){
					
					clienteInvalido = true;
				}
				else{
				
					cliente = (Cliente) Util.retonarObjetoDeColecao(colecaoClientes);
				}
				
				if (!clienteInvalido){
					
					//CARREGANDO A LOCALIDADE QUE ESTA VINDO NO CÓDIGO DE BARRAS
					FiltroLocalidade filtroLocalidade = new FiltroLocalidade();

					filtroLocalidade.adicionarParametro(new ParametroSimples(FiltroLocalidade.ID, idLocalidade));

					Collection colecaoLocalidade = getControladorUtil().pesquisar(filtroLocalidade, Localidade.class.getName());
					
					if (colecaoLocalidade == null || colecaoLocalidade.isEmpty()) {
						
						FiltroLocalidade filtroLocalidadeSede = new FiltroLocalidade();

						filtroLocalidadeSede.adicionarParametro(new ParametroSimples(
						FiltroLocalidade.INDICADOR_LOCALIDADE_SEDE, ConstantesSistema.SIM));

						Collection colecaoLocalidadeSede = getControladorUtil().pesquisar(
						filtroLocalidadeSede, Localidade.class.getName());
						
						Localidade localidadeSede = (Localidade) Util.retonarObjetoDeColecao(colecaoLocalidadeSede);
						
						idLocalidade = localidadeSede.getId();
					}
					
					//CARREGANDO O DEBITO TIPO PARA GUIA DE PAGAMENTO NAO ENCONTRADA
					FiltroDebitoTipo  filtroDebitoTipo = new FiltroDebitoTipo();
					filtroDebitoTipo.adicionarParametro(new ParametroSimples(FiltroDebitoTipo.CODIGO_CONSTANTE, 
					DebitoTipo.GUIA_DE_PAGAMENTO_NAO_ENCONTRADA));
					
					Collection<DebitoTipo> colecaoDebitos = this.getControladorUtil().pesquisar(filtroDebitoTipo, DebitoTipo.class.getName());
					
					debitoTipo = (DebitoTipo) Util.retonarObjetoDeColecao(colecaoDebitos);
				}
			}
			else{
				
				//CARREGANDO OS DADOS DA GUIA DE PAGAMENTO
				FiltroGuiaPagamento filtroGuia = new FiltroGuiaPagamento();
				
				filtroGuia.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));
				
				filtroGuia.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.DEBITO_TIPO);
				filtroGuia.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.LOCALIDADE);
				filtroGuia.adicionarCaminhoParaCarregamentoEntidade(FiltroGuiaPagamento.CLIENTE);
				
				Collection<GuiaPagamento> colecaoGuias = this.getControladorUtil().pesquisar(filtroGuia, GuiaPagamento.class.getName());
				
				guiaPagamento = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuias); 
				
				//LOCALIDADE DA GUIA DE PAGAMENTO
				idLocalidade = guiaPagamento.getLocalidade().getId();
				
				//CLIENTE DA GUIA DE PAGAMENTO
				cliente = guiaPagamento.getCliente();
				
				//DEBITO TIPO DA GUIA DE PAGAMENTO
				debitoTipo = guiaPagamento.getDebitoTipo();
			}
			
			
			if (!clienteInvalido){
				
				//Cria o objeto pagamento para setar os dados
				Pagamento pagamento = new Pagamento();
				pagamento.setAnoMesReferenciaPagamento(null);

				/*
				 * Caso o ano mes da data de dedito seja maior que o ano mes de
				 * arrecadação da tabela sistema parametro então seta o ano mes da
				 * data de debito
				 */
				if (anoMesPagamento > getSistemaParametro().getAnoMesArrecadacao()) {

					pagamento.setAnoMesReferenciaArrecadacao(anoMesPagamento);

				} 
				else {

					/*
					 * caso contrario seta o o ano mes arrecadação da tabela sistema
					 * parametro
					 */
					pagamento.setAnoMesReferenciaArrecadacao(getSistemaParametro().getAnoMesArrecadacao());
				}
				

				pagamento.setValorPagamento(valorPagamento);
				pagamento.setDataPagamento(dataPagamento);
				pagamento.setPagamentoSituacaoAtual(null);
				pagamento.setPagamentoSituacaoAnterior(null);
				
				pagamento.setDebitoTipo(debitoTipo);
				
				pagamento.setContaGeral(null);

				Localidade localidade = new Localidade();
				localidade.setId(idLocalidade);
				pagamento.setLocalidade(localidade);


				// Alterado por Rômulo Aurélio Data: 15/07/2010, Analista Rosana/Aryed
				// quando o tipo de debito for Entrada de Guia é pra inserir 
				// o tipo de documento como guia de Parcelamento
				DocumentoTipo documentoTipo = new DocumentoTipo();
				documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
				
				pagamento.setDocumentoTipo(documentoTipo);

				pagamento.setAvisoBancario(null);
				pagamento.setImovel(null);

				pagamento.setArrecadadorMovimentoItem(null);

				ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
				arrecadacaoForma.setId(idFormaArrecadacao);
				pagamento.setArrecadacaoForma(arrecadacaoForma);
				
				pagamento.setCliente(cliente);
				

				/**
				 * Guia de pagamento não vinha sendo preenchida no momento do processamento
				 * do pagamento
				 * 
				 * @author Wellington Rocha
				 * @date 28/11/2012*/
				pagamento.setGuiaPagamento(guiaPagamento);
				
				
				pagamento.setUltimaAlteracao(new Date());
				pagamento.setFatura(null);
				pagamento.setCobrancaDocumento(null);
			
				DocumentoTipo documentoAgregador = new DocumentoTipo();
				documentoAgregador.setId(DocumentoTipo.GUIA_PAGAMENTO);
				pagamento.setDocumentoTipoAgregador(documentoAgregador);
				
				pagamento.setDataProcessamento(new Date());
				
				colecaoPagamentos.add(pagamento);
			}
			else{
				
				//Atribui o valor 2(NÃO) ao indicador aceitacao registro
				indicadorAceitacaoRegistro = "2";
			}
		} 
		else {

			// Atribui o valor 2(NÃO) ao indicador aceitacao registro
			indicadorAceitacaoRegistro = "2";
		}

		// Seta os parametros que serão retornados
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro);
		pagamentoHelperCodigoBarras.setColecaoProcessarPagamentoParcialContaHelper(colecaoPagamentoParcial);

		return pagamentoHelperCodigoBarras;
	}
	
	/**
	 * [UC0927]  Confirmar Cartão de Crédito/Débito
	 *
	 * @author Raphael Rossiter
	 * @date 18/01/2010
	 *
	 * @param codigoAgente
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarContaBancaria(Short codigoAgente) throws ControladorException {
		
		Integer idContaBancaria = null;
		
		try {
			
			idContaBancaria = repositorioArrecadacao
			.pesquisarIdDepositoArrecadacao(codigoAgente.intValue(), null);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		
		return idContaBancaria;
	}
	
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [FS0001  Verificar existência do arrecadador]
	 * [FS0002  Verificar arrecadação forma cartão crédito]
	 *
	 * @author Raphael Rossiter
	 * @date 26/01/2010
	 *
	 * @param idArrecadador
	 * @return Arrecadador
	 * @throws ControladorException
	 */
	public Arrecadador verificarArrecadacaoFormaCartaoCredito(Integer idArrecadador) 
		throws ControladorException {
		
		FiltroArrecadador filtroArrecadador = new FiltroArrecadador();

		filtroArrecadador.adicionarParametro(new ParametroSimples(
		FiltroArrecadador.ID, idArrecadador));
		
		filtroArrecadador.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection arrecadadorEncontrado = this.getControladorUtil().pesquisar(
		filtroArrecadador, Arrecadador.class.getName());
		
		if (arrecadadorEncontrado == null || arrecadadorEncontrado.isEmpty()) {
			
			//[FS0001  Verificar existência do arrecadador]
			throw new ControladorException("atencao.pesquisa_inexistente", null, "Arrecadador");
		}
		
		Arrecadador arrecadador = (Arrecadador) Util.retonarObjetoDeColecao(arrecadadorEncontrado);
		
		ArrecadadorContratoTarifa arrecadadorContratoTarifa = this.getControladorCobranca()
		.pesquisarArrecadadorContratoTarifa(arrecadador.getId(), ArrecadacaoForma.CARTAO_CREDITO);
		
		if (arrecadadorContratoTarifa == null){
			
			//[FS0002  Verificar arrecadação forma cartão crédito];
			throw new ControladorException("atencao.arrecadador_nao_cartao_credito");
		}
		
		
		return arrecadador;
 	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 *
	 * @author Raphael Rossiter
	 * @date 29/01/2010
	 *
	 * @param arrecadador
	 * @param stringBuilderTxt
	 * @param quantidadeRegistros
	 * @param usuarioLogado
	 * @throws ControladorException
	 */
	public void registrarMovimentoCartaoCredito(Arrecadador arrecadador, StringBuilder stringBuilderTxt,
			int quantidadeRegistros, Usuario usuarioLogado) throws ControladorException {
		
		boolean sucesso = true;
		
		//HEADER
        RegistroCartaoCreditoHeaderHelper header = null;
        
        EnvioEmail envioEmailError = null;
        
        int aux = 1;
        
		try{
			
			envioEmailError = getControladorCadastro().pesquisarEnvioEmail(
            EnvioEmail.REGISTRAR_MOVIMENTO_CARTAO_CREDITO_COM_ERRO);
			
			//tamanho de cada linha da string builder
            int tamanhoLinha = 251;
            
            // inicio da linha da string builder
            Integer inicioLinha = 0;
            
            //TRAILLER
            RegistroCartaoCreditoTraillerHelper trailler = null;
            
            //Para guardar o código do registro no momento do processamento
            Short codigoRegistro = null;

            // cria uma coleção com as linhas do txt
            Collection linhas = new ArrayList();
            // cria uma coleção de avisos bancarios
            Collection avisosBancarios = new ArrayList();
            // cria uma coleção de pagamentos
            Collection pagamentos = new ArrayList(); 

            /*
             * A quantidade de registros do movimento será a quantidade total menos os registros
             * de header e trailler.
             */
            Integer quantidadeRegistrosDeMovimento = quantidadeRegistros - 2;

            // cria um boolean que verifica se é a primeira linha
            boolean primeiraLinha = true;

            
            
            //LENDO O ARQUIVO LINHA POR LINHA
            for (int i = 1; i <= quantidadeRegistros; i++) {
                
                String linha = stringBuilderTxt.substring(inicioLinha, inicioLinha + tamanhoLinha);
                
                /*
                 * Incrementa a primeira linha.O +1 é para tirar o
                 * System.getProperty("line.separator")
                 */
                inicioLinha = inicioLinha + tamanhoLinha + 1;

                //Recupera o código do registro
                codigoRegistro = Short.valueOf(linha.substring(0, 1));

                
                //VERIFICANDO SE O SISTEMA JÁ PROCESSOU A PRIMEIRA LINHA
                if (primeiraLinha) {
                    
                    
                    /*
                     * PROCESSANDO PRIMEIRA LINHA
                     * [SB0001  Inserir o movimento do arrecadador]
                     */
                	header = this.validarArquivoMovimentoCartaoCreditoHeader(arrecadador, codigoRegistro, linha);
                	
                    //PRIMEIRA LINHA PROCESSADA
                    primeiraLinha = false;

                } 
                else {
                	
                	
                	/*
                     * VALIDANDO O MOVIMENTO LINHA POR LINHA
                     * 
                     * [SB0001  Inserir o movimento do arrecadador]
                     * [FS0005  Verificar a existência do registro código 9]
                     * 
                     * O sistema lê o arquivo de movimento de arrecadador seqüencialmente até encontrar o registro 
                	 * código 9, contando a quantidade total registros retirando os registros códigos 0 e 9, 
                	 * guardando os registros lidos em uma coleção. [FS0005  Verificar a existência do 
                	 * registro código 9].
                     */
                	trailler = this.validarArquivoMovimentoCartaoCreditoTrailler(codigoRegistro, linha,
                	quantidadeRegistrosDeMovimento);
                	
                	if (trailler == null){
                		linhas.add(linha);
                	}
                }
            }
            //FINAL DO LOOP PARA LEITURA DO ARQUIVO
            
            
            /*
             * VALIDANDO O MOVIMENTO LINHA POR LINHA
             * 
             * [SB0001  Inserir o movimento do arrecadador]
             * [FS0005  Verificar a existência do registro código 9]
             */
            if (trailler == null) {
                
            	throw new ControladorException("atencao.arquivo.movimento.nao.codigo.nove");
            }
            
            
            //[SB0001  Inserir o movimento do arrecadador]
            ArrecadadorMovimento arrecadadorMovimento = this.inserirArrecadadorMovimentoCartaoCredito(
            arrecadador, header, trailler);
            
            //Valor total dos pagamentos
            BigDecimal valorTotalPagamentos = BigDecimal.ZERO;
            
            /*
             * Para cada registro guardado na coleção, o sistema:
             * 
             * 4.1.	Atribui o valor OK ao campo Descrição da Ocorrência do Movimento;
             * 4.2.	Atribui o valor 1 (SIM) ao Indicador de Aceitação do Registro do Movimento;

             */
            String descricaoOcorrenciaMovimento = "OK";
            Short indicadorAceitacaoRegistroMovimento = ConstantesSistema.SIM;
            MovimentoCartaoRejeita movimentoCartaoRejeita = null;
            
            //OBTENDO OS PARÂMETROS DO SISTEMA
            SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
            
            Iterator linhaIterator = linhas.iterator();
            
            while (linhaIterator.hasNext()) {

                aux++;
                
                descricaoOcorrenciaMovimento = "OK";
                
                indicadorAceitacaoRegistroMovimento = ConstantesSistema.SIM;
                
                movimentoCartaoRejeita = null;

                // Recupera a linha da coleção
                String linhaRegistro = (String) linhaIterator.next();
                
                //Recupera o código do registro
                codigoRegistro = Short.valueOf(linhaRegistro.substring(0, 1));
                
                /*
                 * Caso o tipo de registro = 1 (C01 = 1), o sistema distribui os dados do conteúdo do registro 
                 * de movimento do arrecadador, 
                 * 
                 * [SB0002 Distribuir Dados do Registro de Movimento do Arrecadador.
                 * 
                 * Caso o tipo de registro = 2 (C01 = 2), o sistema distribui os dados do conteúdo do registro 
                 * de movimento do arrecadador, 
                 * 
                 * [SB0006 Distribuir Dados do Registro de Movimento do Arrecadador.
                 */
                if (codigoRegistro.equals(RegistroCartaoCreditoTipo1Helper.CODIGO_MOVIMENTO_TIPO_1) ||
                	codigoRegistro.equals(RegistroCartaoCreditoTipo2Helper.CODIGO_MOVIMENTO_TIPO_2)){
                	
                	RegistroCartaoCreditoTipo1Helper movimentoTipo1 = null;
                	RegistroCartaoCreditoTipo2Helper movimentoTipo2 = null;
                	
                	PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = null;
                	
                	if (codigoRegistro.equals(RegistroCartaoCreditoTipo1Helper.CODIGO_MOVIMENTO_TIPO_1)){
                		
                		//DISTRIBUINDO OS DADOS DO MOVIMENTO PARA O TIPO 1
                    	movimentoTipo1 = this.distribuirDadosArquivoMovimentoCartaoCreditoTipo1(codigoRegistro, linhaRegistro); 
                    	
                    	//[SB0005]  Processar Pagamento Cartão de Crédito
                    	pagamentoHelperCodigoBarras = this.processarPagamentosCartaoCreditoTipo1(
                    	arrecadador, header, movimentoTipo1, getSistemaParametro(), usuarioLogado);
                    	
                    	descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras.getDescricaoOcorrencia();
                        
                        indicadorAceitacaoRegistroMovimento = Short.valueOf(pagamentoHelperCodigoBarras.getIndicadorAceitacaoRegistro());
                	}
                	else{
                		
                		//DISTRIBUINDO OS DADOS DO MOVIMENTO PARA O TIPO 2
                    	movimentoTipo2 = this.distribuirDadosArquivoMovimentoCartaoCreditoTipo2(codigoRegistro, linhaRegistro); 
                    	
                    	//[SB0005]  Processar Pagamento Cartão de Crédito
                    	pagamentoHelperCodigoBarras = this.processarPagamentosCartaoCreditoTipo2(
                    	arrecadador, header, movimentoTipo2, getSistemaParametro(), usuarioLogado);
                    	
                    	descricaoOcorrenciaMovimento = pagamentoHelperCodigoBarras.getDescricaoOcorrencia();
                        
                        indicadorAceitacaoRegistroMovimento = Short.valueOf(pagamentoHelperCodigoBarras.getIndicadorAceitacaoRegistro());
                        
                        movimentoCartaoRejeita = pagamentoHelperCodigoBarras.getMovimentoCartaoRejeita();
                	}
                	
                	
                    
                    //[SB0004]  Inserir o item de movimento do arrecadador
                    ArrecadadorMovimentoItem arrecadadorMovimentoItem = this.inserirArrecadadorMovimentoItemCartaoCredito(arrecadadorMovimento, linhaRegistro, 
                    descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, movimentoCartaoRejeita);
                    
                    
                    //APENAS OS REGISTROS DO TIPO 1 IRÃO GERAR PAGAMENTOS
                    if (codigoRegistro.equals(RegistroCartaoCreditoTipo1Helper.CODIGO_MOVIMENTO_TIPO_1) && 
                       (descricaoOcorrenciaMovimento.equals("OK") || descricaoOcorrenciaMovimento.equals("CARTAO DE DEBITO"))){
                        
                    	AvisoBancario avisoBancario = null;
                    	
                    	if (descricaoOcorrenciaMovimento.equals("CARTAO DE DEBITO")){
                    		
                    		/*
                    		 * [SB0007]  Processar Pagamento Cartão de Débito
                    		 * 
                    		 * Caso já exista o aviso bancário o sistema atualiza o valor da arrecadação e da devolução do aviso bancário 
                    		 * (tabela AVISO_BANCARIO) conforme descrito abaixo (a partir da tabela AVISO_BANCÁRIO com ARRC_ID=Campo A05, 
                    		 * AVBC_DTLANCAMENTO=Campo C10 e ARFM_ID que tenha o ARFM_CDARRECADACAOFORMA= Cartão de Débito 
                    		 * (AVBC_DTPREVISTA=Data Prevista para o crédito ou AVBC_DTREALIZADA=Data Prevista para o crédito) e 
                    		 * (AVBC_VLARRECADACAOCALCULADO com o valor zero ou com ARMV_ID com o id do movimento que está sendo processado))
                    		 */
                    		try {
                                
                        		avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(
                        		arrecadador.getCodigoAgente().intValue(), new Date(), 
                        		movimentoTipo1.getDataPrevistaPagamento(), arrecadadorMovimento.getId(), 
                        		ArrecadacaoForma.CARTAO_DEBITO);
                        		
                            } catch (ErroRepositorioException e) {
                                throw new ControladorException(
                                        "erro.sistema", e);
                            }
                            
                            
                            if (avisoBancario != null){
                            	
                            	//ACUMULANDO O VALOR DA ARRECADAÇÃO DO AVISO BANCÁRIO
                            	avisoBancario = this.acumularValorArrecadacaoAvisoBancarioCartaoDebito(avisoBancario,
                            	movimentoTipo1.getValorBruto());
                            	
                            	//ARRECADADOR MOVIMENTO
                                avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
                                
                                //ÚLTIMA ALTERAÇÃO
                                avisoBancario.setUltimaAlteracao(new Date());
                                
                                //ATUALIZANDO O AVISO BANCÁRIO
                                this.getControladorUtil().atualizar(avisoBancario);
                                
                            }
                            else{
                            	
                            	descricaoOcorrenciaMovimento = "CARTAO DE DEBITO NAO CONFIRMADO";
                            	indicadorAceitacaoRegistroMovimento = ConstantesSistema.NAO;

                                // INSERINDO O ITEM DO MOVIMENTO DO ARRECADADOR
                                this.inserirArrecadadorMovimentoItemCartaoCredito(arrecadadorMovimento, linhaRegistro, 
                                descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, null);
                            }
                    	}
                    	else{
                    		
                    		/*
                        	 * Caso já exista o aviso bancário o sistema atualiza o valor da arrecadação e da devolução 
                        	 * do aviso bancário (tabela AVISO_BANCARIO) conforme descrito abaixo (a partir da tabela 
                        	 * AVISO_BANCÁRIO com ARRC_ID=Campo A05, AVBC_DTLANCAMENTO=Campo C10 e ARFM_ID que tenha o 
                        	 * ARFM_CDARRECADACAOFORMA= Cartão de Crédito (AVBC_DTPREVISTA=Data Prevista para o 
                        	 * crédito ou AVBC_DTREALIZADA=Data Prevista para o crédito) e (AVBC_VLARRECADACAOCALCULADO 
                        	 * com o valor zero ou com ARMV_ID com o id do movimento que está sendo processado)).
                        	 */
                    		try {
                                
                        		avisoBancario = repositorioArrecadacao.pesquisarAvisoBancario(
                        		arrecadador.getCodigoAgente().intValue(), new Date(), 
                        		movimentoTipo1.getDataPrevistaPagamento(), arrecadadorMovimento.getId(), 
                        		ArrecadacaoForma.CARTAO_CREDITO);
                        		
                            } catch (ErroRepositorioException e) {
                                throw new ControladorException(
                                        "erro.sistema", e);
                            }
                            
                            //SEMPRE VIRÁ APENAS UM PAGAMENTO 
                        	Collection pagamentosCodigoBarras = pagamentoHelperCodigoBarras
                            .getColecaoPagamentos();
                            
                        	Pagamento pagamento = (Pagamento) Util.retonarObjetoDeColecao(pagamentosCodigoBarras);
                        	
                        	//AVISO BANCÁRIO
                        	pagamento.setAvisoBancario(avisoBancario);

                        	//ARRECADADOR MOVIMENTO ÍTEM
                            pagamento.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
                            
                        	
                            //O sistema atualiza o valor da arrecadação do aviso bancário
                            if (avisoBancario != null) {
                            	
                            	//ACUMULANDO O VALOR DA ARRECADAÇÃO DO AVISO BANCÁRIO
                            	avisoBancario = this.acumularValorArrecadacaoAvisoBancarioCartaoCredito(avisoBancario,
                            	pagamento.getValorPagamento());
                            	
                                //ARRECADADOR MOVIMENTO
                                avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);
                                
                                //ÚLTIMA ALTERAÇÃO
                                avisoBancario.setUltimaAlteracao(new Date());
                                
                                //ATUALIZANDO O AVISO BANCÁRIO
                                this.getControladorUtil().atualizar(avisoBancario);
                                
                                //CALCULANDO O VALOR DA DEDUÇÃO DO AVISO BANCÁRIO
                                BigDecimal valorDeducao = this.getControladorCobranca().calcularValorDeducao(
                                arrecadador.getId(), pagamento.getValorPagamento(),
                                ArrecadacaoForma.CARTAO_CREDITO);
                                
                                //GERAR/ATUALIZAR VALOR DA DEDUÇÃO DO AVISO BANCÁRIO
                                this.getControladorCobranca().gerarAtualizarAvisoDeducoes(avisoBancario, valorDeducao);
                            } 
                            else {
                                
                            	/*
                                 * Seta o valor da data prevista para quando for inserir o
                                 * pagamento saber de que aviso bancário o pagamento está
                                 * relacionado.
                                 */
                                 pagamento.setDataPrevistaCreditoHelper(movimentoTipo1.getDataPrevistaPagamento());
                                 
                                 
                                 /*
                                  * Caso já exista na coleção de avisos bancários para o movimento ocorrência com a 
                                  * data prevista para o crédito, o sistema atualiza o valor da arrecadação e 
                                  * da devolução do aviso bancário na ocorrência da coleção de avisos bancários.
                                  */
                                 Iterator avisosBancarioIterator = avisosBancarios.iterator();
                                 
    		                     boolean achou = false;
    		                     
    		                     while (avisosBancarioIterator.hasNext()) {
    		                         
    		                    	 AvisoBancario avisoBancarioDaColecao = (AvisoBancario) avisosBancarioIterator.next();
    		                         
    		                    	 /*
    		                    	  * 1º CONDIÇÃO
    		                    	  * 
    		                    	  * A data prevista do aviso tem que ser igual a data prevista do pagamento
    		                    	  */
    		                    	 boolean comparaDataIguais = Util.datasIguais(avisoBancarioDaColecao
    		                         .getDataPrevista(), movimentoTipo1.getDataPrevistaPagamento());
    		                         
    		                    	 /*
    		                    	  * 2º CONDIÇÃO
    		                    	  * 
    		                    	  * A forma de arrecadação tem que ser igual a cartão de crédito.
    		                    	  */
    		                         boolean formasArrecadacaoIguais = avisoBancarioDaColecao
    		                         .getArrecadacaoForma().getId().intValue() == ArrecadacaoForma.CARTAO_CREDITO;
    		                         
    		                         if (comparaDataIguais && formasArrecadacaoIguais) {
    		
    		                        	 //ACUMULANDO O VALOR DA ARRECADAÇÃO DO AVISO BANCÁRIO
    		                         	 avisoBancario = this.acumularValorArrecadacaoAvisoBancarioCartaoCredito(avisoBancarioDaColecao,
    		                         	 pagamento.getValorPagamento());
    		                        	 
    		                             achou = true;
    		                             break;
    		                         }
    		                     }
    		                     
    		                     if (!achou) {
    		                     	
    		                    	 //A data de lançamento do aviso será a data atual.
    		                    	 RegistroHelperCodigoA registroHelperCodigoA = new RegistroHelperCodigoA();
    		                    	 
    		                    	 //UTLIZADO PARA SETAR A DATA DE LANÇAMENTO DO AVISO BANCÁRIO
    		                    	 registroHelperCodigoA.setDataGeracaoArquivo(Util.formatarDataAAAAMMDD(new Date()));
    		                    	 
    		                    	 //UTILIZADO PARA OBTER OS DADOS DO ARRECADADOR
    		                    	 registroHelperCodigoA.setCodigoBanco(arrecadador.getCodigoAgente().toString());
    		                    	 
    		                    	 /*
    		                    	  * [UC0242] - Registrar Movimento dos Arrecadadores 
    		                    	  * [SF0008] - Gerar Ocorrência na coleção de Avisos Bancários
    		                    	  */
    		                         avisoBancario = gerarOcorrenciaAvisoBancario(arrecadadorMovimento.getId(),
    		                         registroHelperCodigoA, 
    		                         movimentoTipo1.getDataPrevistaPagamento(),
    		                         trailler.getTotalRegistros().toString(),
    		                         getSistemaParametro().getAnoMesArrecadacao(),
    		                         arrecadador.getCodigoAgente().toString(),
    		                         pagamento.getValorPagamento(),
    		                         pagamento.getValorPagamento(),
    		                         BigDecimal.ZERO,
    		                         BigDecimal.ZERO,
    		                         new Short("0"),
    		                         ArrecadacaoForma.CARTAO_CREDITO,
    		                         indicadorAceitacaoRegistroMovimento,
    		                         null);
    		
    		                         
    		                         //AVISOS BANCÁRIOS QUE SERÃO INSERIDOS
    		                         avisosBancarios.add(avisoBancario);
    		                     }
                            }
                            
                            
                            //PAGAMENTOS QUE SERÃO INSERIDOS
                            pagamentos.add(pagamento);
                    	}
                    }
                }
                else{
                	
                	descricaoOcorrenciaMovimento = "MOVIMENTO NÃO É DO TIPO 1 e 2";
                	indicadorAceitacaoRegistroMovimento = ConstantesSistema.NAO;

                    // INSERINDO O ITEM DO MOVIMENTO DO ARRECADADOR
                    this.inserirArrecadadorMovimentoItemCartaoCredito(arrecadadorMovimento, linhaRegistro, 
                    descricaoOcorrenciaMovimento, indicadorAceitacaoRegistroMovimento, null);
                }
            }
            
            
            
            //INSERINDO OS AVISOS BANCÁRIOS GERADOS
            if (avisosBancarios != null && !avisosBancarios.isEmpty()) {
                
            	Iterator avisosBancarioIterator = avisosBancarios.iterator();
            	
                while (avisosBancarioIterator.hasNext()) {
                    
                	AvisoBancario avisoBancario = (AvisoBancario) avisosBancarioIterator.next();
                    
                	Integer idAvisoBancario = (Integer)getControladorUtil().inserir(avisoBancario);

                    avisoBancario.setId(idAvisoBancario);
                    
                    //CALCULANDO O VALOR DA DEDUÇÃO DO AVISO BANCÁRIO
                    BigDecimal valorDeducao = this.getControladorCobranca().calcularValorDeducao(
                    arrecadador.getId(), avisoBancario.getValorArrecadacaoCalculado(),
                    ArrecadacaoForma.CARTAO_CREDITO);
                    
                    //GERAR/ATUALIZAR VALOR DA DEDUÇÃO DO AVISO BANCÁRIO
                    this.getControladorCobranca().gerarAtualizarAvisoDeducoes(avisoBancario, valorDeducao);
                }
            }

            //PREPARANDO A INSERÇÃO DOS PAGAMENTOS
            if (pagamentos != null && !pagamentos.isEmpty()) {

                Collection colecaoPagamentos = new ArrayList();

                Iterator pagamentoIterator = pagamentos.iterator();
                
                while (pagamentoIterator.hasNext()) {
                    
                	Pagamento pagamento = (Pagamento) pagamentoIterator.next();
                	
                	//Somatório dos pagamentos recebidos para atualizar no movimento
                	valorTotalPagamentos = valorTotalPagamentos.add(pagamento.getValorPagamento());
                    
                    /*
                     * Verifica se existe o aviso bancário no pagamento,
                     * se não existe então seta o aviso bancário no pagamento
                     */
                	if (pagamento.getAvisoBancario() == null) {
                        
                		Iterator avisosBancarioIterator = avisosBancarios.iterator();
                        
                		while (avisosBancarioIterator.hasNext()) {
                            
                			AvisoBancario avisoBancario = (AvisoBancario) 
                			avisosBancarioIterator.next();
                            
                			/*
                			 * Caso a data prevista seja a mesma então seta o aviso
                			 * bancário no pagamento.
                			 */
                			boolean comparaDataIguais = Util.datasIguais(
                            avisoBancario.getDataPrevista(),
                            pagamento.getDataPrevistaCreditoHelper());
                    		                                    
                            boolean formasArrecadacaoIguais = 
                            avisoBancario.getArrecadacaoForma().getId().intValue() ==
                            pagamento.getArrecadacaoForma().getId().intValue();
                            
                            if (comparaDataIguais && formasArrecadacaoIguais) {

                                pagamento.setAvisoBancario(avisoBancario);
                                break;
                            }
                        }
                    }
                	
                	//PAGAMENTOS QUE SERÃO INSERIDOS
                    colecaoPagamentos.add(pagamento);
                }

                System.out.println(" >> MovArrec.Inserindo pagamentos [ CARTAO DE CREDITO ] = " 
                + colecaoPagamentos.size());
                
                
                //INSERINDO OS PAGAMENTOS
                getControladorBatch().inserirColecaoObjetoParaBatchTransacao(
                colecaoPagamentos);
                
                
                System.out.println(" >> MovArrec.Pagamentos inseridos [ CARTAO DE CREDITO ] = " 
                + colecaoPagamentos.size());
                
            }
            
            
            //ATUALIZANDO O VALOR TOTAL DO MOVIMENTO COM O VALOR TOTAL DOS PAGAMENTOS RECEBIDOS
            this.atualizarValorMovimentoArrecadadorMovimento(arrecadadorMovimento.getId(), valorTotalPagamentos);
            
            //INSERINDO O NÚMERO DO NSA DO MOVIMENTO
            this.inserirNumeroNsaCartaoCredito(arrecadador, Integer.valueOf(header.getSequencia()),
            header.getOpcaoExtrato());
            
		}
		//PROBLEMAS NO PROCESSAMENTO DO ARQUIVO TXT
		catch (Exception e) {            
            
			System.out.println( "Deu erro na linha: " + aux );
            e.printStackTrace();

            //PREPARANDO A MENSAGEM DE ERRO QUE IRÁ COMPOR O EMAIL
            String mensagem = e.getMessage();
            if (mensagem != null) {
                
            	String[] inicioMensagem = mensagem.split("\\.");
                
            	if (inicioMensagem != null && 
                	(!inicioMensagem[0].equals("erro") && !inicioMensagem[0].equals("atencao"))) {
                    
                	mensagem = "erro.sistema";
                }
            } 
            else {
                mensagem = "erro.sistema";
            }

            String emailRemetente = envioEmailError.getEmailRemetente();
            String tituloMensagem = envioEmailError.getTituloMensagem();
            
            if (header != null){
            	tituloMensagem = tituloMensagem + " - " + header.getSequencia();
            }
            
            String emailReceptor = envioEmailError.getEmailReceptor();

            try {
                
            	ServicosEmail.enviarMensagem(emailRemetente, emailReceptor,
                tituloMensagem, ConstantesAplicacao.get(mensagem));
                
            } 
            catch (ErroEmailException e1) {
            	System.out.println("Problemas no envio do email para mensagem de ERRO");
            }
            
            //APENAS ROLLBACK PARA ERROS QUE NÃO FOREM PROVENIENTES DE ENVIO DE EMAIL
            if(!(e instanceof SendFailedException)) {
            	sessionContext.setRollbackOnly();
                sucesso = false;
			}
        }
		
		
		
		if (sucesso) {

            EnvioEmail envioEmail = getControladorCadastro()
            .pesquisarEnvioEmail(EnvioEmail.REGISTRAR_MOVIMENTO_CARTAO_CREDITO);
            
            String emailRemetente = envioEmail.getEmailRemetente();
            String tituloMensagem = envioEmail.getTituloMensagem()+ " - " + header.getSequencia();
            String corpoMensagem = envioEmail.getCorpoMensagem();
            String emailReceptor = envioEmail.getEmailReceptor();

            String mensagemErro = "Ocorreu um problema no processamento de: " + arrecadador.getCliente().getNome();
            
            try {
            	
            	ServicosEmail.enviarMensagem(emailReceptor, emailRemetente, 
	            tituloMensagem, corpoMensagem);
                
                

            } catch (Exception e) {
            	
            	try {
					
            		ServicosEmail.enviarMensagem(emailRemetente,
				        emailReceptor, 
				        tituloMensagem, 
				        mensagemErro);
					
				} catch (ErroEmailException e1) {
					e1.printStackTrace();
				}
            	
                throw new ControladorException("erro.sistema", e);
            }
        }
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0001]  Inserir Movimento do Arrecadador
	 *
	 * @author Raphael Rossiter
	 * @date 28/01/2010
	 *
	 * @param arrecadador
	 * @param codigoRegistro
	 * @param linha
	 * @return RegistroCartaoCreditoHeaderHelper
	 * @throws ControladorException
	 */
	public RegistroCartaoCreditoHeaderHelper validarArquivoMovimentoCartaoCreditoHeader(
			Arrecadador arrecadador, Short codigoRegistro, String linha) throws ControladorException {
		
		RegistroCartaoCreditoHeaderHelper header = null;

		/*
		 * Caso o código do registro (campo A01) não corresponda a 0, exibir a mensagem Arquivo de Movimento 
		 * de Arrecadador sem Header e encerrar o caso de uso.
		 */
		if (!codigoRegistro.equals(RegistroCartaoCreditoHeaderHelper.CODIGO_HEADER)) {
			
			throw new ControladorException("atencao.arquivo_movimento_cartao_credito_sem.header");
		}
		
		//DISTRIBUINDO O REGISTRO TIPO HEADER
		header = (RegistroCartaoCreditoHeaderHelper) this.distribuirDadosArquivoMovimentoCartaoCreditoHeader(
		codigoRegistro, linha);
		
		/*
		 * Caso o estabelecimento matriz não corresponda ao da empresa que está recebendo o arquivo 
		 * (A(02) = ARCT_NNCONTRATO da tabela ARRECADADOR_CONTRATO com ARRC_ID = ARRC_ID do arrecadador 
		 * selecionado com tipo de arrecadação = Cartão de Crédito).
		 */
		ArrecadadorContratoTarifa arrecadadorContratoTarifa = this.getControladorCobranca()
		.pesquisarArrecadadorContratoTarifa(arrecadador.getId(), ArrecadacaoForma.CARTAO_CREDITO);
		
		if (arrecadadorContratoTarifa == null){
			
			//[FS0002  Verificar arrecadação forma cartão crédito];
			throw new ControladorException("atencao.arrecadador_nao_cartao_credito");
		}
		
		if (!arrecadadorContratoTarifa.getArrecadadorContrato().getNumeroContrato()
		   .equals(header.getEstabelecimentoMatriz().trim())){
			
			throw new ControladorException("atencao.arquivo_movimento_numero_contrato_invalido");
		}
		
		/*
		 * Verificando se o arquivo já foi registrado a partir do seu número de sequencia
		 */
		Integer numeroNsa = null;
		
		try {
            
			numeroNsa = repositorioArrecadacao.pesquisarNumeroNsaPorArrecadador(arrecadador.getId(),
			Integer.valueOf(header.getSequencia()), header.getOpcaoExtrato());
    		
        } catch (ErroRepositorioException e) {
            throw new ControladorException(
                    "erro.sistema", e);
        }
        
        if (numeroNsa != null){
        	
        	throw new ControladorException("atencao.arquivo_movimento_ja_registrado");
        }
		
		
		return header;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0001]  Inserir Movimento do Arrecadador 
	 *
	 * @author Raphael Rossiter
	 * @date 28/01/2010
	 *
	 * @param codigoRegistro
	 * @param linha
	 * @return RegistroCartaoCreditoHeaderHelper
	 * @throws ControladorException
	 */
	public RegistroCartaoCreditoHeaderHelper distribuirDadosArquivoMovimentoCartaoCreditoHeader(
		Short codigoRegistro, String linha)
		throws ControladorException{
		
		RegistroCartaoCreditoHeaderHelper header = new RegistroCartaoCreditoHeaderHelper();
		
		//TIPO DO REGISTRO
		header.setTipoRegistro(codigoRegistro);
		
		//ESTABELECIMENTO MATRIZ
		header.setEstabelecimentoMatriz(linha.substring(1, 11));
		
		//DATA PROCESSAMENTO
		header.setDataProcessamento(Util.converteStringInvertidaSemBarraParaDate(linha.substring(11, 19)));
		
		//PERÍODO INICIAL
		header.setDataPeriodoInicial(Util.converteStringInvertidaSemBarraParaDate(linha.substring(19, 27)));
		
		//PERÍODO FINAL
		header.setDataPeriodoFinal(Util.converteStringInvertidaSemBarraParaDate(linha.substring(27, 35)));
		
		//PRODUTO
		header.setProduto(linha.substring(35, 38));
		
		//SEQUENCIA
		header.setSequencia(linha.substring(38, 45));
		
		//EMPRESA
		header.setEmpresa(linha.substring(45, 52));
		
		//OPÇÃO EXTRATO
		header.setOpcaoExtrato(linha.substring(52, 53));
		
		//TRANSMISSÃO
		header.setTransmissao(linha.substring(53, 54));
		
		//DESCRIÇÃO OPÇÃO DO EXTRATO
		header.setDescricaoOpcaoExtrato(linha.substring(54, 124));
		
		
		return header;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0001]  Inserir Movimento do Arrecadador 
	 *
	 * @author Raphael Rossiter
	 * @date 28/01/2010
	 *
	 * @param codigoRegistro
	 * @param linha
	 * @param quantidadeRegistrosDeMovimento
	 * @return RegistroCartaoCreditoTraillerHelper
	 * @throws ControladorException
	 */
	public RegistroCartaoCreditoTraillerHelper validarArquivoMovimentoCartaoCreditoTrailler(
		Short codigoRegistro, String linha, Integer quantidadeRegistrosDeMovimento) 
		throws ControladorException {
		
		RegistroCartaoCreditoTraillerHelper trailler = null;
		
		//[FS0005  Verificar a existência do registro código 9]
		if (codigoRegistro.equals(RegistroCartaoCreditoHeaderHelper.CODIGO_HEADER)) {
            throw new ControladorException("atencao.arquivo.movimento.nao.codigo.nove");
        }
        
		
		if (!codigoRegistro.equals(RegistroCartaoCreditoHeaderHelper.CODIGO_HEADER) && 
			!codigoRegistro.equals(RegistroCartaoCreditoTraillerHelper.CODIGO_TRAILLER) &&
			!codigoRegistro.equals(RegistroCartaoCreditoTipo1Helper.CODIGO_MOVIMENTO_TIPO_1) &&
			!codigoRegistro.equals(RegistroCartaoCreditoTipo2Helper.CODIGO_MOVIMENTO_TIPO_2)) {
                
			throw new ControladorException("atencao.arquivo.movimento.codigo.invalido");
        }

        
		//O sistema distribui os dados do conteúdo do registro 9 do movimento do arrecadador
        if (codigoRegistro.equals(RegistroCartaoCreditoTraillerHelper.CODIGO_TRAILLER)) {

        	trailler = this.distribuirDadosArquivoMovimentoCartaoCreditoTrailler(codigoRegistro, linha);
            
        	/*
        	 * Caso a quantidade total de registros não seja igual ao total de registros do arquivo 
        	 * (campo Z(02)) exibir a mensagem Total de registros do arquivo de movimento inválido e 
        	 * encerrar o caso de uso.
        	 */
        	if (trailler.getTotalRegistros().intValue() != quantidadeRegistrosDeMovimento.intValue()) {
        		
                throw new ControladorException("atencao.total.registros.invalido");
            }
        }
        
        
        return trailler;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0001]  Inserir Movimento do Arrecadador
	 *
	 * @author Raphael Rossiter
	 * @date 28/01/2010
	 *
	 * @param codigoRegistro
	 * @param linha
	 * @return
	 * @throws ControladorException
	 */
	public RegistroCartaoCreditoTraillerHelper distribuirDadosArquivoMovimentoCartaoCreditoTrailler(
			Short codigoRegistro, String linha) throws ControladorException{
			
		RegistroCartaoCreditoTraillerHelper trailler = new RegistroCartaoCreditoTraillerHelper();
			
		//TIPO DO REGISTRO
		trailler.setTipoRegistro(codigoRegistro);
		
		//TOTAL DE REGISTROS
		trailler.setTotalRegistros(Integer.valueOf(linha.substring(1, 12)));
					
			
		return trailler;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0001]  Inserir Movimento do Arrecadador 
	 *
	 * @author Raphael Rossiter
	 * @date 29/01/2010
	 *
	 * @param arrecadador
	 * @param header
	 * @param trailler
	 * @return ArrecadadorMovimento
	 * @throws ControladorException
	 */
	public ArrecadadorMovimento inserirArrecadadorMovimentoCartaoCredito(Arrecadador arrecadador, 
			RegistroCartaoCreditoHeaderHelper header, RegistroCartaoCreditoTraillerHelper trailler)
			throws ControladorException {

		
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		
		//NSA
		arrecadadorMovimento.setNumeroSequencialArquivo(Integer.valueOf(header.getSequencia()));
		
		//CÓDIGO DA REMESSA
		if (header.getOpcaoExtrato().equals("A")){
			arrecadadorMovimento.setCodigoRemessa(new Short("1"));
		}
		else if (header.getOpcaoExtrato().equals("C")){
			arrecadadorMovimento.setCodigoRemessa(new Short("2"));
		}
		else if (header.getOpcaoExtrato().equals("D")){
			arrecadadorMovimento.setCodigoRemessa(new Short("3"));
		}
		else{
			arrecadadorMovimento.setCodigoRemessa(new Short("4"));
		}
		
		
		//CÓDIGO DO CONVÊNIO
		arrecadadorMovimento.setCodigoConvenio(header.getEstabelecimentoMatriz().trim());
		
		//CÓDIGO DO BANCO
		arrecadadorMovimento.setCodigoBanco(arrecadador.getCodigoAgente());
		
		//NOME DO BANCO
		arrecadadorMovimento.setNomeBanco(arrecadador.getCliente().getNome());
		
		//DATA DA GERAÇÃO
		arrecadadorMovimento.setDataGeracao(new Date());
		
		//VERSÃO LAYOUT
		arrecadadorMovimento.setNumeroVersaoLayout(1);
		
		//DESCRIÇÃO DA IDENTIFICAÇÃO DO SERVIÇO
		arrecadadorMovimento.setDescricaoIdentificacaoServico(
		Util.completaString(header.getDescricaoOpcaoExtrato().trim(), 17));
		
		//NUMERO REGISTROS MOVIMENTO
		arrecadadorMovimento.setNumeroRegistrosMovimento(trailler.getTotalRegistros());
		
		//VALOR TOTAL DO MOVIMENTO
		arrecadadorMovimento.setValorTotalMovimento(BigDecimal.ZERO);
		
		//ULTIMA ALTERAÇÃO
		arrecadadorMovimento.setUltimaAlteracao(new Date());

		Integer idMovimento = (Integer) this.getControladorUtil().inserir(arrecadadorMovimento);
		arrecadadorMovimento.setId(idMovimento);
		
		
		return arrecadadorMovimento;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 *
	 * @author Raphael Rossiter
	 * @date 29/01/2010
	 *
	 * @param arrecadadorMovimento
	 * @param linhaRegistro
	 * @param descricaoOcorrencia
	 * @param indicadorAceitacaoRegistro
	 * @param movimentoCartaoRejeita
	 * @return ArrecadadorMovimentoItem
	 * @throws ControladorException
	 */
	public ArrecadadorMovimentoItem inserirArrecadadorMovimentoItemCartaoCredito(ArrecadadorMovimento arrecadadorMovimento, 
			String linhaRegistro, String descricaoOcorrencia, Short indicadorAceitacaoRegistro, MovimentoCartaoRejeita movimentoCartaoRejeita) 
		throws ControladorException {

		//Recupera o código do registro de cada linha
		String codigoRegistro = linhaRegistro.substring(0, 1);

		/*
		 * Recupera o id do registro da tabela REGSITRO_CÓDIGO passando o código
		 * do registro.
		 */
		Integer idRegistroCodigo = null;
		try {
			
			idRegistroCodigo = repositorioArrecadacao.pesquisarIdRegistroCodigo(codigoRegistro);
			
		} 
		catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}

		//Seta os campos para a inserção em arrecadador movimento item
		ArrecadadorMovimentoItem arrecadadorMovimentoItem = new ArrecadadorMovimentoItem();

		RegistroCodigo registroCodigo = new RegistroCodigo();
		registroCodigo.setId(idRegistroCodigo);
		String completaLinhaRegistro = null;
		if (linhaRegistro != null && linhaRegistro.trim().length() == 251) {
			completaLinhaRegistro = Util.completaString(linhaRegistro, 150);
		} else {
			completaLinhaRegistro = Util.completaString(linhaRegistro, 149);
			completaLinhaRegistro = completaLinhaRegistro.concat("*");
		}

		//CÓDIGO DO REGISTRO
		arrecadadorMovimentoItem.setRegistroCodigo(registroCodigo);
		
		//CONTEÚDO DO REGISTRO
		arrecadadorMovimentoItem.setConteudoRegistro(completaLinhaRegistro);
		
		//ARRECADADOR
		arrecadadorMovimentoItem.setArrecadadorMovimento(arrecadadorMovimento);
		
		//DESCRIÇÃO DA OCORRÊNCIA
		arrecadadorMovimentoItem.setDescricaoOcorrencia(descricaoOcorrencia);
		
		//INDICADOR DE ACEITAÇÃO
		arrecadadorMovimentoItem.setIndicadorAceitacao(indicadorAceitacaoRegistro);
		
		//ÚLTIMA ALTERAÇÃO
		arrecadadorMovimentoItem.setUltimaAlteracao(new Date());
		

		//INSERINDO ARRECADADOR MOVIMENTO ÍTEM
		Integer idArrecadadorMovimentoItem = (Integer) this.getControladorUtil().inserir(arrecadadorMovimentoItem);
		arrecadadorMovimentoItem.setId(idArrecadadorMovimentoItem);

		if (movimentoCartaoRejeita != null){
			
			//ASSOCIANDO O ÍTEM AOS DADOS DO MOVIMENTO QUE ESTA SENDO REJEITADO
			movimentoCartaoRejeita.setArrecadadorMovimentoItem(arrecadadorMovimentoItem);
			
			//ÚLTIMA ALTERAÇÃO
			movimentoCartaoRejeita.setUltimaAlteracao(new Date());
			
			//INSERINDO
			this.getControladorUtil().inserir(movimentoCartaoRejeita);
		}
		return arrecadadorMovimentoItem;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0002 Distribuir Dados do Registro de Movimento do Arrecadador]
	 *
	 * @author Raphael Rossiter
	 * @date 29/01/2010
	 *
	 * @param codigoRegistro
	 * @param linha
	 * @return RegistroCartaoCreditoTipo1Helper
	 * @throws ControladorException
	 */
	public RegistroCartaoCreditoTipo1Helper distribuirDadosArquivoMovimentoCartaoCreditoTipo1(
			Short codigoRegistro, String linha)
			throws ControladorException{
			
			RegistroCartaoCreditoTipo1Helper movimentoTipo1 = new RegistroCartaoCreditoTipo1Helper();
			
			//TIPO DO REGISTRO
			movimentoTipo1.setTipoRegistro(codigoRegistro);
			
			//ESTABELECIMENTO SUBMISSOR
			movimentoTipo1.setEstabelecimentoSubmissor(linha.substring(1, 11));
			
			//NÚMERO DO RO
			movimentoTipo1.setNumeroResumoOperacao(linha.substring(11, 18));
			
			//PARCELA
			movimentoTipo1.setParcela(linha.substring(18, 20));
			
			//FILLER
			movimentoTipo1.setFiller(linha.substring(20, 21));
			
			//PLANO
			movimentoTipo1.setPlano(linha.substring(21, 23));
			
			//SITUAÇÃO
			movimentoTipo1.setSituacao(linha.substring(23, 36));
			
			//STATUS
			movimentoTipo1.setStatus(linha.substring(36, 38));
			
			//DATA DE DEPÓSITO
			String dataDeposito = linha.substring(38, 44);
			if (!dataDeposito.trim().equals("") && !dataDeposito.trim().equals("000000")){
				
				movimentoTipo1.setDataDeposito(Util.converteStringInvertidaSemBarraAAMMDDParaDate(
				dataDeposito));
			}
			
			//DATA PREVISTA DE PAGAMENTO
			String dataPrevistaPagamento = linha.substring(44, 50);
			if (!dataPrevistaPagamento.trim().equals("") && !dataPrevistaPagamento.trim().equals("000000")){
				
				movimentoTipo1.setDataPrevistaPagamento(Util.converteStringInvertidaSemBarraAAMMDDParaDate(
				dataPrevistaPagamento));
			}
			
			//DATA DE ENVIO PARA O BANCO
			String dataEnvioBanco = linha.substring(50, 56);
			if (!dataEnvioBanco.trim().equals("") && !dataEnvioBanco.trim().equals("000000")){
				
				movimentoTipo1.setDataEnvioBanco(Util.converteStringInvertidaSemBarraAAMMDDParaDate(
				dataEnvioBanco));
			}
			
			//SINAL DO VALOR BRUTO
			movimentoTipo1.setSinalValorBruto(linha.substring(56, 57));
			
			//VALOR BRUTO
			movimentoTipo1.setValorBruto(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
			linha.substring(57, 70)));
			
			//SINAL DA COMISSÃO
			movimentoTipo1.setSinalComissao(linha.substring(70, 71));
			
			//VALOR COMISSÃO
			movimentoTipo1.setValorComissao(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
			linha.substring(71, 84)));
			
			//SINAL DO VALOR REJEITADO
			movimentoTipo1.setSinalValorRejeitado(linha.substring(84, 85));
			
			//VALOR REJEITADO
			movimentoTipo1.setValorRejeitado(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
			linha.substring(85, 98)));
			
			//SINAL DO VALOR LÍQUIDO
			movimentoTipo1.setSinalValorLiguido(linha.substring(98, 99));
			
			//VALOR LÍQUIDO
			movimentoTipo1.setValorLiquido(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
			linha.substring(99, 112)));
			
			//BANCO
			movimentoTipo1.setCodigoBanco(linha.substring(112, 116));
			
			//AGÊNCIA
			movimentoTipo1.setCodigoAgencia(linha.substring(116, 121));
			
			//CONTA CORRENTE
			movimentoTipo1.setContaCorrente(linha.substring(121, 135));
			
			//QUANTIDADE DE VENDAS ACEITAS
			movimentoTipo1.setQuantidadeVendasAceitas(Integer.valueOf(linha.substring(135, 141)));
			
			//IDENTIFICADOR DO PRODUTO
			movimentoTipo1.setIdentificadorProduto(linha.substring(141, 142));
			
			//QUANTIDADE DE VENDAS REJEITADAS
			movimentoTipo1.setQuantidadeVendasRejeitadas(Integer.valueOf(linha.substring(142, 148)));
			
			//IDENTIFICADOR DE REVENDA/ACELERAÇÃO
			movimentoTipo1.setIdentificadorRevendaAceleracao(linha.substring(148, 149));
			
			//IDENTIFICADOR DA OPÇÃO DE EXTRATO
			movimentoTipo1.setIdentificadorOpcaoExtrato(linha.substring(149, 150));
			
			//DATA DA CAPTURA DA TRANSAÇÃO
			String dataCapturaTransacao = linha.substring(150, 156);
			if (!dataCapturaTransacao.trim().equals("") && !dataCapturaTransacao.trim().equals("000000")){
				
				movimentoTipo1.setDataCapturaTransacao(Util.converteStringInvertidaSemBarraAAMMDDParaDate(
				dataCapturaTransacao));
			}
			
			//ORIGEM DO AJUSTE
			movimentoTipo1.setOrigemAjuste(linha.substring(156, 158));
			
			//VALOR TROCO FÁCIL
			String valorTrocoFacil = linha.substring(159, 172);
			if (!valorTrocoFacil.trim().equals("")){
				
				movimentoTipo1.setValorLiquido(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
				valorTrocoFacil));
			}
			
			return movimentoTipo1;
		}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
	 * [SB0005]  Processar Pagamento Cartão de Crédito
	 *
	 * @author Raphael Rossiter
	 * @date 30/01/2010
	 *
	 * @param arrecadador
	 * @param header
	 * @param movimentoTipo1
	 * @param sistemaParametro
	 * @param usuarioLogado
	 * @return
	 * @throws ControladorException
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCartaoCreditoTipo1(Arrecadador arrecadador,
			RegistroCartaoCreditoHeaderHelper header, 
			RegistroCartaoCreditoTipo1Helper movimentoTipo1, SistemaParametro sistemaParametro,
			Usuario usuarioLogado) throws ControladorException {
		
		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();

		String descricaoOcorrencia = "OK";

		Short indicadorAceitacaoRegistro = ConstantesSistema.SIM;

		Collection colecaoPagamentos = new ArrayList();
		
		/*
		 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
		 * 
		 * 1.1 - Caso a data prevista para o pagamento seja maior que a data atual, o sistema deverá
		 * lê outro registro e continua o processamento
		 */
		if (movimentoTipo1.getDataPrevistaPagamento().compareTo(new Date()) > 0){
			
			descricaoOcorrencia = "DATA PREVISTA PAGAMENTO MAIOR QUE A DATA ATUAL";
		}
		
		/*
		 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
		 * 
		 * 1.2 - Caso a data da transação de cartão de crédito não seja válida para o sistema de arrecadação atual (Campo C(09) 
		 * menor que constante de data de implantação do  sistema GSAN), o sistema não deverá registrar o pagamento e informar o 
		 * motivo da rejeição (Transação efetuado no sistema anterior).
		 */
		if (descricaoOcorrencia.equalsIgnoreCase("OK") && 
			movimentoTipo1.getDataDeposito().compareTo(getSistemaParametro().getDataImplantacaoSistema()) < 0){
			
			descricaoOcorrencia = "TRANSACAO EFETUADA NO SISTEMA ANTERIOR";
		}
		
		/*
		 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
		 * 
		 * 1.3 - Caso o campo de valor de rejeição(C(17) esteja com valor diferente de zeros, o sistema não deverá aceitar o registro e 
		 * informar o motivo da rejeição (C(29)  01  cancelamento solicitado pelo Estabelecimento, 02  cancelamento solicitado pelo  
		 * portador do cartão, 00  outros motivos ).
		 */
		if (descricaoOcorrencia.equalsIgnoreCase("OK") && movimentoTipo1.getValorRejeitado().compareTo(new BigDecimal("0.00")) > 0){
			
			if (movimentoTipo1.getOrigemAjuste().equals(RegistroCartaoCreditoTipo1Helper.MOTIVO_REJEICAO_01)){
				
				descricaoOcorrencia = RegistroCartaoCreditoTipo1Helper.DESCRICAO_MOTIVO_REJEICAO_01;
			}
			else if (movimentoTipo1.getOrigemAjuste().equals(RegistroCartaoCreditoTipo1Helper.MOTIVO_REJEICAO_02)){
				
				descricaoOcorrencia = RegistroCartaoCreditoTipo1Helper.DESCRICAO_MOTIVO_REJEICAO_02;
			}
			else{
				
				descricaoOcorrencia = RegistroCartaoCreditoTipo1Helper.DESCRICAO_MOTIVO_REJEICAO_03;
			}
		}
		
		//Só serão recebidos os arquivos que estejam com o status de liquidação
		if (descricaoOcorrencia.equalsIgnoreCase("OK") && !movimentoTipo1.getStatus().equals(RegistroCartaoCreditoTipo1Helper.STATUS_LIGUIDACAO)){
			
			descricaoOcorrencia = "MOVIMENTO DIFERENTE DE LIQUIDACAO";
		}
		
		/*
		 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
		 * 
		 * 1.4 - Caso o tipo de recebimento não seja cartão de crédito (C(24)) com valor diferente de espaços, 
		 * o sistema deverá atualizar as informações de recebimento no aviso bancário correspondente 
		 * [SB0007  Processar Pagamento Cartão de Débito].
		 */
		if (descricaoOcorrencia.equalsIgnoreCase("OK") && !movimentoTipo1.getIdentificadorProduto().trim().equals("")){
			
			descricaoOcorrencia = "CARTAO DE DEBITO";
		}
		
		
		//Caso a Descrição da Ocorrência do Movimento corresponda a OK, o sistema:
		if (descricaoOcorrencia.equals("OK")) {
			
			/*
			 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
			 * 
			 * O sistema verifica se existe a guia de pagamento referente ao dia de crédito (tabela 
			 * GUIA_PAGAMENTO com GPAG_DTVENCIMENTO = data do crédito (C (09), CLIE_ID = CLIE_ID da 
			 * tabela ARRECADADOR).
			 */
			GuiaPagamento guiaPagamento = this.getControladorCobranca().pesquisarGuiaPagamentoCartaoCredito(
			arrecadador.getCliente().getId(), movimentoTipo1.getDataPrevistaPagamento());
			
			/*
			 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
			 * 
			 * Caso não exista a guia de pagamento, o sistema deverá incluir a guia para processar o 
			 * pagamento <Inclui>> [UC0927  Confirmar Cartão de Crédito/Débito. 
			 */
			
			if (guiaPagamento == null){
				
				guiaPagamento = this.getControladorCobranca().inserirGuiaPagamentoCliente(arrecadador
				.getCliente().getId(), movimentoTipo1.getDataPrevistaPagamento(), movimentoTipo1.getValorBruto(), 
				DebitoTipo.MOVIMENTO_CARTAO_CREDITO, usuarioLogado);
			}
			
			/*
			 * Caso a guia de pagamento tenha sido gerada através do registrar movimento cartão de
			 * crédito, será necessário atualizar o valor da guia.
			 */
			else if (guiaPagamento.getDebitoTipo() != null &&
					guiaPagamento.getDebitoTipo().getId().equals(DebitoTipo.MOVIMENTO_CARTAO_CREDITO)){
				
				BigDecimal valorAcumuladoGuiaPagamento = guiaPagamento.getValorDebito();
				valorAcumuladoGuiaPagamento = valorAcumuladoGuiaPagamento.add(movimentoTipo1.getValorBruto());
				
				guiaPagamento.setValorDebito(valorAcumuladoGuiaPagamento);
				guiaPagamento.setUsuario(usuarioLogado);
				
				//ATUALIZANDO A GUIA DE PAGAMENTO
				this.getControladorCobranca().atualizarGuiaPagamentoCartaoCredito(guiaPagamento);
			}
			
			//[SB0005]  Processar Pagamento Cartão de Crédito
			Pagamento pagamento = this.gerarPagamentoGuiaPagamentoCartaoCredito(guiaPagamento, movimentoTipo1,
			getSistemaParametro());
			
			colecaoPagamentos.add(pagamento);
		}
		else {
			
			//ATRIBUI O INDICADOR DE ACEITAÇÃO PARA NÃO ACEITO
			indicadorAceitacaoRegistro = ConstantesSistema.NAO;
		}

		//[SB0007  Processar Pagamento Cartão de Débito]
		if (descricaoOcorrencia.equalsIgnoreCase("CARTAO DE DEBITO")){
			
			
			//ATRIBUI O INDICADOR DE ACEITAÇÃO PARA ACEITO
			indicadorAceitacaoRegistro = ConstantesSistema.SIM;
		}
		
		//PREPARANDO O HELPER DE RETORNO
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro.toString());

		
		return pagamentoHelperCodigoBarras;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0005]  Processar Pagamento Cartão de Crédito
	 *
	 * @author Raphael Rossiter
	 * @date 30/01/2010
	 *
	 * @param guiaPagamento
	 * @param movimentoTipo1
	 * @param sistemaParametro
	 * @return Pagamento
	 * @throws ControladorException
	 */
	public Pagamento gerarPagamentoGuiaPagamentoCartaoCredito(GuiaPagamento guiaPagamento,
			RegistroCartaoCreditoTipo1Helper movimentoTipo1, SistemaParametro sistemaParametro) throws ControladorException{
		
		Pagamento pagamento = new Pagamento();
		
		//Cria o pagamento para a guia de pagamento
		pagamento.setAnoMesReferenciaPagamento(null);
		
		Integer anoMesDataPrevistaPagamento = Util.getAnoMesComoInteger(movimentoTipo1.getDataPrevistaPagamento());
		Integer anosMesArrecadacao = getSistemaParametro().getAnoMesArrecadacao();
		
		if (Util.compararAnoMesReferencia(anoMesDataPrevistaPagamento, anosMesArrecadacao, ">")){
			pagamento.setAnoMesReferenciaArrecadacao(anoMesDataPrevistaPagamento);
		}
		else{
			pagamento.setAnoMesReferenciaArrecadacao(anosMesArrecadacao);
		}
		
		pagamento.setValorPagamento(movimentoTipo1.getValorBruto());
		pagamento.setDataPagamento(movimentoTipo1.getDataPrevistaPagamento());
		pagamento.setPagamentoSituacaoAtual(null);
		pagamento.setPagamentoSituacaoAnterior(null);
		pagamento.setDebitoTipo(guiaPagamento.getDebitoTipo());	
		pagamento.setContaGeral(null);
		pagamento.setGuiaPagamento(guiaPagamento);
		pagamento.setDebitoACobrarGeral(null);
		pagamento.setLocalidade(guiaPagamento.getLocalidade());
		
		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(new Integer(DocumentoTipo.GUIA_PAGAMENTO));
		pagamento.setDocumentoTipo(documentoTipo);
		pagamento.setDocumentoTipoAgregador(documentoTipo);
		
		pagamento.setAvisoBancario(null);
		pagamento.setImovel(null);
		pagamento.setArrecadadorMovimentoItem(null);
		
		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(ArrecadacaoForma.CARTAO_CREDITO);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		
		pagamento.setUltimaAlteracao(new Date());
		pagamento.setCliente(guiaPagamento.getCliente());
		pagamento.setDataProcessamento(new Date());
		
		
		return pagamento;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0002]  Distribuir Dados do Registro de Movimento do Arrecadador
	 *
	 * @author Raphael Rossiter
	 * @date 01/02/2010
	 *
	 * @param avisoBancarioSituacaoAtual
	 * @param valorPagamento
	 * @return AvisoBancario
	 * @throws ControladorException
	 */
	public AvisoBancario acumularValorArrecadacaoAvisoBancarioCartaoCredito(AvisoBancario avisoBancarioSituacaoAtual,
			BigDecimal valorPagamento) throws ControladorException{
		
		AvisoBancario avisoBancarioSituacaoAtualizado = avisoBancarioSituacaoAtual;
		
		//VALOR ARRECADAÇÃO CALCULADO
        if (avisoBancarioSituacaoAtual.getValorArrecadacaoCalculado() != null) {
    		
    		//Adiciona o valor do pagamento
    		BigDecimal novoValorArrecadacaoCalculado = avisoBancarioSituacaoAtual
            .getValorArrecadacaoCalculado().add(valorPagamento);
            
    		avisoBancarioSituacaoAtualizado.setValorArrecadacaoCalculado(novoValorArrecadacaoCalculado);
        } 
    	else {
            
    		avisoBancarioSituacaoAtualizado.setValorArrecadacaoCalculado(valorPagamento);
        }

        //VALOR ARRECADACAO INFORMADO
        if (avisoBancarioSituacaoAtual.getValorArrecadacaoInformado() != null) {
            
        	BigDecimal novoValorArrecadacaoInformado = avisoBancarioSituacaoAtual
            .getValorArrecadacaoInformado().add(valorPagamento);
            
        	avisoBancarioSituacaoAtualizado.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
        	avisoBancarioSituacaoAtualizado.setValorRealizado(novoValorArrecadacaoInformado);
        } 
        else {
            
        	avisoBancarioSituacaoAtualizado.setValorArrecadacaoInformado(valorPagamento);
        	avisoBancarioSituacaoAtualizado.setValorRealizado(valorPagamento);
        }
        
        
        return avisoBancarioSituacaoAtualizado;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito 
	 *
	 * @author Raphael Rossiter
	 * @date 03/02/2010
	 *
	 * @param arrecadador
	 * @param numeroNsa
	 * @param codigoOpcaoExtrato
	 * @throws ControladorException
	 */
	public void inserirNumeroNsaCartaoCredito(Arrecadador arrecadador, Integer numeroNsa, 
			String codigoOpcaoExtrato) throws ControladorException{
		
		SequenciaCartao sequenciaCartao = new SequenciaCartao();
		
		//ARRECADADOR
		sequenciaCartao.setArrecadador(arrecadador);
		
		//NÚMERO NSA
		sequenciaCartao.setNumeroNsa(numeroNsa);
		
		//OPÇÃO EXTRATO
		sequenciaCartao.setCodigoOpcaoExtrato(codigoOpcaoExtrato);
		
		//ÚLTIMA ALTERAÇÃO
		sequenciaCartao.setUltimaAlteracao(new Date());
		
		//INSERINDO O NSA DO CARTÃO DE CRÉDITO
		this.getControladorUtil().inserir(sequenciaCartao);
	}

	/**
	 * Pesquisa PagamentoEntidadesBeneficentes para a geração do relatório '[UC0978] Gerar
	 * Relatório de Pagamento para Entidades beneficentes Analítico' de acordo com a opção de totalização.
	 * 
	 * @author Daniel Alves
	 * @created 26/01/2010
	 * 
	 * @param opcaoTotalizacao
	 * @return Collection
	 * @throws ControladorException
	 */
	
	public Collection pesquisarPagamentoEntidadesBeneficentesAnalitico(
			String mesAnoInicial, String mesAnoFinal,
			String idEntidadeBeneficente, String idGerenciaRegional,
			String idUnidadeNegocio, String idLocalidade, int opcaoTotalizacao)
			throws ControladorException {
		
		Collection retorno = new ArrayList();
		Collection colecaoPagamentoEntidadesBeneficentesRelatorio = null;
		
		// Converter de mesAno para anoMes para que funcione nas consultas
		String anoMesInicial = String.valueOf(Util.formatarMesAnoComBarraParaAnoMes(mesAnoInicial));
		String anoMesFinal = String.valueOf(Util.formatarMesAnoComBarraParaAnoMes(mesAnoFinal));
			
		try {		
			colecaoPagamentoEntidadesBeneficentesRelatorio = (Collection) repositorioArrecadacao
			 .pesquisarPagamentoEntidadesBeneficentesAnalitico(anoMesInicial, anoMesFinal, idEntidadeBeneficente, 
					                                  idGerenciaRegional, idUnidadeNegocio, idLocalidade, 
					                                  opcaoTotalizacao);
			

			RelatorioPagamentoEntidadesBeneficentesAnaliticoBean relatorioBean = null;
			if(colecaoPagamentoEntidadesBeneficentesRelatorio != null){
				Iterator iterator = colecaoPagamentoEntidadesBeneficentesRelatorio.iterator();
				
				
				while (iterator.hasNext()) {
					
					relatorioBean = new RelatorioPagamentoEntidadesBeneficentesAnaliticoBean();
					
					Object[] dadosRelatorio = (Object[]) iterator.next();
					int idImovel = Integer.parseInt(dadosRelatorio[0].toString());
					
					relatorioBean.setMatricula(dadosRelatorio[0].toString());
					
					relatorioBean.setInscricao(this.getControladorImovel().pesquisarInscricaoImovel(idImovel));
					
					relatorioBean.setEndereco(this.getControladorEndereco().pesquisarEndereco(idImovel));
					
					relatorioBean.setNomeCliente(dadosRelatorio[1].toString());
					
					relatorioBean.setEntidadeBeneficente(dadosRelatorio[3].toString());
					
					relatorioBean.setIdEntidadeBeneficente(dadosRelatorio[2].toString());
					
					relatorioBean.setLocalidade(dadosRelatorio[5].toString());
					
					relatorioBean.setIdLocalidade(dadosRelatorio[4].toString());
					
					relatorioBean.setUnidadeNegocio(dadosRelatorio[7].toString());
					
					relatorioBean.setIdUnidadeNegocio(dadosRelatorio[6].toString());
					
					relatorioBean.setGerenciaRegional(dadosRelatorio[9].toString());
					
					relatorioBean.setIdGerenciaRegional(dadosRelatorio[8].toString());
					
					BigDecimal valor = new BigDecimal(dadosRelatorio[10].toString());
					
					relatorioBean.setValor(valor);
					
					relatorioBean.setReferencia(dadosRelatorio[11].toString());

					retorno.add(relatorioBean);
				}
			}
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);						
		}

		return retorno;
	}
	
	
	
	/**
	 * Pesquisa PagamentoEntidadesBeneficentes para a geração do relatório '[UC0978] Gerar
	 * Relatório de Pagamento para Entidades beneficentes Sintético' de acordo com a opção de totalização.
	 * 
	 * @author Daniel Alves
	 * @created 26/01/2010
	 * 
	 * @param opcaoTotalizacao
	 * @return Collection
	 * @throws ControladorException
	 */
	
	public Collection pesquisarPagamentoEntidadesBeneficentesSintetico(
			String mesAnoInicial, String mesAnoFinal,
			String idEntidadeBeneficente, String idGerenciaRegional,
			String idUnidadeNegocio, String idLocalidade, int opcaoTotalizacao)
			throws ControladorException {
		
		List<RelatorioPagamentoEntidadesBeneficentesSinteticoBean> beans = new ArrayList<RelatorioPagamentoEntidadesBeneficentesSinteticoBean>();
		List objetosEncontrados = null;
		
		// Converter de mesAno para anoMes para que funcione nas consultas
		String anoMesInicial = String.valueOf(Util.formatarMesAnoComBarraParaAnoMes(mesAnoInicial));
		String anoMesFinal = String.valueOf(Util.formatarMesAnoComBarraParaAnoMes(mesAnoFinal));
			
		try {		
			objetosEncontrados = (List) repositorioArrecadacao
			 	.pesquisarPagamentoEntidadesBeneficentesSintetico(anoMesInicial, anoMesFinal, idEntidadeBeneficente, 
					                                  idGerenciaRegional, idUnidadeNegocio, idLocalidade, 
					                                  opcaoTotalizacao);
			
			Object obj = null;
			Object[] dados = null;
			Object[] dadosAnterior = null;
			
			Integer quantidadeGerencia = 0;
			BigDecimal valorGerencia = new BigDecimal(0);
			Integer quantidadeEstado = 0;
			BigDecimal valorEstado = new BigDecimal(0);
			Integer quantidadeUnidade = 0;
			BigDecimal valorUnidade = new BigDecimal(0);
			Integer quantidadeLocalidade = 0;
			BigDecimal valorLocalidade = new BigDecimal(0);
			int totalBeansPorGerencia = 0;
			int totalBeansPorUnidade = 0;
			RelatorioPagamentoEntidadesBeneficentesSinteticoBean bean = null;
			
			
			//seta os dados dos beans
			if (objetosEncontrados != null){
				for (int i = 0; i < objetosEncontrados.size(); i++) {
					obj = objetosEncontrados.get(i);
					
					if (obj instanceof Object[]) {
						dados = (Object[]) obj;
						
						bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
						
						switch (opcaoTotalizacao) {
						case 1:
							//TIPO 1 - Resumo por Estado
							quantidadeEstado += 1;
							valorEstado = valorEstado.add(new BigDecimal(dados[9].toString()));
							
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
								bean.setDescricao("ESTADO");
								bean.setQuantidade(quantidadeEstado);
								bean.setValor(valorEstado);
								bean.setTipoTotalizacao("entidadeBeneficente");
								beans.add(bean);
								
							}
							break;
						case 2:
							//TIPO 2 - Resumo do Estado por Gerência
							
							quantidadeEstado += 1;
							valorEstado = valorEstado.add(new BigDecimal(dados[9].toString()));
							
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
								bean.setDescricao("ESTADO");
								bean.setQuantidade(quantidadeEstado);
								bean.setValor(valorEstado);
								bean.setTipoTotalizacao("entidadeBeneficente");
								beans.add(0,bean);
							}
							//para preencher as gerencias
							if (dadosAnterior == null || dados[6].toString().equals(dadosAnterior[6].toString())){
								quantidadeGerencia += 1;
								valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							}else{
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente((String) dadosAnterior[0]);
								bean.setEntidadeBeneficente((String) dadosAnterior[1]);
							    bean.setDescricao((String) dadosAnterior[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(bean);
								//zera os totalizadores
								quantidadeGerencia = 0;
								valorGerencia = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeGerencia += 1;
								valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
							    bean.setDescricao((String) dados[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(bean);
							}
							
							break;
						case 3:
							//TIPO 3 - Resumo por Gerência Específica
							//para preencher as gerencias
							quantidadeGerencia += 1;
							valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
							    bean.setDescricao((String) dados[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(bean);
							}
							break;
						case 4:
							//TIPO 4 - Resumo do Estado por Gerência por Unidade de Negócio
							//para preencher as unidades de negócio
							if (dadosAnterior == null || dados[4].toString().equals(dadosAnterior[4].toString())){
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}else{
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(bean);
								//zera os totalizadores
								quantidadeUnidade = 0;
								valorUnidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
								//atualiza o indexe dos beans
								totalBeansPorGerencia++;
							}
							
							//para totalizar as gerencias
							if (dadosAnterior == null || dados[6].toString().equals(dadosAnterior[6].toString())){
								quantidadeGerencia += 1;
								valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							}else if (dadosAnterior != null && !dados[6].toString().equals(dadosAnterior[6].toString())){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								// preenche a gerencia
								bean.setIdEntidadeBeneficente((String) dadosAnterior[0]);
								bean.setEntidadeBeneficente((String) dadosAnterior[1]);
							    bean.setDescricao((String) dadosAnterior[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorGerencia, bean);
								//zera os totalizadores
								totalBeansPorGerencia = 0;
								quantidadeGerencia = 0;
								valorGerencia = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeGerencia += 1;
								valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							}
							
							//para preencher o estado
							quantidadeEstado += 1;
							valorEstado = valorEstado.add(new BigDecimal(dados[9].toString()));
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
								bean.setDescricao("ESTADO");
								bean.setQuantidade(quantidadeEstado);
								bean.setValor(valorEstado);
								bean.setTipoTotalizacao("entidadeBeneficente");
								beans.add(0,bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
							    bean.setDescricao((String) dados[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorGerencia, bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(bean);
							}
							break;
						case 5:
							//TIPO 5 - Resumo por Unidade de Negócio Específica
							//para totaliza as Unidades 
							quantidadeUnidade += 1;
							valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(bean);
							}
							break;
						case 6:
							//TIPO 6 - Resumo do Estado por Gerência por Unidade de Negócio por Localidade
							//para preencher as localidades
							if (dadosAnterior == null || dados[2].toString().equals(dadosAnterior[2].toString())){
								quantidadeLocalidade += 1;
								valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
							}else{
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
								//zera os totalizadores
								quantidadeLocalidade = 0;
								valorLocalidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeLocalidade += 1;
								valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
								//atualiza o indexe dos beans
								totalBeansPorUnidade++;
								totalBeansPorGerencia++;
							}
							
							//para totalizar as unidades
							if (dadosAnterior == null || dados[4].toString().equals(dadosAnterior[4].toString())){
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}else if (dadosAnterior != null && !dados[2].toString().equals(dadosAnterior[2].toString())){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								// preenche a Unidade
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorUnidade, bean);
								totalBeansPorGerencia ++;
								//zera os totalizadores
								totalBeansPorUnidade = 0;
								quantidadeUnidade = 0;
								valorUnidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}
							
							//para totalizar as gerencias
							if (dadosAnterior == null || dados[6].toString().equals(dadosAnterior[6].toString())){
								quantidadeGerencia += 1;
								valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							}else if (dadosAnterior != null && !dados[6].toString().equals(dadosAnterior[6].toString())){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								// preenche a gerencia
								bean.setIdEntidadeBeneficente((String) dadosAnterior[0]);
								bean.setEntidadeBeneficente((String) dadosAnterior[1]);
							    bean.setDescricao((String) dadosAnterior[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorGerencia, bean);
								//zera os totalizadores
								totalBeansPorGerencia = 0;
								quantidadeGerencia = 0;
								valorGerencia = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeGerencia += 1;
								valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							}
							
							//para preencher o estado
							quantidadeEstado += 1;
							valorEstado = valorEstado.add(new BigDecimal(dados[9].toString()));
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
								bean.setDescricao("ESTADO");
								bean.setQuantidade(quantidadeEstado);
								bean.setValor(valorEstado);
								bean.setTipoTotalizacao("entidadeBeneficente");
								beans.add(0,bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
							    bean.setDescricao((String) dados[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorGerencia, bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorUnidade, bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
							}
							
							break;
						case 7:
							//TIPO 7 - Resumo por Localidade Específica
							//para totalizar a localidade
							quantidadeLocalidade += 1;
							valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
							
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
							}
							break;
						case 8:
							//TIPO 8 - Gerência Especifica por Unidade de Negócio
							quantidadeGerencia += 1;
							valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
							    bean.setDescricao((String) dados[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
								beans.add(0,bean);
							}
							
							//para preencher as unidades de negocio
							if (dadosAnterior == null || dados[4].toString().equals(dadosAnterior[4].toString())){
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}else{
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(bean);
								//zera os totalizadores
								quantidadeUnidade = 0;
								valorUnidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(bean);
							}
							break;
						case 9:
							//TIPO 9 - Gerências Especificas por Unidade de Negócio por Localidade
							//para preencher as localidades
							if (dadosAnterior == null || dados[2].toString().equals(dadosAnterior[2].toString())){
								quantidadeLocalidade += 1;
								valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
							}else{
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
								//zera os totalizadores
								quantidadeLocalidade = 0;
								valorLocalidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeLocalidade += 1;
								valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
								//atualiza o indexe dos beans
								totalBeansPorUnidade++;
								totalBeansPorGerencia++;
							}
							
							//para totalizar as unidades
							if (dadosAnterior == null || dados[4].toString().equals(dadosAnterior[4].toString())){
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}else if (dadosAnterior != null && !dados[2].toString().equals(dadosAnterior[2].toString())){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								// preenche a Unidade
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorUnidade, bean);
								//zera os totalizadores
								totalBeansPorUnidade = 0;
								quantidadeUnidade = 0;
								valorUnidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeUnidade += 1;
								valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							}
							
							//para totalizar a gerencia
							quantidadeGerencia += 1;
							valorGerencia = valorGerencia.add(new BigDecimal(dados[9].toString()));
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente((String) dados[0]);
								bean.setEntidadeBeneficente((String) dados[1]);
							    bean.setDescricao((String) dados[7]);
							    bean.setQuantidade(quantidadeGerencia);
							    bean.setValor(valorGerencia);				
							    bean.setTipoTotalizacao("gerenciaRegional");
							    //adiciona ben
								beans.add(0,bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								//adiciona bean
								beans.add(beans.size() - totalBeansPorUnidade, bean);
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
							}
							
							break;
						case 10:
							//TIPO 10 - Unidade de Negócio Específica por Localidade
							quantidadeUnidade += 1;
							valorUnidade = valorUnidade.add(new BigDecimal(dados[9].toString()));
							if (i == (objetosEncontrados.size() - 1)){
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[5].toString());
								bean.setQuantidade(quantidadeUnidade);
								bean.setValor(valorUnidade);
								bean.setTipoTotalizacao("unidadeNegocio");
								beans.add(0,bean);
							}
							
							//para preencher as Localidades
							//para preencher as localidades
							if (dadosAnterior == null || dados[2].toString().equals(dadosAnterior[2].toString())){
								quantidadeLocalidade += 1;
								valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
							}else{
								bean.setIdEntidadeBeneficente(dadosAnterior[0].toString());
								bean.setEntidadeBeneficente(dadosAnterior[1].toString());
								bean.setDescricao(dadosAnterior[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
								//zera os totalizadores
								quantidadeLocalidade = 0;
								valorLocalidade = new BigDecimal(0);
								//totaliza os da próxima/atual
								quantidadeLocalidade += 1;
								valorLocalidade = valorLocalidade.add(new BigDecimal(dados[9].toString()));
							}
							
							if (i == (objetosEncontrados.size() - 1)){
								bean = new RelatorioPagamentoEntidadesBeneficentesSinteticoBean();
								bean.setIdEntidadeBeneficente(dados[0].toString());
								bean.setEntidadeBeneficente(dados[1].toString());
								bean.setDescricao(dados[3].toString());
								bean.setQuantidade(quantidadeLocalidade);
								bean.setValor(valorLocalidade);
								bean.setTipoTotalizacao("localidade");
								//adiciona bean
								beans.add(bean);
							}
							break;
						default:
							break;
						}
						dadosAnterior = dados;
					}
				}
			}
	
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);						
		}

		return beans;
	}
	
	/**
	 * [UC0978] Count para Relatório de Pagamento para Entidades Beneficentes
	 * 
	 * @author Daniel Alves
	 * @data   26/01/2010
	 * @param  mesAnoInicial = periodo inicial do relatorio
	 *         mesAnoFinal   = periodo final do relatorio
	 *         idUnidadeBeneficente
	 *         idGerenciaRegional
	 *         idUnidadeNegocio
	 *         idLocalidade
	 *         opcaoTotalizacao
	 *         relatorioTipo = Analitico/Sintetico	
	 * @throws ControladorException 
	 */ 
	public int pesquisarPagamentoEntidadesBeneficentesCount(String mesAnoInicial, String mesAnoFinal,
			String idEntidadeBeneficente, String idGerenciaRegional, String idUnidadeNegocio, String idLocalidade,
			int opcaoTotalizacao, String relatorioTipo
			) throws ControladorException {		
		
		// Converter de mesAno para anoMes para que funcione nas consultas
		String anoMesInicial = String.valueOf(Util.formatarMesAnoComBarraParaAnoMes(mesAnoInicial));
		String anoMesFinal = String.valueOf(Util.formatarMesAnoComBarraParaAnoMes(mesAnoFinal));
		int retorno = 0;
		try{
			if(relatorioTipo.equals("analitico")){
				retorno = (Integer) repositorioArrecadacao
			 	.pesquisarPagamentoEntidadesBeneficentesAnaliticoCount(anoMesInicial, anoMesFinal, idEntidadeBeneficente, 
					                                  idGerenciaRegional, idUnidadeNegocio, idLocalidade, 
					                                  opcaoTotalizacao);				
			}else if(relatorioTipo.equals("sintetico")){
				retorno = (Integer) repositorioArrecadacao
			 	.pesquisarPagamentoEntidadesBeneficentesSinteticoCount(anoMesInicial, anoMesFinal, idEntidadeBeneficente, 
					                                  idGerenciaRegional, idUnidadeNegocio, idLocalidade, 
					                                  opcaoTotalizacao);				
			}
			
			return retorno;
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);						
		}
		
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas 
	 *
	 * @author Raphael Rossiter
	 * @date 12/04/2010
	 *
	 * @param idDebitoACobrar
	 * @param numeroParcelasAntecipadas
	 * @throws ControladorException
	 */
	public Object gerarDebitoCreditoParcelasAntecipadas(Integer idImovel, CobrancaDocumentoItem cobrancaDocumentoItem, 
			Usuario usuarioLogado) throws ControladorException {
		
		Object retorno = null;
		
		Imovel imovel = new Imovel();
		imovel.setId(idImovel);
		
		if (cobrancaDocumentoItem.getDebitoACobrarGeral() != null){
			
			FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
			
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("quadra");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("registroAtendimento");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("ordemServico");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("financiamentoTipo");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAtual");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAnterior");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("parcelamentoGrupo");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("cobrancaForma");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("parcelamento");
			filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");
			
			filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, cobrancaDocumentoItem
			.getDebitoACobrarGeral().getDebitoACobrar().getId()));
			
			Collection colecaoDebitoACobrar = this.getControladorUtil().pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());
			DebitoACobrar debitoACobrar = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
			
			/*
			 * Atualiza o número de prestações cobradas na tabela DEBITO_A_COBRAR (DBAC_NNPRESTACAOCOBRADAS=DBAC_NNPRESTACAOCOBRADAS + 
			 * quantidade de parcelas antecipadas) e atualiza o número de parcelas antecipadas na tabela DEBITO_A_COBRAR 
			 * (DBAC_NNPARCELASANTECIPADAS=DBAC_ NNPARCELASANTECIPADAS + quantidade de parcelas antecipadas) 
			 * e o ano/mês de referencia da conta em que foi cobrada a prestação corrente (DBAC_AMREFERENCIAPRESTACAO=Ano/mês de referência)
			 */
			this.atualizarNumeroPrestacoesAntecipadasECobradas(debitoACobrar, cobrancaDocumentoItem.getNumeroParcelasAntecipadas());
			
			/*
			 * Para cada um dos débitos a cobrar com parcelas antecipadas, o sistema deverá gerar outro débito a cobrar com as mesmas 
			 * características para que sejam associados aos pagamentos que deverão ser gerados.
			 */
			debitoACobrar.setId(null);
			debitoACobrar.setDebitoACobrarCategorias(null);
			
			//GERAÇÃO DO DÉBITO
			debitoACobrar.setGeracaoDebito(new Date());
			
			//NÚMERO DE PRESTAÇÕES DO DÉBITO E NÚMERO DE PRESTAÇÕES COBRADAS
			debitoACobrar.setNumeroPrestacaoCobradas(new Short("0"));
			debitoACobrar.setNumeroPrestacaoDebito(Short.valueOf(cobrancaDocumentoItem.getNumeroParcelasAntecipadas().toString()));
			
			//VALOR DO DÉBITO
			debitoACobrar.setValorDebito(cobrancaDocumentoItem.getValorItemCobrado());
			
			//ÚLTIMA ALTERAÇÃO
			debitoACobrar.setUltimaAlteracao(new Date());
			
			/*********************************************************
			 * CRC5063
			 * autor: Ivan Sergio
			 * analista: Rosana
			 * data: 01/10/2010
			 *********************************************************/
			//Debito a Cobrar Origem
			debitoACobrar.setDebitoACobrarGeralOrigem(cobrancaDocumentoItem.getDebitoACobrarGeral());
			
			//[UC0183 - Inserir Débito A Cobrar]
			Integer idDebitoACobrar = this.getControladorFaturamento().inserirDebitoACobrar(cobrancaDocumentoItem.getNumeroParcelasAntecipadas(),
			debitoACobrar, cobrancaDocumentoItem.getValorItemCobrado(), imovel, null, null, usuarioLogado, true);
			
			debitoACobrar.setId(idDebitoACobrar);
			
			retorno = (Object) debitoACobrar;
		}
		
		else if (cobrancaDocumentoItem.getCreditoARealizarGeral() != null){
			
			FiltroCreditoARealizar filtroCreditoARealizar = new FiltroCreditoARealizar();
			
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("imovel");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("creditoTipo");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("registroAtendimento");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("quadra");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("ordemServico");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("lancamentoItemContabil");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAtual");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("debitoCreditoSituacaoAnterior");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("creditoOrigem");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("parcelamento");
			filtroCreditoARealizar.adicionarCaminhoParaCarregamentoEntidade("documentoTipo");
			
			filtroCreditoARealizar.adicionarParametro(new ParametroSimples(FiltroCreditoARealizar.ID, cobrancaDocumentoItem
			.getCreditoARealizarGeral().getId()));
			
			Collection colecaoCreditoARealizar = this.getControladorUtil().pesquisar(filtroCreditoARealizar, CreditoARealizar.class.getName());
			CreditoARealizar creditoARealizar = (CreditoARealizar) Util.retonarObjetoDeColecao(colecaoCreditoARealizar);
			
			/*
			 * Atualiza o número de prestações realizadas na tabela CREDITO_A_REALIZAR (CRAR_NNPRESTACAOREALIZADAS = CRAR_NNPRESTACAOREALIZADAS + 
			 * quantidade de parcelas antecipadas) e atualiza o número de parcelas antecipadas na tabela 
			 * CREDITO_A_REALIZAR (CRAC_NNPARCELASANTECIPADAS=CRAC_ NNPARCELASANTECIPADAS + quantidade de parcelas antecipadas) 
			 * e o ano/mês de referencia da conta em que foi cobrada a prestação corrente (CRAC_AMREFERENCIAPRESTACAO=Ano/mês de referência);
			 */
			this.atualizarNumeroPrestacoesAntecipadasERealizadas(creditoARealizar, cobrancaDocumentoItem.getNumeroParcelasAntecipadas());
			
			/*
			 * Para cada um dos créditos a realizar com parcelas antecipadas, o sistema deverá gerar outro crédito a realizar com as mesmas 
			 * características para que sejam associados as devoluções que deverão ser geradas.
			 */
			creditoARealizar.setId(null);
			creditoARealizar.setCreditoARealizarCategoria(null);
			
			//GERAÇÃO DO CRÉDITO
			creditoARealizar.setGeracaoCredito(new Date());
			
			//VALOR DO CRÉDITO
			creditoARealizar.setValorCredito(cobrancaDocumentoItem.getValorItemCobrado());
			
			//NÚMERO DE PRESTAÇÕES DO CRÉDITO E NÚMERO DE PRESTAÇÕES REALIZADAS
			creditoARealizar.setNumeroPrestacaoRealizada(new Short("0"));
			creditoARealizar.setNumeroPrestacaoCredito(Short.valueOf(cobrancaDocumentoItem.getNumeroParcelasAntecipadas().toString()));
			
			//REGISTRO DE ATENDIMENTO E ORDEM DE SERVIÇO NULOS
			creditoARealizar.setRegistroAtendimento(null);
			creditoARealizar.setOrdemServico(null);
			
			//ÚLTIMA ALTERAÇÃO E USUÁRIO LOGADO
			creditoARealizar.setUltimaAlteracao(new Date());
			creditoARealizar.setUsuario(usuarioLogado);
			
			//[UC0194] - Inserir Crédito a Realizar
			Integer idCreditoARealizar = this.getControladorFaturamento().gerarCreditoARealizar(creditoARealizar, imovel, usuarioLogado);
			creditoARealizar.setId(idCreditoARealizar);
			
			retorno = (Object) creditoARealizar;
		}
		
		
		return retorno;
	}
	
	
	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas 
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2010
	 *
	 * @param debitoACobrar
	 * @param numeroParcelasAntecipadas
	 * @throws ControladorException
	 */
	public void atualizarNumeroPrestacoesAntecipadasECobradas(DebitoACobrar debitoACobrar, Integer numeroParcelasAntecipadas) 
		throws ControladorException {
		
		Integer numeroPrestacoesCobradas = debitoACobrar.getNumeroPrestacaoCobradas() + numeroParcelasAntecipadas.intValue();
		Integer numeroPrestacoesAntecipadas = null;
		
		if (debitoACobrar.getNumeroParcelasAntecipadas() != null){
			numeroPrestacoesAntecipadas = debitoACobrar.getNumeroParcelasAntecipadas().intValue() + numeroParcelasAntecipadas.intValue();
		}
		else{
			numeroPrestacoesAntecipadas = numeroParcelasAntecipadas.intValue();
		}
		
		try {
			
			repositorioArrecadacao.atualizarNumeroPrestacoesAntecipadasECobradas(debitoACobrar.getId(), numeroPrestacoesCobradas, 
			numeroPrestacoesAntecipadas);
		} 
		catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0259] - Processar Pagamento com código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas 
	 *
	 * @author Raphael Rossiter
	 * @date 14/04/2010
	 *
	 * @param creditoARealizar
	 * @param numeroParcelasAntecipadas
	 * @throws ControladorException
	 */
	public void atualizarNumeroPrestacoesAntecipadasERealizadas(CreditoARealizar creditoARealizar, Integer numeroParcelasAntecipadas) 
		throws ControladorException {
		
		Integer numeroPrestacoesRealizadas = creditoARealizar.getNumeroPrestacaoRealizada() + numeroParcelasAntecipadas.intValue();
		Integer numeroPrestacoesAntecipadas = null;
		
		if (creditoARealizar.getNumeroParcelasAntecipadas() != null){
			numeroPrestacoesAntecipadas = creditoARealizar.getNumeroParcelasAntecipadas().intValue() + numeroParcelasAntecipadas.intValue();
		}
		else{
			numeroPrestacoesAntecipadas = numeroParcelasAntecipadas.intValue();
		}
		
		try {
			
			repositorioArrecadacao.atualizarNumeroPrestacoesAntecipadasERealizadas(creditoARealizar.getId(), numeroPrestacoesRealizadas, 
			numeroPrestacoesAntecipadas);
		} 
		catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	
	/**
	 * [UC0259]  Processar Pagamento com Código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas.
	 *
	 * @author Raphael Rossiter
	 * @date 19/04/2010
	 *
	 * @param idParcelamento
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrar pesquisarDebitoACobrarJurosParcelamento(Integer idParcelamento) 
	throws ControladorException {

		DebitoACobrar debitoACobrar = null;

		try {
	
			debitoACobrar = repositorioArrecadacao.pesquisarDebitoACobrarJurosParcelamento(idParcelamento);
	
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		return debitoACobrar;
	}
	
	
	/**
	 * [UC0259]  Processar Pagamento com Código de Barras
	 * 
	 * [SB0019]  Gerar Débitos/Créditos Parcelas Antecipadas. 
	 *
	 * @author Raphael Rossiter
	 * @date 19/04/2010
	 *
	 * @param debitoACobrar
	 * @throws ControladorException
	 */
	public void atualizarNumeroParcelasBonus(DebitoACobrar debitoACobrar) 
	throws ControladorException {
	
		try {
			
			repositorioArrecadacao.atualizarNumeroParcelasBonus(debitoACobrar);
		} 
		catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do tipo Aviso Bancario
	 * pesquisarPagamentoAvisoBancario
	 * 
	 * @author Arthur Carvalho
	 * @date 12/05/10
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoAvisoBancarioCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos, 
            String valorPagamentoInicial, 
            String valorPagamentoFinal) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoHistoricoAvisoBancarioCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial, 
                    valorPagamentoFinal);
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0322] Inserir Guia Devolucao.
	 * 		[FS0023] Verificar crédito a realizar. Verificarasds 
	 *
	 * [UC0194] Inserir Crédito a realizar.
	 * 		[FS0013] Verificar crédito a realizar. Verificarasds 
	 *
	 * @author Hugo Leonardo
	 * @date 26/05/2010
	 *
	 * @param idImovel, anoMesReferenciaConta
	 * @throws ControladorException
	 */
	public Integer verificarExistenciaCreditoARealizar(Integer idImovel, Integer anoMesReferenciaConta)
		throws ControladorException {

	    // Retorna a "1" se existir Guia Devolucao ou vazio se não existir.
		try {
			return repositorioArrecadacao
					.verificarExistenciaCreditoARealizar(idImovel, anoMesReferenciaConta);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0322] Inserir Guia Devolucao.
	 * 		[FS0023] Verificar crédito a realizar histórico.Verificara
	 *
	 *	[UC0194] Inserir Crédito a realizar.
	 * 		[FS0013] Verificar crédito a realizar histórico.
	 * 
	 * @author Hugo Leonardo
	 * @date 26/05/2010
	 *
	 * @param idImovel, anoMesReferenciaConta
	 * @throws ControladorException
	 */
	public Integer verificarExistenciaCreditoARealizarHistorico(Integer idImovel, Integer anoMesReferenciaConta)
		throws ControladorException {

	    // Retorna a "1" se existir Guia Devolucao ou vazio se não existir.
		try {
			return repositorioArrecadacao
					.verificarExistenciaCreditoARealizarHistorico(idImovel, anoMesReferenciaConta);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0194] Inserir Crédito a realizar.
	 * 		[FS0013] Verificar Guia devolução. Verificarasds 
	 *
	 * @author Hugo Leonardo
	 * @date 27/05/2010
	 *
	 * @param idImovel, anoMesReferenciaGuiaDevolucao
	 * @throws ControladorException
	 */
	public Integer verificarExistenciaGuiaDevolucao(Integer idImovel, Integer anoMesReferenciaGuiaDevolucao)
		throws ControladorException {

	    // Retorna a "1" se existir Guia Devolucao ou vazio se não existir.
		try {
			return repositorioArrecadacao
					.verificarExistenciaGuiaDevolucao(idImovel, anoMesReferenciaGuiaDevolucao);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	
	/**
	 * [UC0629] Consultar Arquivo Texto para Leitura
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2010
	 *
	 * @param helper
	 * @return Integer
	 * @throws ErroRepositorioException
	 */
	public Integer filtrarArquivoTextoRoteiroEmpresaCount(ConsultarArquivoTextoRoteiroEmpresaHelper helper)
		throws ControladorException {
		
		try {
			
			return repositorioArrecadacao.filtrarArquivoTextoRoteiroEmpresaCount(helper);
			
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	
	/**
	 * [UC0629] Consultar Arquivo Texto para Leitura 
	 *
	 * @author Raphael Rossiter
	 * @date 29/06/2010
	 *
	 * @param helper
	 * @param numeroPagina
	 * @return Collection
	 * @throws ControladorException
	 */
	public Collection filtrarArquivoTextoRoteiroEmpresaParaPaginacao(ConsultarArquivoTextoRoteiroEmpresaHelper helper, 
			Integer numeroPagina) throws ControladorException {

		Collection retorno = new ArrayList();
		Collection colecaoArquivoTextoRoteiroEmpresa = null;

		try {

			colecaoArquivoTextoRoteiroEmpresa = repositorioArrecadacao.filtrarArquivoTextoRoteiroEmpresaParaPaginacao(helper, numeroPagina);

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}

		if (colecaoArquivoTextoRoteiroEmpresa != null && !colecaoArquivoTextoRoteiroEmpresa.isEmpty()){
			
			Iterator iterator = colecaoArquivoTextoRoteiroEmpresa.iterator();

			while (iterator.hasNext()) {

				ArquivoTextoRoteiroEmpresa arquivoTextoRoteiroEmpresa = new ArquivoTextoRoteiroEmpresa();
				
				Object[] objetoPesquisa = (Object[]) iterator.next();

				//ID
				if (objetoPesquisa[0] != null) {
					
	            	arquivoTextoRoteiroEmpresa.setId((Integer) objetoPesquisa[0]);
				}

				//ANO MES REFERENCIA
				if (objetoPesquisa[1] != null) {
					
	            	arquivoTextoRoteiroEmpresa.setAnoMesReferencia((Integer) objetoPesquisa[1]);
				}
				
				//QUANTIDADE DE IMOVEIS
				if (objetoPesquisa[2] != null) {
					
	            	arquivoTextoRoteiroEmpresa.setQuantidadeImovel((Integer) objetoPesquisa[2]);
				}
				
				//SEQUENCIAL LEITURA
				if (objetoPesquisa[3] != null) {
					
	            	arquivoTextoRoteiroEmpresa.setNumeroSequenciaLeitura((Integer) objetoPesquisa[3]);
				}
				
				//NOME DO ARQUIVO
				if (objetoPesquisa[4] != null) {
					
	            	arquivoTextoRoteiroEmpresa.setNomeArquivo((String) objetoPesquisa[4]);
				}
				
				//FONE LEITURISTA
				if (objetoPesquisa[5] != null) {
					
	            	arquivoTextoRoteiroEmpresa.setNumeroFoneLeiturista((String) objetoPesquisa[5]);
				}
				
				//ROTA
				if (objetoPesquisa[6] != null) {
					
	            	Rota rota = new Rota();
	            	rota.setId((Integer) objetoPesquisa[6]);
	            	rota.setCodigo((Short) objetoPesquisa[7]);
	            						
	            	//Numero Imoveis Limite
					if(objetoPesquisa[18] != null){
						rota.setNumeroLimiteImoveis((Integer) objetoPesquisa[18]);
					}
	            	
	            	arquivoTextoRoteiroEmpresa.setRota(rota);
					
				}
				
				//SERVICO TIPO CELULAR
				if (objetoPesquisa[8] != null) {
					
	            	ServicoTipoCelular servicoTipoCelular = new ServicoTipoCelular();
	            	servicoTipoCelular.setId((Integer) objetoPesquisa[8]);
	            	servicoTipoCelular.setDescricao( (String) objetoPesquisa[21] );
	            	
					arquivoTextoRoteiroEmpresa.setServicoTipoCelular(servicoTipoCelular);
				}
				
				//SITUACAO TRANSMISSAO LEITURA
				if (objetoPesquisa[9] != null) {
					
	            	SituacaoTransmissaoLeitura situacaoTransmissaoLeitura = new SituacaoTransmissaoLeitura();
	            	situacaoTransmissaoLeitura.setId((Integer) objetoPesquisa[9]);
	            	situacaoTransmissaoLeitura.setDescricaoSituacao((String) objetoPesquisa[10]);
	            	
					arquivoTextoRoteiroEmpresa.setSituacaoTransmissaoLeitura(situacaoTransmissaoLeitura);
				}
				
				//LOCALIDADE
				if (objetoPesquisa[11] != null) {
					
	            	Localidade localidade = new Localidade();
	            	localidade.setId((Integer) objetoPesquisa[11]);
	            	localidade.setDescricao((String) objetoPesquisa[20] );
	            	
					arquivoTextoRoteiroEmpresa.setLocalidade(localidade);
				}
				
				//CODIGO SETOR COMERCIAL 1
				if (objetoPesquisa[12] != null) {
					
					arquivoTextoRoteiroEmpresa.setCodigoSetorComercial1((Integer) objetoPesquisa[12]);
				}
				
				//FATURAMENTO GRUPO
				if (objetoPesquisa[13] != null) {
					
	            	FaturamentoGrupo faturamentoGrupo = new FaturamentoGrupo();
	            	faturamentoGrupo.setId((Integer) objetoPesquisa[13]);
	            	
					arquivoTextoRoteiroEmpresa.setFaturamentoGrupo(faturamentoGrupo);
				}
				
				Leiturista leiturista = null;
				
				//NOME DO CLIENTE
				if (objetoPesquisa[14] != null) {
					
	            	Cliente cliente = new Cliente();
	            	cliente.setNome((String) objetoPesquisa[14]);
	            	
	            	leiturista = new Leiturista();
	            	leiturista.setCliente(cliente);
				}
				
				//NOME DO FUNCIONARIO
				if (objetoPesquisa[15] != null) {
					
	            	Funcionario funcionario = new Funcionario();
	            	funcionario.setNome((String) objetoPesquisa[15]);
	            	
	            	if (leiturista == null){
	            		
	            		leiturista = new Leiturista();
	                	leiturista.setFuncionario(funcionario);
	            	}
	            	else{
	            		leiturista.setFuncionario(funcionario);
	            	}
				}
				
				// NOME DA EMPRESA
				if ( objetoPesquisa[19] != null ){
					Empresa empresa = new Empresa();					
					empresa.setDescricao( (String) objetoPesquisa[19] );
					
					arquivoTextoRoteiroEmpresa.setEmpresa( empresa );
				}
				
				arquivoTextoRoteiroEmpresa.setLeiturista(leiturista);
				
				//ULTIMA ALTERACAO
				arquivoTextoRoteiroEmpresa.setUltimaAlteracao((Date) objetoPesquisa[16]);
				
				// Imei
				if(objetoPesquisa[17] != null){
					arquivoTextoRoteiroEmpresa.setNumeroImei((Long) objetoPesquisa[17]);
				}
				
				if(arquivoTextoRoteiroEmpresa.getRota()!=null && arquivoTextoRoteiroEmpresa.getAnoMesReferencia()!=null
						&& arquivoTextoRoteiroEmpresa.getServicoTipoCelular()!=null){
					arquivoTextoRoteiroEmpresa.setLeiturasRealizas(
						this.getControladorMicromedicao().quantidadeLeiturasRealizada(
								arquivoTextoRoteiroEmpresa.getRota().getId(),
								arquivoTextoRoteiroEmpresa.getAnoMesReferencia(),
								arquivoTextoRoteiroEmpresa.getServicoTipoCelular().getId()));
				}
				
				retorno.add(arquivoTextoRoteiroEmpresa);
			}
		}
		

		if (retorno == null || retorno.isEmpty()) {
			throw new ControladorException("atencao.nenhum_arquivo_texto_roteiro_empresa", null, "Arquivo Texto Leitura");
		}

		return retorno;
	}


	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0006 Distribuir Dados do Registro de Movimento do Arrecadador]
	 *
	 * @author Raphael Rossiter
	 * @date 04/06/2010
	 *
	 * @param codigoRegistro
	 * @param linha
	 * @return RegistroCartaoCreditoTipo1Helper
	 * @throws ControladorException
	 */
	public RegistroCartaoCreditoTipo2Helper distribuirDadosArquivoMovimentoCartaoCreditoTipo2(
			Short codigoRegistro, String linha)
			throws ControladorException{
			
		RegistroCartaoCreditoTipo2Helper movimentoTipo2 = new RegistroCartaoCreditoTipo2Helper();
			
		//TIPO DO REGISTRO
		movimentoTipo2.setTipoRegistro(codigoRegistro);
			
		//ESTABELECIMENTO SUBMISSOR
		movimentoTipo2.setEstabelecimentoSubmissor(linha.substring(1, 11));
			
		//NÚMERO DO RO
		movimentoTipo2.setNumeroResumoOperacao(linha.substring(11, 18));
			
		//NÚMERO DO CARTÃO
		movimentoTipo2.setNumeroCartao(linha.substring(18, 37));
			
		//DATA DA COMPRA/AJUSTE
		String dataCompraAjuste = linha.substring(37, 45);
		if (!dataCompraAjuste.trim().equals("") && !dataCompraAjuste.trim().equals("000000")){
				
			movimentoTipo2.setDataCompraAjuste(Util.converteStringInvertidaSemBarraAAAAMMDDParaDate(dataCompraAjuste));
		}
			
		//SINAL DO VALOR DA COMPRA
		movimentoTipo2.setSinalValorCompraParcela(linha.substring(45, 46));
			
		//VALOR DA COMPRA OU VALOR DA PARCELA
		movimentoTipo2.setValorCompraParcela(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
		linha.substring(46, 59)));
			
		//PARCELA
		if ((linha.substring(59, 61)).trim().length() > 0){
			
			movimentoTipo2.setParcela(Integer.valueOf(linha.substring(59, 61)));
		}
			
		//TOTAL DE PARCELAS
		if ((linha.substring(61, 63)).trim().length() > 0){
			
			movimentoTipo2.setTotalParcelas(Integer.valueOf(linha.substring(61, 63)));
		}
			
		//MOTIVO DA REJEIÇÃO
		movimentoTipo2.setMotivoRejeicao(linha.substring(63, 93));
			
		//CÓDIGO DE AUTORIZAÇÃO
		movimentoTipo2.setCodigoAutorizacao(linha.substring(93, 99));
			
		//IDENTIFICAÇÃO DA TRANSAÇÃO PARA COMÉRCIO ELETRÔNICO - TID
		movimentoTipo2.setTid(linha.substring(99, 139));
			
		//REFERÊNCIA ORIGINAL DA TRANSAÇÃO - NSU
		movimentoTipo2.setNsu(linha.substring(139, 145));
			
		//VALOR TROCO FÁCIL
		movimentoTipo2.setValorTrocoFacil(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(
		linha.substring(145, 158)));
			
		//NÚMERO DE DÍGITOS DO CARTÃO
		movimentoTipo2.setNumeroDigitosCartao(linha.substring(158, 160));
			
		//NÚMERO DA NOTA FISCAL
		movimentoTipo2.setNumeroNotaFiscal(linha.substring(186, 195));
			
		//CÓDIGO DO PAÍS EMISSOR DO CARTÃO
		movimentoTipo2.setCodigoPaisEmissorCartao(linha.substring(195, 199));
			
		//NÚMERO LÓGICO DO TERMINAL
		movimentoTipo2.setNumeroLogicoTerminal(linha.substring(199, 207));
			
		//IDENTIFICADOR DE TAXE DE EMBARQUE OU VALOR DE ENTRADA
		movimentoTipo2.setNumeroLogicoTerminal(linha.substring(207, 209));
			
			
		return movimentoTipo2;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0006 Distribuir Dados do Registro de Movimento do Arrecadador] 
	 *
	 * @author Raphael Rossiter
	 * @date 08/06/2010
	 *
	 * @param arrecadador
	 * @param header
	 * @param movimentoTipo2
	 * @param sistemaParametro
	 * @param usuarioLogado
	 * @return PagamentoHelperCodigoBarras
	 * @throws ControladorException
	 */
	protected PagamentoHelperCodigoBarras processarPagamentosCartaoCreditoTipo2(Arrecadador arrecadador,
			RegistroCartaoCreditoHeaderHelper header, 
			RegistroCartaoCreditoTipo2Helper movimentoTipo2, SistemaParametro sistemaParametro,
			Usuario usuarioLogado) throws ControladorException {
		
		PagamentoHelperCodigoBarras pagamentoHelperCodigoBarras = new PagamentoHelperCodigoBarras();


		String descricaoOcorrencia = "OK";

		Short indicadorAceitacaoRegistro = ConstantesSistema.SIM;
		
		MovimentoCartaoRejeita movimentoCartaoRejeita = null;

		Collection colecaoPagamentos = new ArrayList();
		
		/*
		 * [SB0006]  Distribuir Dados do Registro de Movimento de Cartão.
		 * 
		 * 2.1.	Caso o número do cartão não esteja informado (Campo D(04) com valor igual a zeros ou espaços), o sistema deverá desprezar o 
		 * registro atribuindo à descrição da ocorrência a informação: (Número do cartão não informado).
		 */
		if (movimentoTipo2.getNumeroCartao().equalsIgnoreCase("0000000000000000000") ){
			
			descricaoOcorrencia = "NUMERO DO CARTAO NAO INFORMADO";
		}
		
		/*
		 * [SB0006]  Distribuir Dados do Registro de Movimento de Cartão.
		 * 
		 * 2.2.	Caso a data da transação de cartão de crédito não seja válida para o sistema de arrecadação atual (Campo D(05) menor que 
		 * constante de data de implantação do  sistema GSAN), o sistema não deverá registrar o registro e atribuir à descrição da 
		 * ocorrência a informação: (Transação efetuado no sistema anterior).
		 */
		if (descricaoOcorrencia.equalsIgnoreCase("OK") && 
			movimentoTipo2.getDataCompraAjuste().compareTo(getSistemaParametro().getDataImplantacaoSistema()) < 0){
			
			descricaoOcorrencia = "TRANSACAO EFETUADA NO SISTEMA ANTERIOR";
		}
		
		/*
		 * [SB0006]  Distribuir Dados do Registro de Movimento de Cartão.
		 * 
		 * 2.3.	Caso o motivo da rejeição esteja informado (Campo D(10) com valor diferente de nulo ou espaços), o sistema deverá desprezar 
		 * o registro e atribuir à descrição da ocorrência  o valor do conteúdo do campo.
		 */
		if (descricaoOcorrencia.equalsIgnoreCase("OK") && 
			movimentoTipo2.getMotivoRejeicao() != null && !movimentoTipo2.getMotivoRejeicao().trim().equalsIgnoreCase("")){
			
			descricaoOcorrencia = movimentoTipo2.getMotivoRejeicao();
		}
		
		
		//Caso a Descrição da Ocorrência do Movimento corresponda a OK, o sistema:
		if (descricaoOcorrencia.equals("OK")) {
			
			/*
			 * 2.4.1. Comparar o campo com a numeração do cartão de crédito (Campo D(04)), após a criptografia do mesmo, com o valor do cartão 
			 * informado na confirmação do parcelamento por cartão de crédito (PACC_NNDOCTOCARTAOCREDITO da tabela 
			 * PARCELAMENTO_PAGAMENTO_CARTAO_CREDITO).
			 */
			String numeroCartaoCriptografado = Util.encrypt(movimentoTipo2.getNumeroCartao().trim());
			
			BigDecimal valorTransacao = movimentoTipo2.getValorCompraParcela();
			
			if (movimentoTipo2.getTotalParcelas() != null){
				
				valorTransacao = valorTransacao.multiply(BigDecimal.valueOf(movimentoTipo2.getTotalParcelas()));	
			}
			
			BigDecimal tresCentavos = new BigDecimal("0.03");
			BigDecimal valorTransacaoParaMenos = valorTransacao.subtract(tresCentavos);
			BigDecimal valorTransacaoParaMais = valorTransacao.add(tresCentavos);
			
			FiltroParcelamentoPagamentoCartaoCredito filtroCartaoCredito = new FiltroParcelamentoPagamentoCartaoCredito();
			
			filtroCartaoCredito.adicionarParametro(new ParametroSimples(FiltroParcelamentoPagamentoCartaoCredito.NUMERO_CARTAO_CREDITO,
			numeroCartaoCriptografado));
			
			filtroCartaoCredito.adicionarParametro(new ParametroSimples(FiltroParcelamentoPagamentoCartaoCredito.INDICADOR_CONFIRMADO_OPERADORA,
			ConstantesSistema.NAO));
			
			filtroCartaoCredito.adicionarParametro(new Intervalo(FiltroParcelamentoPagamentoCartaoCredito.VALOR_PARCELADO,
			valorTransacaoParaMenos, valorTransacaoParaMais));
			
			Collection colecaoCartaoCredito = this.getControladorUtil().pesquisar(filtroCartaoCredito, 
			ParcelamentoPagamentoCartaoCredito.class.getName());
			
			if (colecaoCartaoCredito != null && !colecaoCartaoCredito.isEmpty()){
				
				ParcelamentoPagamentoCartaoCredito parcelamentoPagamentoCartaoCredito = (ParcelamentoPagamentoCartaoCredito)
				Util.retonarObjetoDeColecao(colecaoCartaoCredito);
				
				//PACC_ICCONFIRMADOOPERADORA = 1
				parcelamentoPagamentoCartaoCredito.setIndicadorConfirmadoOperadora(ConstantesSistema.SIM);
				
				//PACC_DTCONFIRMADOOPERADORA = Data da Confirmação (Campo D(05))
				parcelamentoPagamentoCartaoCredito.setDataConfirmadoOperadora(movimentoTipo2.getDataCompraAjuste());
				
				//PACC_VLCONFIRMADOOPERADORA = Valor informado pela operadora (Campo D(07))
				parcelamentoPagamentoCartaoCredito.setValorConfirmadoOperadora(movimentoTipo2.getValorCompraParcela());				
				
				parcelamentoPagamentoCartaoCredito.setUltimaAlteracao(new Date());
				
				//CONFIRMANDO RECEBIMENTO VIA CARTÃO DE CRÉDITO
				try {
					
					repositorioArrecadacao.confirmarPagamentoCartaoCreditoOperadora(parcelamentoPagamentoCartaoCredito);
					
				} catch (ErroRepositorioException e) {
					throw new ControladorException("erro.sistema", e);
				}
			}
			else{
				
				/*
				 * 1.1.1. Caso contrário, o sistema deverá comparar o campo com a numeração do cartão de débito (Campo D(04)), após a 
				 * criptografia do mesmo, com o valor do cartão informado na confirmação do pagamento por cartão de débito 
				 * (PACD_NNDOCTOCARTAODEBITO da tabela PAGAMENTO_CARTAO_DEBITO)
				 */
				FiltroPagamentoCartaoDebito filtroCartaoDebito = new FiltroPagamentoCartaoDebito();
				
				filtroCartaoDebito.adicionarParametro(new ParametroSimples(FiltroPagamentoCartaoDebito.NUMERO_CARTAO_DEBITO,
				numeroCartaoCriptografado));
				
				filtroCartaoDebito.adicionarParametro(new ParametroSimples(FiltroPagamentoCartaoDebito.INDICADOR_CONFIRMADO_OPERADORA,
				ConstantesSistema.NAO));
				
				filtroCartaoDebito.adicionarParametro(new Intervalo(FiltroPagamentoCartaoDebito.VALOR_PAGAMENTO,
				valorTransacaoParaMenos, valorTransacaoParaMais));
				
				Collection colecaoCartaoDebito = this.getControladorUtil().pesquisar(filtroCartaoDebito, 
				PagamentoCartaoDebito.class.getName());
				
				if (colecaoCartaoDebito != null && !colecaoCartaoDebito.isEmpty()){
					
					PagamentoCartaoDebito pagamentoCartaoDebito = (PagamentoCartaoDebito)
					Util.retonarObjetoDeColecao(colecaoCartaoDebito);
					
					//PACD_ICCONFIRMADOOPERADORA = 1
					pagamentoCartaoDebito.setIndicadorConfirmadoOperadora(ConstantesSistema.SIM);
					
					//PACD_DTCONFIRMADOOPERADORA = Data da Confirmação (Campo D(05))
					pagamentoCartaoDebito.setDataConfirmadoOperadora(movimentoTipo2.getDataCompraAjuste());
					
					//PACD_VLCONFIRMADOOPERADORA = Valor informado pela operadora (Campo D(07))
					pagamentoCartaoDebito.setValorConfirmadoOperadora(movimentoTipo2.getValorCompraParcela());				
					
					pagamentoCartaoDebito.setUltimaAlteracao(new Date());
					
					//CONFIRMANDO RECEBIMENTO VIA CARTÃO DE DÉBITO
					try {
						
						repositorioArrecadacao.confirmarPagamentoCartaoDebitoOperadora(pagamentoCartaoDebito);
						
					} catch (ErroRepositorioException e) {
						throw new ControladorException("erro.sistema", e);
					}
				}
				else{
					
					/*
					 * 1.1.2. Caso Contrário, o número não tenha sido encontrado e atribuir à descrição da ocorrência a informação: 
					 * Número do cartão de crédito não localizado e não aceitar o registro.
					 */
					descricaoOcorrencia = "NUMERO DO CARTAO NAO LOCALIZADO";
					
					//ATRIBUI O INDICADOR DE ACEITAÇÃO PARA NÃO ACEITO
					indicadorAceitacaoRegistro = ConstantesSistema.NAO;
					
					movimentoCartaoRejeita = this.gerarMovimentoCartaoRejeita(movimentoTipo2);
				}
			}
		}
		else {
			
			//ATRIBUI O INDICADOR DE ACEITAÇÃO PARA NÃO ACEITO
			indicadorAceitacaoRegistro = ConstantesSistema.NAO;
		}


		//PREPARANDO O HELPER DE RETORNO
		pagamentoHelperCodigoBarras.setColecaoPagamentos(colecaoPagamentos);
		pagamentoHelperCodigoBarras.setDescricaoOcorrencia(descricaoOcorrencia);
		pagamentoHelperCodigoBarras.setIndicadorAceitacaoRegistro(indicadorAceitacaoRegistro.toString());
		pagamentoHelperCodigoBarras.setMovimentoCartaoRejeita(movimentoCartaoRejeita);
		
		return pagamentoHelperCodigoBarras;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito
	 * 
	 * [SB0007]  Processar Pagamento Cartão de Débito.
	 *
	 * @author Raphael Rossiter
	 * @date 09/06/2010
	 *
	 * @param avisoBancarioSituacaoAtual
	 * @param valorPagamento
	 * @return AvisoBancario
	 * @throws ControladorException
	 */
	public AvisoBancario acumularValorArrecadacaoAvisoBancarioCartaoDebito(AvisoBancario avisoBancarioSituacaoAtual,
			BigDecimal valorPagamento) throws ControladorException{
		
		AvisoBancario avisoBancarioSituacaoAtualizado = avisoBancarioSituacaoAtual;
		
		//VALOR ARRECADACAO INFORMADO
        if (avisoBancarioSituacaoAtual.getValorArrecadacaoInformado() != null) {
            
        	BigDecimal novoValorArrecadacaoInformado = avisoBancarioSituacaoAtual
            .getValorArrecadacaoInformado().add(valorPagamento);
            
        	avisoBancarioSituacaoAtualizado.setValorArrecadacaoInformado(novoValorArrecadacaoInformado);
        	avisoBancarioSituacaoAtualizado.setValorRealizado(novoValorArrecadacaoInformado);
        } 
        else {
            
        	avisoBancarioSituacaoAtualizado.setValorArrecadacaoInformado(valorPagamento);
        	avisoBancarioSituacaoAtualizado.setValorRealizado(valorPagamento);
        }
        
        
        return avisoBancarioSituacaoAtualizado;
	}
	
	/**
	 * [UC0339] Consultar Dados Diários da Arrecadação
	 *
	 * @author Hugo Amorim
	 * @date 29/06/2010
	 *
	 * @throws ControladorException
	 */
	public Date pesquisarDataProcessamentoMes(Integer anoMes) throws ControladorException {
		
		Date retorno = null;
		
		try {
			
			retorno = repositorioArrecadacao
				.pesquisarDataProcessamentoMes(anoMes);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		
		return retorno;
	}
	
	/**
	 * [UC0322] Inserir Guia de Devolução
	 *
	 *
	 * @author Fernando Fontelles
	 * @date 21/07/2010
	 *
	 * @param colecaoConta
	 */
	public ContaGeral retornaContaGeral(Collection colecaoConta)
		throws ControladorException {
		
		ContaGeral contaGeral = null;
		
		/*
		 * Caso a conta esteja cadastrada no sistema. Seta todas as informações da conta no form.
		 * Caso contrário: Seta as informações da conta para nulo e indica ao usuário que não existe conta para 
		 * o imóvel informado com a referência indicada. 
		 */
		if (colecaoConta != null && !colecaoConta.isEmpty()) {
			
			contaGeral = new ContaGeral();

			//Recupera a conta do imóvel com a referência informada
			Object objetoConta = colecaoConta.iterator().next();
			
			
			if (objetoConta instanceof Conta) {
				
				Conta conta = (Conta) objetoConta;
				contaGeral.setId(conta.getId());
				contaGeral.setConta(conta);
				
			}
			else{
				
				ContaHistorico contaHistorico = (ContaHistorico) objetoConta;
				contaGeral.setId(contaHistorico.getId());
				contaGeral.setContaHistorico(contaHistorico);
				
			}
			
		}
		
		return contaGeral;
	}
	
	
	/**
	 * [UC0977] - Registrar Movimento Cartão de Crédito 
	 *
	 * @author Raphael Rossiter
	 * @date 07/07/2010
	 *
	 * @param movimentoTipo2
	 * @return MovimentoCartaoRejeita
	 * @throws ControladorException
	 */
	public MovimentoCartaoRejeita gerarMovimentoCartaoRejeita(RegistroCartaoCreditoTipo2Helper movimentoTipo2) throws ControladorException {
		
		//PREPARANDO PARA REGISTRAR OS DADOS DA TRANSAÇÃO QUE NÃO FOI CONFIRMADA NO SISTEMA
		MovimentoCartaoRejeita movimentoCartaoRejeita = new MovimentoCartaoRejeita();
		
		//NÚMERO DO CARTÃO
		movimentoCartaoRejeita.setNumeroCartao(Util.encrypt(movimentoTipo2.getNumeroCartao()));
		
		//DATA DA COMPRA
		movimentoCartaoRejeita.setDataCompra(movimentoTipo2.getDataCompraAjuste());
		
		//VALOR DA PARCELA OU DA COMPRA
		movimentoCartaoRejeita.setValorVenda(movimentoTipo2.getValorCompraParcela());
		
		//NÚMERO DA PARCELA
		movimentoCartaoRejeita.setNumeroParcela(movimentoTipo2.getParcela().shortValue());
		
		//NÚMERO TOTAL PARCELA
		movimentoCartaoRejeita.setNumeroParcelaDebito(movimentoTipo2.getTotalParcelas().shortValue());
		
		
		return movimentoCartaoRejeita;
	}
	
	/**
	 * 
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 * 
	 * 			-Validações
	 * 
	 * @author Hugo Amorim
	 * @since 21/07/2010
	 *
	 */
	public void validarGerarRelatorioAnalisePagamentoCartaoDebito(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper) throws ControladorException{
		
		// [FS0002] - Validar datas do período	
		//Período de Confirmação do Pagamento.
		
		//. Caso a data inicial esteja inválida ou maior que a data corrente, exibir a mensagem 
		//'Data inicial informada inválida' 
		if(helper.getDataConfirmacaoPagamentoInicial()!=null
				&& !helper.getDataConfirmacaoPagamentoInicial().equals("")){
			
			if(Util.validarDiaMesAno(helper.getDataConfirmacaoPagamentoInicial())){
				throw new ControladorException("atencao.data_pagamento_invalida",null,"inicial");
			}
			
			Date dataConfirmacaoPagamentoInicial = 
				Util.converteStringParaDate(helper.getDataConfirmacaoPagamentoInicial());
			
			if(Util.compararData(
					dataConfirmacaoPagamentoInicial,
					new Date())==1){
				throw new ControladorException("atencao.data_pagamento_maior_data_atual",null,"inicial");
			}
		}
		//. Caso a data final esteja inválida ou maior que a data corrente, exibir a mensagem 
		//'Data final informada inválida' 
		//e retornar para o passo correspondente no fluxo principal.
		if(helper.getDataConfirmacaoPagamentoFinal()!=null
				&& !helper.getDataConfirmacaoPagamentoFinal().equals("")){
			
			if(Util.validarDiaMesAno(helper.getDataConfirmacaoPagamentoFinal())){
				throw new ControladorException("atencao.data_pagamento_invalida",null,"final");
			}
			
			Date dataConfirmacaoPagamentoFinal = 
				Util.converteStringParaDate(helper.getDataConfirmacaoPagamentoFinal());
			
			if(Util.compararData(
					dataConfirmacaoPagamentoFinal,
					new Date())==1){
				throw new ControladorException("atencao.data_pagamento_maior_data_atual",null,"final");
			}
			
		}
		//. Caso a data inicial esteja maior que a data final, exibir a mensagem 
		//Data inicial informada  maior que a data corrente e retornar para o 
		//passo correspondente no fluxo principal
		if(helper.getDataConfirmacaoPagamentoInicial()!=null &&
			!helper.getDataConfirmacaoPagamentoInicial().equals("") &&
			helper.getDataConfirmacaoPagamentoFinal()!=null &&
			!helper.getDataConfirmacaoPagamentoFinal().equals("")){
			
			Date dataConfirmacaoPagamentoInicial = 
				Util.converteStringParaDate(helper.getDataConfirmacaoPagamentoInicial());
			Date dataConfirmacaoPagamentoFinal = 
				Util.converteStringParaDate(helper.getDataConfirmacaoPagamentoFinal());
			
			
			if(Util.compararData(
				dataConfirmacaoPagamentoInicial,
				dataConfirmacaoPagamentoFinal)==1){
				throw new ControladorException("atencao.data_pagamento_inicial_maior_final");
			}
		}
		
		//Período de Confirmação da Operadora.
		
		//. Caso a data inicial esteja inválida ou maior que a data corrente, exibir a mensagem 
		//'Data inicial informada inválida' 
		if(helper.getDataConfirmacaoOperadoraInicial()!=null
				&& !helper.getDataConfirmacaoOperadoraInicial().equals("")){
			
			if(Util.validarDiaMesAno(helper.getDataConfirmacaoOperadoraInicial())){
				throw new ControladorException("atencao.data_operadora_invalida",null,"inicial");
			}
			
			Date dataConfirmacaoConfirmacaoInicial = 
				Util.converteStringParaDate(helper.getDataConfirmacaoOperadoraInicial());
			
			if(Util.compararData(
					dataConfirmacaoConfirmacaoInicial,
					new Date())==1){
				throw new ControladorException("atencao.data_operadora_maior_data_atual",null,"inicial");
			}
		}
		//. Caso a data final esteja inválida ou maior que a data corrente, exibir a mensagem 
		//'Data final informada inválida' 
		//e retornar para o passo correspondente no fluxo principal.
		if(helper.getDataConfirmacaoOperadoraFinal()!=null
				&& !helper.getDataConfirmacaoOperadoraFinal().equals("")){
			
			if(Util.validarDiaMesAno(helper.getDataConfirmacaoOperadoraFinal())){
				throw new ControladorException("atencao.data_operadora_invalida",null,"final");
			}
			
			Date dataConfirmacaoConfimacaoFinal = 
				Util.converteStringParaDate(helper.getDataConfirmacaoOperadoraFinal());
			
			if(Util.compararData(
					dataConfirmacaoConfimacaoFinal,
					new Date())==1){
				throw new ControladorException("atencao.data_operadora_maior_data_atual",null,"final");
			}
			
		}
		//. Caso a data inicial esteja maior que a data final, exibir a mensagem 
		//Data inicial informada  maior que a data corrente e retornar para o 
		//passo correspondente no fluxo principal
		if(helper.getDataConfirmacaoOperadoraInicial()!=null &&
			!helper.getDataConfirmacaoOperadoraInicial().equals("") &&
			helper.getDataConfirmacaoOperadoraFinal()!=null &&
			!helper.getDataConfirmacaoOperadoraFinal().equals("")){
			
			Date dataConfirmacaoConfirmacaoInicial = 
				Util.converteStringParaDate(helper.getDataConfirmacaoOperadoraInicial());
			Date dataConfirmacaoConfimacaoFinal = 
				Util.converteStringParaDate(helper.getDataConfirmacaoOperadoraFinal());
				
			if(Util.compararData(
					dataConfirmacaoConfirmacaoInicial,
					dataConfirmacaoConfimacaoFinal)==1){
				throw new ControladorException("atencao.data_operadora_inicial_maior_final");
			}
		}
	}
	
	/**
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 *
	 * @author Hugo Amorim
	 * @date 21/06/2010
	 *
	 * @throws ErroRepositorioException
	 */
	public Integer relatorioAnalisePagamentoCartaoDebitoCount(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper) 
			throws ControladorException {
		try {
			return repositorioArrecadacao
				.relatorioAnalisePagamentoCartaoDebitoCount(helper);
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * 
	 * [UC1043] Gerar Relatório Análise Pagamento Cartão Débito
	 * 
	 * 			-Pesquisa
	 * 
	 * @author Hugo Amorim
	 * @since 21/07/2010
	 *
	 */
	public List<RelatorioAnalisePagamentoCartaoDebitoBean> 
		pesquisarBeansRelatorioAnalisePagamentoCartaoDebito(
			ConsultarRelatorioAnalisePagamentoCartaoDebitoHelper helper)
				throws ControladorException{
		
		List<RelatorioAnalisePagamentoCartaoDebitoBean> retorno = 
			new ArrayList<RelatorioAnalisePagamentoCartaoDebitoBean>();
		
		try {
		
			Collection<Object[]> colecaoDados =
				repositorioArrecadacao
					.pesquisarDadosRelatorioAnalisePagamentoCartaoDebito(helper);
			
			RelatorioAnalisePagamentoCartaoDebitoBean bean = null;
			
			for (Object[] dado : colecaoDados) {
				
				//	Pesquisa itens do registro pagamento com cartao debito
				//pelo id do mesmo.
				Collection<Object[]> colecaoItens =
					repositorioArrecadacao
						.pesquisarDadosItenRelatorioAnalisePagamentoCartaoDebito(
								(Integer)dado[0]);			
				
				boolean primeiraVez = true;
				
				for (Object[] dadoIten : colecaoItens) {		
					
					String tipo = "";	
					switch (new Integer((String)dadoIten[1]).intValue()) {
						case 1:
							tipo 	=	"Conta";
							break;
						case 2:
							tipo	 =	"Guia Pagamento";
							break;
						case 3:
							tipo 	=	"Débito a Cobrar";
							break;
						default:
							break;
					}
					
					
					if(primeiraVez){
						
						primeiraVez = false;
						
						bean = new RelatorioAnalisePagamentoCartaoDebitoBean(
								//id
								dado[0]!=null?dado[0].toString():null,
								//matricula
								dadoIten[0]!=null?dadoIten[0].toString():null,
								//numeroCartaoDebito	
								dado[1]!=null?Util.decrypt((String) dado[1]):null,
								//titularCartaoDebito	
								dado[2]!=null?(String)dado[2]:null,
								//dataConfirmacaoPagamento	
								dado[3]!=null?Util.formatarData((Date) dado[3]):null,
								//valorConfirmacaoPagamento	
								dado[4]!=null?Util.formatarMoedaReal((BigDecimal)dado[4]):null,
								//usuarioConfirmacaoPagamento	
								dado[5]!=null?(String)dado[5]:null,
								//situacaoConfirmacaoOperadora	
								dado[6]!=null?(String)dado[6]:null,
								//dataConfirmacaoOperadora	
								dado[7]!=null?Util.formatarData((Date) dado[7]):null,
								//valorConfirmacaoOperadora	
								dado[8]!=null?Util.formatarMoedaReal((BigDecimal)dado[8]):null,
								//tipo
								""
								);
						
						//Adiciona bean para retorno
						retorno.add(bean);
						
					}
					
					
					//	Pesquisa detalhe itens do registro pagamento com cartao debito
					//pelo tipo e id do mesmo.
					Collection<Object[]> colecaoItensDetalhes =
						repositorioArrecadacao
							.pesquisarDetalheItenRelatorioAnalisePagamentoCartaoDebito(
									new Integer((String)dadoIten[1]).intValue(),
									(Integer)dadoIten[2]);
					
					for (Object[] itenDetalhe : colecaoItensDetalhes) {
						
						bean = new RelatorioAnalisePagamentoCartaoDebitoBean(
								//id
								dado[0]!=null && itenDetalhe[0]!=null?
										dado[0].toString()+""+itenDetalhe[0].toString():null,
								//matricula
								dadoIten[0]!=null?dadoIten[0].toString():null,
								//numeroCartaoDebito	
								dado[1]!=null?Util.decrypt((String) dado[1]):null,
								//titularCartaoDebito	
								dado[2]!=null?(String)dado[2]:null,
								//dataConfirmacaoPagamento	
								dado[3]!=null?Util.formatarData((Date) dado[3]):null,
								//valorConfirmacaoPagamento	
								dado[4]!=null?Util.formatarMoedaReal((BigDecimal)dado[4]):null,
								//usuarioConfirmacaoPagamento	
								dado[5]!=null?(String)dado[5]:null,
								//situacaoConfirmacaoOperadora	
								dado[6]!=null?(String)dado[6]:null,
								//dataConfirmacaoOperadora	
								dado[7]!=null?Util.formatarData((Date) dado[7]):null,
								//valorConfirmacaoOperadora	
								dado[8]!=null?Util.formatarMoedaReal((BigDecimal)dado[8]):null,
								//tipo
								tipo
								);
						
						String detalhe = "";	
						switch (new Integer((String)dadoIten[1]).intValue()) {
							case 1:
								detalhe = Util.formatarAnoMesParaMesAno((String) itenDetalhe[1]);
								break;
							case 2:
								detalhe	 =	(String) itenDetalhe[1];
								break;
							case 3:
								detalhe  =	(String) itenDetalhe[1];
								break;
							default:
								break;
						}
						
						bean.setDetalhe(detalhe);
						
						bean.setValor(itenDetalhe[2]!=null?
								Util.formatarMoedaReal((BigDecimal)itenDetalhe[2]):null);
						
						//Adiciona bean para retorno
						retorno.add(bean);	
					}
				}	
			}
			
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
		
		return retorno;	
	}
	
	
	/**
	 * [UC0265] Inserir Pagamentos 
	 *
	 * @author Raphael Rossiter
	 * @date 30/11/2010
	 *
	 * @param codigoBarras
	 * @return RegistroHelperFichaCompensacao
	 * @throws ControladorException
	 */
	public RegistroHelperFichaCompensacao distribuirDadosFichaCompensacao(String codigoBarras) throws ControladorException{
		
		RegistroHelperFichaCompensacao retorno = new RegistroHelperFichaCompensacao();
		
		//CODIGO BANCO
		retorno.setCodigoBanco(codigoBarras.substring(0, 3));
		
		//CODIGO MOEDA
		retorno.setCodigoMoeda(codigoBarras.substring(3, 4));
		
		//NÃO UTILIZADO CAMPO 1
		retorno.setNaoUtilizadoCampo1(codigoBarras.substring(4, 9));
		
		//DÍGITO VERIFICADOR MÓDULO 10 CAMPO 1
		retorno.setDigitoVerificadorModulo10Campo1(codigoBarras.substring(9, 10));
		
		//NÃO UTILIZADO CAMPO 2
		retorno.setNaoUtilizadoCampo2(codigoBarras.substring(10, 11));
		
		//CONVÊNIO
		retorno.setConvenio(codigoBarras.substring(11, 18));
		
		//DOCUMENTO TIPO
		retorno.setIdDocumentoTipo(codigoBarras.substring(18, 20));
		
		//DÍGITO VERIFICADOR MÓDULO 10 CAMPO 2
		retorno.setDigitoVerificadorModulo10Campo2(codigoBarras.substring(20, 21));
		
		//DOCUMENTO COBRANÇA
		retorno.setIdCobrancaDocumento(codigoBarras.substring(21, 29));
		
		//CARTEIRA
		retorno.setCarteira(codigoBarras.substring(29, 31));
		
		//DÍGITO VERIFICADOR MÓDULO 10 CAMPO 3
		retorno.setDigitoVerificadorModulo10Campo3(codigoBarras.substring(31, 32));
		
		//DÍGITO VERIFICADOR MÓDULO 11
		retorno.setDigitoVerificadorModulo11(codigoBarras.substring(32, 33));
		
		//FATOR DE VENCIMENTO
		retorno.setFatorVencimento(codigoBarras.substring(33, 37));
		
		//VALOR DO DOCUMENTO
		retorno.setValorDocumento(Util.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(codigoBarras.substring(37, 47)));
		
		
		return retorno;
	}

	/**
	 * [UC0339] Consultar Dados Diários da Arrecadação
	 *
	 * @author Mariana Victor
	 * @date 01/02/2011
	 *
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarFaturamentoCobradoEmConta(Integer anoMes) throws ControladorException {
		try {

			return repositorioArrecadacao
				.pesquisarFaturamentoCobradoEmConta(anoMes);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC0339] Consultar Dados Diários da Arrecadação
	 *
	 * @author Arthur Carvalho
	 * @date 22/03/2011
	 *
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarFaturamentoCobradoEmContaComQuebra(Integer anoMes, Integer idGerenciaRegional, Integer idCategoria) 
		throws ControladorException {
		try {

			return repositorioArrecadacao
				.pesquisarFaturamentoCobradoEmContaComQuebra(anoMes, idGerenciaRegional, idCategoria);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}

	/**
	 * [UC0188] Manter Guia de Pagamento
	 *
	 * [FS0019]  Verificar bloqueio de guia de pagamento
	 * 
	 * @author Mariana Victor
	 * @date 27/04/2011
	 *
	 * @throws ErroRepositorioException
	 */
	public Collection<Integer> verificarBloqueioGuiaPagamento(Collection<GuiaPagamento> guiasPagamentos) 
		throws ControladorException {
		try {

			return repositorioArrecadacao
				.verificarBloqueioGuiaPagamento(guiasPagamentos);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * 
	 * [UC0300] Classificar Pagamentos e Devoluções
	 * 
	 * @author Raphael Rossiter
	 * @date 01/06/2011
	 * 
	 * @param idLocalidade
	 * @param anoMesReferencia
	 * 
	 * @throws ErroRepositorioException
	 */
	public void atualizarPagamentoBatimentoRelatorio(Integer idLocalidade, Integer anoMesReferencia) 
		throws ControladorException {
		
		try {
	
			//PRIMEIRA ETAPA
			repositorioArrecadacao.atualizarPagamentoBatimentoRelatorioPrimeiraSituacao(idLocalidade, anoMesReferencia);
			
			//SEGUNDA ETAPA
			repositorioArrecadacao.atualizarPagamentoBatimentoRelatorioSegundaSituacao(idLocalidade, anoMesReferencia);
			
			//TERCEIRA ETAPA
			repositorioArrecadacao.atualizarPagamentoBatimentoRelatorioTerceiraSituacao(idLocalidade, anoMesReferencia);
			
			//QUARTA ETAPA
			repositorioArrecadacao.atualizarPagamentoBatimentoRelatorioQuartaSituacao(idLocalidade, anoMesReferencia);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * [UC 1215]  Gerar Relatório de Documentos não Aceitos
	 * 
	 * @author Raimundo Martins
	 *
	 * @date 19/08/2011
	 */
	public List<RelatorioDocumentoNaoAceitosBean> pesquisarDocumentosNaoAceitos(Arrecadador arrecadador, 
			String periodoInicial, String periodoFinal, Integer movimentoArrecadadorCodigo, 
			AvisoBancario avisoBancario, ArrecadacaoForma arrecadacaoForma) throws ControladorException{
		if(repositorioArrecadacao.existeClienteIdDocNaoIdentificado()){
			try{
				List<RelatorioDocumentoNaoAceitosBean> relatorioDocumentosNaoAceitos = null;
				relatorioDocumentosNaoAceitos = repositorioArrecadacao.pesquisarDocumentosNaoAceitos(arrecadador, periodoInicial, 
						periodoFinal, movimentoArrecadadorCodigo, avisoBancario, arrecadacaoForma);
				if(relatorioDocumentosNaoAceitos !=null && !relatorioDocumentosNaoAceitos.isEmpty()){
					return relatorioDocumentosNaoAceitos;	
				}
				else{
					throw new ControladorException("atencao.relatorio.vazio");
				}
			}
			catch(ErroRepositorioException e){
				throw new ControladorException("erro.sistema", e);
			}
		}
		else{
			throw new ControladorException("atencao.sistema_nao_parametrizado.para_documentos.nao_aceitos");
		}
		
	}
	

	/**
	 * [UC 1217]  Gerar Relatório de Transferencia de Pagamento
	 * 
	 * @author Raimundo Martins
	 *
	 * @date 19/08/2011
	 */
	public List<RelatorioTranferenciaPagamentoBean> pesquisarTransfereciasPagamento(Arrecadador arrecadador, 
			String periodoInicial, String periodoFinal, AvisoBancario avisoBancario, ArrecadacaoForma arrecadacaoForma, 
			DebitoTipo debitoTipo, DocumentoTipo documentoTipo) throws ControladorException{
		
		try{
			List<RelatorioTranferenciaPagamentoBean> relatorioTranferenciaPagamento = null;
			
			relatorioTranferenciaPagamento = repositorioArrecadacao.pesquisarTransfereciasPagamento(arrecadador, periodoInicial, 
					periodoFinal, avisoBancario, arrecadacaoForma, debitoTipo, documentoTipo);
			
			return relatorioTranferenciaPagamento;	
			
		}
		catch(ErroRepositorioException e){
			throw new ControladorException("erro.sistema", e);
		}
	}
	/**
	 * [UC0242] - Registrar Movimento dos Arrecadadores
	 * 
	 * [SB0019] - Inserir pagamento para cliente fictício 
	 * 
	 * @author Mariana Victor
	 * @param idFormaArrecadacao 
	 * @date 18/08/2011
	 * 
	 * @return
	 * @throws ControladorException
	 * @throws ErroRepositorioException 
	 */
	public Pagamento inserirPagamentosClienteFicticio(
			String valor, String dataPagamento, Integer idFormaArrecadacao, Date dataPrevistaCredito) 
		throws ControladorException, ErroRepositorioException {

		SistemaParametro sistemaParametro = this.getControladorUtil().pesquisarParametrosDoSistema();
		
		Pagamento pagamento = new Pagamento();
		
		BigDecimal valorPagamento = Util
			.formatarMoedaRealparaBigDecimalComUltimos2CamposDecimais(valor);
		
		Integer anoMes = Util.formataAnoMes(
				Util.converteStringSemBarraParaDate(dataPagamento));
		
		// 1.1.	O sistema armazena o pagamento para posterior inserção 
		//   na tabela PAGAMENTO com os seguintes valores:

		// Caso o ano/mês da data do pagamento seja maior que a PARM_AMREFERENCIAARRECADACAO da tabela SISTEMA_PARAMETROS
		if (anoMes.compareTo(getSistemaParametro().getAnoMesArrecadacao()) > 0) {
			// atribuir ano/mês da data do pagamento
			pagamento.setAnoMesReferenciaArrecadacao(
					anoMes);
		} else {
			// caso contrário atribuir o PARM_AMREFERENCIAARRECADACAO
			pagamento.setAnoMesReferenciaArrecadacao(
					getSistemaParametro().getAnoMesArrecadacao());
		}
		
		// Campo G.05.5
		pagamento.setValorPagamento(valorPagamento);
		
		// Data do Pagamento
		pagamento.setDataPagamento(Util.converteStringSemBarraParaDate(dataPagamento));
		
		// Id do tipo de débito referente a ?Documento não aceito? da tabela DEBITO_TIPO
		DebitoTipo debitoTipo = this.repositorioArrecadacao
			.obterDebitoTipoCodigoConstante(DebitoTipo.DOCUMENTO_NAO_ACEITO);
		pagamento.setDebitoTipo(debitoTipo);
		
		// LOCA_ID da tabela cadastro.LOCALIDADE com LOCA_ICSEDE=1 (um)
		Localidade localidadeSede = this.getControladorCobranca().pesquisarLocalidadeSede();
		pagamento.setLocalidade(localidadeSede);
		
		// DOTP_ID da tabela DOCUMENTO_TIPO com o valor correspondente a guia de pagamento. 
		DocumentoTipo documentoTipo = new DocumentoTipo();
		documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
		pagamento.setDocumentoTipo(documentoTipo);
		
		// Id da forma de arrecadação
		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaArrecadacao);
		pagamento.setArrecadacaoForma(arrecadacaoForma);
		
		// CLIE_IDDOCNAOIDENTIFICADO da tabela SISTEMA_PARAMETRO
		Cliente cliente = getSistemaParametro().getClienteFicticioParaAssociarOsPagamentosNaoIdentificados();
		pagamento.setCliente(cliente);
		
		// Data e hora correntes
		pagamento.setUltimaAlteracao(new Date());
		
		// Com o valor correspondente a guia de pagamento da tabela DOCUMENTO_TIPO
		pagamento.setDocumentoTipoAgregador(documentoTipo);
		
		// Data e hora correntes
		pagamento.setDataProcessamento(new Date());
		
		pagamento.setDataPrevistaCreditoHelper(dataPrevistaCredito);
		
		
		return pagamento;
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * 3. O sistema identifica os pagamentos com documentos não aceitos 
	 * 	 que foram gerados para um cliente fictício e
	 *   junto com o filtro selecionado pelo usuário.
	 * 
	 * @author Mariana Victor
	 * @date 19/08/2011
	 * 
	 * @param codigoConstante
	 * 
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection<PagamentoDocumentosNaoAceitosHelper> pesquisarPagamentosDocumentosNaoAceitos(
			InformarAcertoDocumentosNaoAceitosPagamentoHelper helper) throws ControladorException {
		
		Collection<PagamentoDocumentosNaoAceitosHelper> colecaoHelper = null;
		
		try {

			Collection dadosPagamentos = repositorioArrecadacao
				.pesquisarPagamentosDocumentosNaoAceitos(helper);
			
			if (dadosPagamentos != null && !dadosPagamentos.isEmpty()) {
				
				colecaoHelper = new ArrayList<PagamentoDocumentosNaoAceitosHelper>();
				
				Iterator iterator = dadosPagamentos.iterator();
				
				while (iterator.hasNext()) {
					Object[] pagamento = (Object[]) iterator.next();
					PagamentoDocumentosNaoAceitosHelper helperRetorno = new PagamentoDocumentosNaoAceitosHelper();
					
					helperRetorno.setIdPagamento(
							((Integer) pagamento[0]).toString());
					helperRetorno.setTipoDebito(
							(String) pagamento[1]);
					helperRetorno.setFormaArrecadacao(
							(String) pagamento[2]);
					helperRetorno.setDataPagamento(
							Util.formatarData((Date) pagamento[3]));
					helperRetorno.setValorPagamento(
							Util.formatarMoedaReal((BigDecimal) pagamento[4]));
					helperRetorno.setNumeroNsa(
							((Integer) pagamento[5]).toString());
					helperRetorno.setArrecadador(
							(String) pagamento[6]);
					
					colecaoHelper.add(helperRetorno);
				}
				
			}
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		
		return colecaoHelper;
		
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 *  7.2.1. Total do Pagamento (PGMT _VLPAGAMENTO do pagamento doc. não aceito).
	 * 
	 * @author Mariana Victor
	 * @date 22/08/2011
	 * 
	 * @param idPagamento
	 * 
	 * @return BigDecimal
	 * @throws ErroRepositorioException
	 */
	public BigDecimal pesquisarValorPagamento(
			Integer idPagamento) throws ControladorException {
		
		try {

			return repositorioArrecadacao
				.pesquisarValorPagamento(idPagamento);
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		
	}

	
	/**
	 * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * Pesquisa a guia de pagamento do imóvel informado pelo usuário
	 * 
	 * [FS0009] ? Verificar existência da guia de pagamento
	 * 
	 * @author Mariana Victor
	 * @date 23/08/2011
	 * 
	 * @param idImovel
	 * @param idGuiaPagamento
	 * @return
	 * @throws ControladorException 
	 */
	public GuiaPagamentoValoresHelper pesquisarGuiaPagamentoDigitada(String idImovel, 
			String idGuiaPagamento) throws ControladorException {
		
		GuiaPagamentoValoresHelper helper = null;
		GuiaPagamento guiaPagamentoDigitada = null;

		FiltroGuiaPagamento filtroGuiaPagamento = new FiltroGuiaPagamento();
		FiltroGuiaPagamentoHistorico filtroGuiaPagamentoHistorico = new FiltroGuiaPagamentoHistorico();

		if (idImovel != null && !idImovel.trim().equalsIgnoreCase("")) {
			
			filtroGuiaPagamento.adicionarParametro(new ParametroSimples(
			FiltroGuiaPagamento.IMOVEL_ID, idImovel));
			
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(
			FiltroGuiaPagamentoHistorico.IMOVEL_ID, idImovel));
		} else {
			throw new ControladorException("atencao.naoinformado", null, "Imóvel");
		}

		filtroGuiaPagamento.adicionarParametro(new ParametroSimples(FiltroGuiaPagamento.ID, idGuiaPagamento));

		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("imovel");
		filtroGuiaPagamento.adicionarCaminhoParaCarregamentoEntidade("cliente");

		Collection colecaoGuiaPagamento = this.getControladorUtil()
			.pesquisar(filtroGuiaPagamento, GuiaPagamento.class.getName());

		if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {
			guiaPagamentoDigitada = (GuiaPagamento) Util.retonarObjetoDeColecao(colecaoGuiaPagamento);
			helper = new GuiaPagamentoValoresHelper();
			helper.setGuiaPagamento(guiaPagamentoDigitada);
			helper.setIndicadorDebitoPago(ConstantesSistema.NAO);
		} else {
			// Caso a guia de pagamento não exista 
			filtroGuiaPagamentoHistorico.adicionarParametro(new ParametroSimples(FiltroGuiaPagamentoHistorico.ID, 
			idGuiaPagamento));

			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			filtroGuiaPagamentoHistorico.adicionarCaminhoParaCarregamentoEntidade("cliente");

			colecaoGuiaPagamento = this.getControladorUtil()
				.pesquisar(filtroGuiaPagamentoHistorico, GuiaPagamentoHistorico.class.getName());
			
			if (colecaoGuiaPagamento != null && !colecaoGuiaPagamento.isEmpty()) {
				GuiaPagamentoHistorico guiaPagamentoHistorico = (GuiaPagamentoHistorico) 
				Util.retonarObjetoDeColecao(colecaoGuiaPagamento);
				
				guiaPagamentoDigitada = new GuiaPagamento();
				guiaPagamentoDigitada.setDebitoTipo(guiaPagamentoHistorico.getDebitoTipo());
				guiaPagamentoDigitada.setLocalidade(guiaPagamentoHistorico.getLocalidade());
				guiaPagamentoDigitada.setImovel(guiaPagamentoHistorico.getImovel());
				guiaPagamentoDigitada.setCliente(guiaPagamentoHistorico.getCliente());
				guiaPagamentoDigitada.setValorDebito(guiaPagamentoHistorico.getValorDebito());
				
				helper = new GuiaPagamentoValoresHelper();
				helper.setGuiaPagamento(guiaPagamentoDigitada);
				helper.setIndicadorDebitoPago(ConstantesSistema.SIM);
				
			}
		}

		// Retorna a guia de pagamento encontrada ou nulo se não existir aa guia
		// de pagamento
		return helper;
	}
	
	
	/**
	 * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * Pesquisa o débito a cobrar do imóvel informado pelo usuário
	 * 
	 * [FS0012] - Verificar existência do débito.
	 * 
	 * @author Mariana Victor
	 * @date 23/08/2011
	 * 
	 * @param idImovel
	 * @param idDebitoACobrar
	 * @return
	 * @throws ControladorException
	 */
	public DebitoACobrarValoresHelper pesquisarDebitoACobrarImovelDigitado(String idImovel,
			String idDebitoACobrar) throws ControladorException {

		DebitoACobrarValoresHelper helper = null;
		
		// Cria a variável que vai armazenar o débito a cobrar pesquisado
		DebitoACobrar debitoACobrarDigitado = null;

		// Cria o filtro de débito a cobrar e seta todos os parâmetros para
		// pesquisar o débito a cobrar do imóvel
		FiltroDebitoACobrar filtroDebitoACobrar = new FiltroDebitoACobrar();
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.IMOVEL_ID, idImovel));
		filtroDebitoACobrar.adicionarParametro(new ParametroSimples(FiltroDebitoACobrar.ID, idDebitoACobrar));
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("localidade");
		filtroDebitoACobrar.adicionarCaminhoParaCarregamentoEntidade("imovel");
		
		Collection colecaoDebitoACobrar = this.getControladorUtil()
			.pesquisar(filtroDebitoACobrar, DebitoACobrar.class.getName());

		if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {
			debitoACobrarDigitado = (DebitoACobrar) Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
			helper = new DebitoACobrarValoresHelper();
			helper.setDebitoACobrar(debitoACobrarDigitado);
			helper.setIndicadorDebitoPago(ConstantesSistema.NAO);
		} else {
			// Caso não exista o débito 
			
			FiltroDebitoACobrarHistorico filtroDebitoACobrarHistorico = new FiltroDebitoACobrarHistorico();
			filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.IMOVEL_ID, idImovel));
			filtroDebitoACobrarHistorico.adicionarParametro(new ParametroSimples(FiltroDebitoACobrarHistorico.ID, idDebitoACobrar));
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("debitoTipo");
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("localidade");
			filtroDebitoACobrarHistorico.adicionarCaminhoParaCarregamentoEntidade("imovel");
			
			colecaoDebitoACobrar = this.getControladorUtil()
				.pesquisar(filtroDebitoACobrarHistorico, DebitoACobrarHistorico.class.getName());
			
			if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {
				DebitoACobrarHistorico debitoACobrarHistorico = (DebitoACobrarHistorico) 
				Util.retonarObjetoDeColecao(colecaoDebitoACobrar);
				
				debitoACobrarDigitado = new DebitoACobrar();
				debitoACobrarDigitado.setId(debitoACobrarHistorico.getId());
				debitoACobrarDigitado.setDebitoTipo(debitoACobrarHistorico.getDebitoTipo());
				debitoACobrarDigitado.setLocalidade(debitoACobrarHistorico.getLocalidade());
				debitoACobrarDigitado.setImovel(debitoACobrarHistorico.getImovel());
				debitoACobrarDigitado.setAnoMesReferenciaDebito(debitoACobrarHistorico.getAnoMesReferenciaDebito());
				debitoACobrarDigitado.setAnoMesCobrancaDebito(debitoACobrarHistorico.getAnoMesCobrancaDebito());
				debitoACobrarDigitado.setValorDebito(debitoACobrarHistorico.getValorDebito());
				
				helper = new DebitoACobrarValoresHelper();
				helper.setDebitoACobrar(debitoACobrarDigitado);
				helper.setIndicadorDebitoPago(ConstantesSistema.SIM);
			}
		}

		// Retorna o débito a cobrar encontrado ou nulo se não existir o débito
		// a cobrar
		return helper;
	}
	
	
	/**
	 * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * 10.	O usuário conclui o acerto dos pagamentos 
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param helper
	 * @return
	 * @throws ControladorException
	 */
	public void efetuarAcertosPagamentos(InformarAcertoDocumentosNaoAceitosHelper helper)
		throws ControladorException {
		
		Collection<ContaValoresHelper> colecaoContaValores =
    		helper.getColecaoContaValores();
		Collection<GuiaPagamentoValoresHelper> colecaoGuiaPagamentoValores =  
    		helper.getColecaoGuiaPagamentoValores();
		Collection<DebitoACobrarValoresHelper>  colecaoDebitoACobrar = 
    		helper.getColecaoDebitoACobrar();
		
		BigDecimal valorTotalDebitos = helper.getValorTotalDebitos();		
		BigDecimal valorPagamento = helper.getValorPagamento();

		String idPagamento = helper.getIdPagamento().toString();
		
		FiltroPagamento filtroPagamento = new FiltroPagamento();
		filtroPagamento.adicionarParametro(new ParametroSimples(FiltroPagamento.ID, idPagamento));
		filtroPagamento.adicionarCaminhoParaCarregamentoEntidade(FiltroPagamento.AVISO_BANCARIO);
		
		Collection colecaoPagamento = getControladorUtil().pesquisar(filtroPagamento,Pagamento.class.getSimpleName());
		Pagamento pagamento = (Pagamento) Util.retonarObjetoDeColecao(colecaoPagamento);
		
		try {
			// 10.1. Para cada débito selecionado:
			
			if (colecaoContaValores != null && !colecaoContaValores.isEmpty()) {
				Iterator iterator = colecaoContaValores.iterator();
				
				while(iterator.hasNext()) {
					ContaValoresHelper contaValoresHelper = (ContaValoresHelper) iterator.next();
					
					// 10.1.1. Insere o pagamento na tabela PAGAMENTO [SB0004 - Inclui Pagamento].
					this.incluiPagamentos(contaValoresHelper, null, null, pagamento, helper.getImovel());
				}
			}
			
			if (colecaoGuiaPagamentoValores != null && !colecaoGuiaPagamentoValores.isEmpty()) {
				Iterator iterator = colecaoGuiaPagamentoValores.iterator();
				
				while(iterator.hasNext()) {
					GuiaPagamentoValoresHelper guiaPagamentoValoresHelper = (GuiaPagamentoValoresHelper) iterator.next();
					
					// 10.1.1. Insere o pagamento na tabela PAGAMENTO [SB0004 - Inclui Pagamento].
					this.incluiPagamentos(null, guiaPagamentoValoresHelper, null, pagamento, helper.getImovel());
				}
			}
			
			if (colecaoDebitoACobrar != null && !colecaoDebitoACobrar.isEmpty()) {
				Iterator iterator = colecaoDebitoACobrar.iterator();
				
				while(iterator.hasNext()) {
					DebitoACobrarValoresHelper debitoACobrarValoresHelper = (DebitoACobrarValoresHelper) iterator.next();
					
					// 10.1.1. Insere o pagamento na tabela PAGAMENTO [SB0004 - Inclui Pagamento].
					this.incluiPagamentos(null, null, debitoACobrarValoresHelper, pagamento, helper.getImovel());
				}
			}
			
		} catch (ErroRepositorioException e) {
			throw new ControladorException("erro.sistema", e);
		}
		
		// 10.2. Caso o Total do Pagamento seja igual ao Total dos Débitos:
		if (valorTotalDebitos.compareTo(valorPagamento) == 0) {
			
			// 10.2.1. Remover o pagamento doc. não aceito (Exclui o pagamento na tabela PAGAMENTO).
			getControladorUtil().remover(pagamento);
			
		} else {
			
			// 10.3. Caso Contrário, ou seja, o Total do Pagamento é maior que o Total dos Débitos
			// 10.3.1. Atualizar o pagamento doc. não aceito na tabela de PAGAMENTO.
			pagamento.setValorPagamento(valorPagamento.subtract(valorTotalDebitos));
			this.getControladorUtil().atualizar(pagamento);
			
		}
		
	}
	
	/**
	 * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * [SB0004] - Inclui Pagamento
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param helper
	 * @return
	 * @throws ControladorException
	 * @throws ErroRepositorioException 
	 */
	public void incluiPagamentos(ContaValoresHelper contaValoresHelper, 
			GuiaPagamentoValoresHelper guiaPagamentoValoresHelper, 
			DebitoACobrarValoresHelper debitoACobrarValoresHelper, 
			Pagamento pagamentoNaoAceito,
			Imovel imovel)
		throws ControladorException, ErroRepositorioException {
		
		Pagamento pagamento = new Pagamento();
		
		// 1. Inclui o pagamento na tabela PAGAMENTO de acordo com o tipo do documento selecionado:
		if (contaValoresHelper != null 
				&& contaValoresHelper.getConta() != null) {
			// 1.1.	Tipo do Documento correspondente a Conta:

			Conta conta = contaValoresHelper.getConta();

			// Referência da Conta (inverter para AAAAMM).
			pagamento.setAnoMesReferenciaPagamento(conta.getReferencia());
			pagamento.setAnoMesReferenciaArrecadacao(pagamentoNaoAceito.getAnoMesReferenciaArrecadacao());
			
			// Valor da Conta.
			pagamento.setValorPagamento(conta.getValorTotal());
			
			// Data do pagamento doc. não aceito.
			pagamento.setDataPagamento(pagamentoNaoAceito.getDataPagamento());
			
			// Caso exista pagamento para conta (indicador de débito pago = 1),
			if (contaValoresHelper.getIndicadorDebitoPago() != null 
					&& contaValoresHelper.getIndicadorDebitoPago().compareTo(ConstantesSistema.SIM) == 0) {
				// atribuir o valor nulo
				pagamento.setContaGeral(null);
			} else {
				// caso contrário, atribuir o id da conta.
				ContaGeral contaGeral = new ContaGeral();
				contaGeral.setId(conta.getId());
				pagamento.setContaGeral(contaGeral);
			}
			
			// LOCA_ID da tabela CONTA
			pagamento.setLocalidade(conta.getLocalidade());
			
			// Com o valor correspondente a conta da tabela DOCUMENTO_TIPO.
			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.CONTA);
			pagamento.setDocumentoTipo(documentoTipo);
			
			// AVBC_ID do pagamento doc. não aceito.
			pagamento.setAvisoBancario(pagamentoNaoAceito.getAvisoBancario());
			
			// IMOV_ID da tabela IMOVEL.
			pagamento.setImovel(imovel);;

			// AMIT_ID do pagamento doc. não aceito.
			pagamento.setArrecadadorMovimentoItem(pagamentoNaoAceito.getArrecadadorMovimentoItem());
			
			// ARFM_ID do pagamento doc. não aceito.
			pagamento.setArrecadacaoForma(pagamentoNaoAceito.getArrecadacaoForma());
			
			// Data e hora correntes.
			pagamento.setUltimaAlteracao(new Date());
			
			this.getControladorUtil().inserir(pagamento);

			// 1.1.1. O sistema verifica se existe item de documento de cobrança associado a esta conta. 
			// 1.1.2. O Sistema atualiza a situação do item do documento de cobrança referente à Conta
	        getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
	              CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento());
	        
	        // 1.1.3. O sistema verifica se existem itens de negativação associados a esta conta 
			// <<Inclui>> [UC0937 - Obter Itens de Negativação Associados à Conta] 
			Collection colecaoNegativadorMovimentoRegItem = this.getControladorSpcSerasa()
					.obterItensNegativacaoAssociadosAConta(pagamento.getImovel().getId(), conta.getReferencia());

			// 1.1.4. Caso existam itens de negativação associados a esta conta:
			if(colecaoNegativadorMovimentoRegItem != null && !colecaoNegativadorMovimentoRegItem.isEmpty()){
				// 1.1.4.1.	Para cada item de negativação retornado, o sistema atualiza o item de negativação com os dados do pagamento
				Iterator iterNmri = colecaoNegativadorMovimentoRegItem.iterator();
				
				while (iterNmri.hasNext()) {
					Integer idItemNegativacao = (Integer) iterNmri.next();
					
					// [SB0005 - Atualizar Item da Negativação]
					this.repositorioSpcSerasa.atualizarNegativadorMovimentoRegItem(
							idItemNegativacao, pagamento.getValorPagamento(),
							pagamento.getDataPagamento(),CobrancaDebitoSituacao.PAGO);
				}
			}
			
			
		} else if (guiaPagamentoValoresHelper != null 
				&& guiaPagamentoValoresHelper.getGuiaPagamento() != null){
			// 1.2.	Tipo do Documento correspondente a Guia de Pagamento:
			
			GuiaPagamento guiaPagamento = guiaPagamentoValoresHelper.getGuiaPagamento();
			
			pagamento.setAnoMesReferenciaArrecadacao(pagamentoNaoAceito.getAnoMesReferenciaArrecadacao());
			
			// Valor da guia de pagamento.
			pagamento.setValorPagamento(guiaPagamento.getValorDebito());
			
			// Data do pagamento doc. não aceito.
			pagamento.setDataPagamento(pagamentoNaoAceito.getDataPagamento());
			
			// Id do Tipo de Débito da Guia de Pagamento 
			pagamento.setDebitoTipo(guiaPagamento.getDebitoTipo());
			
			// Caso exista pagamento para guia (indicador de débito pago = 1),
			if (guiaPagamentoValoresHelper.getIndicadorDebitoPago() != null 
					&& guiaPagamentoValoresHelper.getIndicadorDebitoPago().compareTo(ConstantesSistema.SIM) == 0) {
				// atribuir o valor nulo
				pagamento.setGuiaPagamento(null);
			} else {
				// caso contrário, atribuir o id da Guia de Pagamento.
				pagamento.setGuiaPagamento(guiaPagamento);
			}
			
			// Localidade da Guia de Pagamento
			pagamento.setLocalidade(guiaPagamento.getLocalidade());
			
			// Com o valor correspondente a guia de pagamento da tabela DOCUMENTO_TIPO.
			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.GUIA_PAGAMENTO);
			pagamento.setDocumentoTipo(documentoTipo);
			
			// AVBC_ID do pagamento doc. não aceito.
			pagamento.setAvisoBancario(pagamentoNaoAceito.getAvisoBancario());
			
			// IMOV_ID da tabela IMOVEL
			pagamento.setImovel(imovel);

			// AMIT_ID do pagamento doc. não aceito.
			pagamento.setArrecadadorMovimentoItem(pagamentoNaoAceito.getArrecadadorMovimentoItem());
			
			// ARFM_ID do pagamento doc. não aceito.
			pagamento.setArrecadacaoForma(pagamentoNaoAceito.getArrecadacaoForma());
			
			// Data e hora correntes.
			pagamento.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(pagamento);
			
			// 1.2.1. O sistema verifica se existe item de documento de cobrança associado a esta guia de pagamento.
			// 1.2.2. O Sistema atualiza a situação do item do documento de cobrança referente à Guia de Pagamento.
			this.getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
			          CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento()); 
				
			// 1.2.3. O sistema verifica se existem itens de negativação associados a esta guia de pagamento 
			// <<Inclui>> [UC1009 - Obter Itens de Negativação Associados à Guia] 
			Collection colecaoNegativadorMovimentoRegItem = this.getControladorSpcSerasa().
					obterNegativadorMovimentoRegItemAssociadosAGuiaPagamento(
							guiaPagamento.getId());
			
			// 1.2.4. Caso existam itens de negativação associados a esta guia de pagamento:
			if(colecaoNegativadorMovimentoRegItem != null && !colecaoNegativadorMovimentoRegItem.isEmpty()){
				// 1.2.4.1.	Para cada item de negativação retornado, o sistema atualiza o item de negativação com os dados do pagamento
				Iterator iterNmri = colecaoNegativadorMovimentoRegItem.iterator();
				
				while (iterNmri.hasNext()) {
					Integer idItemNegativacao = (Integer) iterNmri.next();

					// [SB0005 - Atualizar Item da Negativação]
					this.repositorioSpcSerasa.atualizarNegativadorMovimentoRegItem(
							idItemNegativacao, pagamento.getValorPagamento(),
							pagamento.getDataPagamento(),CobrancaDebitoSituacao.PAGO);
				}
			}
			
		} else if (debitoACobrarValoresHelper != null 
				&& debitoACobrarValoresHelper.getDebitoACobrar() != null){
			// 1.3.	Tipo do Documento correspondente a Débito A Cobrar:
			
			DebitoACobrar debitoACobrar = debitoACobrarValoresHelper.getDebitoACobrar();
			
			pagamento.setAnoMesReferenciaArrecadacao(pagamentoNaoAceito.getAnoMesReferenciaArrecadacao());
			
			// Valor do Pagamento.
			pagamento.setValorPagamento(debitoACobrar.getValorDebito());
			
			// Data do pagamento doc. não aceito.
			pagamento.setDataPagamento(pagamentoNaoAceito.getDataPagamento());
			
			//  
			pagamento.setDebitoTipo(debitoACobrar.getDebitoTipo());
			
			// Caso exista pagamento para débito a cobrar (indicador de débito pago = 1),
			if (debitoACobrarValoresHelper.getIndicadorDebitoPago() != null 
					&& debitoACobrarValoresHelper.getIndicadorDebitoPago().compareTo(ConstantesSistema.SIM) == 0) {
				// atribuir o valor nulo
				pagamento.setDebitoACobrarGeral(null);
			} else {
				DebitoACobrarGeral debitoACobrarGeral = new DebitoACobrarGeral();
				debitoACobrarGeral.setId(debitoACobrar.getId());
				// caso contrário, atribuir o id da Guia de Pagamento.
				pagamento.setDebitoACobrarGeral(debitoACobrarGeral);
			}
			
			// LOCA_ID da tabela débito a dobrar
			pagamento.setLocalidade(debitoACobrar.getLocalidade());
			
			// Com o valor correspondente a débito a cobrar da tabela DOCUMENTO_TIPO.
			DocumentoTipo documentoTipo = new DocumentoTipo();
			documentoTipo.setId(DocumentoTipo.DEBITO_A_COBRAR);
			pagamento.setDocumentoTipo(documentoTipo);
			
			// AVBC_ID do pagamento doc. não aceito.
			pagamento.setAvisoBancario(pagamentoNaoAceito.getAvisoBancario());
			
			// IMOV_ID da tabela IMOVEL
			pagamento.setImovel(imovel);

			// AMIT_ID do pagamento doc. não aceito.
			pagamento.setArrecadadorMovimentoItem(pagamentoNaoAceito.getArrecadadorMovimentoItem());
			
			// ARFM_ID do pagamento doc. não aceito.
			pagamento.setArrecadacaoForma(pagamentoNaoAceito.getArrecadacaoForma());
			
			// Data e hora correntes.
			pagamento.setUltimaAlteracao(new Date());

			this.getControladorUtil().inserir(pagamento);
			// 1.3.1. O sistema verifica se existe item de documento de cobrança associado a este débito a cobrar. 
			// 1.3.2. O Sistema atualiza a situação do item do documento de cobrança referente ao Débito a cobrar.
	        getControladorCobranca().atualizarSituacaoCobrancaDocumentoItemAPartirPagamento(pagamento,
	              CobrancaDebitoSituacao.PAGO, pagamento.getDataPagamento());
	        
		}

	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param idGuia
	 * 
	 * @return Integer
	 * @throws ControladorException 
	 */
	public Integer pesquisarLocalidadeGuiaPagamento(
			Integer idGuia) throws ControladorException {
		try {
			
			return repositorioArrecadacao
					.pesquisarLocalidadeGuiaPagamento(idGuia);

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param idConta
	 * 
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarLocalidadeConta(
			Integer idConta) throws ControladorException {
		try {
			
			return repositorioArrecadacao
					.pesquisarLocalidadeConta(idConta);

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
     * [UC1214] Informar Acerto Documentos Não Aceitos
	 * 
	 * @author Mariana Victor
	 * @date 24/08/2011
	 * 
	 * @param idDebitoACobrar
	 * 
	 * @return Integer
	 * @throws ControladorException
	 */
	public Integer pesquisarLocalidadeDebitoACobrar(
			Integer idDebitoACobrar) throws ControladorException {
		try {
			
			return repositorioArrecadacao
					.pesquisarLocalidadeDebitoACobrar(idDebitoACobrar);

		} catch (ErroRepositorioException e) {
			e.printStackTrace();
			throw new ControladorException("erro.sistema", e);
		}
	}
	
	/**
	 * Filtrar a quantidade de pagamento historicos do cliente
	 * 
	 * [UC0255] Filtrar Pagamentos
	 * 
	 * Pesquisa os pagamentos do Cliente
	 * 
	 * @author Rodrigo Cabral
	 * @date 15/09/11
	 * 
	 * @return Collection<Pagamento>
	 * @throws ErroRepositorioException
	 */
	public Integer pesquisarPagamentoHistoricoClienteCount(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection qtdes = null;
		int retorno = 0;

		try {
			qtdes = repositorioArrecadacao.pesquisarPagamentoHistoricoClienteCount(
					idImovel, idCliente, idTipoRelacao, localidadeInicial,
					localidadeFinal, idAvisoBancario, idArrecadador,
					periodoArrecadacaoInicial, periodoArrecadacaoFinal,
					periodoPagamentoInicio, periodoPagamentoFim,
					dataPagamentoInicial, dataPagamentoFinal,
					idsPagamentosSituacoes, idsDebitosTipos,
					idsArrecadacaoForma, idsDocumentosTipos,
                    valorPagamentoInicial,
                    valorPagamentoFinal);

			if (qtdes != null && !qtdes.isEmpty()) {

				Iterator qtdesIterator = qtdes.iterator();

				while (qtdesIterator.hasNext()) {
					Integer qtde = (Integer) qtdesIterator.next();
					retorno = retorno + qtde;
				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return retorno;

	}
	
	/**
	 * 
	 * Este caso de uso cria um sql que será usado na pesquisa de pagamentos
	 * para o Relatório
	 * 
	 * @author Rodrigo Cabral
	 * @date 16/09/2011
	 * 
	 * @param FiltroPagamento
	 * @return Collection
	 * @throws ControladorException
	 */

	public Collection pesquisarPagamentoHistoricoClienteRelatorio(String idImovel,
			String idCliente, String idTipoRelacao, String localidadeInicial,
			String localidadeFinal, String idAvisoBancario,
			String idArrecadador, String periodoArrecadacaoInicial,
			String periodoArrecadacaoFinal, String periodoPagamentoInicio,
			String periodoPagamentoFim, Date dataPagamentoInicial,
			Date dataPagamentoFinal, String[] idsPagamentosSituacoes,
			String[] idsDebitosTipos, String[] idsArrecadacaoForma,
			String[] idsDocumentosTipos,
            String valorPagamentoInicial,
            String valorPagamentoFinal) throws ControladorException {

		Collection colecaoDadosPagamento = null;
		Collection colecaoPagamento = new ArrayList();

		try {

			colecaoDadosPagamento = repositorioArrecadacao
					.pesquisarPagamentoHistoricoClienteRelatorio(idImovel, idCliente,
							idTipoRelacao, localidadeInicial, localidadeFinal,
							idAvisoBancario, idArrecadador,
							periodoArrecadacaoInicial, periodoArrecadacaoFinal,
							periodoPagamentoInicio, periodoPagamentoFim,
							dataPagamentoInicial, dataPagamentoFinal,
							idsPagamentosSituacoes, idsDebitosTipos,
							idsArrecadacaoForma, idsDocumentosTipos,
                            valorPagamentoInicial,
                            valorPagamentoFinal);

			if (colecaoDadosPagamento != null
					&& !colecaoDadosPagamento.isEmpty()) {

				Iterator colecaoDadosPagamentoIterator = colecaoDadosPagamento
						.iterator();

				while (colecaoDadosPagamentoIterator.hasNext()) {

					Object[] dadosPagamento = (Object[]) colecaoDadosPagamentoIterator
							.next();

					PagamentoRelatorioHelper pagamentoRelatorioHelper = new PagamentoRelatorioHelper();

					// Id e Descrição da Localidade
					if (dadosPagamento[1] != null) { // 1,2
						pagamentoRelatorioHelper
								.setIdLocalidade((Integer) dadosPagamento[1]);
						pagamentoRelatorioHelper
								.setDescricaoLocalidade((String) dadosPagamento[2]);
					}

					// Id e Nome da Gerência Regional
					if (dadosPagamento[3] != null) { // 3,4
						pagamentoRelatorioHelper
								.setIdGerenciaRegional((Integer) dadosPagamento[3]);
						pagamentoRelatorioHelper
								.setNomeGerenciaRegional((String) dadosPagamento[4]);
					}

					// Id do Imóvel
					if (dadosPagamento[5] != null) { // 5
						pagamentoRelatorioHelper
								.setIdImovel((Integer) dadosPagamento[5]);
					}

					// Id e Nome do Cliente
					if (dadosPagamento[6] != null) { // 6,7
						pagamentoRelatorioHelper
								.setIdCliente((Integer) dadosPagamento[6]);
						pagamentoRelatorioHelper
								.setNomeCliente((String) dadosPagamento[7]);
					}

					// Nome do Arrecador
					if (dadosPagamento[8] != null) { // 8
						pagamentoRelatorioHelper
								.setNomeArrecadador((String) dadosPagamento[8]);
					}

					// Data do Pagamento
					if (dadosPagamento[9] != null) { // 9
						pagamentoRelatorioHelper
								.setDataPagamento((Date) dadosPagamento[9]);
					}

					// Ano Mês Referência do Pagamento
					if (dadosPagamento[10] != null) { // 10
						pagamentoRelatorioHelper
								.setAnoMesReferenciaPagamento((Integer) dadosPagamento[10]);
					}

					// Descrição Tipo Débito
					if (dadosPagamento[11] != null) { // 11
						pagamentoRelatorioHelper
								.setDescricaoTipoDebito((String) dadosPagamento[11]);
					}

					// Valor do Documento
					if (dadosPagamento[12] != null) { // 12
						pagamentoRelatorioHelper
								.setValorDocumento((BigDecimal) dadosPagamento[12]);
					}

					// Valor do Pagamento
					if (dadosPagamento[13] != null) { // 13
						pagamentoRelatorioHelper
								.setValorPagamento((BigDecimal) dadosPagamento[13]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[14] != null) { // 14
						pagamentoRelatorioHelper
								.setIdSituacaoPagamentoAtual((Integer) dadosPagamento[14]);
					}

					// Descrição da Situação Atual do Pagamento
					if (dadosPagamento[15] != null) { // 15
						pagamentoRelatorioHelper
								.setDescricaoSituacaoPagamentoAtual((String) dadosPagamento[15]);
					}

					// Id do Tipo de Documento
					if (dadosPagamento[16] != null) { // 16
						pagamentoRelatorioHelper
								.setIdDocumentoTipo((Integer) dadosPagamento[16]);
					}

					colecaoPagamento.add(pagamentoRelatorioHelper);

				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}

		return colecaoPagamento;
	}
	
	/*
	 * Criado para a consulta, de manter conta por conjunto de imóveis, pelo id do banco
	 * e pelo grupo de faturamento
	 * 
	 * */
	/** @author Adriana Muniz
	  * @date: 08/04/2011
	  * [UC0146] Manter Conta(por conjunto de imóveis)
	  * 
	  * FS0028 - Verificar parâmetro consulta e débito automático
	  * @return
	  * @throws ErroRepositorioException
	  */
	public Collection pesquisarImoveisBancoDebitoAutomaticoEPorGrupoFaturamento(String[] bancos, Integer idGrupoFaturamento)
		throws ControladorException{
		
		Collection retorno = null;
		
		try{
			
			retorno = repositorioArrecadacao.pesquisarImoveisBancoDebitoAutomaticoEPorGrupoFaturamento(bancos, idGrupoFaturamento);
			
		} catch (ErroRepositorioException e) {
			
			e.printStackTrace();
		}
		
		return retorno;
	}
		
	/*
	 * autor: Adriana Muniz
	 * 
	 * Alteração para a conta considerar como filtro grupo de faturamento, quando o mesmo estiver preenchido
	 */
	/**
	 * @autor: Adriana Muniz
	 * @date: 27/04/2011
	 * 
	 * [UC0146] Manter Conta
	 * 
	 * FS0028 - Verificar parâmetro consulta e débito automático
	 * 
	 * Método para retornar a quantidade de contas a partir dos imóveis com débito automático - 
	 * Manter Contas de um Conjunto de imóveis. 
	 * 
	 * @return
     * @throws ErroRepositorioException
	 * */
	public Integer countImoveisBancoDebitoAutomaticoPorGrupoFaturamento(String[] bancos, 
			Integer anoMesInicial,Integer anoMesFinal, Date dataVencimentoInicial,
			Date dataVencimentoFinal, String indicadorContaPaga, Integer idGrupoFaturamento, Integer somenteDebitoAutomatico)
		throws ControladorException{
		
		Integer retorno = null;
		
		try{
			
			retorno = repositorioArrecadacao.countImoveisBancoDebitoAutomaticoPorGrupoFaturamento(bancos, 
					anoMesInicial, anoMesFinal, dataVencimentoInicial, dataVencimentoFinal, indicadorContaPaga, idGrupoFaturamento, somenteDebitoAutomatico);
			
		} catch (ErroRepositorioException e) {
			
			e.printStackTrace();
		}
		
		return retorno;
	}
			
	/**
	 * @author Wellington Rocha
	 * @data 15/03/2012
	 * 
	 * @param idConta
	 * @return pagamento
	 */
	public PagamentoHistorico pesquisarPagamentoDeContaEmHistorico(Integer idConta)
			throws ControladorException {

		PagamentoHistorico pagamento = null;
		Object[] pagamentoDaConta = null;

		try {

			pagamentoDaConta = repositorioArrecadacao
					.pesquisarPagamentoDeContaEmHistorico(idConta);
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}

		if (pagamentoDaConta != null && !(pagamentoDaConta.length < 0)) {

			pagamento = new PagamentoHistorico();

			// Seta o id do pagamento
			if (pagamentoDaConta[0] != null) {
				pagamento.setId((Integer) pagamentoDaConta[0]);
			}
			// Seta o valor do pagamento
			if (pagamentoDaConta[1] != null) {
				pagamento.setValorPagamento((BigDecimal) pagamentoDaConta[1]);
			}
			//Seta a data do pagamento
			if (pagamentoDaConta[2] != null) {
				pagamento.setDataPagamento((Date) pagamentoDaConta[2]);
			}
		}

		return pagamento;
	}
			
	/**
	 * Detalhar contabilização de documentos
	 * inexistentes
	 * 
	 * Retorna os pagamentos nao classificados por situacao atual
	 * 
	 * Refatoração de parte do método @encerrarArrecadacaoMes()
	 * 
	 * @author Wellington Rocha
	 * @author Felipe Santos
	 * @date 02/08/2012
	 */
	public Map<Integer, BigDecimal> retornarValorPagamentosSituacaoAtualPorPagamentoSituacao(
			Map<Integer, BigDecimal> map,
			Collection colecaoPagamentosNaoClassificadosSituacaoAtual)
			throws ControladorException {

		if (colecaoPagamentosNaoClassificadosSituacaoAtual != null
				&& colecaoPagamentosNaoClassificadosSituacaoAtual.size() > 0) {

			for (Object dadosPagamento : colecaoPagamentosNaoClassificadosSituacaoAtual) {

				Object[] arrayDadosPagamento = (Object[]) dadosPagamento;

				BigDecimal valorPagamento = (BigDecimal) arrayDadosPagamento[0];
				Integer idImovel = (Integer) arrayDadosPagamento[1];
				Imovel imovel = new Imovel();
				imovel.setId(idImovel);

				if (idImovel != null) {
					// [UC0108 - Obter Quantidade de Economias por
					// Categoria]
					Collection colecaoCategoriasImovel = getControladorImovel()
							.obterQuantidadeEconomiasCategoria(imovel);

					Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel
							.iterator();

					// [UC0185 - Obter Valor por Categoria]
					Iterator iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualDocumentoInexistente = (getControladorImovel()
							.obterValorPorCategoria(colecaoCategoriasImovel,
									valorPagamento)).iterator();

					while (iteratorColecaoCategoriasImovel.hasNext()
							&& iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualDocumentoInexistente
									.hasNext()) {

						Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel
								.next();

						valorPagamento = (BigDecimal) iteratorColecaoValorPagamentoPorCategoriaSituacaoAtualDocumentoInexistente
								.next();

						if (!map.containsKey(categoria.getId())) {
							map.put(categoria.getId(), BigDecimal.ZERO);
						}

						map.put(categoria.getId(), map.get(categoria.getId())
								.add(valorPagamento));
					}
				} else {
					if (!map.containsKey(Categoria.RESIDENCIAL)) {
						map.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
					}
					map.put(Categoria.RESIDENCIAL, map.get(
							Categoria.RESIDENCIAL).add(valorPagamento));
				}
			}
		}

		return map;
	}

	/**
	 * Detalhar contabilização de documentos
	 * inexistentes
	 * 
	 * Retorna os pagamentos nao classificados por situacao anterior
	 * 
	 * Refatoração de parte do método @encerrarArrecadacaoMes()
	 * 
	 * @author Wellington Rocha
	 * @author Felipe Santos
	 * @date 02/08/2012
	 */
	public Map<Integer, BigDecimal> retornarValorExcedenteSituacaoAnteriorPorPagamentoSituacao(
			Map<Integer, BigDecimal> map,
			Collection colecaoPagamentosNaoClassificadosSituacaoAnterior)
			throws ControladorException {

		if (colecaoPagamentosNaoClassificadosSituacaoAnterior != null
				&& colecaoPagamentosNaoClassificadosSituacaoAnterior.size() > 0) {

			for (Object dadosPagamento : colecaoPagamentosNaoClassificadosSituacaoAnterior) {

				Object[] arrayDadosPagamento = (Object[]) dadosPagamento;

				BigDecimal valorExcedente = (BigDecimal) arrayDadosPagamento[0];
				Integer idImovel = (Integer) arrayDadosPagamento[1];
				Imovel imovel = new Imovel();
				imovel.setId(idImovel);

				if (idImovel != null) {

					// [UC0108 - Obter Quantidade de Economias por
					// Categoria]
					Collection colecaoCategoriasImovel = getControladorImovel()
							.obterQuantidadeEconomiasCategoria(imovel);

					Iterator iteratorColecaoCategoriasImovel = colecaoCategoriasImovel
							.iterator();

					// [UC0185 - Obter Valor por Categoria]
					Iterator iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorDocumentoInexistente = (getControladorImovel()
							.obterValorPorCategoria(colecaoCategoriasImovel,
									valorExcedente)).iterator();

					while (iteratorColecaoCategoriasImovel.hasNext()
							&& iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorDocumentoInexistente
									.hasNext()) {

						Categoria categoria = (Categoria) iteratorColecaoCategoriasImovel
								.next();

						valorExcedente = (BigDecimal) iteratorColecaoValorExcedentePorCategoriaSituacaoAnteriorDocumentoInexistente
								.next();

						if (!map.containsKey(categoria.getId())) {
							map.put(categoria.getId(), BigDecimal.ZERO);
						}

						map.put(categoria.getId(), map.get(categoria.getId())
								.add(valorExcedente));
					}

				} else {
					if (!map.containsKey(Categoria.RESIDENCIAL)) {
						map.put(Categoria.RESIDENCIAL, BigDecimal.ZERO);
					}
					map.put(Categoria.RESIDENCIAL, map.get(
							Categoria.RESIDENCIAL).add(valorExcedente));
				}
			}
		}

		return map;
	}

	/**
	 *
	 * 
	 * Detalhar contabilização de documentos inexistentes
	 * 
	 * Refatoração de parte do método @encerrarArrecadacaoMes()
	 * 
	 * @author Wellington Rocha
	 * @author Felipe Santos
	 * @date 02/08/2012
	 */
	public ResumoArrecadacao retornarResumoArrecadacaoPorItem(
			Integer idCategoria, GerenciaRegional gerenciaRegional,
			Localidade localidade, Categoria categoria,
			Integer anoMesReferenciaArrecadacao, Integer recebimentoTipoId,
			Integer lancamentoTipoId, Integer lancamentoItemId,
			Short sequenciaTipoLancamento, Map<Integer, BigDecimal> map)
			throws ControladorException {

		ResumoArrecadacao resumoArrecadacao = new ResumoArrecadacao();

		RecebimentoTipo recebimentoTipo = new RecebimentoTipo();
		LancamentoTipo lancamentoTipo = new LancamentoTipo();
		LancamentoItem lancamentoItem = new LancamentoItem();

		recebimentoTipo.setId(recebimentoTipoId);
		lancamentoTipo.setId(lancamentoTipoId);
		lancamentoItem.setId(lancamentoItemId);
		resumoArrecadacao.setGerenciaRegional(gerenciaRegional);
		resumoArrecadacao.setLocalidade(localidade);
		resumoArrecadacao.setCategoria(categoria);
		resumoArrecadacao.setAnoMesReferencia(anoMesReferenciaArrecadacao);
		resumoArrecadacao.setRecebimentoTipo(recebimentoTipo);
		resumoArrecadacao.setLancamentoTipo(lancamentoTipo);
		resumoArrecadacao.setLancamentoItem(lancamentoItem);
		resumoArrecadacao.setLancamentoItemContabil(null);
		resumoArrecadacao.setSequenciaTipoLancamento(sequenciaTipoLancamento);
		resumoArrecadacao.setSequenciaItemTipoLancamento(new Short("0"));
		resumoArrecadacao.setUltimaAlteracao(new Date());
		resumoArrecadacao.setValorItemArrecadacao(map.get(idCategoria));

		return resumoArrecadacao;
	}
		
	/**
	 * Relatório Analitico dos valores diários da arrecadação
	 * 
	 * @author Adriana Muniz
	 * data: 05/09/2012
	 * 
	 * Obtém as formas de arrecadação por dia
	 * 
	 * @param helper
	 * @param filtro
	 * @return
	 */
	public Collection<FormasArrecadacaoDadosDiariosHelper> obterFormasDeArrecadacaoPorDia(
			Object helper, FiltroConsultarDadosDiariosArrecadacao filtro) {
		Collection colecaoFormasArrecadacao = null;
		Collection<FormasArrecadacaoDadosDiariosHelper> colecaoFormasArrecadacaoHelper = new ArrayList<FormasArrecadacaoDadosDiariosHelper>();
		
		try {
			colecaoFormasArrecadacao = repositorioArrecadacao.obterFormasDeArrecadacaoPorDia(helper, filtro);
			
			BigDecimal valorTotal = new BigDecimal(0.0);            
			if(colecaoFormasArrecadacao != null && 
					!colecaoFormasArrecadacao.equals("")) {
				Iterator colecaoFormasArrecadacaoIterator = colecaoFormasArrecadacao.iterator();
				while(colecaoFormasArrecadacaoIterator.hasNext()) {
					Object[] dadosConsulta = (Object[]) colecaoFormasArrecadacaoIterator.next();

					FormasArrecadacaoDadosDiariosHelper formasHelper = new FormasArrecadacaoDadosDiariosHelper();
					
					formasHelper.setIdArrecadador((Integer)dadosConsulta[0]);
					formasHelper.setDescricaoArrecadador((String)dadosConsulta[1]);
					formasHelper.setQtdeDocumentos((Integer) dadosConsulta[2]);
					formasHelper.setQtdePagamentos((Integer) dadosConsulta[3]);
					formasHelper.setDebitos((BigDecimal) dadosConsulta[4]);
					formasHelper.setDescontos((BigDecimal) dadosConsulta[5]);
					formasHelper.setDevolucoes((BigDecimal) dadosConsulta[6]);
					formasHelper.setValorArrecadado(formasHelper.getDebitos()
							.subtract(formasHelper.getDescontos()));
					formasHelper.setArrecadacaoLiquida(formasHelper.getDebitos()
							.subtract(formasHelper.getDescontos()).subtract(formasHelper.getDevolucoes()));
					valorTotal = valorTotal.add(formasHelper.getArrecadacaoLiquida());
					formasHelper.setValorTotal(valorTotal);
					
					colecaoFormasArrecadacaoHelper.add(formasHelper);
				}
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return colecaoFormasArrecadacaoHelper;
	}
			
	/**
	 * data: 02/10/2012
	 * 
	 * @param anoMesInicial
	 * @param anoMesFinal
	 * @param filtro
	 * @return
	 * @throws ControladorException
	 */
	public Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> 
		filtrarDadosDiariosFormasArrecadacaoComTarifa(int anoMesInicial, int anoMesFinal, 
				FiltroConsultarDadosDiariosArrecadacao filtro) throws ControladorException{
		
		Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> mapAnoMes = new TreeMap();
		try {
			
			if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")){
				anoMesInicial = Integer.parseInt(filtro.getAnoMesArrecadacao());
				anoMesFinal = anoMesInicial;
			}
			
			filtro = filtro.clone();

			for (int anoMes = anoMesInicial; anoMes <= anoMesFinal; anoMes++){
				
				filtro.setAnoMesArrecadacao(anoMes+"");
				filtro.setAgrupamento(GROUP_BY.DATA);
				Collection colecaoDadosDiarios = repositorioArrecadacao
					.filtrarDadosDiariosArrecadacao(filtro);
				
				BigDecimal valorTotal = new BigDecimal(0.0);
				BigDecimal percentualTotal = new BigDecimal(0.0);
				
				Collection<FiltrarDadosDiariosArrecadacaoHelper> colecaoDadosDiariosHelpers = new ArrayList<FiltrarDadosDiariosArrecadacaoHelper>();

				if(colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()){
					for (Iterator iter = colecaoDadosDiarios.iterator(); iter
							.hasNext();) {
						Object[] dadosConsulta = (Object[]) iter.next();
						
						FiltrarDadosDiariosArrecadacaoHelper helper = new FiltrarDadosDiariosArrecadacaoHelper();
						helper.setValorAgrupado(dadosConsulta[0] + "");
						
						helper.setItemAgrupado(pesquisarItemAgrupadoFiltrarDadosDiariosArrecadacao(
								dadosConsulta[0], filtro.getAgrupamento()));
						
						helper.setQuantidadeDocumentos((Integer) dadosConsulta[1]);
						helper.setValorDebitos((BigDecimal) dadosConsulta[3]);
						helper.setValorDescontos((BigDecimal) dadosConsulta[4]);
						helper.setValorArrecadacao(helper.getValorDebitos()
							.subtract(helper.getValorDescontos()));
						helper.setValorDevolucoes((BigDecimal) dadosConsulta[5]);
						
						helper.setValorArrecadacaoLiquida(helper.getValorDebitos()
								.subtract(helper.getValorDescontos()).subtract(helper.getValorDevolucoes()));
						
						Collection<FormasArrecadacaoDadosDiariosHelper> colecaoFormasDeArrecadacaoPorDia = 
								this.obterFormasDeArrecadacaoComTarifaPorDia(helper.getItemAgrupado(), filtro);
						
						BigDecimal valoresTarifas = new BigDecimal("0.00");

						for(FormasArrecadacaoDadosDiariosHelper helperFA : colecaoFormasDeArrecadacaoPorDia ) {
							if(helperFA.getValorTarifa() != null && !helperFA.getValorTarifa().equals(""))
								valoresTarifas = valoresTarifas.add(helperFA.getValorTarifa());
						}
						
						if(valoresTarifas != null && !valoresTarifas.equals(""))
							helper.setValorArrecadacaoLiquida(helper.getValorArrecadacaoLiquida().subtract(valoresTarifas));
							
						valorTotal = valorTotal.add(helper.getValorArrecadacaoLiquida());
						
						helper.setColecaoFormasArrecadacao(colecaoFormasDeArrecadacaoPorDia);
						
						colecaoDadosDiariosHelpers.add(helper);
					}
					
					// Calculando os percentuais
					Iterator iter = colecaoDadosDiariosHelpers.iterator();
					while (iter.hasNext()) {
						FiltrarDadosDiariosArrecadacaoHelper helper = 
							(FiltrarDadosDiariosArrecadacaoHelper) iter.next();
						
						BigDecimal big100 = new BigDecimal("100.00");
						
						BigDecimal percentual = helper.getValorArrecadacaoLiquida()
							.multiply(big100).divide(valorTotal,2,BigDecimal.ROUND_HALF_UP);
						if (percentual.add(percentualTotal)
							.compareTo(big100) > 0){
							percentual = big100.subtract(percentualTotal);
						}
						helper.setPercentual(percentual);
						

					}
					
					mapAnoMes.put(anoMes, colecaoDadosDiariosHelpers);
				}
				
			}
			

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return mapAnoMes;
		
	}
			
	/**
	 * 
	 * @author Adriana Muniz
	 * data: 02/10/2012
	 * 
	 * Obtém as formas de arrecadação com tarifa por dia
	 * 
	 * @param helper
	 * @param filtro
	 * @return
	 */
	public Collection<FormasArrecadacaoDadosDiariosHelper> obterFormasDeArrecadacaoComTarifaPorDia(
			Object helper, FiltroConsultarDadosDiariosArrecadacao filtro) {
		Collection colecaoFormasArrecadacao = null;
		Collection<FormasArrecadacaoDadosDiariosHelper> colecaoFormasArrecadacaoHelper = new ArrayList<FormasArrecadacaoDadosDiariosHelper>();
		
		try {
			colecaoFormasArrecadacao = repositorioArrecadacao.obterFormasDeArrecadacaoComTarifaPorDia(helper, filtro);
			
			///falta organizar isso aqui
			BigDecimal valorTotal = new BigDecimal(0.0);            
			if(colecaoFormasArrecadacao != null && 
					!colecaoFormasArrecadacao.equals("")) {
				Iterator colecaoFormasArrecadacaoIterator = colecaoFormasArrecadacao.iterator();
				while(colecaoFormasArrecadacaoIterator.hasNext()) {
					Object[] dadosConsulta = (Object[]) colecaoFormasArrecadacaoIterator.next();

					FormasArrecadacaoDadosDiariosHelper formasHelper = new FormasArrecadacaoDadosDiariosHelper();
					
					formasHelper.setIdArrecadador((Integer)dadosConsulta[0]);
					formasHelper.setDescricaoArrecadador((String)dadosConsulta[1]);
					formasHelper.setValorTarifa((BigDecimal)dadosConsulta[2]);
					formasHelper.setDataPrevista((Date)dadosConsulta[3]);
					formasHelper.setQtdeDocumentos((Integer) dadosConsulta[4]);
					formasHelper.setQtdePagamentos((Integer) dadosConsulta[5]);
					formasHelper.setDebitos((BigDecimal) dadosConsulta[6]);
					formasHelper.setDescontos((BigDecimal) dadosConsulta[7]);
					formasHelper.setDevolucoes((BigDecimal) dadosConsulta[8]);
					formasHelper.setValorArrecadado(formasHelper.getDebitos().subtract(formasHelper.getDescontos()));
					
					formasHelper.setArrecadacaoLiquida(formasHelper.getDebitos()
							.subtract(formasHelper.getDescontos()).subtract(formasHelper.getDevolucoes()));
					
					if(formasHelper.getValorTarifa() != null && !formasHelper.getValorTarifa().equals(""))
						formasHelper.setArrecadacaoLiquida(
								formasHelper.getArrecadacaoLiquida().subtract(formasHelper.getValorTarifa()));
					valorTotal = valorTotal.add(formasHelper.getArrecadacaoLiquida());
					formasHelper.setValorTotal(valorTotal);
					
					colecaoFormasArrecadacaoHelper.add(formasHelper);
				}
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return colecaoFormasArrecadacaoHelper;
	}
			

	/**
	 * @Data: 05/12/2012
	 * @author Adriana Muniz
	 * 
	 * Gera os dados diários da arrecadação acumulando a quantidade e o valor
	 * dos pagamentos
	 * 
	 * @throws ControladorException
	 */
	public void gerarDadosDiariosArrecadacaoAuxiliar(Integer idLocalidade, Integer anoMesArrecadacaoAtual)
			throws ControladorException {

		Collection colecaoDadosDiariosArrecadacaoAuxiliarInserir = null;

		ArrecadacaoDadosDiariosAuxiliar arrecadacaoDadosDiariosAuxiliar = null;

		Imovel imovel = null;
		Localidade localidade = null;
		SetorComercial setorComercial = null;
		Rota rota = null;
		Quadra quadra = null;
		int codigoSetorComercial = 0;
		int numeroQuadra = 0;
		ImovelPerfil perfilImovel = null;
		LigacaoAguaSituacao situacaoLigacaoAgua = null;
		LigacaoEsgotoSituacao situacaoLigacaoEsgoto = null;
		Categoria principalCategoria = null;
		EsferaPoder esferaPoder = null;
		Short indicadorHidrometro = null;
		BigDecimal somaValor = null;
		Integer quantidade = null;
		AvisoBancario avisoBancario = null;
		Arrecadador arrecadador = null;
		UnidadeNegocio unidadeNegocio = null;
		GerenciaRegional gerenciaRegional = null;
		DocumentoTipo documentoTipo = null;
		ArrecadacaoForma arrecadacaoForma = null;
		Date dataPagamento = null;
		Date dataDevolucao = null;
		DocumentoTipo documentoTipoAgregador = null;
		
		Integer qtdDocumentosAgregados = null;
		
		Collection colecaoDadosPagamentos = null;
		Collection colecaoDadosDevolucoes = null;
		boolean concluiuComSucesso = false;

		try {

			int cont = 0;

			repositorioArrecadacao
					.excluirDadosDiariosArrecadacaoAuxiliarPorAnoMesArrecadacaoPorLocalidade(
							anoMesArrecadacaoAtual, idLocalidade);

			localidade = new Localidade();
			localidade.setId(idLocalidade);
			cont = 0;

			colecaoDadosPagamentos = repositorioArrecadacao
					.acumularQuantidadeEValorPagamentoPorAnoMesArrecadacaoAuxiliar(
							anoMesArrecadacaoAtual, localidade.getId());

			colecaoDadosDiariosArrecadacaoAuxiliarInserir = new ArrayList();
			
			if (colecaoDadosPagamentos != null) {
				
				for (Object dadosPagamento : colecaoDadosPagamentos) {

					Object[] arrayDadosPagamento = (Object[]) dadosPagamento;

					if (arrayDadosPagamento != null) {
						// SOMA DO VALOR
						if (arrayDadosPagamento[0] != null) {

							somaValor = (BigDecimal) arrayDadosPagamento[0];
						} else {
							somaValor = null;
						}

						// QUANTIDADE PAGAMENTOS
						if (arrayDadosPagamento[1] != null) {
							quantidade = (Integer) arrayDadosPagamento[1];
						} else {
							quantidade = null;
						}

						// ID GERENCIA REGIONAL
						if (arrayDadosPagamento[2] != null) {
							gerenciaRegional = new GerenciaRegional();
							gerenciaRegional
									.setId((Integer) arrayDadosPagamento[2]);
						} else {
							gerenciaRegional = null;
						}

						// ID AVISO BANCARIO
						if (arrayDadosPagamento[3] != null) {
							avisoBancario = new AvisoBancario();
							avisoBancario
									.setId((Integer) arrayDadosPagamento[3]);
						} else {
							avisoBancario = null;
						}

						// ID ARRECADADOR
						if (arrayDadosPagamento[4] != null) {
							arrecadador = new Arrecadador();
							arrecadador
									.setId((Integer) arrayDadosPagamento[4]);
						} else {
							arrecadador = null;
						}

						// ID DOCUMENTO TIPO
						if (arrayDadosPagamento[5] != null) {
							documentoTipo = new DocumentoTipo();
							documentoTipo
									.setId((Integer) arrayDadosPagamento[5]);
						} else {
							documentoTipo = null;
						}

						// ID ARRECADACAO FORMA
						if (arrayDadosPagamento[6] != null) {
							arrecadacaoForma = new ArrecadacaoForma();
							arrecadacaoForma
									.setId((Integer) arrayDadosPagamento[6]);
						} else {
							arrecadacaoForma = null;
						}

						// DATA DO PAGAMENTO
						if (arrayDadosPagamento[7] != null) {
							dataPagamento = (Date) arrayDadosPagamento[7];
						} else {
							dataPagamento = null;
						}

						// ID UNIDADE DE NEGOCIO
						if (arrayDadosPagamento[8] != null) {
							unidadeNegocio = new UnidadeNegocio();
							unidadeNegocio
									.setId((Integer) arrayDadosPagamento[8]);
						} else {
							unidadeNegocio = null;
						}

						// TIPO DE DOCUMENTO AGREGADOR
						if (arrayDadosPagamento != null
								&& arrayDadosPagamento[9] != null) {
							Integer idDocumentoTipoAgregador = (Integer) arrayDadosPagamento[9];
							if (!idDocumentoTipoAgregador
									.equals(new Integer(0))) {
								documentoTipoAgregador = new DocumentoTipo();
								documentoTipoAgregador
										.setId(idDocumentoTipoAgregador);
							} else {
								documentoTipoAgregador = null;
							}
						}

						// QTD DE DOCUMENTOS AGREGADOS
						if (arrayDadosPagamento != null
								&& arrayDadosPagamento[10] != null) {
							qtdDocumentosAgregados = (Integer) arrayDadosPagamento[10];
						}

						ArrecadadorContratoTarifa arrecadadorContratoTarifa = null;

						// Pesquisar valores de tarifa
						if (arrecadador != null && arrecadacaoForma != null) {
							arrecadadorContratoTarifa = repositorioArrecadacao
									.pesquisarArrecadadorContratoTarifa(
											arrecadador.getId(),
											arrecadacaoForma.getId());
						}

						arrecadacaoDadosDiariosAuxiliar = new ArrecadacaoDadosDiariosAuxiliar();
						arrecadacaoDadosDiariosAuxiliar.setAnoMesReferenciaArrecadacao(anoMesArrecadacaoAtual);
						arrecadacaoDadosDiariosAuxiliar.setArrecadador(arrecadador);
						arrecadacaoDadosDiariosAuxiliar.setUnidadeNegocio(unidadeNegocio);
						arrecadacaoDadosDiariosAuxiliar.setGerenciaRegional(gerenciaRegional);
						arrecadacaoDadosDiariosAuxiliar.setLocalidade(localidade);
						arrecadacaoDadosDiariosAuxiliar.setDocumentoTipo(documentoTipo);
						arrecadacaoDadosDiariosAuxiliar.setArrecadacaoForma(arrecadacaoForma);
						arrecadacaoDadosDiariosAuxiliar.setDataPagamento(dataPagamento);
						arrecadacaoDadosDiariosAuxiliar.setQuantidadePagamentos(quantidade);
						arrecadacaoDadosDiariosAuxiliar.setValorPagamentos(somaValor);
						arrecadacaoDadosDiariosAuxiliar.setQuantidadeDocumentos(qtdDocumentosAgregados);
						arrecadacaoDadosDiariosAuxiliar.setDocumentoTipoAgregador(documentoTipoAgregador);
						arrecadacaoDadosDiariosAuxiliar.setUltimaAlteracao(new Date());

						if (arrecadadorContratoTarifa != null) {
							arrecadacaoDadosDiariosAuxiliar.setValorUnitarioTarifa(arrecadadorContratoTarifa
											.getValorTarifa());
							arrecadacaoDadosDiariosAuxiliar.setNumeroDiasFloat(arrecadadorContratoTarifa
											.getNumeroDiaFloat());
							if (arrecadacaoDadosDiariosAuxiliar.getValorUnitarioTarifa() != null
									&& arrecadacaoDadosDiariosAuxiliar.getQuantidadeDocumentos() != null) {
								arrecadacaoDadosDiariosAuxiliar
										.setValorTotalTarifas(arrecadacaoDadosDiariosAuxiliar
												.getValorUnitarioTarifa()
												.multiply(new BigDecimal(
														arrecadacaoDadosDiariosAuxiliar.getQuantidadeDocumentos())));
							}
						}
						cont++;
						colecaoDadosDiariosArrecadacaoAuxiliarInserir.add(arrecadacaoDadosDiariosAuxiliar);
						
					}
				}

				colecaoDadosPagamentos.clear();

			}
			
			repositorioArrecadacao.excluirDadosDiariosDevolucaoPorAnoMesArrecadacaoAuxiliarPorLocalidade(
							anoMesArrecadacaoAtual,	idLocalidade);

			// Acumula a quantidade e o valor das devolucoes
			colecaoDadosDevolucoes = repositorioArrecadacao.
					acumularQuantidadeEValorDevolucaoPorAnoMesArrecadacaoAuxiliar(
							anoMesArrecadacaoAtual, localidade.getId());
										
			if (colecaoDadosDevolucoes != null) {
				
				for (Object dadosDevolucao : colecaoDadosDevolucoes) {

					Object[] arrayDadosDevolucao = (Object[]) dadosDevolucao;

					// SOMA DO VALOR
					if (arrayDadosDevolucao!= null && arrayDadosDevolucao[0] != null) {
						somaValor = (BigDecimal) arrayDadosDevolucao[0];
					} else {
						somaValor = null;
					}

					// QUANTIDADE DEVOLUCOES
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[1] != null) {
						quantidade = (Integer) arrayDadosDevolucao[1];
					} else {
						quantidade = null;
					}

					// ID GERENCIA REGIONAL
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[2] != null) {
						gerenciaRegional = new GerenciaRegional();
						gerenciaRegional.setId((Integer) arrayDadosDevolucao[2]);
					} else {
						gerenciaRegional = null;
					}

					// ID AVISO BANCARIO
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[3] != null) {
						avisoBancario = new AvisoBancario();
						avisoBancario.setId((Integer) arrayDadosDevolucao[3]);
					} else {
						avisoBancario = null;
					}

					// ID ARRECADADOR
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[4] != null) {
						arrecadador = new Arrecadador();
						arrecadador
								.setId((Integer) arrayDadosDevolucao[4]);
					} else {
						arrecadador = null;
					}

					documentoTipo = new DocumentoTipo();
					documentoTipo.setId(DocumentoTipo.DEVOLUCAO_VALOR);

					
					// ID ARRECADACAO FORMA
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[5] != null) {
						arrecadacaoForma = new ArrecadacaoForma();
						arrecadacaoForma.setId((Integer) arrayDadosDevolucao[5]);
					} else {
						arrecadacaoForma = null;
					}

					// DATA DE DEVOLUCAO
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[6] != null) {
							dataDevolucao = (Date) arrayDadosDevolucao[6];
					} else {
						dataDevolucao = null;
					}

					// ID UNIDADE DE NEGOCIO
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[7] != null) {
						unidadeNegocio = new UnidadeNegocio();
						unidadeNegocio.setId((Integer) arrayDadosDevolucao[7]);
					} else {
						unidadeNegocio = null;
					}
					
					// TIPO DE DEVOLUCAO
					String tipoDevolucao = "";
					if(arrayDadosDevolucao != null && arrayDadosDevolucao[10] != null){
						tipoDevolucao = (String) arrayDadosDevolucao[10];
						if (tipoDevolucao.equals("N")){
							documentoTipoAgregador = documentoTipo;
						}
					}
					
					// TIPO DE DOCUMENTO AGREGADOR
					if (arrayDadosDevolucao != null && arrayDadosDevolucao[8] != null){
						Integer idDocumentoTipoAgregador = (Integer) arrayDadosDevolucao[8];
						if (!tipoDevolucao.equals("N")){
							if (!idDocumentoTipoAgregador.equals(new Integer(0))){
								documentoTipoAgregador = new DocumentoTipo();
								documentoTipoAgregador.setId(idDocumentoTipoAgregador);
							} else {
								documentoTipoAgregador = null;
							}
						}
					}								
														
					// QTD DE DOCUMENTOS AGREGADOS
					if(arrayDadosDevolucao != null && arrayDadosDevolucao[9] != null){
						qtdDocumentosAgregados = (Integer) arrayDadosDevolucao[9];
					}
					
					DevolucaoDadosDiariosAuxiliar devolucaoDadosDiariosAuxiliar = new DevolucaoDadosDiariosAuxiliar();
					devolucaoDadosDiariosAuxiliar.setAnoMesReferencia(anoMesArrecadacaoAtual);
					devolucaoDadosDiariosAuxiliar.setArrecadador(arrecadador);
					devolucaoDadosDiariosAuxiliar.setUnidadeNegocio(unidadeNegocio);
					devolucaoDadosDiariosAuxiliar.setGerenciaRegional(gerenciaRegional);
					devolucaoDadosDiariosAuxiliar.setLocalidade(localidade);				
					devolucaoDadosDiariosAuxiliar.setDocumentoTipo(documentoTipo);
					devolucaoDadosDiariosAuxiliar.setArrecadacaoForma(arrecadacaoForma);
					devolucaoDadosDiariosAuxiliar.setDataDevolucao(dataDevolucao);
					devolucaoDadosDiariosAuxiliar.setQuantidadeDevolucoes(quantidade);
					devolucaoDadosDiariosAuxiliar.setValorDevolucoes(somaValor);
					devolucaoDadosDiariosAuxiliar.setQuantidadeDocumentos(qtdDocumentosAgregados);
					devolucaoDadosDiariosAuxiliar.setDocumentoTipoAgregador(documentoTipoAgregador);
					devolucaoDadosDiariosAuxiliar.setDevolucaoTipo(tipoDevolucao);
					devolucaoDadosDiariosAuxiliar.setDataUltimaAlteracao(new Date());
					cont++;
					
					colecaoDadosDiariosArrecadacaoAuxiliarInserir.add(devolucaoDadosDiariosAuxiliar);
				}
				
				colecaoDadosDevolucoes.clear();
				
			}

		}catch(Exception e) {
			e.printStackTrace();
		}
					
		getControladorBatch().inserirColecaoObjetoParaBatch(colecaoDadosDiariosArrecadacaoAuxiliarInserir);
		colecaoDadosDiariosArrecadacaoAuxiliarInserir = null;
					
	}
			

	/**
	 * data: 11/12/2012
	 * 
	 * Recupera os dados diarios da arrecadação auxiliar
	 * 
	 * @param anoMesInicial
	 * @param anoMesFinal
	 * @param filtro
	 * @return
	 * @throws ControladorException
	 */
	public Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> 
		filtrarDadosDiariosArrecadacaoAuxiliar(int anoMesInicial, int anoMesFinal, 
				FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro) throws ControladorException{
		
		Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> mapAnoMes = new TreeMap();
		try {
			
			if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")){
				anoMesInicial = Integer.parseInt(filtro.getAnoMesArrecadacao());
				anoMesFinal = anoMesInicial;
			}
			
			filtro = filtro.clone();

			for (int anoMes = anoMesInicial; anoMes <= anoMesFinal; anoMes++){
				
				filtro.setAnoMesArrecadacao(anoMes+"");
				Collection colecaoDadosDiarios = repositorioArrecadacao
					.filtrarDadosDiariosArrecadacaoAuxiliar(filtro);
				
				BigDecimal valorTotal = new BigDecimal(0.0);
				BigDecimal percentualTotal = new BigDecimal(0.0);
				
				Collection<FiltrarDadosDiariosArrecadacaoHelper> colecaoDadosDiariosHelpers = new ArrayList<FiltrarDadosDiariosArrecadacaoHelper>();

				if(colecaoDadosDiarios != null && !colecaoDadosDiarios.isEmpty()){
					for (Iterator iter = colecaoDadosDiarios.iterator(); iter
							.hasNext();) {
						Object[] dadosConsulta = (Object[]) iter.next();
						
						FiltrarDadosDiariosArrecadacaoHelper helper = new FiltrarDadosDiariosArrecadacaoHelper();
						helper.setValorAgrupado(dadosConsulta[0] + "");
						
						helper.setItemAgrupado(pesquisarItemAgrupadoFiltrarDadosDiariosArrecadacaoAuxiliar(
								dadosConsulta[0], filtro.getAgrupamento()));
						
						helper.setQuantidadeDocumentos((Integer) dadosConsulta[1]);
						helper.setQuantidadePagamentos((Integer) dadosConsulta[2]);
						helper.setValorDebitos((BigDecimal) dadosConsulta[3]);
						helper.setValorDescontos((BigDecimal) dadosConsulta[4]);
						helper.setValorArrecadacao(helper.getValorDebitos()
							.subtract(helper.getValorDescontos()));
						helper.setValorDevolucoes((BigDecimal) dadosConsulta[5]);
						helper.setValorArrecadacaoLiquida(helper.getValorDebitos()
							.subtract(helper.getValorDescontos()).subtract(helper.getValorDevolucoes()));
						
						valorTotal = valorTotal.add(helper.getValorArrecadacaoLiquida());
						
						colecaoDadosDiariosHelpers.add(helper);
						
					}
					
					// Calculando os percentuais
					Iterator iter = colecaoDadosDiariosHelpers.iterator();
					while (iter.hasNext()) {
						FiltrarDadosDiariosArrecadacaoHelper helper = 
							(FiltrarDadosDiariosArrecadacaoHelper) iter.next();
						
						BigDecimal big100 = new BigDecimal("100.00");
						
						BigDecimal percentual = helper.getValorArrecadacaoLiquida()
							.multiply(big100).divide(valorTotal,2,BigDecimal.ROUND_HALF_UP);
						if (percentual.add(percentualTotal)
							.compareTo(big100) > 0){
							percentual = big100.subtract(percentualTotal);
						}
						helper.setPercentual(percentual);
						

					}
					
					mapAnoMes.put(anoMes, colecaoDadosDiariosHelpers);
				}
				
			}
			

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return mapAnoMes;
		
	}
			
	private Object pesquisarItemAgrupadoFiltrarDadosDiariosArrecadacaoAuxiliar(Object idObjeto, 
			GROUP_BY_AUX agrupamento) throws ControladorException{
			
		Object itemAgrupado = null;
		
		try {
			switch (agrupamento) {
			case GERENCIA_REGIONAL:
				//pesquisar na base a gerencia Regional
				FiltroGerenciaRegional filtroGerenciaRegional = new FiltroGerenciaRegional ();
				filtroGerenciaRegional.adicionarParametro(new ParametroSimples(FiltroGerenciaRegional.ID,
						idObjeto));
				
				Collection colecaoGerenciaRegional = repositorioUtil.pesquisar(
						filtroGerenciaRegional,
						GerenciaRegional.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoGerenciaRegional);
				break;

			case UNIDADE_NEGOCIO:
				//pesquisar na base a unidade negocio
				FiltroUnidadeNegocio filtroUnidadeNegocio = new FiltroUnidadeNegocio();
				
				filtroUnidadeNegocio.adicionarParametro(new ParametroSimples(FiltroUnidadeNegocio.ID,
						idObjeto));
				
				Collection colecaoUnidadeNegocio = repositorioUtil.pesquisar(filtroUnidadeNegocio,
						UnidadeNegocio.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoUnidadeNegocio);				
				break;
				
			case ELO:
				// pesquisar na base a localidade
				FiltroLocalidade filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples("localidade.id",
					idObjeto));
				filtroLocalidade.adicionarCaminhoParaCarregamentoEntidade("localidade");
				
				Collection colecaoLocalidade = repositorioUtil.pesquisar(filtroLocalidade,
						Localidade.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoLocalidade);				
				break;
			case LOCALIDADE:
				// pesquisar na base a localidade
				filtroLocalidade = new FiltroLocalidade();
				filtroLocalidade.adicionarParametro(new ParametroSimples("id",
					idObjeto));
				
				colecaoLocalidade = repositorioUtil.pesquisar(filtroLocalidade,
						Localidade.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoLocalidade);				
				break;
				
			case DATA:
			case ANO_MES:				
				itemAgrupado = idObjeto;
				break;
			case ARRECADADOR:
				//pesquisar na base o arrecadador
				FiltroArrecadador filtroArrecadador = new FiltroArrecadador();
				filtroArrecadador.adicionarParametro(new ParametroSimples(FiltroArrecadador.ID,
						idObjeto));
				filtroArrecadador.adicionarCaminhoParaCarregamentoEntidade("cliente");
				
				Collection colecaoArrecadador = repositorioUtil.pesquisar(filtroArrecadador,
						Arrecadador.class.getName());
				
				itemAgrupado = Util.retonarObjetoDeColecao(colecaoArrecadador);				
				break;
			case FORMA_ARRECADACAO:
				if (idObjeto != null){
					//pesquisar na base o arrecadacao forma
					FiltroArrecadacaoForma filtroArrecadacaoForma = new FiltroArrecadacaoForma();
					filtroArrecadacaoForma.adicionarParametro(new ParametroSimples(FiltroArrecadacaoForma.CODIGO,
							idObjeto));
					
					Collection colecaoArrecadacaoForma = repositorioUtil.pesquisar(filtroArrecadacaoForma,
							ArrecadacaoForma.class.getName());
					
					itemAgrupado = Util.retonarObjetoDeColecao(colecaoArrecadacaoForma);					
				}
				
				if(itemAgrupado == null){
					ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
					arrecadacaoForma.setId(0);
					arrecadacaoForma.setDescricao("Sem forma de arrecadação");
					itemAgrupado = arrecadacaoForma;
				}				
								
				break;
			case CATEGORIA:
				//pesquisar na base a Categoria
				FiltroCategoria filtroCategoria = new FiltroCategoria();
				filtroCategoria.adicionarParametro(new ParametroSimples(FiltroCategoria.CODIGO,
						idObjeto));
				
				Collection colecaoCategorias = repositorioUtil.pesquisar(filtroCategoria,
						Categoria.class.getName());
				
				itemAgrupado =  Util.retonarObjetoDeColecao(colecaoCategorias);				
				break;
			case PERFIL:
				//pesquisar na base o Imovel Perfil
				FiltroImovelPerfil filtroImovelPerfil = new FiltroImovelPerfil();
				filtroImovelPerfil.adicionarParametro(new ParametroSimples(FiltroImovelPerfil.ID,
						idObjeto));
				
				Collection colecaoImovelPerfil = repositorioUtil.pesquisar(filtroImovelPerfil,
						ImovelPerfil.class.getName());

				itemAgrupado = Util.retonarObjetoDeColecao(colecaoImovelPerfil);
				break;
			case TIPO_DOCUMENTO:
			case TIPO_DOCUMENTO_AGREGADOR:
				
				if (idObjeto != null) {
					//pesquisar na base o Documento Tipo
					FiltroDocumentoTipo filtroDocumentoTipo = new FiltroDocumentoTipo();
					filtroDocumentoTipo.adicionarParametro(new ParametroSimples(FiltroDocumentoTipo.ID,
							idObjeto));
					
					Collection colecaoDocumentoTipo = repositorioUtil.pesquisar(filtroDocumentoTipo,
							DocumentoTipo.class.getName());
					
					itemAgrupado = Util.retonarObjetoDeColecao(colecaoDocumentoTipo);
				}
				
				if (itemAgrupado == null){
					DocumentoTipo documentoTipo = new DocumentoTipo();
					documentoTipo.setDescricaoDocumentoTipo("Sem tipo de documento");
					documentoTipo.setId(0);
					itemAgrupado = documentoTipo;
				}
				break;
			default:
				break;
			}
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		
		return itemAgrupado;
	}
			
	/**
	 * @author Adriana Muniz
	 * @date 10/12/2012
	 * 
	 * Consultar Dados Diários da Arrecadação da tabela arrecadacao_dados_diarios_auxiliar
	 *
	 * Verificar se existe dados diarios da arrecadacao de acordo com o filtro 
	 * passado
	 *
	 *
	 * @param filtro
	 * @return boolean de existencia dos dados
	 * @throws ControladorException
	 */
	public boolean verificarExistenciaDadosDiariosArrecadacaoAuxiliar(int anoMesInicial, int anoMesFinal,
		FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro) throws ControladorException{
		
		boolean retorno = false;
		try {
			if (filtro.getAnoMesArrecadacao() != null && !filtro.getAnoMesArrecadacao().equals("")){
				anoMesInicial = Integer.parseInt(filtro.getAnoMesArrecadacao());
				anoMesFinal = anoMesInicial;
			}
			
			filtro = filtro.clone();

			for (int anoMes = anoMesInicial; anoMes <= anoMesFinal; anoMes++){
				
				filtro.setAnoMesArrecadacao(anoMes+"");

				retorno = repositorioArrecadacao.verificarExistenciaDadosDiariosArrecadacaoAuxiliar(filtro);
				
				if (retorno) {
					break;
				}
			}

		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}		
		return retorno;
	}
			
	/**
	 *
	 * @author Adriana Muniz 
	 * @data: 19/12/2012
	 * 
	 * Consulta para retornar os dados diários arrecadação auxiliar
	 * agrupados por formas de arrecadação com tarifa
	 * 
	 * @param anoMesInicial
	 * @param anoMesFinal
	 * @param filtro
	 * @return
	 * @throws ControladorException
	 */
	public Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> filtrarDadosDiariosArrecadacaoAuxiliarFormasArrecadacaoComTarifa(
			int anoMesInicial, int anoMesFinal,
			FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro)
			throws ControladorException {

		Map<Integer, Collection<FiltrarDadosDiariosArrecadacaoHelper>> mapAnoMes = new TreeMap();
		try {

			if (filtro.getAnoMesArrecadacao() != null
					&& !filtro.getAnoMesArrecadacao().equals("")) {
				anoMesInicial = Integer.parseInt(filtro.getAnoMesArrecadacao());
				anoMesFinal = anoMesInicial;
			}

			filtro = filtro.clone();

			for (int anoMes = anoMesInicial; anoMes <= anoMesFinal; anoMes++) {

				filtro.setAnoMesArrecadacao(anoMes + "");
				filtro.setAgrupamento(GROUP_BY_AUX.DATA);
				Collection colecaoDadosDiarios = repositorioArrecadacao
						.filtrarDadosDiariosArrecadacaoAuxiliar(filtro);

				BigDecimal valorTotal = new BigDecimal(0.0);
				BigDecimal percentualTotal = new BigDecimal(0.0);

				Collection<FiltrarDadosDiariosArrecadacaoHelper> colecaoDadosDiariosHelpers = new ArrayList<FiltrarDadosDiariosArrecadacaoHelper>();

				if (colecaoDadosDiarios != null
						&& !colecaoDadosDiarios.isEmpty()) {
					for (Iterator iter = colecaoDadosDiarios.iterator(); iter
							.hasNext();) {
						Object[] dadosConsulta = (Object[]) iter.next();

						FiltrarDadosDiariosArrecadacaoHelper helper = new FiltrarDadosDiariosArrecadacaoHelper();
						helper.setValorAgrupado(dadosConsulta[0] + "");

						helper.setItemAgrupado(pesquisarItemAgrupadoFiltrarDadosDiariosArrecadacaoAuxiliar(
								dadosConsulta[0], filtro.getAgrupamento()));

						helper.setQuantidadeDocumentos((Integer) dadosConsulta[1]);
						helper.setValorDebitos((BigDecimal) dadosConsulta[3]);
						helper.setValorDescontos((BigDecimal) dadosConsulta[4]);
						helper.setValorArrecadacao(helper.getValorDebitos()
								.subtract(helper.getValorDescontos()));
						helper.setValorDevolucoes((BigDecimal) dadosConsulta[5]);

						helper.setValorArrecadacaoLiquida(helper
								.getValorDebitos()
								.subtract(helper.getValorDescontos())
								.subtract(helper.getValorDevolucoes()));

						Collection<FormasArrecadacaoDadosDiariosHelper> colecaoFormasDeArrecadacaoPorDia = this
								.obterFormasDeArrecadacaoComTarifaPorDiaAuxiliar(
										helper.getItemAgrupado(), filtro);

						BigDecimal valoresTarifas = new BigDecimal("0.00");

						for (FormasArrecadacaoDadosDiariosHelper helperFA : colecaoFormasDeArrecadacaoPorDia) {
							if (helperFA.getValorTarifa() != null
									&& !helperFA.getValorTarifa().equals(""))
								valoresTarifas = valoresTarifas.add(helperFA
										.getValorTarifa());
						}

						if (valoresTarifas != null
								&& !valoresTarifas.equals(""))
							helper.setValorArrecadacaoLiquida(helper
									.getValorArrecadacaoLiquida().subtract(
											valoresTarifas));

						valorTotal = valorTotal.add(helper
								.getValorArrecadacaoLiquida());

						helper.setColecaoFormasArrecadacao(colecaoFormasDeArrecadacaoPorDia);

						colecaoDadosDiariosHelpers.add(helper);
					}

					// Calculando os percentuais
					Iterator iter = colecaoDadosDiariosHelpers.iterator();
					while (iter.hasNext()) {
						FiltrarDadosDiariosArrecadacaoHelper helper = (FiltrarDadosDiariosArrecadacaoHelper) iter
								.next();

						BigDecimal big100 = new BigDecimal("100.00");

						BigDecimal percentual = helper
								.getValorArrecadacaoLiquida()
								.multiply(big100)
								.divide(valorTotal, 2, BigDecimal.ROUND_HALF_UP);
						if (percentual.add(percentualTotal).compareTo(big100) > 0) {
							percentual = big100.subtract(percentualTotal);
						}
						helper.setPercentual(percentual);

					}

					mapAnoMes.put(anoMes, colecaoDadosDiariosHelpers);
				}

			}

		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
		return mapAnoMes;

	}
			
	/**
	 * 
	 * @author Adriana Muniz
	 * data: 19/12/2012
	 * 
	 * Obtém as formas de arrecadação com tarifa por dia
	 * 
	 * @param helper
	 * @param filtro
	 * @return
	 */
	public Collection<FormasArrecadacaoDadosDiariosHelper> obterFormasDeArrecadacaoComTarifaPorDiaAuxiliar(
			Object helper, FiltroConsultarDadosDiariosArrecadacaoAuxiliar filtro) {
		Collection colecaoFormasArrecadacao = null;
		Collection<FormasArrecadacaoDadosDiariosHelper> colecaoFormasArrecadacaoHelper = new ArrayList<FormasArrecadacaoDadosDiariosHelper>();
		
		try {
			colecaoFormasArrecadacao = repositorioArrecadacao.obterFormasDeArrecadacaoComTarifaPorDiaAuxiliar(helper, filtro);
			
			///falta organizar isso aqui
			BigDecimal valorTotal = new BigDecimal(0.0);            
			if(colecaoFormasArrecadacao != null && 
					!colecaoFormasArrecadacao.equals("")) {
				Iterator colecaoFormasArrecadacaoIterator = colecaoFormasArrecadacao.iterator();
				while(colecaoFormasArrecadacaoIterator.hasNext()) {
					Object[] dadosConsulta = (Object[]) colecaoFormasArrecadacaoIterator.next();

					FormasArrecadacaoDadosDiariosHelper formasHelper = new FormasArrecadacaoDadosDiariosHelper();
					
					formasHelper.setIdArrecadador((Integer)dadosConsulta[0]);
					formasHelper.setDescricaoArrecadador((String)dadosConsulta[1]);
					formasHelper.setValorTarifa((BigDecimal)dadosConsulta[2]);
					formasHelper.setDataPrevista((Date)dadosConsulta[3]);
					formasHelper.setQtdeDocumentos((Integer) dadosConsulta[4]);
					formasHelper.setQtdePagamentos((Integer) dadosConsulta[5]);
					formasHelper.setDebitos((BigDecimal) dadosConsulta[6]);
					formasHelper.setDescontos((BigDecimal) dadosConsulta[7]);
					formasHelper.setDevolucoes((BigDecimal) dadosConsulta[8]);
					formasHelper.setValorArrecadado(formasHelper.getDebitos().subtract(formasHelper.getDescontos()));
					
					formasHelper.setArrecadacaoLiquida(formasHelper.getDebitos()
							.subtract(formasHelper.getDescontos()).subtract(formasHelper.getDevolucoes()));
					
					if(formasHelper.getValorTarifa() != null && !formasHelper.getValorTarifa().equals(""))
						formasHelper.setArrecadacaoLiquida(
								formasHelper.getArrecadacaoLiquida().subtract(formasHelper.getValorTarifa()));
					valorTotal = valorTotal.add(formasHelper.getArrecadacaoLiquida());
					formasHelper.setValorTotal(valorTotal);
					
					colecaoFormasArrecadacaoHelper.add(formasHelper);
				}
			}
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return colecaoFormasArrecadacaoHelper;
	}
	
	/**
	 * Felipe Santos - 25/10/2013
	 * 
	 * Método que gera os dados para o Relatório BIG
	 * 
	 * @param anoMesReferencia
	 * @param localidades
	 * @param idFuncionalidadeIniciada
	 * @throws ControladorException
	 */
	public void gerarDadosRelatorioBIG(Integer anoMesReferencia, Localidade localidade,
			Integer idFuncionalidadeIniciada) throws ControladorException {
		
		Integer idLocalidade = localidade.getId();
		Date dataInicial = Util.gerarDataInicialApartirAnoMesRefencia(anoMesReferencia);
		Date dataFinal = Util.gerarDataApartirAnoMesRefencia(anoMesReferencia);
		
		int idUnidadeIniciada = 0;
		
		try {
			
			idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(
					idFuncionalidadeIniciada, UnidadeProcessamento.LOCALIDADE, idLocalidade);
			
			BoletimInformacoesGerenciais big = new BoletimInformacoesGerenciais();
			
			big.setAnoMesReferencia(anoMesReferencia);
			
			big.setLocalidade(localidade);
			
			big = this.setQuantidadeContasRelatorioBIG(anoMesReferencia, idLocalidade, big); // [C] [D]
			
			big = this.setValorArrecadacaoRelatorioBIG(anoMesReferencia, idLocalidade, big); // [E]
			
			if (big.getValorArrecadacao().compareTo(BigDecimal.valueOf(0.00)) == 1
					&& big.getValorFaturamento().compareTo(BigDecimal.valueOf(0.00)) == 1) {
				big = this.setEficienciaArrecadacaoRelatorioBIG(big); // [F]
				
				big = this.setValorMedioFaturamentoRelatorioBIG(big); // [G]
				
				big = this.setErrosContasRelatorioBIG(anoMesReferencia, idLocalidade,
						dataInicial, dataFinal, big); // [H] [I]
				
				big = this.setRecebimentoMedioRelatorioBIG(anoMesReferencia, idLocalidade, big); // [J]
				
				BigDecimal[] inadimplenciaAte30 = this.setInadimpleciaAte30RelatorioBIG(
						anoMesReferencia, idLocalidade, dataInicial);
				big.setIndicadorQuantidadeInadimplenciaAte30(inadimplenciaAte30[0]); // [K]
				big.setIndicadorValorInadimplenciaAte30(inadimplenciaAte30[1]); // [L]
				
				BigDecimal[] inadimplenciaAte90 = this.setInadimpleciaAte90RelatorioBIG(
						anoMesReferencia, idLocalidade, dataInicial);
				big.setIndicadorQuantidadeInadimplenciaAte90(inadimplenciaAte90[0]); // [M]
				big.setIndicadorValorInadimplenciaAte90(inadimplenciaAte90[1]); // [N]
				
				BigDecimal[] inadimplenciaMaior90 = this.setInadimpleciaMaior90RelatorioBIG(
						anoMesReferencia, idLocalidade, dataInicial);
				big.setIndicadorQuantidadeInadimplenciaMaior90(inadimplenciaMaior90[0]); // [O]
				big.setIndicadorValorInadimplenciaMaior90(inadimplenciaMaior90[1]); // [P]
				
				big = this.setQuantidadeFaturamentosComprometidosRelatorioBIG(big, inadimplenciaAte30,
						inadimplenciaAte90, inadimplenciaMaior90); // [Q]
				
				big = this.setIndiceHidrometracaoRelatorioBIG(anoMesReferencia, idLocalidade, big); // [R]
				
				big.setQuantidadeHidrometrosInstalados(repositorioMicromedicao.pesquisarQuantidadeHidrometrosRelatorioBIG(
						dataInicial, dataFinal, idLocalidade, Hidrometro.SITUACAO_INSTALADO)); // [S]
				
				big.setQuantidadeHidrometrosSubstituidos(repositorioMicromedicao.pesquisarQuantidadeHidrometrosRelatorioBIG(
						dataInicial, dataFinal, idLocalidade, Hidrometro.SITUACAO_SUBSTITUIDO)); // [T]
				
				big = this.setPrazoAtendimentoOSRelatorioBIG(anoMesReferencia, idLocalidade, big); // [U]
				
				big = this.setNovasLigacoesEsgotoRelatorioBIG(anoMesReferencia, idLocalidade, big); // [V] [W]
				
				big = this.setNovasLigacoesAguaRelatorioBIG(anoMesReferencia, idLocalidade, big); // [X] [Y]
				
				Integer quantidadeConsumidoresLigados = repositorioAtendimentoPublico.pesquisarQuantidadeConsumidoresRelatorioBIG(
						idLocalidade, LigacaoAguaSituacao.LIGADO);
				big.setQuantidadeConsumidoresLigados(quantidadeConsumidoresLigados); // [Z]
				
				Integer quantidadeConsumidoresCortados = repositorioAtendimentoPublico.pesquisarQuantidadeConsumidoresRelatorioBIG(
						idLocalidade, LigacaoAguaSituacao.CORTADO);
				big.setQuantidadeConsumidoresCortados(quantidadeConsumidoresCortados); // [AA]
				
				Integer quantidadeConsumidoresSuprimidos = repositorioAtendimentoPublico.pesquisarQuantidadeConsumidoresRelatorioBIG(
						idLocalidade, LigacaoAguaSituacao.SUPRIMIDO);
				big.setQuantidadeConsumidoresSuprimidos(quantidadeConsumidoresSuprimidos); // [AB]
				
				Integer quantidadeConsumidoresFactiveis = repositorioAtendimentoPublico.pesquisarQuantidadeConsumidoresRelatorioBIG(
						idLocalidade, LigacaoAguaSituacao.FACTIVEL);
				big.setQuantidadeConsumidoresFactiveis(quantidadeConsumidoresFactiveis); // [AC]
				
				Integer quantidadeConsumidoresTotal = quantidadeConsumidoresLigados + quantidadeConsumidoresCortados +
						quantidadeConsumidoresSuprimidos + quantidadeConsumidoresFactiveis;
				big.setQuantidadeConsumidoresTotal(quantidadeConsumidoresTotal); // [AD]
				
				big = this.setIndiceCortadosRelatorioBIG(big, quantidadeConsumidoresCortados,
						quantidadeConsumidoresTotal); // [AE]
				
				big = this.setIndiceSuprimidosRelatorioBIG(big, quantidadeConsumidoresSuprimidos,
						quantidadeConsumidoresTotal); // [AF]
				
				big = this.setIndiceFactiveisRelatorioBIG(big, quantidadeConsumidoresFactiveis,
						quantidadeConsumidoresTotal); // [AG]
				
				big.setUltimaAlteracao(new Date());
				
				this.getControladorUtil().inserir(big);
			}
			
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,idUnidadeIniciada, false);
		} catch (Exception ex) {
			System.out.println("Erro no processamento da LOCALIDADE: " + idLocalidade + " - " + localidade.getDescricao());
			ex.printStackTrace();
			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex, idUnidadeIniciada, true);
			throw new EJBException(ex);
		}
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param big
	 * @param quantidadeConsumidoresFactiveis
	 * @param quantidadeConsumidoresTotal
	 * @return BoletimInformacoesGerenciais
	 */
	private BoletimInformacoesGerenciais setIndiceFactiveisRelatorioBIG(
			BoletimInformacoesGerenciais big,
			Integer quantidadeConsumidoresFactiveis,
			Integer quantidadeConsumidoresTotal) {
		
		BigDecimal indiceFactiveis = BigDecimal.valueOf(0.00);
		
		if (quantidadeConsumidoresFactiveis > 0 && quantidadeConsumidoresTotal > 0) {
			indiceFactiveis = BigDecimal.valueOf(quantidadeConsumidoresFactiveis).divide(
					BigDecimal.valueOf(quantidadeConsumidoresTotal), 10, BigDecimal.ROUND_HALF_UP);
		}
		
		big.setIndiceFactiveis(indiceFactiveis);
		
		return big;
	}
	
	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param big
	 * @param quantidadeConsumidoresSuprimidos
	 * @param quantidadeConsumidoresTotal
	 * @return BoletimInformacoesGerenciais
	 */
	private BoletimInformacoesGerenciais setIndiceSuprimidosRelatorioBIG(
			BoletimInformacoesGerenciais big,
			Integer quantidadeConsumidoresSuprimidos,
			Integer quantidadeConsumidoresTotal) {
		
		BigDecimal indiceSuprimidos = BigDecimal.valueOf(0.00);
		
		if (quantidadeConsumidoresSuprimidos > 0 && quantidadeConsumidoresTotal > 0) {
			indiceSuprimidos = BigDecimal.valueOf(quantidadeConsumidoresSuprimidos).divide(
					BigDecimal.valueOf(quantidadeConsumidoresTotal), 10, BigDecimal.ROUND_HALF_UP);
		}
		
		big.setIndiceSuprimidos(indiceSuprimidos);
		
		return big;
	}
	
	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param big
	 * @param quantidadeConsumidoresCortados
	 * @param quantidadeConsumidoresTotal
	 * @return BoletimInformacoesGerenciais
	 */
	private BoletimInformacoesGerenciais setIndiceCortadosRelatorioBIG(
			BoletimInformacoesGerenciais big,
			Integer quantidadeConsumidoresCortados,
			Integer quantidadeConsumidoresTotal) {
		
		BigDecimal indiceCortados = BigDecimal.valueOf(0.00);
		
		if (quantidadeConsumidoresCortados > 0 && quantidadeConsumidoresTotal > 0) {
			indiceCortados = BigDecimal.valueOf(quantidadeConsumidoresCortados).divide(
					BigDecimal.valueOf(quantidadeConsumidoresTotal), 10, BigDecimal.ROUND_HALF_UP);
		}
		
		big.setIndiceCortados(indiceCortados);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param big
	 * @param inadimplenciaAte30
	 * @param inadimplenciaAte90
	 * @param inadimplenciaMaior90
	 * @return BoletimInformacoesGerenciais
	 */
	private BoletimInformacoesGerenciais setQuantidadeFaturamentosComprometidosRelatorioBIG(
			BoletimInformacoesGerenciais big, BigDecimal[] inadimplenciaAte30,
			BigDecimal[] inadimplenciaAte90, BigDecimal[] inadimplenciaMaior90) {
		
		BigDecimal valorTotalInadimplenciaVencidas = inadimplenciaAte30[2].add(
				inadimplenciaAte90[2].add(inadimplenciaMaior90[2]));
		
		if (valorTotalInadimplenciaVencidas.compareTo(BigDecimal.valueOf(0.00)) == 1) {
			valorTotalInadimplenciaVencidas = valorTotalInadimplenciaVencidas.divide(
					big.getValorFaturamento(), 10, BigDecimal.ROUND_HALF_UP)
					.setScale(2, BigDecimal.ROUND_HALF_UP);
		}
		
		big.setQuantidadeFaturamentosComprometidos(valorTotalInadimplenciaVencidas);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setNovasLigacoesAguaRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Date dataInicial = Util.gerarDataInicialApartirAnoMesRefencia(anoMesReferencia);
		Date dataFinal = Util.gerarDataApartirAnoMesRefencia(anoMesReferencia);
		
		Object[] novasLigacoesAgua = repositorioAtendimentoPublico.pesquisarNovasLigacoesAguaRelatorioBIG(
				dataInicial, dataFinal, idLocalidade);
		
		big.setQuantidadeNovasLigacoesAgua((Integer) novasLigacoesAgua[0]);
		big.setEconomiasNovasLigacoesAgua((Integer) novasLigacoesAgua[1]);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setNovasLigacoesEsgotoRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Date dataInicial = Util.gerarDataInicialApartirAnoMesRefencia(anoMesReferencia);
		Date dataFinal = Util.gerarDataApartirAnoMesRefencia(anoMesReferencia);
		
		Object[] novasLigacoesEsgoto = repositorioAtendimentoPublico.pesquisarNovasLigacoesEsgotoRelatorioBIG(
				dataInicial, dataFinal, idLocalidade);
		
		big.setQuantidadeNovasLigacoesEsgoto((Integer) novasLigacoesEsgoto[0]);
		big.setEconomiasNovasLigacoesEsgoto((Integer) novasLigacoesEsgoto[1]);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setPrazoAtendimentoOSRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Date dataInicial = Util.gerarDataInicialApartirAnoMesRefencia(anoMesReferencia);
		Date dataFinal = Util.gerarDataApartirAnoMesRefencia(anoMesReferencia);
		
		Object[] prazoOS = repositorioAtendimentoPublico.pesquisarPrazoMedioAtendimentoOSRelatorioBIG(
				dataInicial, dataFinal, idLocalidade);
		BigDecimal numeroDias = BigDecimal.valueOf((Integer) prazoOS[0]);
		BigDecimal quantidadeOS = BigDecimal.valueOf((Integer) prazoOS[1]);
		
		BigDecimal prazoMedioAtendimentoOS = BigDecimal.valueOf(0.00);
		if (numeroDias.compareTo(prazoMedioAtendimentoOS) == 1 
				&& quantidadeOS.compareTo(prazoMedioAtendimentoOS) == 1) {
			prazoMedioAtendimentoOS = numeroDias.divide(
					quantidadeOS, 10, BigDecimal.ROUND_HALF_UP)
					.setScale(2, BigDecimal.ROUND_HALF_UP);
		}
		
		big.setPrazoMedioAtendimentoOS(prazoMedioAtendimentoOS);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setIndiceHidrometracaoRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Object[] ligacoes = repositorioGerencialCadastro.pesquisarLigacoesTotalHidrometricaRelatorioBIG(
				anoMesReferencia, idLocalidade);
		BigDecimal ativas = BigDecimal.valueOf((Integer) ligacoes[0]);
		BigDecimal hidrometricas = BigDecimal.valueOf((Integer) ligacoes[1]);
		
		BigDecimal indiceHidrometracao = hidrometricas.divide(
				ativas, 10, BigDecimal.ROUND_HALF_UP);
		big.setIndiceHidrometracao(indiceHidrometracao);
		
		return big;
	}
	
	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BigDecimal[]
	 * @throws ErroRepositorioException
	 */
	private BigDecimal[] setInadimpleciaMaior90RelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			Date dataReferencia) throws ErroRepositorioException {
		
		Date dataFinal = Util.subtrairNumeroDiasDeUmaData(dataReferencia, 90);
		
		Object[] vencidas = repositorioFaturamento.pesquisarInadimplenciaVencidasMaior90RelatorioBIG(
				dataReferencia, dataFinal, idLocalidade);
		
		Object[] emitidas = repositorioFaturamento.pesquisarInadimplenciaEmitidasMaior90RelatorioBIG(
				dataFinal, idLocalidade);
		
		return this.setInadimpleciaRelatorioBIG(vencidas, emitidas);
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BigDecimal[]
	 * @throws ErroRepositorioException
	 */
	private BigDecimal[] setInadimpleciaAte90RelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			Date dataReferencia) throws ErroRepositorioException {
		
		Date dataInicial = Util.subtrairNumeroDiasDeUmaData(dataReferencia, 90);
		Date dataFinal = Util.subtrairNumeroDiasDeUmaData(dataReferencia, 30);
		
		Object[] vencidas = repositorioFaturamento.pesquisarInadimplenciaVencidasRelatorioBIG(
				dataReferencia, dataInicial, dataFinal, idLocalidade);
		
		Object[] emitidas = repositorioFaturamento.pesquisarInadimplenciaEmitidasRelatorioBIG(
				dataInicial, dataFinal, idLocalidade);
		
		return this.setInadimpleciaRelatorioBIG(vencidas, emitidas);
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BigDecimal[] setInadimpleciaAte30RelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			Date dataReferencia) throws ErroRepositorioException {
		
		Date dataInicial = Util.subtrairNumeroDiasDeUmaData(dataReferencia, 30);
		
		Object[] vencidas = repositorioFaturamento.pesquisarInadimplenciaVencidasRelatorioBIG(
				dataReferencia, dataInicial, dataReferencia, idLocalidade);
		
		Object[] emitidas = repositorioFaturamento.pesquisarInadimplenciaEmitidasRelatorioBIG(
				dataInicial, dataReferencia, idLocalidade);
		
		BigDecimal[] inadimplencia = this.setInadimpleciaRelatorioBIG(vencidas, emitidas);
		
		return inadimplencia;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param idLocalidade
	 * @param dataReferenciaInicial
	 * @param dataReferenciaFinal
	 * @return BigDecimal[]
	 * @throws ErroRepositorioException
	 */
	private BigDecimal[] setInadimpleciaRelatorioBIG(
			Object[] vencidas, Object[] emitidas)
	throws ErroRepositorioException {
		
		BigDecimal quantidadeVencidas = BigDecimal.valueOf((Integer) vencidas[0]);
		BigDecimal quantidadeEmitidas = BigDecimal.valueOf((Integer) emitidas[0]);
		BigDecimal indicadorQuantidade = quantidadeVencidas.divide(
				quantidadeEmitidas, 10, BigDecimal.ROUND_HALF_UP);
		
		BigDecimal valorVencidas = (BigDecimal) vencidas[1];
		BigDecimal valorEmitidas = (BigDecimal) emitidas[1];
		BigDecimal indicadorValor = valorVencidas.divide(
				valorEmitidas, 10, BigDecimal.ROUND_HALF_UP);
		
		BigDecimal[] inadimplencia = { 
				indicadorQuantidade, 
				indicadorValor,
				valorVencidas};
		
		return inadimplencia;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setRecebimentoMedioRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Object[] recebimentoMedio = repositorioArrecadacao.pesquisarPrazoMedioRecebimentoContasRelatorioBIG(
				anoMesReferencia, idLocalidade);
		
		BigDecimal diferencaDatas = BigDecimal.valueOf((Integer) recebimentoMedio[0]);
		BigDecimal quantidadePagamentos = BigDecimal.valueOf((Integer) recebimentoMedio[1]);
		
		BigDecimal indicadorRecebimentoMedio = diferencaDatas.divide(
				quantidadePagamentos, 10, BigDecimal.ROUND_HALF_UP)
				.setScale(2, BigDecimal.ROUND_HALF_UP);
		
		big.setIndicadorRecebimentoMedio(indicadorRecebimentoMedio);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param dataInicial
	 * @param dataFinal
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setErrosContasRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			Date dataInicial, Date dataFinal,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Object[] errosContas = repositorioFaturamento.pesquisarErrosContasRelatorioBIG(
				anoMesReferencia, dataInicial, dataFinal, idLocalidade);
		
		BigDecimal quantidadeRetificadas = BigDecimal.valueOf((Integer) errosContas[0]);
		BigDecimal quantidadeEmitidas = BigDecimal.valueOf((Integer) errosContas[2]);
		BigDecimal indicadorQuantidade = quantidadeRetificadas.divide(
				quantidadeEmitidas, 10, BigDecimal.ROUND_HALF_UP);
		big.setIndicadorQuantidadeErrosContas(indicadorQuantidade);
		
		BigDecimal valorRetificadas = (BigDecimal) errosContas[1];
		BigDecimal valorEmitidas = (BigDecimal) errosContas[3];
		BigDecimal indicadorValor = valorRetificadas.divide(
				valorEmitidas, 10, BigDecimal.ROUND_HALF_UP);
		big.setIndicadorValorErrosContas(indicadorValor);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 */
	private BoletimInformacoesGerenciais setValorMedioFaturamentoRelatorioBIG(
			BoletimInformacoesGerenciais big) {
		
		BigDecimal valorFaturamento = big.getValorFaturamento();
		BigDecimal quantidadeContas = BigDecimal.valueOf(big.getQuantidadeContas());
		
		BigDecimal valorMedioFaturamento = valorFaturamento.divide(
				quantidadeContas, 10, BigDecimal.ROUND_HALF_UP)
				.setScale(2, BigDecimal.ROUND_HALF_UP);
		big.setValorMedioFaturamento(valorMedioFaturamento);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 */
	private BoletimInformacoesGerenciais setEficienciaArrecadacaoRelatorioBIG(
			BoletimInformacoesGerenciais big) {
		
		BigDecimal valorArrecadacao = big.getValorArrecadacao();
		BigDecimal valorFaturamento = big.getValorFaturamento();
		
		BigDecimal eficienciaArrecadacao = valorArrecadacao.divide(
				valorFaturamento, 10, BigDecimal.ROUND_HALF_UP);
		big.setEficienciaArrecadacao(eficienciaArrecadacao);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setValorArrecadacaoRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		BigDecimal valorArrecadacao = repositorioArrecadacao.pesquisarTotalArrecadacaoRelatorioBIG(
				anoMesReferencia, idLocalidade);
		big.setValorArrecadacao(valorArrecadacao);
		
		return big;
	}

	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * @param anoMesReferencia
	 * @param idLocalidade
	 * @param big
	 * @return BoletimInformacoesGerenciais
	 * @throws ErroRepositorioException
	 */
	private BoletimInformacoesGerenciais setQuantidadeContasRelatorioBIG(
			Integer anoMesReferencia, Integer idLocalidade,
			BoletimInformacoesGerenciais big) throws ErroRepositorioException {
		
		Object[] quantidadeContas = repositorioFaturamento.pesquisarContasRelatorioBIG(
					anoMesReferencia, idLocalidade);
		big.setQuantidadeContas((Integer) quantidadeContas[0]);
		big.setValorFaturamento((BigDecimal) quantidadeContas[1]);
		
		return big;
	}
	
	/**
	 * Felipe Santos - 29/10/2013
	 * 
	 * Retorna dados para Relatorio BIG
	 * 
	 * @param anoMesReferencia
	 * @param big
	 * @return Collection
	 * @throws ErroRepositorioException
	 */
	public Collection pesquisarDadosRelatorioBIG(
			Integer anoMesReferencia) throws ControladorException {
		
		Collection retorno = new ArrayList();
		
		try {
			
			Collection colecaoBIG = repositorioArrecadacao.pesquisarDadosRelatorioBIG(anoMesReferencia);
			
			if (colecaoBIG != null && !colecaoBIG.isEmpty()) {
				Iterator iterator = colecaoBIG.iterator();
				
				while (iterator.hasNext()) {
					RelatorioBIGHelper helper = new RelatorioBIGHelper();
					Object[] objetoBIG = (Object[]) iterator.next();
					
					helper.setGerenciaRegional((String) objetoBIG[0]);
					helper.setLocalidade((String) objetoBIG[1]);
					helper.setQuantidadeContas((Integer) objetoBIG[2]);
					helper.setValorFaturamento((BigDecimal) objetoBIG[3]);
					helper.setValorArrecadacao((BigDecimal) objetoBIG[4]);
					helper.setEficienciaArrecadacao((BigDecimal) objetoBIG[5]);
					helper.setValorMedioFaturamento((BigDecimal) objetoBIG[6]);
					helper.setIndicadorQuantidadeErrosContas((BigDecimal) objetoBIG[7]);
					helper.setIndicadorValorErrosContas((BigDecimal) objetoBIG[8]);
					helper.setIndicadorRecebimentoMedio((BigDecimal) objetoBIG[9]);
					helper.setIndicadorQuantidadeInadimplenciaAte30((BigDecimal) objetoBIG[10]);
					helper.setIndicadorValorInadimplenciaAte30((BigDecimal) objetoBIG[11]);
					helper.setIndicadorQuantidadeInadimplenciaAte90((BigDecimal) objetoBIG[12]);
					helper.setIndicadorValorInadimplenciaAte90((BigDecimal) objetoBIG[13]);
					helper.setIndicadorQuantidadeInadimplenciaMaior90((BigDecimal) objetoBIG[14]);
					helper.setIndicadorValorInadimplenciaMaior90((BigDecimal) objetoBIG[15]);
					helper.setQuantidadeFaturamentosComprometidos((BigDecimal) objetoBIG[16]);
					helper.setIndiceHidrometracao((BigDecimal) objetoBIG[17]);
					helper.setQuantidadeHidrometrosInstalados((Integer) objetoBIG[18]);
					helper.setQuantidadeHidrometrosSubstituidos((Integer) objetoBIG[19]);
					helper.setPrazoMedioAtendimentoOS((BigDecimal) objetoBIG[20]);
					helper.setQuantidadeNovasLigacoesEsgoto((Integer) objetoBIG[21]);
					helper.setEconomiasNovasLigacoesEsgoto((Integer) objetoBIG[22]);
					helper.setQuantidadeNovasLigacoesAgua((Integer) objetoBIG[23]);
					helper.setEconomiasNovasLigacoesAgua((Integer) objetoBIG[24]);
					helper.setQuantidadeConsumidoresLigados((Integer) objetoBIG[25]);
					helper.setQuantidadeConsumidoresCortados((Integer) objetoBIG[26]);
					helper.setQuantidadeConsumidoresSuprimidos((Integer) objetoBIG[27]);
					helper.setQuantidadeConsumidoresFactiveis((Integer) objetoBIG[28]);
					helper.setQuantidadeConsumidoresTotal((Integer) objetoBIG[29]);
					helper.setIndiceCortados((BigDecimal) objetoBIG[30]);
					helper.setIndiceSuprimidos((BigDecimal) objetoBIG[31]);
					helper.setIndiceFactiveis((BigDecimal) objetoBIG[32]);
					helper.setIdLocalidade((Integer) objetoBIG[33]);
					
					retorno.add(helper);
				}
			}
			
			return retorno;
		} catch (ErroRepositorioException e) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", e);
		}
	}

	private void processarDevolucoesDuplicidadeExcesso(Collection colecaoConjuntoDevolucoes, Imovel imovelAnterior, Integer anoMesReferenciaDevolucaoAnterior)
			throws ControladorException {
		try {
			Collection<Pagamento> colecaoPagamentoNaoClassificados = this.selecionarPagamentosNaoClassificadosConta(imovelAnterior,
					anoMesReferenciaDevolucaoAnterior);

			if (colecaoPagamentoNaoClassificados == null || colecaoPagamentoNaoClassificados.isEmpty()) {
				Iterator iteratorColecaoConjuntoDevolucoes = colecaoConjuntoDevolucoes.iterator();
				String[] idDevolucao = new String[1];

				Devolucao devolucaoConjunto;
				while (iteratorColecaoConjuntoDevolucoes.hasNext()) {
					devolucaoConjunto = (Devolucao) iteratorColecaoConjuntoDevolucoes.next();
					idDevolucao[0] = String.valueOf(devolucaoConjunto.getId());
					repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao, DevolucaoSituacao.PAGAMENTO_DUPLICIDADE_NAO_ENCONTRADO);
				}
			} else {
				this.processarDevolucaoPagamento(colecaoConjuntoDevolucoes, colecaoPagamentoNaoClassificados);
			}
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}

	private void processarDevolucoesCobradasIndevidamente(Collection colecaoConjuntoDevolucoes, Imovel imovel, DebitoTipo debitoTipo, Cliente cliente)
			throws ControladorException {
		try {
			Collection<Pagamento> colecaoPagamentoNaoClassificados = this.selecionarPagamentosNaoClassificadosGuiaPagamentoDebitoACobrar(imovel, cliente,
					debitoTipo);

			if (colecaoPagamentoNaoClassificados == null || colecaoPagamentoNaoClassificados.isEmpty()) {
				Iterator iteratorColecaoConjuntoDevolucoes = colecaoConjuntoDevolucoes.iterator();
				String[] idDevolucao = new String[1];

				Devolucao devolucaoConjunto;
				while (iteratorColecaoConjuntoDevolucoes.hasNext()) {
					devolucaoConjunto = (Devolucao) iteratorColecaoConjuntoDevolucoes.next();
					idDevolucao[0] = String.valueOf(devolucaoConjunto.getId());

					if (devolucaoConjunto.getGuiaDevolucao() != null || devolucaoConjunto.getCreditoARealizarGeral() != null) {
						repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao, DevolucaoSituacao.DEVOLUCAO_OUTROS_VALORES);
					} else {
						repositorioArrecadacao.atualizarSituacaoDevolucao(idDevolucao, DevolucaoSituacao.GUIA_DEVOLUCAO_NAO_INFORMADA);
					}
				}
			} else {
				this.processarDevolucaoPagamento(colecaoConjuntoDevolucoes, colecaoPagamentoNaoClassificados);
			}
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public void atualizarGuiasPagamentoNaoPagasAtePeriodo(Integer idFuncionalidadeIniciada, Date dataVencimentoLimite, 
			Integer financiamentoTipoServico, Integer idLocalidade) throws ControladorException {
		
		Integer idUnidadeIniciada = getControladorBatch().iniciarUnidadeProcessamentoBatch(idFuncionalidadeIniciada,UnidadeProcessamento.FUNCIONALIDADE,0);

		try {
			Collection<Integer> guiasPagamentoNaoPagasAtePeriodo = repositorioArrecadacao.pesquisarIdsGuiasPagamentoNaoPagas(dataVencimentoLimite, idLocalidade);
			
			Integer anoMesReferencia = getSistemaParametro().getAnoMesArrecadacao();
			
			repositorioArrecadacao.atualizarGuiasPagamentoNaoPagasAtePeriodo(financiamentoTipoServico, guiasPagamentoNaoPagasAtePeriodo, anoMesReferencia);
			
			getControladorBatch().encerrarUnidadeProcessamentoBatch(null,idUnidadeIniciada, false);

		} catch (ErroRepositorioException ex) {
			System.out.println("Erro no processamento da LOCALIDADE: " + idLocalidade );
			getControladorBatch().encerrarUnidadeProcessamentoBatch(ex, idUnidadeIniciada, true);
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public Collection<Integer> pesquisarIdsLocalidadeComGuiasPagamentoNaoPagas(Date dataVencimentoLimite, 
			Integer financiamentoTipoServico) throws ControladorException {
		
		Collection<Integer> colecaoGuiaPagamentos;
		try {

			colecaoGuiaPagamentos = repositorioArrecadacao
					.pesquisarIdsLocalidadeComGuiasPagamentoNaoPagas(financiamentoTipoServico, dataVencimentoLimite);
			
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
		
		return colecaoGuiaPagamentos;
		
	}
	
	public DadosConteudoCodigoBarrasHelper apresentarDadosConteudoCodigoBarrasFichaCompensacaoNovo(
            RegistroFichaCompensacaoTipo7Helper registroTipo7)
            throws ControladorException {

        DadosConteudoCodigoBarrasHelper retorno = new DadosConteudoCodigoBarrasHelper();
        
        BigDecimal valorPagamento = registroTipo7.getValorRecebidoFormatado();
        
        String nossoNumeroSemDV = registroTipo7.getNossoNumero();
        Integer tipoDocumento = registroTipo7.getTipoDocumentoInteger();
        Integer idDocumento = registroTipo7.getIdDocumentoEmitido();
        
        if(tipoDocumento.equals(DocumentoTipo.CONTA)){
        	
        	Conta conta = getControladorFaturamento().obterImovelLocalidadeConta(idDocumento);
            
            if (conta != null){
                //id da Localidade
                retorno.setCodigoLocalidade(conta.getLocalidade().getId().toString());

                //matrícula do imóvel
                retorno.setMatriculaImovel(conta.getImovel().getId().toString());

                //mês e ano de referência da conta
                retorno.setMesAnoReferenciaConta(conta.getReferenciaFormatada());
            }
            else{
                ContaHistorico contaHistorico = getControladorFaturamento().
                    obterImovelLocalidadeContaHistorico(new Integer(idDocumento));
                
                if (contaHistorico != null){
                    //id da Localidade
                    retorno.setCodigoLocalidade(contaHistorico.getLocalidade().getId().toString());

                    //matrícula do imóvel
                    retorno.setMatriculaImovel(contaHistorico.getImovel().getId().toString());

                    //mês e ano de referência da conta
                    retorno.setMesAnoReferenciaConta(contaHistorico.getFormatarAnoMesParaMesAno());
                }
            }
            
            //tipo de pagamento
            retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_CONTA);
        }
        else if (tipoDocumento.equals(DocumentoTipo.EXTRATO_DE_DEBITO) || 
        		tipoDocumento.equals(DocumentoTipo.VISITA_COBRANCA) ||
        		tipoDocumento.equals(DocumentoTipo.ORDEM_CORTE)){
        	
        	CobrancaDocumento cobrancaDocumento = null ;
            
        	try {
        		cobrancaDocumento = repositorioArrecadacao.pesquisarCobrancaDocumentoProcessarFichaCompensacao(new Integer(idDocumento));
            } 
        	catch (ErroRepositorioException e) {
                throw new ControladorException("erro.sistema", e);
            }
        	
        	if (cobrancaDocumento != null){
        		
        		if (cobrancaDocumento.getImovel() != null){
        			
        			retorno.setMatriculaImovel(cobrancaDocumento.getImovel().getId().toString());
        		}
        		else{
        			
        			retorno.setCodigoCliente(cobrancaDocumento.getCliente().getId().toString());
        		}
        		
        		retorno.setSequencialDocumentoCobranca(cobrancaDocumento.getId().toString());
    			
    			retorno.setCodigoTipoDocumento(tipoDocumento.toString());
        	}
        	
        	//tipo de pagamento
            retorno.setTipoPagamento(ConstantesSistema.TIPO_PAGAMENTO_DOCUMENTO_COBRANCA);
        }
        
        
        Date dataVencimentoMais15 = Util.adicionarNumeroDiasDeUmaData(new Date(),15);
        String fatorVencimento = getControladorFaturamento().obterFatorVencimento(dataVencimentoMais15);
        
        String especificacaoCodigoBarra = obterEspecificacaoCodigoBarraFichaCompensacao(
                    ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO, 
                    ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO, 
                    valorPagamento, nossoNumeroSemDV.toString(),
                    ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO, fatorVencimento);
        
        String digitoVerificador = especificacaoCodigoBarra.substring(4,5);
        
        //código do banco
        retorno.setCodigoBanco(ConstantesSistema.CODIGO_BANCO_FICHA_COMPENSACAO);
        
        //código da moeda
        retorno.setCodigoMoeda(ConstantesSistema.CODIGO_MOEDA_FICHA_COMPENSACAO);
        
        //dígito verificador geral
        retorno.setDigitoVerificadorGeral(digitoVerificador);
        
        //fator de vencimento
        retorno.setFatorVencimento(fatorVencimento);
        
        //valor do código de barras
        retorno.setValorCodigoBarras(Util.formatarMoedaReal(valorPagamento));
        
        //nosso número
        retorno.setNossoNumero(nossoNumeroSemDV);
        
        //tipo de carteira
        retorno.setTipoCarteira(ConstantesSistema.CARTEIRA_FICHA_COMPENSACAO);
        
        return retorno;

    }
	
	public Collection<Pagamento> obterPagamentos(Collection<Integer> idsPagamentos) 
		throws ControladorException {
		Collection<Pagamento> pagamentos = null;
		try {
			
			pagamentos = repositorioArrecadacao.obterPagamentos(idsPagamentos);
			
		} catch (ErroRepositorioException e) {
			e.printStackTrace();
		}
		return pagamentos;
	}
	
	/**
	 * Nova regra para classificar pagamentos em DUPLICIDADE, CANCELADO POR PARCELAMENTO
	 * @param pagamentoSituacao
	 * @param dataInicial
	 * @param dataFinal
	 * @return
	 * @throws ControladorException 
	 */
	public void recuperarCredito(Collection<Pagamento> pagamentos, Usuario usuarioLogado, CreditoTipo creditoTipo, CreditoOrigem creditoOrigem, 
			boolean indicadorIncluirCredito, Integer idSituacaoPagamento) throws ControladorException {
		try {
			
			if (indicadorIncluirCredito) {
				incluirCreditoPagamentosResolvidos(pagamentos, usuarioLogado, creditoTipo, creditoOrigem);
			} else {
				refaturarContaParaClassificarPagamentos(pagamentos, usuarioLogado);
			}
			
			pagamentos = atualizarIndicacaoClassificacaoReuperacaoCredito(pagamentos);
			
			if(idSituacaoPagamento.equals(PagamentoSituacao.PAGAMENTO_EM_DUPLICIDADE)) {
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(pagamentos, PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_DUPLICIDADE);
			} else {
				repositorioArrecadacao.atualizarSituacaoEValorExcedentePagamento(pagamentos, PagamentoSituacao.PAGAMENTO_CLASSIFICADO_RECUPERACAO_CREDITO_CANCELADO);
			}
		} catch(Exception e) {
			throw new ControladorException("Erro ao recuperar credito", e);
		}
	}
	
	private Collection<Pagamento> atualizarIndicacaoClassificacaoReuperacaoCredito(Collection<Pagamento> pagamentos) {
		Collection<Pagamento> pagamentosAtualizados = new ArrayList<Pagamento>();
		
		for (Pagamento pagamento : pagamentos) {
			pagamento.setIndicadorClassificadoRecuperacaoCredito(ConstantesSistema.SIM);
			pagamentosAtualizados.add(pagamento);
		}
		
		return pagamentosAtualizados;
	}
	private void refaturarContaParaClassificarPagamentos(Collection<Pagamento> pagamentos, Usuario usuarioLogado) 
		throws ControladorException {
		
		try{
			Map<Integer, Conta> mapContasNovas = getControladorFaturamento().incluirContasParaRefaturarPagamentos(pagamentos, usuarioLogado);
			
			Collection<Integer> idsContas = getControladorFaturamento().getListaIdContas(pagamentos);

			Set<Integer> listaIdsContaHistorico = mapContasNovas.keySet();
			
			for (Integer idContaHistorico : listaIdsContaHistorico) {
				Pagamento pagamento = this.pesquisarPagamentoDeConta(idContaHistorico);
				if (pagamento != null) {
					Conta novaConta = mapContasNovas.get(idContaHistorico);
					pagamento.setContaGeral(novaConta.getContaGeral());
					pagamento.setUltimaAlteracao(new Date());
					repositorioUtil.atualizar(pagamento);
				}
			}
		} catch (Exception e) {
			logger.error("Erro ao refaturar conta para recuperação de crédito.", e);
			throw new ControladorException("Erro ao refaturar conta para recuperação de crédito.", e);
		}
	}
	
	public void incluirCreditoPagamentosResolvidos(Collection<Pagamento> pagamentos, Usuario usuarioLogado, CreditoTipo creditoTipo, CreditoOrigem creditoOrigem) throws Exception {
		
		SistemaParametro sistemaParametros = getControladorUtil().pesquisarParametrosDoSistema();	

		for (Pagamento pagamento : pagamentos){
			Imovel imovel = getControladorImovel().pesquisarImovel(pagamento.getImovel().getId());

			CreditoARealizar credito = new CreditoARealizar();
			
			credito.setAnoMesReferenciaCredito(pagamento.getAnoMesReferenciaPagamento());
			credito.setAnoMesCobrancaCredito(this.obterReferenciaCobrancaCreditoRecuperacaoCredito(imovel.getId()));
			credito.setAnoMesReferenciaContabil(sistemaParametros.getAnoMesFaturamento());
			credito.setCreditoTipo(creditoTipo);
			credito.setCreditoOrigem(creditoOrigem);
			credito.setImovel(imovel);
			credito.setCodigoSetorComercial(imovel.getSetorComercial().getCodigo());
			credito.setNumeroQuadra(imovel.getQuadra().getNumeroQuadra());
			credito.setNumeroLote(imovel.getLote());
			credito.setNumeroSubLote(imovel.getSubLote());
			credito.setQuadra(imovel.getQuadra());
			credito.setLocalidade(imovel.getLocalidade());
			credito.setNumeroPrestacaoCredito((short) 1);
			credito.setNumeroPrestacaoRealizada((short)0);
			credito.setValorResidualMesAnterior(new BigDecimal(0.00));
			credito.setValorCredito(pagamento.getValorPagamento());
			credito.setGeracaoCredito(new Date());
			credito.setUltimaAlteracao(new Date());
			credito.setLancamentoItemContabil(new LancamentoItemContabil(LancamentoItemContabil.OUTROS_SERVICOS_AGUA));
			credito.setDebitoCreditoSituacaoAtual(new DebitoCreditoSituacao(DebitoCreditoSituacao.NORMAL));
			credito.setUsuario(usuarioLogado);
			
			getControladorFaturamento().gerarCreditoARealizar(credito, imovel, usuarioLogado);
		}
	}
	
	private Integer obterReferenciaCobrancaCreditoRecuperacaoCredito(Integer idImovel) throws Exception {
		Integer referenciaCobranca = null;
		Rota rota = getControladorMicromedicao().buscarRotaDoImovel(idImovel);
		
		if (getControladorMicromedicao().isImovelEmCampo(idImovel)) {
			referenciaCobranca = Util.somaUmMesAnoMesReferencia(rota.getFaturamentoGrupo().getAnoMesReferencia());
		} else {
			referenciaCobranca = rota.getFaturamentoGrupo().getAnoMesReferencia();
		}
		
		return referenciaCobranca;
	}
	
	public void atualizarIndicadorDebitoAutomaticoComDataExclusao(Integer idImovel) throws ControladorException {
		try {
			Collection<DebitoAutomatico> colecaoDebitoAutomatico = repositorioArrecadacao.pesquisarDebitoAutomaticoSemDataExclusao(idImovel);

			if (colecaoDebitoAutomatico == null || colecaoDebitoAutomatico.isEmpty()) {
				repositorioCobranca.atualizarIndicadorDebitoAutomatico(idImovel.toString(), Integer.valueOf(ConstantesSistema.NAO));
			}
		} catch (ErroRepositorioException ex) {
			sessionContext.setRollbackOnly();
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public Collection pesquisarClienteGuiaPagamentoECliente(Integer idGuiaPagamento)throws ControladorException {
		try{
		  return repositorioArrecadacao.pesquisarClienteGuiaPagamentoECliente(idGuiaPagamento);
		} catch (ErroRepositorioException ex) {
	        throw new ControladorException("erro.sistema", ex);
	    }
	}
	
	
	public AvisoBancario gerarOcorrenciaAvisoBancario(Integer idMovimento,
			RegistroHelperCodigoA registroHelperCodigoA,
			Date dataPrevistaCredito, String valorTotalRegistrosArquivo,
			String codigoBanco, BigDecimal valorArrecadacaoInf, BigDecimal valorArrecadacaoCalc,
			BigDecimal valorDevolucaoCalc, BigDecimal valorDevolucaoInf,
			Short numeroSequencialAvisoBancario, Integer idFormaArrecadacao, int indicadorDeAceitacaoDoMovimento,
			String codigoConvenio, Integer anoMesReferenciaArrecadacao) throws ControladorException {
		
		AvisoBancario avisoBancario = new AvisoBancario();

		FiltroArrecadador filtro = new FiltroArrecadador();
		filtro.adicionarParametro(new ParametroSimples(FiltroArrecadador.CODIGO_AGENTE, new Integer(registroHelperCodigoA.getCodigoBanco())));
		Collection colArrecadadores = Fachada.getInstancia().pesquisar( filtro, Arrecadador.class.getName() );
		Arrecadador arrecadador = (Arrecadador) colArrecadadores.iterator().next();
		
		avisoBancario.setArrecadador(arrecadador);
		
		FiltroArrecadadorContrato filtroArrecadadorContrato = new FiltroArrecadadorContrato();
		filtroArrecadadorContrato.adicionarParametro(new ParametroSimples(FiltroArrecadadorContrato.ARRECADADOR_ID, arrecadador.getId()));
		Collection<ArrecadadorContrato> colecaoArrecadadorContrato = Fachada.getInstancia().pesquisar(filtroArrecadadorContrato, ArrecadadorContrato.class.getName());
		
		ArrecadadorContratoTarifa arrecContratoTarifa = pesquisarArrecadadorContratoTarifa(idFormaArrecadacao, colecaoArrecadadorContrato);
		
		ContaBancaria contaBancaria = new ContaBancaria();
		if(arrecContratoTarifa != null)
			contaBancaria.setId(arrecContratoTarifa.getContaBancariaDepositoArrecadacao().getId());
		avisoBancario.setContaBancaria(contaBancaria);
		
		Date dataLancamento = Util.converteStringInvertidaSemBarraParaDate(registroHelperCodigoA
						.getDataGeracaoArquivo());
		avisoBancario.setDataLancamento(dataLancamento);
		avisoBancario.setNumeroSequencial(numeroSequencialAvisoBancario);
		avisoBancario.setDataPrevista(dataPrevistaCredito);
		avisoBancario.setDataRealizada(dataPrevistaCredito);
		if(indicadorDeAceitacaoDoMovimento==2){
			avisoBancario.setValorRealizado(valorArrecadacaoCalc);
			avisoBancario.setValorArrecadacaoCalculado(new BigDecimal("0.00"));
			/**
			 * @autor Adriana Muniz e Wellington Rocha
			 * @data 04/11/2013
			 * Correção do valor inserido no valor informado
			 * */
			avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
		}else{
			avisoBancario.setValorRealizado(valorArrecadacaoInf);
			avisoBancario.setValorArrecadacaoInformado(valorArrecadacaoInf);
			avisoBancario.setValorArrecadacaoCalculado(valorArrecadacaoCalc);
		}
		avisoBancario.setValorDevolucaoCalculado(valorDevolucaoCalc);
		avisoBancario.setValorDevolucaoInformado(valorDevolucaoInf);
		avisoBancario.setValorContabilizado(new BigDecimal("0.00"));
		avisoBancario.setAnoMesReferenciaArrecadacao(anoMesReferenciaArrecadacao);
		avisoBancario.setIndicadorCreditoDebito(AvisoBancario.INDICADOR_CREDITO);
		avisoBancario.setNumeroDocumento(0);
		avisoBancario.setUltimaAlteracao(new Date());
		
		ArrecadadorMovimento arrecadadorMovimento = new ArrecadadorMovimento();
		arrecadadorMovimento.setId(idMovimento);
		avisoBancario.setArrecadadorMovimento(arrecadadorMovimento);

		ArrecadacaoForma arrecadacaoForma = new ArrecadacaoForma();
		arrecadacaoForma.setId(idFormaArrecadacao);
		avisoBancario.setArrecadacaoForma(arrecadacaoForma);
		
		return avisoBancario;
	}
	
	public List<ResumoCreditosAvisosBancariosDTO> pesquisarResumoCreditosAvisosBancarios(Date data) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarResumoCreditosAvisosBancarios(data);
		} catch (ErroRepositorioException ex) {
			throw new ControladorException("erro.sistema", ex);
		}
	}
	
	public Object[] pesquisarPagamentoInconformeImovel(String idImovel) throws ControladorException {
		try {
			return repositorioArrecadacao.pesquisarPagamentoInconformeImovel(idImovel);
		} catch (ErroRepositorioException ex) {
			ex.printStackTrace();
			throw new ControladorException("erro.sistema", ex);
		}
	}
}

